"use strict";(self.webpackChunksc_depot=self.webpackChunksc_depot||[]).push([[33562],{26855:(e,t,i)=>{i.d(t,{A:()=>c});var a,s=i(35143),n=i(46053),r=(i(81806),i(76460),i(47249),i(6409)),o=i(85842),l=i(75116);let u=a=class extends l.A{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(e){return"point"===(e=e.clone()).type?(e.x>180+this.tolerance&&(e.x-=360),e):(e.xmin>=180-this.tolerance?(e.xmax-=360,e.xmin-=360):e.xmax>180+this.tolerance&&(e.xmin=-180,e.xmax=180),e)}inverseTransform(e){return"point"===(e=e.clone()).type?(e.x<-this.tolerance&&(e.x+=360),e):(e.xmin<-this.tolerance&&(e.xmin+=360,e.xmax+=360),e)}clone(){return new a({tolerance:this.tolerance})}};(0,s._)([(0,r.e)({GCSShiftXform:"gcs-shift"})],u.prototype,"type",void 0),(0,s._)([(0,n.MZ)()],u.prototype,"tolerance",void 0),u=a=(0,s._)([(0,o.$)("esri.layers.support.rasterTransforms.GCSShiftTransform")],u);const c=u},29754:(e,t,i)=>{i.d(t,{A:()=>y});var a,s=i(35143),n=i(46053),r=(i(81806),i(76460),i(47249),i(6409)),o=i(28379),l=i(85842),u=i(17707),c=i(76797),f=i(19247),d=i(75116);function h(e,t,i){const{x:a,y:s}=t;if(i<2)return{x:e[0]+a*e[2]+s*e[4],y:e[1]+a*e[3]+s*e[5]};if(2===i){const t=a*a,i=s*s,n=a*s;return{x:e[0]+a*e[2]+s*e[4]+t*e[6]+n*e[8]+i*e[10],y:e[1]+a*e[3]+s*e[5]+t*e[7]+n*e[9]+i*e[11]}}const n=a*a,r=s*s,o=a*s,l=n*a,u=n*s,c=a*r,f=s*r;return{x:e[0]+a*e[2]+s*e[4]+n*e[6]+o*e[8]+r*e[10]+l*e[12]+u*e[14]+c*e[16]+f*e[18],y:e[1]+a*e[3]+s*e[5]+n*e[7]+o*e[9]+r*e[11]+l*e[13]+u*e[15]+c*e[17]+f*e[19]}}function p(e,t,i){const{xmin:a,ymin:s,xmax:n,ymax:r,spatialReference:o}=t;let l=[];if(i<2)l.push({x:a,y:r}),l.push({x:n,y:r}),l.push({x:a,y:s}),l.push({x:n,y:s});else{let e=10;for(let t=0;t<e;t++)l.push({x:a,y:s+(r-s)*t/(e-1)}),l.push({x:n,y:s+(r-s)*t/(e-1)});e=8;for(let t=1;t<=e;t++)l.push({x:a+(n-a)*t/e,y:s}),l.push({x:a+(n-a)*t/e,y:r})}l=l.map((t=>h(e,t,i)));const u=l.map((e=>e.x)),f=l.map((e=>e.y));return new c.default({xmin:Math.min.apply(null,u),xmax:Math.max.apply(null,u),ymin:Math.min.apply(null,f),ymax:Math.max.apply(null,f),spatialReference:o})}let m=a=class extends d.A{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,t){const{coeffX:i,coeffY:a}=t;if(null===i||void 0===i||!i.length||null===a||void 0===a||!a.length||i.length!==a.length)return null;const s=[];for(let n=0;n<i.length;n++)s.push(i[n]),s.push(a[n]);return s}writeForwardCoefficients(e,t,i){const a=[],s=[];for(let n=0;n<(null===e||void 0===e?void 0:e.length);n++)n%2==0?a.push(e[n]):s.push(e[n]);t.coeffX=a,t.coeffY=s}get inverseCoefficients(){let e=this._get("inverseCoefficients");const t=this._get("forwardCoefficients");return!e&&t&&this.polynomialOrder<2&&(e=function(e){const[t,i,a,s,n,r]=e,o=a*r-n*s,l=n*s-a*r;return[(n*i-t*r)/o,(a*i-t*s)/l,r/o,s/l,-n/o,-a/l]}(t)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,t){const{inverseCoeffX:i,inverseCoeffY:a}=t;if(null===i||void 0===i||!i.length||null===a||void 0===a||!a.length||i.length!==a.length)return null;const s=[];for(let n=0;n<i.length;n++)s.push(i[n]),s.push(a[n]);return s}writeInverseCoefficients(e,t,i){const a=[],s=[];for(let n=0;n<(null===e||void 0===e?void 0:e.length);n++)n%2==0?a.push(e[n]):s.push(e[n]);t.inverseCoeffX=a,t.inverseCoeffY=s}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if("point"===e.type){const t=h(this.forwardCoefficients,e,this.polynomialOrder);return new f.default({x:t.x,y:t.y,spatialReference:e.spatialReference})}return p(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if("point"===e.type){const t=h(this.inverseCoefficients,e,this.polynomialOrder);return new f.default({x:t.x,y:t.y,spatialReference:e.spatialReference})}return p(this.inverseCoefficients,e,this.polynomialOrder)}clone(){return new a({polynomialOrder:this.polynomialOrder,forwardCoefficients:this.forwardCoefficients?[...this.forwardCoefficients]:null,inverseCoefficients:this.inverseCoefficients?[...this.inverseCoefficients]:null})}};(0,s._)([(0,n.MZ)({json:{write:!0}})],m.prototype,"polynomialOrder",void 0),(0,s._)([(0,n.MZ)()],m.prototype,"forwardCoefficients",void 0),(0,s._)([(0,o.w)("forwardCoefficients",["coeffX","coeffY"])],m.prototype,"readForwardCoefficients",null),(0,s._)([(0,u.K)("forwardCoefficients")],m.prototype,"writeForwardCoefficients",null),(0,s._)([(0,n.MZ)({json:{write:!0}})],m.prototype,"inverseCoefficients",null),(0,s._)([(0,o.w)("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],m.prototype,"readInverseCoefficients",null),(0,s._)([(0,u.K)("inverseCoefficients")],m.prototype,"writeInverseCoefficients",null),(0,s._)([(0,n.MZ)()],m.prototype,"affectsPixelSize",null),(0,s._)([(0,r.e)({PolynomialXform:"polynomial"})],m.prototype,"type",void 0),m=a=(0,s._)([(0,l.$)("esri.layers.support.rasterTransforms.PolynomialTransform")],m);const y=m},33562:(e,t,i)=>{i.r(t),i.d(t,{default:()=>E});var a=i(89379),s=i(35143),n=i(73204),r=i(69098),o=i(50076),l=i(76460),u=i(77717),c=i(50346),f=i(68134),d=i(46053),h=i(40565),p=(i(81806),i(47249),i(85842)),m=i(25515),y=i(19502),v=i(65624),g=i(31362),w=i(24709),x=i(11270),b=i(94729),I=i(26324),_=i(21617),S=i(5682),T=i(78817),R=i(95363),C=i(44135),M=i(51939),A=i(44038),O=i(16175),F=i(80068),P=i(76562),k=i(30973),D=i(61701);let N=class extends((0,v.dM)((0,S.j)((0,x.q)((0,b.A)((0,I.H)((0,g.d)((0,w.o)((0,T.e)((0,y.b)((0,_.J)((0,u.P)(r.A.ClonableMixin(m.default))))))))))))){constructor(){super(...arguments),this._primaryRasters=[],this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this.source=void 0,this._debouncedSaveOperations=(0,c.debounce)((async(e,t,a)=>{const{save:s,saveAs:n}=await i.e(20964).then(i.bind(i,20964));switch(e){case D.X.SAVE:return s(this,t);case D.X.SAVE_AS:return n(this,a,t)}}))}normalizeCtorArgs(e,t){return"string"==typeof e?(0,a.A)({url:e},t):e}load(e){const t=null!=e?e.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},e).catch(c.throwIfAbortError).then((()=>this._openRaster(t)))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){var e,t;const i=[(0,M.rZ)("Pixel Value"),(0,M.dy)("Raw Pixel Value")],a=null!==(e=null===(t=this.raster)||void 0===t?void 0:t.rasterInfo)&&void 0!==e?e:this.serviceRasterInfo,s=null===a||void 0===a?void 0:a.attributeTable;if(s){const e=(0,M.jC)(s);i.push(...e)}const n=null===a||void 0===a?void 0:a.dataType,r=null===a||void 0===a?void 0:a.multidimensionalInfo;if(("vector-magdir"===n||"vector-uv"===n)&&null!=r){var o;const e=null===(o=r.variables[0].unit)||void 0===o?void 0:o.trim(),t=(0,M.DV)(e),a=(0,M.y6)();i.push(t,a)}if(r){const e=(0,M.AL)(r);i.push(...e)}return i}createPopupTemplate(e){var t;const{rasterFields:i}=this,s=null!==(t=null===e||void 0===e?void 0:e.visibleFieldNames)&&void 0!==t?t:new Set(i.map((e=>{let{name:t}=e;return t})).filter((e=>e!==M.F_.rawServicePixelValue))),n=(0,k.createPopupTemplate)({fields:i,title:this.title},(0,a.A)((0,a.A)({},e),{},{visibleFieldNames:s})),{rasterInfo:r}=this.raster;return null!==n&&void 0!==n&&n.fieldInfos&&r&&(0,M.h4)(n.fieldInfos,r),n}async generateRasterInfo(e,t){var i;if(e=(0,h.PZ)(A.default,e),await this.load(),!e||"none"===(null===(i=e.functionName)||void 0===i?void 0:i.toLowerCase()))return this.serviceRasterInfo;try{const{rasterInfo:i}=await this._openFunctionRaster(e,t);return i}catch(a){if(a instanceof o.default)throw a;throw new o.default("imagery-tile-layer","the given raster function is not supported")}}async save(e){return this._debouncedSaveOperations(D.X.SAVE,e)}async saveAs(e,t){return this._debouncedSaveOperations(D.X.SAVE_AS,t,e)}write(e,t){var i;const a=null!==(i=this._primaryRasters[0])&&void 0!==i?i:this.raster;if(this.loaded?"RasterTileServer"===a.datasetFormat&&("Raster"===a.tileType||"Map"===a.tileType):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(e,t);if(null!==t&&void 0!==t&&t.messages){const e="".concat(t.origin,"/").concat(t.layerContainerType||"operational-layers");t.messages.push(new o.default("layer:unsupported","Layers (".concat(this.title,", ").concat(this.id,") of type '").concat(this.declaredClass,"' are not supported in the context of '").concat(e,"'"),{layer:this}))}return null}async _openRaster(e){var t;let i=!1;if(this.raster)await this._openFromRaster(this.raster,e),i="Function"===this.raster.datasetFormat,!i&&this.rasterFunction&&(this._primaryRasters=[this.raster],await this._initializeWithFunctionRaster(this.rasterFunction));else{const{url:t,rasterFunction:i,source:a}=this;if(!t&&!a)throw new o.default("imagery-tile-layer:open","missing url or source parameter");a?await this._openFromSource(a,e):i?await this._openFromUrlWithRasterFunction(t,i,e):await this._openFromUrl(t,e)}const s=this.raster.rasterInfo;if(!s)throw new o.default("imagery-tile-layer:load","cannot load resources on "+this.url);if(this._set("serviceRasterInfo",i?s:this._primaryRasters[0].rasterInfo),this._set("spatialReference",s.spatialReference),this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,null!=this.sourceJSON){const e="Map"===this.raster.tileType&&null!=this.sourceJSON.minLOD&&null!=this.sourceJSON.maxLOD?this.sourceJSON:(0,a.A)((0,a.A)({},this.sourceJSON),{},{minScale:0,maxScale:0});this.read(e,{origin:"service"})}else this.read({tileInfo:null===(t=this.serviceRasterInfo)||void 0===t?void 0:t.storageInfo.tileInfo.toJSON()},{origin:"service"});this.title||(this.title=this.raster.datasetName),"Map"===this.raster.tileType&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles((0,f.watch)((()=>this.customParameters),(e=>{this.raster&&(this.raster.ioConfig.customFetchParameters=e)})))}async _openFromRaster(e,t){e.rasterInfo||await e.open({signal:t}),this._primaryRasters="Function"===e.datasetFormat?e.primaryRasters.rasters:[e],this.url||(this.url=this._primaryRasters[0].url)}async _openFromUrlWithRasterFunction(e,t,i){const s=[e];t&&(0,P.UD)(t.toJSON(),s);const n=await Promise.all(s.map((e=>F.default.open({url:e,sourceJSON:this.sourceJSON,ioConfig:(0,a.A)((0,a.A)({sampling:"closest"},this.ioConfig),{},{customFetchParameters:this.customParameters}),signal:i})))),r=n.findIndex((e=>null==e));if(r>-1)throw new o.default("imagery-tile-layer:open","cannot open raster: ".concat(s[r]));return this._primaryRasters=n,this._initializeWithFunctionRaster(t)}async _openFromUrl(e,t){const i=await F.default.open({url:e,sourceJSON:this.sourceJSON,ioConfig:(0,a.A)((0,a.A)({sampling:"closest"},this.ioConfig),{},{customFetchParameters:this.customParameters}),signal:t});if(null==i)throw new o.default("imagery-tile-layer:open","cannot open raster: ".concat(e));this._primaryRasters=[i],this.raster=i}async _openFromSource(e,t){var i;const s="the tiled imagery data source is not supported",n="coverage"===(null===(i=e.type)||void 0===i?void 0:i.toLowerCase())?"CovJSON":e.extent&&e.pixelBlock?"MEMORY":null;if(!n)throw new o.default("imagery-tile-layer:open",s);"MEMORY"===n&&(e=(0,a.A)((0,a.A)({},e),{},{pixelBlock:void 0,pixelBlocks:[e.pixelBlock]}));const r=await F.default.open({url:"",source:e,datasetFormat:n,ioConfig:(0,a.A)((0,a.A)({sampling:"closest"},this.ioConfig),{},{customFetchParameters:this.customParameters}),signal:t});if(null==r)throw new o.default("imagery-tile-layer:open",s);this._primaryRasters=[r],this.rasterFunction?await this._initializeWithFunctionRaster(this.rasterFunction):this.raster=r}async _openFunctionRaster(e,t){var i,a;const s={raster:this._primaryRasters[0]};this._primaryRasters.length>1&&this._primaryRasters.forEach((e=>s[e.url]=e));const n=(0,P.vt)(null!==(i=null===(a=e.functionDefinition)||void 0===a?void 0:a.toJSON())&&void 0!==i?i:e.toJSON(),s),r=new O.A({rasterFunction:n});return await r.open(t),r}async _initializeWithFunctionRaster(e,t){try{this.raster=await this._openFunctionRaster(e,t)}catch(i){i instanceof o.default&&l.A.getLogger(this).error("imagery-tile-layer:open",i.message),l.A.getLogger(this).warn("imagery-tile-layer:open","the raster function cannot be applied and is removed"),this._set("rasterFunction",null),this.raster=this._primaryRasters[0]}}};(0,s._)([(0,d.MZ)({clonable:!1})],N.prototype,"_primaryRasters",void 0),(0,s._)([(0,d.MZ)(R.fV)],N.prototype,"legendEnabled",void 0),(0,s._)([(0,d.MZ)({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],N.prototype,"isReference",void 0),(0,s._)([(0,d.MZ)({type:["show","hide"]})],N.prototype,"listMode",void 0),(0,s._)([(0,d.MZ)({json:{read:!0,write:!0}})],N.prototype,"blendMode",void 0),(0,s._)([(0,d.MZ)({type:A.default,json:{name:"renderingRule",write:!0}})],N.prototype,"rasterFunction",void 0),(0,s._)([(0,d.MZ)()],N.prototype,"sourceJSON",void 0),(0,s._)([(0,d.MZ)({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],N.prototype,"version",void 0),(0,s._)([(0,d.MZ)({readOnly:!0,json:{read:!1}})],N.prototype,"type",void 0),(0,s._)([(0,d.MZ)({type:["ArcGISTiledImageServiceLayer"]})],N.prototype,"operationalLayerType",void 0),(0,s._)([(0,d.MZ)({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(e,t)=>!t.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}},writer(e,t,i){t[i]=!e}}}})],N.prototype,"popupEnabled",void 0),(0,s._)([(0,d.MZ)({type:n.default,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}}}}})],N.prototype,"popupTemplate",void 0),(0,s._)([(0,d.MZ)({readOnly:!0})],N.prototype,"defaultPopupTemplate",null),(0,s._)([(0,d.MZ)({readOnly:!0,type:[C.default]})],N.prototype,"fields",void 0),(0,s._)([(0,d.MZ)({readOnly:!0,type:[C.default]})],N.prototype,"rasterFields",null),(0,s._)([(0,d.MZ)({constructOnly:!0})],N.prototype,"source",void 0),N=(0,s._)([(0,p.$)("esri.layers.ImageryTileLayer")],N);const E=N},75116:(e,t,i)=>{i.d(t,{A:()=>l});var a=i(35143),s=i(42553),n=i(46053),r=(i(81806),i(76460),i(47249),i(85842));let o=class extends s.A{get affectsPixelSize(){return!1}forwardTransform(e){return e}inverseTransform(e){return e}};(0,a._)([(0,n.MZ)()],o.prototype,"affectsPixelSize",null),(0,a._)([(0,n.MZ)({json:{write:!0}})],o.prototype,"spatialReference",void 0),o=(0,a._)([(0,r.$)("esri.layers.support.rasterTransforms.BaseRasterTransform")],o);const l=o},80068:(e,t,i)=>{i.r(t),i.d(t,{default:()=>ge});var a=i(50076),s=i(35143),n=i(46053),r=i(81806),o=i(76460),l=(i(47249),i(85842)),u=i(10410),c=i(69539),f=i(76797),d=i(13312),h=i(38042),p=i(66486),m=i(52297);function y(e){return["x","e","east","long","longitude"].includes(e.toLowerCase())}function v(e){return["y","n","west","lat","latitude"].includes(e.toLowerCase())}function g(e){const{axes:t}=e.domain,i=Object.keys(t),a=[],s=[];let n=-1,r=-1,o=[];for(let f=0;f<i.length;f++){const e=i[f];y(e)?n=f:v(e)&&(r=f);const l=t[e],u=[];if("values"in l){l.values.forEach((e=>u.push("string"==typeof e?new Date(e).getTime():e)));const e=u[1]-u[0];a.push([u[0]-.5*e,u[u.length-1]+.5*e]),s.push(e)}else{const{start:e,stop:t,num:i}=l,n=(t-e)/(i-1);a.push([e-.5*n,t+.5*n]),s.push(n);for(let a=0;a<i;a++)u.push(e+n*a)}o.push({name:e,values:u,extent:[u[0],u[u.length-1]]})}n>-1&&-1===r?r=0===n?1:0:r>-1&&-1===n?n=0===r?1:0:-1===r&&-1===n&&(n=0,r=1),o=o.filter(((e,t)=>!(t===n||t===r)));const{referencing:l}=e.domain,u=l.find((e=>e.coordinates.includes(i[n]))).system.id,c=null===u||void 0===u?void 0:u.slice(u.lastIndexOf("/")+1),h=null==c||"CRS84"===c?4326:Number(c),p=new d.default({wkid:h}),[m,g]=a[n],[w,x]=a[r],b=new f.default({xmin:m,xmax:g,ymin:w,ymax:x,spatialReference:p});return{width:Math.round(b.width/s[n]),height:Math.round(b.height/s[r]),extent:b,dimensions:o}}function w(e){var t;const i=(0,h.Z0)();return i&&null!==(t=e[i])&&void 0!==t?t:Object.values(e)[0]}function x(){return Math.round(255*Math.random())}function b(e){const t={},{parameters:i}=e;if(!i)return t;for(const[n,r]of Object.entries(i)){var a;const{type:e,description:i,unit:o,categoryEncoding:l,observedProperty:u}=r;if("Parameter"===e&&(t[n]={},i&&(t[n].description=w(i)),o&&(t[n].unit=o.label?w(o.label):null,t[n].symbol=null===(a=o.symbol)||void 0===a?void 0:a.value),l)){var s;const e=Object.entries(l).map(((e,t)=>({OID:t,Value:Number(e[1]),ClassName:e[0].slice(e[0].lastIndexOf("/")+1),Count:1})));let i=!1;(null===u||void 0===u||null===(s=u.categories)||void 0===s?void 0:s.length)&&(u.categories.forEach((t=>{if(!t.id)return;const a=t.id.slice(t.id.lastIndexOf("/")+1),s=e.find((e=>e.ClassName===a));if(!s)return;const n=t.label?w(t.label):null;if(s.Label=n,t.preferredColor){const e=c.default.fromHex(t.preferredColor);e&&(i=!0,s.Red=e.r,s.Green=e.g,s.Blue=e.b)}})),i&&e.forEach((e=>{null==e.Red&&(e.Red=x(),e.Green=x(),e.Blue=x())})));const a={objectIdFieldName:"",fields:[{name:"OID",type:"esriFieldTypeOID",alias:"OID",domain:null},{name:"Value",type:"esriFieldTypeInteger",alias:"Value",domain:null},{name:"Count",type:"esriFieldTypeDouble",alias:"Count",domain:null},{name:"ClassName",type:"esriFieldTypeString",alias:"ClassName",domain:null,length:50},{name:"Label",type:"esriFieldTypeString",alias:"Label",domain:null,length:50}],features:e.map((e=>({attributes:e})))};i&&a.fields.push({name:"Red",type:"esriFieldTypeInteger",alias:"Red",domain:null},{name:"Green",type:"esriFieldTypeInteger",alias:"Green",domain:null},{name:"Blue",type:"esriFieldTypeInteger",alias:"Blue",domain:null}),t[n].attributeTable=a}}return t}function I(e){let t=Number.MAX_VALUE,i=-Number.MAX_VALUE;for(let a=0;a<e.length;a++){const s=e[a];null!=s&&(s<t&&(t=s),s>i&&(i=s))}return(0,m.X1)(t,i)}function _(e,t,i){const a=e.map(((e,i)=>({name:e,count:t[i]}))).sort(((e,t)=>e.name>t.name?-1:1)),s=(n=1,e=>n*=e.count);var n;const r=[...a.slice(1),{name:"",count:1}].reverse().map(s).reverse();let o=0;for(let l=e.length-1;l>=0;l--)o+=r[a.findIndex((t=>{let{name:i}=t;return i===e[l]}))]*(i%t[l]),i=Math.floor(i/t[l]);return o}var S=i(89379),T=i(50346),R=i(15359),C=i(41882),M=i(68347),A=i(52494),O=i(86866);let F=class extends u.A{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.source=null}get url(){return""}fetchRawTile(e,t,i){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!this._pixelBlockTiles){const{rasterInfo:s}=this,[n,r]=s.storageInfo.tileInfo.size,{sliceId:o}=a,{pixelBlocks:l}=this.source,u={pixelBlock:null==o?l[0]:l[o],useBilinear:"thematic"!==s.dataType,tileSize:{width:n,height:r},level:e,row:t,col:i},c=this.rasterJobHandler?this.rasterJobHandler.clipTile(u,a):(0,A.J$)(u);return Promise.resolve(c)}const s=this._pixelBlockTiles.get("".concat(e,"/").concat(t,"/").concat(i));return Promise.resolve(s)}async _open(e){var t,i;const a=this.source,{pixelBlocks:s,attributeTable:n,statistics:r,histograms:o,name:l,nativeExtent:u,transform:c}=a,h=s[0],{width:p,height:m,pixelType:y}=h,v=null!==(t=a.extent)&&void 0!==t?t:new f.default({xmin:-.5,ymin:.5,xmax:p-.5,ymax:m-.5,spatialReference:new d.default({wkid:3857})}),g=null!==(i=a.isPseudoSpatialReference)&&void 0!==i?i:!a.extent,w={x:v.width/p,y:v.height/m},x=(0,S.A)({},a.keyProperties);n&&(x.DataType="Thematic");const b=new C.default({width:p,height:m,pixelType:y,extent:v,nativeExtent:u,attributeTable:n,transform:c,pixelSize:w,spatialReference:v.spatialReference,bandCount:h.pixels.length,keyProperties:x,multidimensionalInfo:a.multidimensionalInfo,statistics:r,isPseudoSpatialReference:g,histograms:o});this.ioConfig.skipMapInfo&&this.updateImageSpaceRasterInfo(b),this.createRemoteDatasetStorageInfo(b,512,512),this._set("rasterInfo",b),this.updateTileInfo(),b.multidimensionalInfo?await this._buildMDimStats(a.pixelBlocks,b.multidimensionalInfo):await this._buildInMemoryRaster(h,{width:512,height:512},e),b.multidimensionalInfo||(this.source=null),this.datasetName=l}async _buildInMemoryRaster(e,t,i){var s,n,r;const{rasterInfo:o}=this,l=null!==(s=o.storageInfo.maximumPyramidLevel)&&void 0!==s?s:0,u="thematic"!==o.dataType,c=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:e,tileSize:t,maximumPyramidLevel:l,useBilinear:u},i):Promise.resolve((0,A.lD)(e,t,l,u)),f=null!=o.statistics,d=null!=o.histograms,h=this.ioConfig.skipStatistics||f?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:e},i):Promise.resolve((0,O.f4)(e)),p=await(0,T.eachAlways)([c,h]);if(!p[0].value&&p[1].value)throw new a.default("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=p[0].value,f||(o.statistics=null===(n=p[1].value)||void 0===n?void 0:n.statistics),d||(o.histograms=null===(r=p[1].value)||void 0===r?void 0:r.histograms)}async _buildMDimStats(e,t,i){for(let a=0;a<t.variables.length;a++){const s=t.variables[a];if(s.statistics)continue;const n=s.dimensions.map((e=>{var t,i,a;return new R.default({variableName:s.name,dimensionName:e.name,values:[null!==(t=null===(i=e.values)||void 0===i?void 0:i[0])&&void 0!==t?t:null===(a=e.extent)||void 0===a?void 0:a[0]],isSlice:!0})})),r=(0,M.NG)(n,t),o=null==r?null:e[r];if(null==o)continue;const l=this.rasterJobHandler?await this.rasterJobHandler.computeStatisticsHistograms({pixelBlock:o},i):(0,O.eH)(o);s.statistics=l.statistics,s.histograms||(s.histograms=l.histograms)}}};(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],F.prototype,"datasetFormat",void 0),(0,s._)([(0,n.MZ)()],F.prototype,"source",void 0),(0,s._)([(0,n.MZ)()],F.prototype,"url",null),F=(0,s._)([(0,l.$)("esri.layers.support.rasterDatasets.InMemoryRaster")],F);const P=F;var k=i(77725);let D=class extends u.A{constructor(){super(...arguments),this.datasetFormat="CovJSON"}fetchRawTile(e,t,i){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this._inMemoryRaster.fetchRawTile(e,t,i,a)}async _open(e){const{extent:t,pixelBlocks:i,multidimensionalInfo:a,attributeTable:s,bandNames:n}=await this._fetchData(e),{statistics:r,histograms:o}=(0,O.eH)(i[0]),l=null===n||void 0===n?void 0:n.map((e=>({BandName:e}))),u={DataType:s?"Thematic":a?"Scientific":"Generic",BandProperties:l},c=new P({source:{extent:t,pixelBlocks:i,attributeTable:s?k.default.fromJSON(s):null,multidimensionalInfo:a,statistics:r,histograms:o,keyProperties:u,isPseudoSpatialReference:!1}});await c.open(),this._inMemoryRaster=c;const f=this.source?"":this.url.slice(this.url.lastIndexOf("/")+1);this._set("datasetName",f.slice(0,f.indexOf("."))),this._set("rasterInfo",c.rasterInfo)}async _fetchData(e){var t,i,s,n;const r=null!==(t=this.source)&&void 0!==t?t:(await this.request(this.url,{signal:null===e||void 0===e?void 0:e.signal})).data,o="imagery-tile-layer:open-coverage-json";if("coverage"!==(null===(i=r.type)||void 0===i?void 0:i.toLowerCase())||"grid"!==(null===(s=r.domain)||void 0===s||null===(s=s.domainType)||void 0===s?void 0:s.toLowerCase()))throw new a.default(o,"Only coverage with Grid domain type is supported");if(!r.ranges)throw new a.default(o,"Missing ranges in the grid coverage data");if(null===(n=r.domain.referencing)||void 0===n||!n.length)throw new a.default(o,"Missing domain referencing in the grid coverage data");const l=Object.values(r.ranges);for(let u=0;u<l.length;u++){const{axisNames:e,shape:t,type:i,values:s}=l[u];if(!("ndarray"===i.toLowerCase()&&null!==s&&void 0!==s&&s.length&&null!==e&&void 0!==e&&e.length&&null!==t&&void 0!==t&&t.length))throw new a.default(o,"Only ranges with valid NdArray, axisNames, shape, and inline values are supported");if(!y(e[e.length-1])||!v(e[e.length-2]))throw new a.default(o,"Only row-major ordered pixel values are supported. X axis must be the last axis.")}return function(e){var t;const{width:i,height:a,extent:s,dimensions:n}=g(e),{ranges:r}=e,o=Object.keys(r).sort(((e,t)=>e<t?-1:1)),l=[];for(let h=0;h<o.length;h++){const e=o[h];(null===n||void 0===n?void 0:n.length)&&l.push({name:e,dimensions:n})}const u=b(e);l.forEach((e=>u[e.name]&&Object.assign(e,u[e.name])));const c=l.length?{variables:l}:void 0,f=[];for(let h=0;h<o.length;h++){const e=o[h],{values:t,dataType:s,axisNames:l,shape:u}=r[e],c=u.length>2?h*u.slice(0,-2).reduce(((e,t)=>e*t)):0,d=l.slice(0,-2),m=u.slice(0,-2),y="float"===s?"f32":I(t),v=i*a,g=t.length/v;for(let r=0;r<g;r++){const e=p.default.createEmptyBand(y,v),s=new Uint8Array(v).fill(255);let o=!1;const l=r*v;for(let i=0;i<v;i++){const a=t[l+i];null==a?(s[i]=0,o=!0):e[i]=a}if(0===h||null!==n&&void 0!==n&&n.length){const t=new p.default({width:i,height:a,mask:o?s:null,pixels:[e],pixelType:y});t.updateStatistics(),null!==n&&void 0!==n&&n.length?f[_(d,m,r)+c]=t:f.push(t)}else{const t=f[r];t.pixels.push(e),o?t.mask&&(t.mask=p.default.combineBandMasks([t.mask,s])):t.mask=o?s:null}}}const d=null===(t=Object.values(u).find((e=>e.attributeTable)))||void 0===t?void 0:t.attributeTable;return{extent:s,pixelBlocks:f,multidimensionalInfo:c,attributeTable:d,bandNames:c?void 0:o}}(r)}};(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],D.prototype,"datasetFormat",void 0),(0,s._)([(0,n.MZ)({constructOnly:!0})],D.prototype,"source",void 0),D=(0,s._)([(0,l.$)("esri.layers.support.rasterDatasets.CovJSONRaster")],D);const N=D;var E=i(18690),L=i(80963),B=i(86769),z=i(29754);function J(e,t){if(!e||!t)return null;const i=[];for(let a=0;a<e.length;a++)i.push(e[a]),i.push(t[a]);return i}function U(e){if(!e)return null;let t=Number(e);if(!isNaN(t)&&0!==t)return new d.default({wkid:t});if(e=String(e).trim(),(0,L.jp)(e))return new d.default({wkt2:e});const i=e.toUpperCase();if(i.startsWith("COMPD_CS")){if(!i.includes("VERTCS")||!i.includes("GEOGCS")&&!i.startsWith("PROJCS"))return null;const a=i.indexOf("VERTCS"),s=i.indexOf("PROJCS"),n=s>-1?s:i.indexOf("GEOGCS");if(-1===n)return null;const r=e.slice(n,e.lastIndexOf("]",a)+1).trim(),o=e.slice(a,e.lastIndexOf("]")).trim();t=j(r);const l=new d.default(t?{wkid:t}:{wkt:r}),u=j(o);return u&&(l.vcsWkid=u),l}return i.startsWith("GEOGCS")||i.startsWith("PROJCS")?(t=j(e),new d.default(0!==t?{wkid:t}:{wkt:e})):null}function j(e){var t;const i=e.replaceAll("]","[").replaceAll('"',"").split("[").map((e=>e.trim())).filter((e=>""!==e)),a=i[i.length-1].split(","),s=null===(t=a[0])||void 0===t?void 0:t.toLowerCase();if(("epsg"===s||"esri"===s)&&e.endsWith('"]]')){const e=Number(a[1]);if(!isNaN(e)&&0!==e)return e}return 0}function H(e){var t;if("pamdataset"!==(null===e||void 0===e||null===(t=e.documentElement.tagName)||void 0===t?void 0:t.toLowerCase()))return{};const i={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};e.documentElement.childNodes.forEach((e=>{if(1===e.nodeType)if((0,B.g7)(e,"SRS")){if(!i.spatialReference){const t=(0,B.mX)(e);i.spatialReference=U(t)}}else if((0,B.g7)(e,"Metadata"))if("xml:ESRI"===e.getAttribute("domain")){const{spatialReference:t,transform:a}=function(e){var t;const i=(0,B.V6)(e,"GeodataXform"),a=U((0,B.v7)(i,"SpatialReference/WKID")||(0,B.mX)(i,"SpatialReference/WKT"));if("typens:PolynomialXform"!==i.getAttribute("xsi:type"))return{spatialReference:a,transform:null};const s=null!==(t=(0,B.v7)(i,"PolynomialOrder"))&&void 0!==t?t:1,n=(0,B.Ui)(i,"CoeffX/Double"),r=(0,B.Ui)(i,"CoeffY/Double"),o=(0,B.Ui)(i,"InverseCoeffX/Double"),l=(0,B.Ui)(i,"InverseCoeffY/Double"),u=J(n,r),c=J(o,l);return{spatialReference:a,transform:u&&c&&u.length&&c.length?new z.A({spatialReference:a,polynomialOrder:s,forwardCoefficients:u,inverseCoefficients:c}):null}}(e);i.transform=a,i.spatialReference||(i.spatialReference=t)}else(0,B.IC)(e,"MDI").forEach((e=>i.metadata[e.getAttribute("key")]=(0,B.mX)(e)));else if((0,B.g7)(e,"PAMRasterBand")){const t=function(e){var t;const i=(0,B.v7)(e,"NoDataValue"),a=(0,B.V6)(e,"Histograms/HistItem"),s=(0,B.v7)(a,"HistMin"),n=(0,B.v7)(a,"HistMax"),r=(0,B.v7)(a,"BucketCount"),o=null===(t=(0,B.mX)(a,"HistCounts"))||void 0===t?void 0:t.split("|").map((e=>Number(e)));let l,u,c,f;(0,B.IC)(e,"Metadata/MDI").forEach((e=>{var t;const i=Number(null!==(t=e.textContent)&&void 0!==t?t:e.nodeValue);switch(e.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":l=i;break;case"STATISTICS_MAXIMUM":u=i;break;case"STATISTICS_MEAN":c=i;break;case"STATISTICS_STDDEV":f=i}}));const d=(0,B.v7)(e,"Metadata/SourceBandIndex");return{noDataValue:i,histogram:null!==o&&void 0!==o&&o.length&&null!=s&&null!=n?{min:s,max:n,size:r||o.length,counts:o}:null,sourceBandIndex:d,statistics:null!=l&&null!=u?{min:l,max:u,avg:c,stddev:f}:null}}(e);null!=t.sourceBandIndex&&null==i.rasterBands[t.sourceBandIndex]?i.rasterBands[t.sourceBandIndex]=t:i.rasterBands.push(t)}}));const a=i.rasterBands;if(a.length){const e=!!a[0].statistics;i.statistics=e?a.map((e=>e.statistics)).filter(E.Ru):null;const t=!!a[0].histogram;i.histograms=t?a.map((e=>e.histogram)).filter(E.Ru):null}return i}var G=i(59648);let Z=class extends u.A{fetchRawTile(e,t,i){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this._inMemoryRaster.fetchRawTile(e,t,i,a)}async _open(e){const t=await this._fetchData(e);let{spatialReference:i,statistics:a,histograms:s,transform:n}=await this._fetchAuxiliaryData(e);const r=!i;r&&(i=new d.default({wkid:3857})),(null===s||void 0===s?void 0:s.length)&&null==a&&(a=(0,O.Pg)(s));const{width:o,height:l}=t;let u=new f.default({xmin:-.5,ymin:.5-l,xmax:o-.5,ymax:.5,spatialReference:i});const c=n?n.forwardTransform(u):u;let h=!0;if(n){const e=n.forwardCoefficients;h=e&&0===e[1]&&0===e[2],h&&(n=null,u=c)}const p=new P({source:{extent:c,nativeExtent:u,transform:n,pixelBlocks:[t],statistics:a,histograms:s,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:r},ioConfig:{sampling:"closest",skipStatistics:!0}});this.ioConfig.skipMapInfo&&(p.ioConfig.skipMapInfo=!0),await p.open(),p.source=null,this._set("rasterInfo",p.rasterInfo),this._inMemoryRaster=p}async _fetchData(e){const{data:t}=await this.request(this.url,{responseType:"array-buffer",signal:null===e||void 0===e?void 0:e.signal}),i=(0,G.g)(t).toUpperCase();if("JPG"!==i&&"PNG"!==i&&"GIF"!==i&&"BMP"!==i)throw new a.default("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",i);const s=i.toLowerCase(),n="gif"===s||"bmp"===s||!(0,r.A)("ios"),o=await this.decodePixelBlock(t,{format:s,useCanvas:n,hasNoZlibMask:!0});if(null==o)throw new a.default("image-aux-raster:open","the data cannot be decoded");return o}async _fetchAuxiliaryData(e){var t;const i=null===e||void 0===e?void 0:e.signal,{skipExtensions:a=[],skipMapInfo:s}=this.ioConfig,n=s||a.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:i}),r=this.datasetFormat,o="JPG"===r?"jgw":"PNG"===r?"pgw":"BMP"===r?"bpw":null,l=o&&a.includes(o)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+o,{responseType:"text",signal:i}),u=await(0,T.eachAlways)([n,l]);if(null!==i&&void 0!==i&&i.aborted)throw(0,T.createAbortError)();const c=H(null===(t=u[0].value)||void 0===t?void 0:t.data);if(!c.transform){const e=u[1].value?u[1].value.data.split("\n").slice(0,6).map((e=>Number(e))):null;c.transform=6===(null===e||void 0===e?void 0:e.length)?new z.A({forwardCoefficients:[e[4],e[5],e[0],-e[1],e[2],-e[3]]}):null}return c}};(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],Z.prototype,"datasetFormat",void 0),Z=(0,s._)([(0,l.$)("esri.layers.support.rasterDatasets.ImageAuxRaster")],Z);const q=Z;var V=i(30726),W=i(90534),X=i(19247),Y=i(49653),$=i(88235),K=i(82356),Q=i(26855),ee=i(25213);let te=class extends u.A{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async fetchRawTile(e,t,i){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{storageInfo:s,extent:n}=this.rasterInfo,{transposeInfo:r}=s,o=null!=r&&!!a.transposedVariableName;if(this._slices&&!o&&null==a.sliceId)return null;const l=o?0:s.maximumPyramidLevel-e+this._levelOffset,u="".concat(this.url,"/tile/").concat(l,"/").concat(t,"/").concat(i),c=this._slices?o?{variable:a.transposedVariableName}:{sliceId:a.sliceId||0}:null,{data:f}=await this.request(u,{query:c,responseType:"array-buffer",signal:a.signal});if(!f)return null;const d=o?r.tileSize:s.tileInfo.size,h=await this.decodePixelBlock(f,{width:d[0],height:d[1],planes:null,pixelType:null,isPoint:"Elevation"===this.tileType,returnInterleaved:o,noDataValue:this.rasterInfo.noDataValue});if(null==h)return null;const p=s.blockBoundary[e];if("jpg"!==s.compression||i>p.minCol&&i<p.maxCol&&t>p.minRow&&t<p.maxRow)return h;const{origin:m,blockWidth:y,blockHeight:v}=s,{x:g,y:w}=this.getPyramidPixelSize(e),x=Math.round((n.xmin-m.x)/g)%y,b=Math.round((n.xmax-m.x)/g)%y||y,I=Math.round((m.y-n.ymax)/w)%v,_=Math.round((m.y-n.ymin)/w)%v||v,S=i===p.minCol?x:0,T=t===p.minRow?I:0,R=i===p.maxCol?b:y,C=t===p.maxRow?_:v;return(0,A.z$)(h,{x:S,y:T},{width:R-S,height:C-T}),h}getSliceIndex(e){if(!this._slices||null==e||0===e.length)return null;const t=e;for(let i=0;i<this._slices.length;i++){const e=this._slices[i].multidimensionalDefinition;if(e.length===t.length&&!e.some((e=>{const i=t.find((t=>e.variableName===t.variableName&&t.dimensionName===e.dimensionName));return!i||(Array.isArray(e.values[0])?"".concat(e.values[0][0],"-").concat(e.values[0][1]):e.values[0])!==(Array.isArray(i.values[0])?"".concat(i.values[0][0],"-").concat(i.values[0][1]):i.values[0])})))return i}return null}async fetchVariableStatisticsHistograms(e,t){var i;const a=this.request(this.url+"/statistics",{query:{variable:e,f:"json"},signal:t}).then((e=>{var t;return null===(t=e.data)||void 0===t?void 0:t.statistics})),s=this.request(this.url+"/histograms",{query:{variable:e,f:"json"},signal:t}).then((e=>{var t;return null===(t=e.data)||void 0===t?void 0:t.histograms})),n=await Promise.all([a,s]);return n[0]&&n[0].forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),null!==(i=n[1])&&void 0!==i&&null!==(i=i[0])&&void 0!==i&&null!==(i=i.counts)&&void 0!==i&&i.length||(n[1]=null),{statistics:n[0]||null,histograms:n[1]||null}}async computeBestPyramidLevelForLocation(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this._tilemapCache)return 0;let i=this.identifyPixelLocation(e,0,t.datumTransformation);if(null===i)return null;let a=0;const{maximumPyramidLevel:s}=this.rasterInfo.storageInfo;let n=s-a+this._levelOffset;const r=i.srcLocation;for(;n>=0;){try{if("available"===await this._tilemapCache.fetchAvailability(n,i.row,i.col,t))break}catch(o){}if(n--,a++,i=this.identifyPixelLocation(r,a,t.datumTransformation),null===i)return null}return-1===n||null==i?null:a}async _open(e){var t,i,s,n,r;const o=null===e||void 0===e?void 0:e.signal,l=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:o});l.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const u=l.data;if(this.sourceJSON=u,!u)throw new a.default("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!u.tileInfo)throw new a.default("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();this.tileType=u.cacheType,null==this.tileType&&(["jpg","jpeg","png","png8","png24","png32","mixed"].includes(u.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===u.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=null!==(t=null===(i=u.name)||void 0===i?void 0:i.slice(u.name.indexOf("/")+1))&&void 0!==t?t:"";const c=await this._fetchRasterInfo({signal:o});if(null==c)throw new a.default("image-server-raster:open","cannot initialize image service");(0,ee.E9)(c,u);const f="Map"===this.tileType?function(e,t){if(!e)return null;const{minScale:i,maxScale:a,minLOD:s,maxLOD:n}=t;if(null!=s&&null!=n)return $.default.fromJSON((0,S.A)((0,S.A)({},e),{},{lods:e.lods.filter((e=>{let{level:t}=e;return null!=t&&t>=s&&t<=n}))}));if(0!==i&&0!==a){const t=e=>Math.round(1e4*e)/1e4,s=i?t(i):1/0,n=a?t(a):-1/0;return $.default.fromJSON((0,S.A)((0,S.A)({},e),{},{lods:e.lods.filter((e=>{const i=t(e.scale);return i<=s&&i>=n}))}))}return $.default.fromJSON(e)}(u.tileInfo,u):$.default.fromJSON(u.tileInfo);(0,V.Lw)(f);const[d,h]=this._computeMinMaxLOD(c,f),{extent:p,pixelSize:m}=c,y=.5/c.width*m.x,v=Math.max(m.x,m.y),{lods:g}=f;("Map"!==this.tileType&&0!==u.maxScale||Math.abs(m.x-m.y)>y||!g.some((e=>Math.abs(e.resolution-v)<y)))&&(m.x=m.y=d.resolution,c.width=Math.ceil((p.xmax-p.xmin)/m.x-.1),c.height=Math.ceil((p.ymax-p.ymin)/m.y-.1));const w=d.level-h.level,[x,b]=f.size,I=[],_=[];g.forEach(((e,t)=>{e.level>=h.level&&e.level<=d.level&&I.push({x:e.resolution,y:e.resolution}),t<g.length-1&&_.push(Math.round(10*e.resolution/g[t+1].resolution)/10)})),I.sort(((e,t)=>e.x-t.x));const T=this.computeBlockBoundary(p,x,b,f.origin,I,w),R=I.length>1?I.slice(1):null;let C;u.transposeInfo&&(C={tileSize:[u.transposeInfo.rows,u.transposeInfo.cols],packetSize:null!==(s=null===(n=c.keyProperties)||void 0===n?void 0:n._yxs.PacketSize)&&void 0!==s?s:0});const M=_.length<=1||_.length>=3&&_.slice(0,-1).every((e=>e===_[0]))?null!==(r=_[0])&&void 0!==r?r:2:Math.round(10/(h.resolution/d.resolution)**(-1/w))/10;if(c.storageInfo=new Y.A({blockWidth:f.size[0],blockHeight:f.size[1],pyramidBlockWidth:f.size[0],pyramidBlockHeight:f.size[1],pyramidResolutions:R,pyramidScalingFactor:M,compression:f.format,origin:f.origin,firstPyramidLevel:1,maximumPyramidLevel:w,tileInfo:f,transposeInfo:C,blockBoundary:T}),function(e){const{extent:t,spatialReference:i}=e;t.xmin>-1&&t.xmax>181&&(null===i||void 0===i?void 0:i.wkid)&&i.isGeographic&&(e.nativeExtent=e.extent,e.transform=new Q.A,e.extent=e.transform.forwardTransform(t))}(c),this._set("rasterInfo",c),u.capabilities.toLowerCase().includes("tilemap")){const e={tileInfo:c.storageInfo.tileInfo,parsedUrl:(0,W.urlToObject)(this.url),url:this.url,tileServers:[]};this._tilemapCache=new K.d({layer:e})}}async _fetchRasterInfo(e){const t=this.sourceJSON;if("Map"===this.tileType){const e=t.fullExtent||t.extent,i=Math.ceil((e.xmax-e.xmin)/t.pixelSizeX-.1),a=Math.ceil((e.ymax-e.ymin)/t.pixelSizeY-.1),s=d.default.fromJSON(t.spatialReference||e.spatialReference),n=new X.default({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:s});return new C.default({width:i,height:a,bandCount:3,extent:f.default.fromJSON(e),spatialReference:s,pixelSize:n,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:i}=e,a=(0,ee.Tw)(this.url,this.sourceJSON,{signal:i,query:this.ioConfig.customFetchParameters}),s=t.hasMultidimensions?this.request("".concat(this.url,"/slices"),{query:{f:"json"},signal:i}).then((e=>{var t;return null===(t=e.data)||void 0===t?void 0:t.slices})).catch((()=>null)):null,n=await Promise.all([a,s]);return this._slices=n[1],n[0]}_fixScaleInServiceInfo(){const{sourceJSON:e}=this;e.minScale&&e.minScale<0&&(e.minScale=0),e.maxScale&&e.maxScale<0&&(e.maxScale=0)}_computeMinMaxLOD(e,t){var i,a;const{pixelSize:s}=e,n=.5/e.width*s.x,{lods:r}=t,o=t.lodAt(Math.max.apply(null,r.map((e=>e.level)))),l=t.lodAt(Math.min.apply(null,r.map((e=>e.level)))),{tileType:u}=this;if("Map"===u)return this._levelOffset=r[0].level,[o,l];var c;if("Raster"===u)return[null!==(c=r.find((e=>e.resolution===s.x)))&&void 0!==c?c:o,l];const{minScale:f,maxScale:d}=this.sourceJSON;let h=o;d>0&&(h=r.find((e=>Math.abs(e.scale-d)<n)),h||(h=null!==(i=r.filter((e=>e.scale>d)).sort(((e,t)=>e.scale>t.scale?1:-1))[0])&&void 0!==i?i:o));let p=l;return f>0&&(p=null!==(a=r.find((e=>Math.abs(e.scale-f)<n)))&&void 0!==a?a:l,this._levelOffset=p.level-l.level),[h,p]}};(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],te.prototype,"datasetFormat",void 0),(0,s._)([(0,n.MZ)()],te.prototype,"tileType",void 0),te=(0,s._)([(0,l.$)("esri.layers.support.rasterDatasets.ImageServerRaster")],te);const ie=te;var ae=i(10798);const se=new Map;se.set("Int8","s8"),se.set("UInt8","u8"),se.set("Int16","s16"),se.set("UInt16","u16"),se.set("Int32","s32"),se.set("UInt32","u32"),se.set("Float32","f32"),se.set("Float64","f32"),se.set("Double64","f32");const ne=new Map;ne.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),ne.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),ne.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),ne.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let re=class extends u.A{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async fetchRawTile(e,t,i){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{blockWidth:s,blockHeight:n,blockBoundary:r}=this.rasterInfo.storageInfo,o=r[e];if(!o||o.maxRow<t||o.maxCol<i||o.minRow>t||o.minCol>i)return null;const{bandCount:l,pixelType:u}=this.rasterInfo,{ranges:c,actualTileWidth:f,actualTileHeight:d}=this._getTileLocation(e,t,i);if(!c||0===c.length)return null;if(0===c[0].from&&0===c[0].to){const e=new Uint8Array(s*n);return new p.default({width:s,height:n,pixels:void 0,mask:e,validPixelCount:0})}const{bandIds:h}=this.ioConfig,m=this._getBandSegmentCount(),y=[];let v=0;for(v=0;v<m;v++)h&&!h.includes(v)||y.push(this.request(this._files.data,{range:{from:c[v].from,to:c[v].to},responseType:"array-buffer",signal:a.signal}));const g=await Promise.all(y),w=g.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),x=new Uint8Array(w),b=[];let I=0;for(v=0;v<m;v++)b.push(I),x.set(new Uint8Array(g[v].data),I),I+=g[v].data.byteLength;const _=ne.get(this.rasterInfo.storageInfo.compression).decoderFormat,S=await this.decodePixelBlock(x.buffer,{width:s,height:n,format:_,planes:(null===h||void 0===h?void 0:h.length)||l,offsets:b,pixelType:u});if(null==S)return null;let{noDataValue:T}=this.rasterInfo;if(null!=T&&"lerc"!==_&&!S.mask&&(T=T[0],null!=T)){const e=S.width*S.height,t=new Uint8Array(e);if(Math.abs(T)>1e24)for(v=0;v<e;v++)Math.abs((S.pixels[0][v]-T)/T)>1e-6&&(t[v]=1);else for(v=0;v<e;v++)S.pixels[0][v]!==T&&(t[v]=1);S.mask=t}let R=0,C=0;if(f!==s||d!==n){let e=S.mask;if(e)for(v=0;v<n;v++)if(C=v*s,v<d)for(R=f;R<s;R++)e[C+R]=0;else for(R=0;R<s;R++)e[C+R]=0;else for(e=new Uint8Array(s*n),S.mask=e,v=0;v<d;v++)for(C=v*s,R=0;R<f;R++)e[C+R]=1}return S}async _open(e){this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const t=e?e.signal:null,i=await this.request(this.url,{responseType:"xml",signal:t}),{rasterInfo:a,files:s}=this._parseHeader(i.data),{skipMapInfo:n,skipExtensions:r=[]}=this.ioConfig;if(!r.includes("aux.xml")&&!n){var o;const t=await this._fetchAuxiliaryData(e);null!=t&&(a.statistics=null!==(o=t.statistics)&&void 0!==o?o:a.statistics,a.histograms=t.histograms,t.histograms&&null==a.statistics&&(a.statistics=(0,O.Pg)(t.histograms)))}n&&this.updateImageSpaceRasterInfo(a),this._set("rasterInfo",a),this._files=s;const l=await this.request(s.index,{responseType:"array-buffer",signal:t});this._storageIndex=function(e){if(e.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let t,i,a,s,n,r;if(ae.Z){for(i=new Uint8Array(e),s=new ArrayBuffer(e.byteLength),a=new Uint8Array(s),n=0;n<e.byteLength/4;n++)for(r=0;r<4;r++)a[4*n+r]=i[4*n+3-r];t=new Uint32Array(s)}else t=new Uint32Array(e);return t}(l.data);const{blockWidth:u,blockHeight:c}=this.rasterInfo.storageInfo,f=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:d,height:h}=this.rasterInfo,p=[],m=this._getBandSegmentCount();let y=0,v=-1;for(;y<this._storageIndex.length;){v++;const e=Math.ceil(d/u/f**v)-1,t=Math.ceil(h/c/f**v)-1;y+=(e+1)*(t+1)*m*4,p.push({maxRow:t,maxCol:e,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=p,v>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=v),this.updateTileInfo()}_getBandSegmentCount(){return ne.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(e,t,i){const{blockWidth:a,blockHeight:s,pyramidScalingFactor:n}=this.rasterInfo.storageInfo,{width:r,height:o}=this.rasterInfo,l=this._getBandSegmentCount();let u,c,f,d=0,h=0;for(f=0;f<e;f++)h=n**f,u=Math.ceil(r/a/h),c=Math.ceil(o/s/h),d+=u*c;h=n**e,u=Math.ceil(r/a/h),c=Math.ceil(o/s/h),d+=t*u+i,d*=4*l;const p=this._storageIndex.subarray(d,d+4*l);let m=0,y=0;const v=[];for(let g=0;g<l;g++)m=p[4*g]*2**32+p[4*g+1],y=m+p[4*g+2]*2**32+p[4*g+3],v.push({from:m,to:y});return{ranges:v,actualTileWidth:i<u-1?a:Math.ceil(r/h)-a*(u-1),actualTileHeight:t<c-1?s:Math.ceil(o/h)-s*(c-1)}}_parseHeader(e){const t=(0,B.V6)(e,"MRF_META/Raster");if(!t)throw new a.default("mrf:open","not a valid MRF format");const i=(0,B.V6)(t,"Size"),s=parseInt(i.getAttribute("x"),10),n=parseInt(i.getAttribute("y"),10),r=parseInt(i.getAttribute("c"),10),o=((0,B.mX)(t,"Compression")||"none").toLowerCase();if(!ne.has(o))throw new a.default("mrf:open","currently does not support compression "+o);const l=(0,B.mX)(t,"DataType")||"UInt8",u=se.get(l);if(null==u)throw new a.default("mrf:open","currently does not support pixel type "+l);const c=(0,B.V6)(t,"PageSize"),h=parseInt(c.getAttribute("x"),10),p=parseInt(c.getAttribute("y"),10),m=(0,B.V6)(t,"DataValues");let y,v;if(m&&(v=m.getAttribute("NoData"),null!=v&&(y=v.trim().split(" ").map((e=>parseFloat(e))))),(0,B.V6)(e,"MRF_META/CachedSource"))throw new a.default("mrf:open","currently does not support MRF referencing other data files");const g=(0,B.V6)(e,"MRF_META/GeoTags"),w=(0,B.V6)(g,"BoundingBox");let x,b=!1;if(null!=w){var I;const e=parseFloat(w.getAttribute("minx")),t=parseFloat(w.getAttribute("miny")),i=parseFloat(w.getAttribute("maxx")),a=parseFloat(w.getAttribute("maxy")),s=(0,B.mX)(g,"Projection")||"";let n=d.default.WGS84;if("LOCAL_CS[]"!==s)if(s.toLowerCase().startsWith("epsg:")){const e=Number(s.slice(5));isNaN(e)||0===e||(n=new d.default({wkid:e}))}else n=null!==(I=U(s))&&void 0!==I?I:d.default.WGS84;else b=!0,n=new d.default({wkid:3857});x=new f.default(e,t,i,a),x.spatialReference=n}else b=!0,x=new f.default({xmin:-.5,ymin:.5-n,xmax:s-.5,ymax:.5,spatialReference:new d.default({wkid:3857})});const _=(0,B.V6)(e,"MRF_META/Rsets"),S=parseInt((null===_||void 0===_?void 0:_.getAttribute("scale"))||"2",10),T=x.spatialReference,R=new Y.A({origin:new X.default({x:x.xmin,y:x.ymax,spatialReference:T}),blockWidth:h,blockHeight:p,pyramidBlockWidth:h,pyramidBlockHeight:p,compression:o,pyramidScalingFactor:S}),M=new X.default({x:x.width/s,y:x.height/n,spatialReference:T}),A=new C.default({width:s,height:n,extent:x,isPseudoSpatialReference:b,spatialReference:T,bandCount:r,pixelType:u,pixelSize:M,noDataValue:y,storageInfo:R}),O=(0,B.mX)(e,"datafile"),F=(0,B.mX)(e,"IndexFile");return{rasterInfo:A,files:{mrf:this.url,index:F||this.url.replace(".mrf",".idx"),data:O||this.url.replace(".mrf",ne.get(o).blobExtension)}}}async _fetchAuxiliaryData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null===e||void 0===e?void 0:e.signal});return H(t)}catch(t){return null}}};(0,s._)([(0,n.MZ)()],re.prototype,"_files",void 0),(0,s._)([(0,n.MZ)()],re.prototype,"_storageIndex",void 0),(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],re.prototype,"datasetFormat",void 0),re=(0,s._)([(0,l.$)("esri.layers.support.rasterDatasets.MRFRaster")],re);const oe=re;var le=i(50611);function ue(e){const t=e.fields,i=e.records,a=t.some((e=>"oid"===e.name.toLowerCase()))?"OBJECTID":"OID",s=[{name:a,type:"esriFieldTypeOID",alias:"OID"}].concat(t.map((e=>({name:e.name,type:"esriFieldType"+e.typeName,alias:e.name})))),n=s.map((e=>e.name)),r=[];let o=0,l=0;return i.forEach((e=>{const t={};for(t[a]=o++,l=1;l<n.length;l++)t[n[l]]=e[l-1];r.push({attributes:t})})),{displayFieldName:"",fields:s,features:r}}class ce{static get supportedVersions(){return[5]}static parse(e){const t=new DataView(e),i=3&t.getUint8(0);if(3!==i)return{header:{version:i},recordSet:null};const a=t.getUint32(4,!0),s=t.getUint16(8,!0),n=t.getUint16(10,!0),r={version:i,recordCount:a,headerByteCount:s,recordByteCount:n};let o=32;const l=[],u=[];let c;if(3===i){for(;13!==t.getUint8(o);)c=String.fromCharCode(t.getUint8(o+11)).trim(),l.push({name:(0,le.w)(new Uint8Array(e,o,11)),type:c,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(c)],length:t.getUint8(o+16)}),o+=32;if(o+=1,l.length>0)for(;u.length<a&&e.byteLength-o>n;){const i=[];32===t.getUint8(o)?(o+=1,l.forEach((t=>{if("C"===t.type)i.push((0,le.w)(new Uint8Array(e,o,t.length)).trim());else if("N"===t.type)i.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(e,o,t.length)).trim(),10));else if("F"===t.type)i.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(e,o,t.length)).trim()));else if("D"===t.type){const a=String.fromCharCode.apply(null,new Uint8Array(e,o,t.length)).trim();i.push(new Date(parseInt(a.slice(0,4),10),parseInt(a.slice(4,6),10)-1,parseInt(a.slice(6,8),10)))}o+=t.length})),u.push(i)):o+=n}}return{header:r,fields:l,records:u,recordSet:ue({fields:l,records:u})}}}var fe=i(87018),de=i(48613);const he=(e,t)=>{var i;return null===(i=e.get(t))||void 0===i?void 0:i.values},pe=(e,t)=>{var i;return null===(i=e.get(t))||void 0===i||null===(i=i.values)||void 0===i?void 0:i[0]};let me=class extends u.A{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async fetchRawTile(e,t,i){var a;let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(null===(a=this._headerInfo)||void 0===a||!a.isSupported||this.isBlockOutside(e,t,i))return null;const n=await this._fetchRawTiffTile(e,t,i,!1,s);if(null!=n&&this._headerInfo.hasMaskBand){const a=await this._fetchRawTiffTile(e,t,i,!0,s);null!=a&&a.pixels[0]instanceof Uint8Array&&(n.mask=a.pixels[0])}return n}async _open(e){var t,i;const s=e?e.signal:null,{data:n}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:s});if(!n)throw new a.default("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:r,firstIFDPos:l,isBigTiff:u}=(0,fe.uT)(n),c=[];await this._readIFDs(c,n,r,l,0,u?8:4,s);const{imageInfo:h,rasterInfo:p}=function(e){var t,i;const a=(0,fe.uc)(e),{width:s,height:n,tileWidth:r,tileHeight:o,planes:l,pixelType:u,compression:c,firstPyramidLevel:h,maximumPyramidLevel:p,pyramidBlockWidth:m,pyramidBlockHeight:y,pyramidResolutions:v,tileBoundary:g,affine:w,metadata:x}=a,b=(null===(t=a.extent.spatialReference)||void 0===t?void 0:t.wkt)||(null===(i=a.extent.spatialReference)||void 0===i?void 0:i.wkid);let I=U(b),_=!!a.isPseudoGeographic;null==I&&(_=!0,I=new d.default({wkid:3857}));const T=new f.default((0,S.A)((0,S.A)({},a.extent),{},{spatialReference:I})),R=new X.default(T?{x:T.xmin,y:T.ymax,spatialReference:I}:{x:0,y:0}),M=new Y.A({blockWidth:r,blockHeight:o,pyramidBlockWidth:m,pyramidBlockHeight:y,compression:c,origin:R,firstPyramidLevel:h,maximumPyramidLevel:p,pyramidResolutions:v,blockBoundary:g}),A=new X.default({x:(T.xmax-T.xmin)/s,y:(T.ymax-T.ymin)/n,spatialReference:I}),O=x?{BandProperties:x.bandProperties,DataType:x.dataType}:{};let F=null;const P=pe(e[0],"PHOTOMETRICINTERPRETATION"),k=he(e[0],"COLORMAP");if(P<=3&&(null===k||void 0===k?void 0:k.length)>3&&k.length%3==0){F=[];const e=k.length/3;for(let t=0;t<e;t++)F.push([t,k[t]>>>8,k[t+e]>>>8,k[t+2*e]>>>8])}const D=new C.default({width:s,height:n,bandCount:l,pixelType:u,pixelSize:A,storageInfo:M,spatialReference:I,isPseudoSpatialReference:_,keyProperties:O,extent:T,colormap:F,statistics:x?x.statistics:null});if(null!==w&&void 0!==w&&w.length&&(D.nativeExtent=new f.default({xmin:-.5,ymin:.5-n,xmax:s-.5,ymax:.5,spatialReference:I}),D.transform=new z.A({polynomialOrder:1,forwardCoefficients:[w[2]+w[0]/2,w[5]-w[3]/2,w[0],w[3],-w[1],-w[4]]}),D.extent=D.transform.forwardTransform(D.nativeExtent),D.pixelSize=new X.default({x:(T.xmax-T.xmin)/s,y:(T.ymax-T.ymin)/n,spatialReference:I}),M.origin.x=-.5,M.origin.y=.5),v){const{x:e,y:t}=D.pixelSize;v.forEach((i=>{i.x*=e,i.y*=t}))}return{imageInfo:a,rasterInfo:D}}(c),m=(0,fe.zS)(c),y=(0,fe.r9)(c);if(this._headerInfo=(0,S.A)({littleEndian:r,isBigTiff:u,ifds:c,pyramidIFDs:m,maskIFDs:y},h),this._set("rasterInfo",p),!h.isSupported)throw new a.default("tiffraster:open","this tiff is not supported: "+h.message);if(!h.tileWidth)throw new a.default("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");p.isPseudoSpatialReference&&o.A.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const v=null===(t=c[0].get("PREDICTOR"))||void 0===t||null===(t=t.values)||void 0===t?void 0:t[0];if(3===(null===(i=c[0].get("SAMPLEFORMAT"))||void 0===i||null===(i=i.values)||void 0===i?void 0:i[0])&&2===v)throw new a.default("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");const{skipMapInfo:g,skipExtensions:w=[]}=this.ioConfig;if(!w.includes("aux.xml")&&!g){const t=await this._fetchAuxiliaryMetaData(e);null!=t&&function(e,t){var i;if(t.statistics=null!==(i=e.statistics)&&void 0!==i?i:t.statistics,t.histograms=e.histograms,e.histograms&&null==t.statistics&&(t.statistics=(0,O.Pg)(e.histograms)),e.transform&&null==t.transform){t.transform=e.transform,t.nativeExtent=t.extent;const i=t.transform.forwardTransform(t.nativeExtent);t.pixelSize=new X.default({x:(i.xmax-i.xmin)/t.width,y:(i.ymax-i.ymin)/t.height,spatialReference:t.spatialReference}),t.extent=i}t.isPseudoSpatialReference&&e.spatialReference&&(t.spatialReference=e.spatialReference,t.extent.spatialReference=t.nativeExtent.spatialReference=t.storageInfo.origin.spatialReference=t.spatialReference)}(t,p)}w.includes("vat.dbf")||1!==p.bandCount||"u8"!==p.pixelType||g||(p.attributeTable=await this._fetchAuxiliaryTable(e),null!=p.attributeTable&&(p.keyProperties.DataType="thematic")),g&&this.updateImageSpaceRasterInfo(p),this.updateTileInfo()}async _readIFDs(e,t,i,a,s){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:4,r=arguments.length>6?arguments[6]:void 0;if(!a)return null;(a>=t.byteLength||a<0)&&(t=(await this.request(this.url,{range:{from:a+s,to:a+s+this._bufferSize},responseType:"array-buffer",signal:r})).data,s=a+s,a=0);const o=await this._readIFD(t,i,a,s,de.A.tiffTags,n,r);if(e.push(o.ifd),!o.nextIFD)return null;await this._readIFDs(e,t,i,o.nextIFD-s,s,n,r)}async _readIFD(e,t,i,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:de.A.tiffTags,n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:4,r=arguments.length>6?arguments[6]:void 0;if(!e)return null;const o=(0,fe.JM)(e,t,i,a,s,n);if(o.success){var l,u;const i=[];if(null!==(l=o.ifd)&&void 0!==l&&l.forEach((e=>{e.values||i.push(e)})),i.length>0){const s=i.map((e=>e.offlineOffsetSize)).filter(E.Ru),n=Math.min.apply(null,s.map((e=>e[0])));if(Math.min.apply(null,s.map((e=>e[0]+e[1])))-n<=this._bufferSize){const{data:s}=await this.request(this.url,{range:{from:n,to:n+this._bufferSize},responseType:"array-buffer",signal:r});e=s,a=n,i.forEach((i=>(0,fe.Cr)(e,t,i,a)))}}if(null!==(u=o.ifd)&&void 0!==u&&u.has("GEOKEYDIRECTORY")){const i=o.ifd.get("GEOKEYDIRECTORY"),s=null===i||void 0===i?void 0:i.values;if(s&&s.length>4){const n=s[0]+"."+s[1]+"."+s[2],o=await this._readIFD(e,t,i.valueOffset+6-a,a,de.A.geoKeys,2,r);i.data=o.ifd,i.data&&i.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[n]})}}return o}if(o.requiredBufferSize&&o.requiredBufferSize!==e.byteLength){const i=await this.request(this.url,{range:{from:a,to:a+o.requiredBufferSize+4},responseType:"array-buffer",signal:r});return(e=i.data).byteLength<o.requiredBufferSize?null:this._readIFD(e,t,0,a,de.A.tiffTags,4,r)}}async _fetchRawTiffTile(e,t,i,a){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};const n=this._getTileLocation(e,t,i,a);if(!n)return null;const{ranges:r,actualTileWidth:o,actualTileHeight:l,ifd:u}=n,c=r.map((e=>this.request(this.url,{range:e,responseType:"array-buffer",signal:s.signal}))),f=await Promise.all(c),d=f.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),h=1===f.length?f[0].data:new ArrayBuffer(d),p=[0],m=[0];if(f.length>1){const e=new Uint8Array(h);for(let t=0,i=0;t<f.length;t++){const a=f[t].data;e.set(new Uint8Array(a),i),p[t]=i,i+=a.byteLength,m[t]=a.byteLength}}const{blockWidth:y,blockHeight:v}=this.getBlockWidthHeight(e),g=await this.decodePixelBlock(h,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:u,offsets:p,sizes:m},width:y,height:v,planes:null,pixelType:null});if(null==g)return null;let w,x,b;if(o!==y||l!==v){let e=g.mask;if(e)for(w=0;w<v;w++)if(b=w*y,w<l)for(x=o;x<y;x++)e[b+x]=0;else for(x=0;x<y;x++)e[b+x]=0;else for(e=new Uint8Array(y*v),g.mask=e,w=0;w<l;w++)for(b=w*y,x=0;x<o;x++)e[b+x]=1}return g}_getTileLocation(e,t,i){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{firstPyramidLevel:s,blockBoundary:n}=this.rasterInfo.storageInfo,r=0===e?0:e-(s-1),{_headerInfo:o}=this;if(!o)return null;const l=a?o.maskIFDs[r]:0===r?null===o||void 0===o?void 0:o.ifds[0]:null===o||void 0===o?void 0:o.pyramidIFDs[r-1];if(!l)return null;const u=(0,fe.XO)(l,o),c=he(l,"TILEOFFSETS");if(void 0===c)return null;const f=he(l,"TILEBYTECOUNTS"),{minRow:d,minCol:h,maxRow:p,maxCol:m}=n[r];if(t>p||i>m||t<d||i<h)return null;const y=pe(l,"IMAGEWIDTH"),v=pe(l,"IMAGELENGTH"),g=pe(l,"TILEWIDTH"),w=pe(l,"TILELENGTH"),x=[];if(u){const{bandCount:e}=this.rasterInfo;for(let a=0;a<e;a++){const e=a*(p+1)*(m+1)+t*(m+1)+i;x[a]={from:c[e],to:c[e]+f[e]-1}}}else{const e=t*(m+1)+i;x.push({from:c[e],to:c[e]+f[e]-1})}for(let b=0;b<x.length;b++)if(null==x[b].from||!x[b].to||x[b].to<0)return null;return{ranges:x,ifd:l,actualTileWidth:i===m&&y%g||g,actualTileHeight:t===p&&v%w||w}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:null===e||void 0===e?void 0:e.signal});return H(t)}catch(t){return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:null===e||void 0===e?void 0:e.signal}),i=ce.parse(t);return null!==i&&void 0!==i&&i.recordSet?k.default.fromJSON(i.recordSet):null}catch(t){return null}}};(0,s._)([(0,n.MZ)()],me.prototype,"_files",void 0),(0,s._)([(0,n.MZ)()],me.prototype,"_headerInfo",void 0),(0,s._)([(0,n.MZ)()],me.prototype,"_bufferSize",void 0),(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],me.prototype,"datasetFormat",void 0),me=(0,s._)([(0,l.$)("esri.layers.support.rasterDatasets.TIFFRaster")],me);const ye=me,ve=new Map;ve.set("MRF",{desc:"Meta Raster Format",constructor:oe}),ve.set("TIFF",{desc:"GeoTIFF",constructor:ye}),ve.set("RasterTileServer",{desc:"Raster Tile Server",constructor:ie}),ve.set("JPG",{desc:"JPG Raster Format",constructor:q}),ve.set("PNG",{desc:"PNG Raster Format",constructor:q}),ve.set("GIF",{desc:"GIF Raster Format",constructor:q}),ve.set("BMP",{desc:"BMP Raster Format",constructor:q}),ve.set("CovJSON",{desc:"COVJSON Raster Format",constructor:N}),ve.set("MEMORY",{desc:"In Memory Raster Format",constructor:P});class ge{static get supportedFormats(){const e=new Set;return ve.forEach(((t,i)=>e.add(i))),e}static async open(e){var t,i;const{url:s,ioConfig:n,source:r,sourceJSON:o}=e;let l=null!==(t=e.datasetFormat)&&void 0!==t?t:null===n||void 0===n?void 0:n.datasetFormat;null==l&&(s.includes(".")?l=s.slice(s.lastIndexOf(".")+1).toUpperCase():"coverage"===(null===r||void 0===r||null===(i=r.type)||void 0===i?void 0:i.toLowerCase())?l="CovJSON":(null===r||void 0===r?void 0:r.extent)&&r.pixelblocks&&(l="MEMORY")),"OVR"===l||"TIF"===l?l="TIFF":"JPG"===l||"JPEG"===l||"JFIF"===l?l="JPG":"COVJSON"===l&&(l="CovJSON"),s.toLowerCase().includes("/imageserver")&&!s.toLowerCase().includes("/wcsserver")&&(l="RasterTileServer");const u={url:s,source:r,sourceJSON:o,datasetFormat:l,ioConfig:null!==n&&void 0!==n?n:{bandIds:null,sampling:null}};if(Object.keys(u).forEach((e=>{null==u[e]&&delete u[e]})),l){if(!this.supportedFormats.has(l))throw new a.default("rasterfactory:open","not a supported format "+l);if("CRF"===l)throw new a.default("rasterfactory:open","cannot open raster: ".concat(s));const t=new(0,ve.get(l).constructor)(u);return await t.open({signal:e.signal}),t}const c=Array.from(ve.keys()).filter((e=>"CovJSON"!==e&&"Memory"!==e));let f=0;const d=()=>{if(l=c[f++],!l)return null;if("CRF"===l)return null;const t=new(0,ve.get(l).constructor)(u);return t.open({signal:e.signal}).then((()=>t)).catch((()=>d()))};return d()}static register(e,t,i){ve.has(e.toUpperCase())||ve.set(e.toUpperCase(),{desc:t,constructor:i})}}},82356:(e,t,i)=>{i.d(t,{d:()=>R});var a,s=i(89379),n=i(35143),r=i(3825),o=i(91967),l=i(55877),u=i(50076),c=i(54901),f=(i(81806),i(53521)),d=i(30015),h=i(50346),p=i(68134),m=i(52394),y=i(90534),v=i(46053),g=(i(76460),i(47249),i(85842)),w=i(11164),x=i(53084),b=i(97255),I=i(78393);class _{constructor(e){!function(e){if(null===e||void 0===e||!e.location)throw new u.default("tilemap:missing-location","Location missing from tilemap response");if(!1===e.valid)throw new u.default("tilemap:invalid","Tilemap response was marked as invalid");if(!e.data)throw new u.default("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(e.data))throw new u.default("tilemap:data-mismatch","Data must be an array of numbers");if(e.data.length!==e.location.width*e.location.height)throw new u.default("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}(e);const{location:t,data:i}=e;this.location=Object.freeze((0,x.clone)(t));const a=this.location.width,s=this.location.height;let n=!0,r=!0;const o=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return e<=I.y9?t?new Array(e).fill(0):new Array(e):new Uint32Array(e)}(Math.ceil(a*s/32));let l=0;for(let u=0;u<i.length;u++){const e=u%32;i[u]?(r=!1,o[l]|=1<<e):n=!1,31===e&&++l}r?(this._availability="unavailable",this.byteSize=40):n?(this._availability="available",this.byteSize=40):(this._availability=o,this.byteSize=40+(0,b.Qf)(o))}getAvailability(e,t){if("unavailable"===this._availability||"available"===this._availability)return this._availability;const i=(e-this.location.top)*this.location.width+(t-this.location.left),a=i%32,s=i>>5,n=this._availability;return s<0||s>n.length?"unknown":n[s]&1<<a?"available":"unavailable"}static fromDefinition(e,t){const i=e.service.request||r.default,{row:a,col:n,width:o,height:l}=e,c={query:{f:"json"}};return t=t?(0,s.A)((0,s.A)({},c),t):c,i(function(e){var t;let i;if(null!==(t=e.service.tileServers)&&void 0!==t&&t.length){const t=e.service.tileServers;i="".concat(t&&t.length?t[e.row%t.length]:e.service.url,"/tilemap/").concat(e.level,"/").concat(e.row,"/").concat(e.col,"/").concat(e.width,"/").concat(e.height)}else i="".concat(e.service.url,"/tilemap/").concat(e.level,"/").concat(e.row,"/").concat(e.col,"/").concat(e.width,"/").concat(e.height);const a=e.service.query;return a&&(i="".concat(i,"?").concat(a)),i}(e),t).then((e=>e.data)).catch((e=>{var t;if(422===(null===e||void 0===e||null===(t=e.details)||void 0===t?void 0:t.httpStatus))return{location:{top:a,left:n,width:o,height:l},valid:!0,data:new Array(o*l).fill(0)};throw e})).then((e=>{if(e.location&&(e.location.top!==a||e.location.left!==n||e.location.width!==o||e.location.height!==l))throw new u.default("tilemap:location-mismatch","Tilemap response for different location than requested",{response:e,definition:{top:a,left:n,width:o,height:l}});return _.fromJSON(e)}))}static fromJSON(e){return Object.freeze(new _(e))}}function S(e){return"".concat(e.level,"/").concat(e.row,"/").concat(e.col,"/").concat(e.width,"/").concat(e.height)}function T(e,t,i){return new u.default("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i})}let R=a=class extends o.default{constructor(e){super(e),this._pendingTilemapRequests={},this.request=r.default,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new f.q(2*l.u.MEGABYTES),this.addHandles((0,p.watch)((()=>{const{layer:e}=this;return[null===e||void 0===e?void 0:e.parsedUrl,null===e||void 0===e?void 0:e.tileServers,null===e||void 0===e?void 0:e.apiKey,null===e||void 0===e?void 0:e.customParameters]}),(()=>this._initializeTilemapDefinition()),p.initial))}get effectiveMinLOD(){var e;return null!==(e=this.minLOD)&&void 0!==e?e:this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){var e;return null!==(e=this.maxLOD)&&void 0!==e?e:this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(e,t,i){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const a=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return a?a.getAvailability(t,i):"unknown"}fetchAvailability(e,t,i,a){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(T(e,t,i)):this._fetchTilemap(e,t,i,a).catch((e=>e)).then((a=>{if(a instanceof _){const s=a.getAvailability(t,i);if("unavailable"===s)throw T(e,t,i);return s}if((0,h.isAbortError)(a))throw a;return"unknown"}))}fetchAvailabilityUpsample(e,t,i,a,s){a.level=e,a.row=t,a.col=i;const n=this.layer.tileInfo;n.updateTileInfo(a);const r=this.fetchAvailability(e,t,i,s).catch((e=>{if((0,h.isAbortError)(e))throw e;if(n.upsampleTile(a))return this.fetchAvailabilityUpsample(a.level,a.row,a.col,a,s);throw e}));return this._fetchAvailabilityUpsamplePrefetch(a.id,e,t,i,s,r),r}async _fetchAvailabilityUpsamplePrefetch(e,t,i,n,r,o){if(!this._prefetchingEnabled||null==e)return;const l="prefetch-".concat(e);if(this.hasHandles(l))return;const u=new AbortController;o.then((()=>u.abort()),(()=>u.abort()));let f=!1;const d=(0,c.hA)((()=>{f||(f=!0,u.abort())}));if(this.addHandles(d,l),await(0,m.waitTicks)(10,u.signal).catch((()=>{})),f||(f=!0,this.removeHandles(l)),(0,h.isAborted)(u))return;const p=new w.U(e,t,i,n),y=(0,s.A)((0,s.A)({},r),{},{signal:u.signal}),v=this.layer.tileInfo;for(let s=0;a._prefetches.length<a._maxPrefetch&&v.upsampleTile(p);++s){const e=this.fetchAvailability(p.level,p.row,p.col,y);a._prefetches.push(e);const t=()=>{a._prefetches.removeUnordered(e)};e.then(t,t)}}_fetchTilemap(e,t,i,a){var n;if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new u.default("tilemap-cache:level-unavailable","Level ".concat(e," is unavailable in the service")));const r=this._tmpTilemapDefinition,o=this._tilemapFromCache(e,t,i,r);if(o)return Promise.resolve(o);const l=null===(n=a)||void 0===n?void 0:n.signal;return a=(0,s.A)((0,s.A)({},a),{},{signal:null}),new Promise(((e,t)=>{(0,h.onAbort)(l,(()=>t((0,h.createAbortError)())));const i=S(r);let s=this._pendingTilemapRequests[i];if(!s){s=_.fromDefinition(r,a).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>{delete this._pendingTilemapRequests[i]};this._pendingTilemapRequests[i]=s,s.then(e,e)}s.then(e,t)}))}_initializeTilemapDefinition(){var e;if(!this.layer.parsedUrl)return;const{parsedUrl:t,apiKey:i,customParameters:a}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:t.path,query:(0,y.objectToQuery)((0,s.A)((0,s.A)((0,s.A)({},t.query),a),{},{token:null!==i&&void 0!==i?i:null===(e=t.query)||void 0===e?void 0:e.token})),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,i,a){a.level=e,a.row=t-t%this.size,a.col=i-i%this.size;const s=S(a);return this._tilemapCache.get(s)}get test(){}};R._maxPrefetch=4,R._prefetches=new d.A({initialSize:a._maxPrefetch}),(0,n._)([(0,v.MZ)({constructOnly:!0})],R.prototype,"layer",void 0),(0,n._)([(0,v.MZ)({constructOnly:!0})],R.prototype,"minLOD",void 0),(0,n._)([(0,v.MZ)({constructOnly:!0})],R.prototype,"maxLOD",void 0),(0,n._)([(0,v.MZ)({constructOnly:!0})],R.prototype,"request",void 0),(0,n._)([(0,v.MZ)({constructOnly:!0})],R.prototype,"size",void 0),R=a=(0,n._)([(0,g.$)("esri.layers.support.TilemapCache")],R)}}]);
//# sourceMappingURL=33562.867e640f.chunk.js.map