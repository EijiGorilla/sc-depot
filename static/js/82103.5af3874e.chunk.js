"use strict";(self.webpackChunksc_depot=self.webpackChunksc_depot||[]).push([[82103],{20265:(t,e,s)=>{s.d(e,{O:()=>h});var n=s(68707),i=s(97799),r=s(79186),o=r.D;class a extends n.G{constructor(t,e,s,n,i,r){super(),this.m_densificator=new o(e,s,n,r,!1,i),this.m_index=-1,this.m_inputGeoms=t}tock(){return!0}getRank(){return 1}next(){let t=null;for(;t=this.m_inputGeoms.next();)return(0,i.d)(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.densify(t);return null}getGeometryID(){return this.m_index}densify(t){return this.m_densificator.densify(t)}}class h{getOperatorType(){return 10202}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s,n,i){return new a(t,e,s,n,arguments.length>5&&void 0!==arguments[5]?arguments[5]:12e3,i)}execute(t,e,s,n,i){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:12e3;return(0,r.d)(t,e,s,n,i,o)}}},79186:(t,e,s)=>{s.d(e,{$:()=>gi,A:()=>ar,B:()=>$i,C:()=>Fr,D:()=>bi,E:()=>Dr,F:()=>Vi,G:()=>Q,H:()=>Et,I:()=>u,J:()=>ni,K:()=>Si,L:()=>$r,M:()=>y,N:()=>vi,O:()=>us,P:()=>ei,Q:()=>Bt,R:()=>ur,S:()=>to,T:()=>j,U:()=>ft,V:()=>Pt,W:()=>v,X:()=>B,Y:()=>Ut,Z:()=>Li,_:()=>Br,a:()=>yi,a0:()=>Wr,a1:()=>Ir,a2:()=>Ur,a3:()=>li,a4:()=>ot,a5:()=>zr,a6:()=>Or,a7:()=>Qr,a8:()=>wr,b:()=>mi,c:()=>ii,d:()=>Ei,e:()=>Gr,f:()=>Tr,g:()=>K,h:()=>d,i:()=>Ar,j:()=>mt,k:()=>pi,l:()=>_i,m:()=>fi,n:()=>Sr,o:()=>vr,p:()=>Ci,q:()=>St,r:()=>p,s:()=>c,t:()=>Ct,u:()=>yn,v:()=>g,w:()=>sn,x:()=>Pe,y:()=>$s,z:()=>or});var n=s(89379),i=s(97799),r=s(91523),o=s(26871),a=s(21557),h=s(16364),m=s(68707);class l{constructor(){this.posStream=null,this.streams=null}get(t){return t>0?this.streams[t-1]:this.posStream}set(t,e){t>0?this.streams[t-1]=e:this.posStream=e}destroyAndSetSize(t){if(this.streams=null,t>1){this.streams=new Array(t-1);for(let e=0;e<t-1;++e)this.streams[e]=null}this.posStream=null}swap(t){[this.streams,t.streams]=[t.streams,this.streams],[this.posStream,t.posStream]=[t.posStream,this.posStream]}empty(){return null===this.posStream&&null===this.streams}}function u(t,e,s){if(t)for(let n=e.length-1;n>=0;--n)s(e[n]);else e.forEach(s)}function c(t,e){let s=(0,o.A)(t);const n=e.length/(0,o.i)();for(let i=0;i<e.length;++i){const t=Math.trunc(s*n);s=(0,o.A)(s);const i=Math.trunc(s*n),r=e[t];e[t]=e[i],e[i]=r}}function g(t,e,s){if(0===t.length)return;let n=0,i=0;for(++i;i!==t.length;++i)e(t[n],t[i])||(s(n,i),n=i);s(n,i)}function d(t,e,s,n,i){(0,o.C)(t,e,n-e,((t,e)=>i(t,e)?-1:1))}function _(t,e,s){if(!(s<=e))for(;e<s;)t[s]=(0,o.b)(t[e],t[e]=t[s]),e++,s--}function p(t,e,s,n){_(t,e,s-1),_(t,s,n-1),t.reverse()}var f=r.V;const P="can not assign an empty point to a vertex";class x{constructor(t){if(this.m_accelerators=null,void 0!==t&&t.move)this.m_description=t.move.m_description,t.move.m_description=(0,r.j)(),this.m_vertexAttributes=t.move.m_vertexAttributes,t.move.m_vertexAttributes=new l,this.m_envelopeData=t.move.m_envelopeData,t.move.m_envelopeData=new r.k,this.m_pointCount=t.move.m_pointCount,this.m_reservedPointCount=t.move.m_reservedPointCount,this.m_flags=t.move.m_flags,this.m_bFillRule=t.move.m_bFillRule,this.m_bPathStarted=t.move.m_bPathStarted,this.m_bPolygon=t.move.m_bPolygon,this.m_simpleTolerance=t.move.m_simpleTolerance;else{const e=void 0!==t&&t.vd?t.vd:(0,r.j)();this.m_description=e,this.m_vertexAttributes=new l,this.m_envelopeData=new r.k,this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_flags=4063,this.m_bFillRule=this.m_bPathStarted=this.m_bPolygon=!1,this.m_simpleTolerance=0,void 0!==t&&t.copy&&t.copy.copyTo(this)}}equalsBase(t,e){if(!(0,i.i)(t.getGeometryType()))return!1;const s=t;if(this===s)return!0;if(!this.m_description.equals(s.getDescription()))return!1;if(this.isEmptyImpl()!==s.isEmptyImpl())return!1;if(this.isEmptyImpl())return!0;const n=this.getPointCount();if(n!==s.getPointCount())return!1;for(let i=0;i<this.m_description.getAttributeCount();i++){const t=this.m_description.getSemantics(i),r=this.getAttributeStreamRef(t),o=s.getAttributeStreamRef(t),a=f.getComponentCount(t);if(!r.equals(o,0,n*a,e))return!1}if(e){if(!this.equalsImplTol(t,e))return!1}else if(!this.equalsImpl(t))return!1;return!0}transformAttribute(t,e,s,n,o){this.addAttribute(t),this.isEmpty()||0===s&&1===n||(function(t,e,s,n,r){(e<0||s<0||n<1||e+n*(s-1)+1>t.size())&&(0,i.t)("Index out of bound");for(let i=e,o=e+n*(s-1)+1;i<o;i+=n)t.writeAsDbl(i,r(t.readAsDbl(i)))}(this.getAttributeStreamRef(t),e,this.getPointCount(),f.getComponentCount(t),(0,r.v)(s,n,o)),this.notifyModified())}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=(0,r.l)(e,t);this.assignVertexDescription(s)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=(0,r.m)(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=(0,r.r)(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=(0,r.j)();t!==this.m_description&&this.assignVertexDescription(t)}getAttributeStreamRef(t){this.throwIfEmpty(),this.m_description.hasAttribute(t)||(0,i.t)("AttributeStream : Geometry does not have the attribute");const e=this.m_description.getAttributeIndex(t);return this.m_vertexAttributes.get(e)}setAttributeStreamRef(t,e){e||(0,i.t)("stream"),e&&f.getPersistence(t)!==e.getPersistence()&&(0,i.t)(""),this.addAttribute(t);const s=this.m_description.getAttributeIndex(t);this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_vertexAttributes.set(s,e),this.notifyModifiedFlags(2001)}notifyModifiedFlags(t){65535===t&&(this.m_reservedPointCount=-1,this.notifyModifiedAllImpl()),this.setDirtyFlagProtected(t,!0),this.clearAccelerators(),32&t&&this.verifyAllStreamsAfterSizeChange()}notifyModified(){this.notifyModifiedFlags(2001)}getPointCount(){return this.m_pointCount}getPointByVal(t,e){const s=e;s.assignVertexDescription(this.m_description);for(let n=0;n<this.m_description.getAttributeCount();n++){const e=this.m_description.getSemantics(n);for(let i=0,r=f.getComponentCount(e);i<r;i++){const o=this.m_vertexAttributes.get(n).readAsDbl(r*t+i);s.setAttributeBasic(e,i,o)}}}setPointByVal(t,e){const s=e;s.isEmpty()&&(0,i.t)(P);const n=s.getDescription();n!==this.m_description&&this.mergeVertexDescription(n);const r=this.m_vertexAttributes.get(0);r.write(2*t,s.getX()),r.write(2*t+1,s.getY());for(let i=1,o=this.m_description.getAttributeCount();i<o;i++){const e=this.m_description.getSemantics(i),n=f.getComponentCount(e);for(let r=0;r<n;r++){const o=s.getAttributeAsDbl(e,r);this.m_vertexAttributes.get(i).writeAsDbl(t*n+r,o)}}this.notifyModifiedFlags(2001)}setPointByValFromArray(t,e,s,n){(0,i.g)(0)}getPointByValAsArray(t,e,s,n){(0,i.g)(0)}isEmpty(){return this.isEmptyImpl()}isEmptyImpl(){return 0===this.m_pointCount}getAttributeAsDbl(t,e,s){const n=f.getComponentCount(t);s>=n&&(0,i.n)("");const r=this.m_description.getAttributeIndex(t);return r>=0?this.m_vertexAttributes.get(r).readAsDbl(e*n+s):f.getDefaultValue(t)}queryAttributeAsDbl(t,e,s,n){const r=f.getComponentCount(t);n<r&&(0,i.n)("");const o=this.m_description.getAttributeIndex(t);if(o>=0){const t=e*r,n=this.m_vertexAttributes.get(o);for(let e=0;e<r;e++)s[e]=n.readAsDbl(t+e)}else{const e=f.getDefaultValue(t);for(let t=0;t<r;t++)s[t]=e}}getAttributeAsInt(t,e,s){return Math.trunc(this.getAttributeAsDbl(t,e,s))}queryAttributeAsInt(t,e,s,n){(0,i.g)(0)}setAttribute(t,e,s,n){const r=f.getComponentCount(t);s>=r&&(0,i.n)(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001),this.m_vertexAttributes.get(o).writeAsDbl(e*r+s,n)}setAttributeFromArray(t,e,s,n){(e<0||e>=this.m_pointCount)&&(0,i.n)("");const r=f.getComponentCount(t);n!==r&&(0,i.n)(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001);const a=this.m_vertexAttributes.get(o);for(let i=0;i<r;++i)a.writeAsDbl(e*r+i,s[i])}getXY(t){return this.m_vertexAttributes.get(0).readPoint2D(2*t)}queryXY(t,e){return this.m_vertexAttributes.get(0).queryPoint2D(2*t,e)}setXY(t,e){this.m_vertexAttributes.get(0).writePoint2D(2*t,e),this.notifyModifiedFlags(2001)}setXYCoords(t,e,s){const n=this.m_vertexAttributes.get(0);n.write(2*t,e),n.write(2*t+1,s),this.notifyModifiedFlags(2001)}getXYZ(t){const e=this.m_vertexAttributes.get(0),s=r.h.getNAN();return s.x=e.read(2*t),s.y=e.read(2*t+1),this.m_description.hasAttribute(1)?s.z=this.m_vertexAttributes.get(1).read(t):s.z=f.getDefaultValue(1),s}setXYZ(t,e){this.addAttribute(1),this.notifyModifiedFlags(2001);const s=this.m_vertexAttributes.get(0);s.write(2*t,e.x),s.write(2*t+1,e.y),this.m_vertexAttributes.get(1).write(t,e.z)}queryEnvelope(t){t instanceof a.Envelope2D||t instanceof r.n?this.updateEnvelope(t):(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t))}queryLooseEnvelope(t){this.updateLooseEnvelope(t)}queryInterval(t,e){const s=o.E.constructEmpty();return this.isEmptyImpl()||(this.updateAllDirtyIntervals(!0),this.m_envelopeData.queryInterval(this.m_description,t,e,s)),s}setAttributeBasic(t,e,s){this.setAttributeImpl(t,e,s)}setAttributeImpl(t,e,s){if(this.addAttribute(t),this.isEmpty())return;let n=!1;const i=f.getComponentCount(t),r=this.getAttributeStreamRef(t),o=Number.isNaN(s);if(1===r.getPersistence()){const t=r;for(let r=e,a=this.m_pointCount*i;r<a;r+=i){const e=t.read(r);(o||e===s)&&Number.isNaN(e)||(t.write(r,s),n=!0)}}else for(let a=e,h=this.m_pointCount*i;a<h;a+=i)r.readAsDbl(a)!==s&&(r.writeAsDbl(a,s),n=!0);n&&this.notifyModifiedFlags(2001)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;let s=!1;const n=f.getComponentCount(t),i=this.getAttributeStreamRef(t);for(let r=0;r<n;r++)if(1===i.getPersistence()){const t=i;for(let i=0,r=this.m_pointCount*n;i<r;i++){const n=t.read(i);Number.isNaN(n)&&(t.write(i,e),s=!0)}}else for(let t=0,o=this.m_pointCount*n;t<o;t++){const n=i.readAsDbl(t);Number.isNaN(n)&&(i.writeAsDbl(t,e),s=!0)}s&&this.notifyModifiedFlags(2001)}calculateLength3D(t){return(0,i.g)(0),0}setEnvelopeForImport(t){this.m_description.equals(t.getDescription())||(0,i.t)(""),this.m_envelopeData=new r.k({moveEnv:t}),this.setDirtyFlagProtected(192,!1)}copyTo(t){t.getGeometryType()!==this.getGeometryType()&&(0,i.t)(""),this!==t&&this.copyToUnchecked(t,!1)}queryCoordinates(t,e,s,n){let r=n<0?this.m_pointCount:n;if(r=Math.min(r,s+e),(s<0||r<s||this.m_pointCount>0&&s>=this.m_pointCount)&&(0,i.t)(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);for(let i=2*s,a=2*r,h=0;i<a;i+=2,h++)o.queryPoint2D(i,t[h]);return r}queryCoordinates3D(t,e,s,n){let r=n<0?this.m_pointCount:n;if(r=Math.min(r,s+e),(s<0||r<s||this.m_pointCount>0&&s>=this.m_pointCount)&&(0,i.t)(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);let a=null;const h=f.getDefaultValue(1),m=this.m_description.hasAttribute(1);m&&(a=this.getAttributeStreamRef(1));let l=0;for(let i=s;i<r;i++,l++)t[l].x=o.read(2*i),t[l].y=o.read(2*i+1),t[l].z=m?a.read(i):h;return r}clearAndSetDirtyFlagProtected(t,e){let s=0;const n=t&~e,i=e|n;s=this.m_flags,(s&i)!==e&&(this.m_flags=s&~n|e)}getIsSimple(t,e){e[0]=0;let s=-1;const n=this.m_flags,i=this.m_simpleTolerance;return 1&n||(s=(14&n)>>1,e[0]=i,i<t&&(s=-1)),s}setIsSimple(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(2===t?(0,i.g)(this.getGeometryType()===i.G.enumPolyline):1===t?(0,i.g)(this.getGeometryType()===i.G.enumMultiPoint||this.getGeometryType()===i.G.enumPolyline):3===t&&(0,i.g)(this.getGeometryType()===i.G.enumPolygon),-1===t)this.setDirtyFlagProtected(17,!0);else{let n=t<<1;s||(n|=16);const i=31;this.clearAndSetDirtyFlagProtected(i,n),this.m_simpleTolerance!==e&&(this.m_simpleTolerance=e)}}attributeStreamIsAllocated(t){this.throwIfEmpty();const e=this.m_description.getAttributeIndex(t);return e>=0&&null!==this.m_vertexAttributes.get(e)}capacity(){return-1===this.m_reservedPointCount&&0===this.m_pointCount?0:this.m_reservedPointCount}getDescriptionImpl(){return this.m_description}copyToUnchecked(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];e&&this.hasDirtyFlag(32)&&(0,i.s)("Cannot do shallow clone on unprepared geometry");const s=t,n=this.getGeometryType(),r=s.getGeometryType();(0,i.g)(n===r||n===i.G.enumPolygon&&r===i.G.enumPolyline,"failure in copyToUnchcked"),s.clearAccelerators(),s.m_description=this.m_description,s.m_vertexAttributes.destroyAndSetSize(0),s.m_envelopeData.releaseAttributes();const o=this.m_description.getAttributeCount(),a=new l;if(!this.m_vertexAttributes.empty()){a.destroyAndSetSize(o);for(let t=0;t<o;t++)if(this.m_vertexAttributes.get(t))if(e)a.set(t,this.m_vertexAttributes.get(t));else{const e=f.getComponentCount(this.m_description.getSemantics(t));a.set(t,this.m_vertexAttributes.get(t).restrictedClone(this.getPointCount()*e))}}if(this.m_envelopeData.copyToIfNotNull(this.m_description,s.m_envelopeData),s.m_flags=this.m_flags,s.m_simpleTolerance=this.m_simpleTolerance,n!==r){const t=[Number.NaN];s.getIsSimple(0,t)>=3?s.setIsSimple(1,t[0]):s.setIsSimple(-1,0)}s.m_vertexAttributes.swap(a),a.destroyAndSetSize(0),s.m_pointCount=this.m_pointCount,s.hasDirtyFlag(32)?((0,i.g)(!e),s.m_reservedPointCount=-1):s.m_reservedPointCount=s.m_pointCount;try{this.copyToImpl(s,e)}catch(h){throw s.setEmpty(),h}s.verifyAllStreamsAfterSizeChange()}buildRasterizedGeometryAccelerator(t,e){return!1}getAccelerators(){return this.m_accelerators}clearAccelerators(){this.m_accelerators&&this.m_accelerators.release(),this.m_accelerators=null}ensureUniqueAccelerators(){if(this.m_accelerators&&!this.m_accelerators.uniqueUse()){const t=this.m_accelerators.clone();this.m_accelerators.release(),this.m_accelerators=t}}interpolateTwoVertices(t,e,s,n){(t<0||t>=this.m_pointCount)&&(0,i.n)(""),(e<0||e>=this.m_pointCount)&&(0,i.n)(""),n.assignVertexDescription(this.m_description);const a=(0,o.d)(f.maxComponentCount(),Number.NaN),h=(0,o.d)(f.maxComponentCount(),Number.NaN),m=(0,r.o)();let l=0;for(let u=0;u<this.m_description.getAttributeCount();u++){const n=this.m_description.getSemantics(u),c=f.getInterpolation(n),g=f.getComponentCount(n),d=f.getDefaultValue(n);this.queryAttributeAsDbl(n,t,a,g),this.queryAttributeAsDbl(n,e,h,g),(0,i.g)(l+g<=r.O),(0,o.B)(c,a,h,m,l,g,s,d),l+=g}!function(t,e){const s=t.getDescription().getTotalComponentCount();t.setX(e[0]),t.setY(e[1]),(0,o.a)(t.getAttributeArray(),e,0,2,s-2)}(n,m)}getShortestDistance(t,e){return o.P.distance(this.getXY(t),this.getXY(e))}getShortestSqrDistance(t,e){return o.P.sqrDistance(this.getXY(t),this.getXY(e))}resizeImpl(t){if(t<0&&(0,i.t)(),(t=Math.ceil(t))===this.m_pointCount)return;this.m_pointCount=t;const e=this.m_pointCount<=this.m_reservedPointCount?2001:4095;this.notifyModifiedFlags(e)}assignVertexDescriptionImpl(t){if(!this.m_vertexAttributes.empty()){const e=(0,r.p)();(0,r.q)(t,this.m_description,e);const s=new l;s.destroyAndSetSize(t.getAttributeCount());for(let n=0;n<t.getAttributeCount();n++){const t=e[n];-1!==t?s.set(n,this.m_vertexAttributes.get(t)):this.m_reservedPointCount=-1}s.swap(this.m_vertexAttributes)}this.m_description=t,this.m_envelopeData.releaseAttributes(),this.notifyModifiedFlags(4095)}hasDirtyFlag(t){return!!(this.m_flags&t)}setDirtyFlagProtected(t,e){e?this.m_flags|=t:this.m_flags&=~t}notifyModifiedAllImpl(){}verifyAllStreamsAfterSizeChange(){this.hasDirtyFlag(32)&&this.verifyAllStreamsAfterSizeChangeImpl()}verifyAllStreamsAfterSizeChangeImpl(){if(this.hasDirtyFlag(32)){if(this.m_reservedPointCount<this.m_pointCount){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_reservedPointCount=Number.MAX_SAFE_INTEGER;let t=0;t=this.m_pointCount<4?3:this.m_pointCount<=128?2*this.m_pointCount:Math.trunc((4*this.m_pointCount+2)/3);for(let e=0;e<this.m_description.getAttributeCount();e++){const s=this.m_description.getSemantics(e);let n=0;if(null!==this.m_vertexAttributes.get(e)){const i=f.getComponentCount(s);n=this.m_vertexAttributes.get(e).size()/i,n<this.m_pointCount&&(this.m_vertexAttributes.get(e).resize(t*i,f.getDefaultValue(s)),n=t)}else this.m_vertexAttributes.set(e,(0,r.t)(s,t)),n=t;n<this.m_reservedPointCount&&(this.m_reservedPointCount=n)}}this.verifyStreamsAfterSizeChangeExtraImpl(),this.setDirtyFlagProtected(32,!1)}}verifyStreamsAfterSizeChangeExtraImpl(){}updateAllDirtyIntervals(t){if(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128)){if(this.isEmpty())return this.hasDirtyFlag(192)&&this.m_envelopeData.setEmpty(this.m_description),void this.setDirtyFlagProtected(192,!1);const e=this.updateXYImpl(t),s=new r.E({vd:this.m_description});s.setEnvelope(e);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),n=f.getComponentCount(e),i=this.m_vertexAttributes.get(t);for(let t=0;t<n;t++){const r=new o.E;r.setEmpty();for(let e=0;e<this.m_pointCount;e++){const s=i.readAsDbl(e*n+t);r.mergeCoordinate(s)}s.setIntervalEnvelope(e,t,r)}}(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128))&&(this.m_envelopeData=new r.k({moveEnv:s}),this.clearDirtyIntervalsFlag(t))}}updateXYImpl(t){const e=a.Envelope2D.constructEmpty(),s=this.m_vertexAttributes.get(0);return e.mergePointsInterleaved(s,0,this.m_pointCount),e}updateEnvelope3D(t){(0,i.g)(0)}updateLooseEnvelope(t){this.updateAllDirtyIntervals(!1),t instanceof a.Envelope2D?t.assign(this.m_envelopeData.m_envelope2D):this.m_envelopeData.queryEnvelope3D(this.m_description,t)}updateEnvelope(t){this.updateAllDirtyIntervals(!0),t.assign(this.m_envelopeData.m_envelope2D)}setEmptyImpl(){this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_vertexAttributes.destroyAndSetSize(0),this.notifyModifiedFlags(4095)}clearDirtyIntervalsFlag(t){this.setDirtyFlagProtected(192,!1)}reserveImpl(t,e){if(t<0&&(0,i.t)(""),0===t)return;let s=t=Math.ceil(t);if(this.m_reservedPointCount<s){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),e?(null===this.m_vertexAttributes.get(0)&&this.m_vertexAttributes.set(0,(0,r.u)(0,0)),this.m_vertexAttributes.get(0).resizeRounded(2*s),s=this.m_vertexAttributes.get(0).size()>>1):null===this.m_vertexAttributes.get(0)?this.m_vertexAttributes.set(0,(0,r.u)(0,s)):this.m_vertexAttributes.get(0).resize(2*s);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),n=f.getComponentCount(e);null!==this.m_vertexAttributes.get(t)?this.m_vertexAttributes.get(t).resize(s*n):this.m_vertexAttributes.set(t,(0,r.u)(e,s))}this.reserveImplImpl(s,e),this.m_reservedPointCount=s}}reserveRounded(t){t<0&&(0,i.t)(),t=Math.ceil(t),this.reserveImpl(t,!0)}reserveImplImpl(t,e){}throwIfEmpty(){this.isEmptyImpl()&&(0,i.u)("")}}class y extends x{constructor(t){super(t),t&&(t.points?this.addPoints2D(t.points,t.pointsSize,0,-1):t.point&&this.add(t.point))}assignCopy(t){return t.copyTo(this),this}assignMove(t){return t.copyTo(this),t.setEmpty(),this}insertPoint2D(t,e){t>this.getPointCount()&&(0,i.t)("invalid point index"),t<0&&(t=this.getPointCount());const s=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let n=0,i=this.m_description.getAttributeCount();n<i;n++){const i=this.m_description.getSemantics(n),o=r.V.getComponentCount(i);if(0===i)this.m_vertexAttributes.get(n).insert(o*t,e,o*s);else{const e=r.V.getDefaultValue(i);this.m_vertexAttributes.get(n).insertRange(o*t,e,o,o*s)}}this.notifyModifiedFlags(2001)}insertPoint(t,e){e.isEmpty()&&(0,i.t)(P),t<0&&(t=this.getPointCount()),this.mergeVertexDescription(e.getDescription());const s=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let n=0,i=this.m_description.getAttributeCount();n<i;n++){const i=this.m_description.getSemantics(n),o=r.V.getComponentCount(i);if(e.hasAttribute(i))this.m_vertexAttributes.get(n).insertAttributes(o*t,e,i,o*s);else{const e=r.V.getDefaultValue(i);this.m_vertexAttributes.get(n).insertRange(o*t,e,o,o*s)}}this.notifyModifiedFlags(2001)}insertPoints(t,e,s){if((t>this.getPointCount()||s<0)&&(0,i.n)(""),t<0&&(t=this.getPointCount()),0===s)return;const n=e[0].getDescription();this.mergeVertexDescription(n);const o=this.m_pointCount;this.resizeNoInit(this.m_pointCount+s);for(let i=0,a=this.m_description.getAttributeCount();i<a;i++){const a=this.m_description.getSemantics(i),h=r.V.getComponentCount(a);if(this.m_vertexAttributes.get(i))if(n.hasAttribute(a))this.m_vertexAttributes.get(i).insertAttributesFromPoints(t*h,e,s,a,o*h);else{const e=r.V.getDefaultValue(a);this.m_vertexAttributes.get(i).insertRange(h*t,e,h*s,h*o)}}this.notifyModifiedFlags(2001)}insertPoints2D(t,e,s){if((t>this.getPointCount()||s<0)&&(0,i.t)("invalid point index"),t<0&&(t=this.getPointCount()),0===s)return;const n=this.m_pointCount;this.resizeNoInit(this.m_pointCount+s);for(let i=0,o=this.m_description.getAttributeCount();i<o;i++){const o=this.m_description.getSemantics(i),a=r.V.getComponentCount(o);if(this.m_vertexAttributes.get(i))if(0===o)this.m_vertexAttributes.get(i).insertRangeFromPoints(a*t,e,0,s,!0,a*n);else{const e=r.V.getDefaultValue(o);this.m_vertexAttributes.get(i).insertRange(a*t,e,a,a*n)}}this.notifyModifiedFlags(2001)}removePoints(t,e){if((t<0||e<0||t+e>this.getPointCount())&&(0,i.n)("remove_points"),0!==e){for(let s=0,n=this.m_description.getAttributeCount();s<n;s++)if(this.m_vertexAttributes.get(s)){const n=this.m_description.getSemantics(s),i=r.V.getComponentCount(n);this.m_vertexAttributes.get(s).eraseRange(i*t,i*e,i*this.m_pointCount)}this.m_pointCount-=e,this.m_reservedPointCount>0&&(this.m_reservedPointCount-=e),this.notifyModifiedFlags(2001)}}removePoint(t){for(let e=0,s=this.m_description.getAttributeCount();e<s;e++)if(this.m_vertexAttributes.get(e)){const s=this.m_description.getSemantics(e),n=r.V.getComponentCount(s);this.m_vertexAttributes.get(e).eraseRange(n*t,n,n*this.m_pointCount)}this.m_pointCount--,this.m_reservedPointCount>0&&this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}calculateEnvelope2D(){return this.updateXYImpl(!0)}resizeNoInit(t){this.resizeImpl(t)}resizeAndInitNonPositionAttributes(t){const e=this.m_pointCount;if(this.resizeImpl(t),this.m_pointCount>e)for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const t=this.m_description.getSemantics(s),n=r.V.getDefaultValue(t),i=r.V.getComponentCount(t);this.m_vertexAttributes.get(s).insertRange(i*e,n,i*(this.m_pointCount-e),i*e)}}queryCoordinates3D(t,e,s,n){let o=n<0?this.m_pointCount:n;if(o=Math.min(o,s+e),(s<0||o<s||this.m_pointCount>0&&s>=this.m_pointCount)&&(0,i.t)(""),0===this.m_pointCount)return o;const a=this.getAttributeStreamRef(0);let h=null;const m=r.V.getDefaultValue(1),l=this.m_description.hasAttribute(1);l&&(h=this.getAttributeStreamRef(1));let u=0;for(let i=s;i<o;i++,u++)t[u].x=a.read(2*i),t[u].y=a.read(2*i+1),t[u].z=l?h.read(i):m;return o}queryAttributeAsInt(t,e,s,n){(0,i.g)(0)}add(t){t.isEmpty()&&(0,i.t)(P),this.resizeAndInitNonPositionAttributes(this.m_pointCount+1),this.setPointByVal(this.m_pointCount-1,t)}addXY(t,e){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const s=new o.P(t,e);this.setXY(this.m_pointCount-1,s)}addXYZ(t,e,s){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const n=new r.h;n.setCoords(t,e,s),this.setXYZ(this.m_pointCount-1,n)}addPoint2D(t){this.addXY(t.x,t.y)}addPoint3D(t){this.addXYZ(t.x,t.y,t.z)}addPoints(t,e,s){this===t&&(0,i.t)("Multi_point_impl.add");const n=s<0?t.getPointCount():s;if((e<0||e>t.getPointCount()||n<e)&&(0,i.t)(""),e===n)return;const o=t.getDescription();this.mergeVertexDescription(o);const a=n-e,h=this.m_pointCount;this.resizeNoInit(this.m_pointCount+a);for(let i=0,m=this.m_description.getAttributeCount();i<m;i++){const s=this.m_description.getSemantics(i),n=r.V.getComponentCount(s),m=this.getAttributeStreamRef(s);if(o.hasAttribute(s)){const i=t.getAttributeStreamRef(s);m.insertRangeFromStream(h*n,i,e*n,a*n,!0,1,h*n)}else{const t=r.V.getDefaultValue(s);m.insertRange(h*n,t,a*n,h*n)}}}addPoints2D(t,e,s,n){let r=e;const o=n<0?r:n;if((r<0||s<0||s>r||o<s)&&(0,i.t)(""),s===o)return;r=o-s;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+r);const h=this.getAttributeStreamRef(0);for(let i=0;i<r;++i)h.writePoint2D(2*(a+i),t[s+i]);this.notifyModifiedFlags(2001)}addPoints3D(t,e,s,n){let r=e;const a=n<0?r:n;if((r<0||s<0||s>r||a<s)&&(0,i.t)(""),this.addAttribute(1),s===a)return;r=a-s;const h=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+r);const m=this.getAttributeStreamRef(0),l=new o.P;for(let i=0;i<r;i++)l.x=t[s+i].x,l.y=t[s+i].y,m.writePoint2D(2*(h+i),l);const u=this.getAttributeStreamRef(1);for(let i=0;i<r;i++)u.write(h+i,t[s+i].z);this.notifyModifiedFlags(2001)}getGeometryType(){return i.G.enumMultiPoint}getDimension(){return 0}createInstance(){return new y({vd:this.getDescription()})}setEmpty(){this.setEmptyImpl()}applyTransformation(t){if(this.isEmpty())return;if(t.isIdentity())return;const e=this.m_vertexAttributes.get(0);1===t.m_TransformationType?e.applyTransformation(t,0,this.m_pointCount):(0,i.b)("3d xform not impl"),this.notifyModifiedFlags(2001)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(t){return 0}equals(t,e){return t.getGeometryType()===i.G.enumMultiPoint&&this.equalsBase(t,e)}queryEnvelope(t){4===t.m_EnvelopeType?(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t)):2===t.m_EnvelopeType?this.updateEnvelope(t):(0,i.b)("")}getImpl(){return this}getBoundary(){return null}reserve(t){this.reserveImpl(t)}clone(){const t=this.createInstance();return this.copyTo(t),t}swap(t){(0,i.g)(0)}buildQuadTreeAccelerator(t){return!1}getHashCodeImpl(){return(0,i.g)(0),0}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}copyToImpl(t,e){}}y.type=i.G.enumMultiPoint;class E{constructor(){this.m_EnvelopeType=5,this.envAabb=a.Envelope2D.constructEmpty(),this.envRot=a.Envelope2D.constructEmpty()}static constructEmpty(){return new E}width(){return this.envAabb.width()}height(){return this.envAabb.height()}maxDim(){return Math.max(this.width(),this.height())}setEmpty(){this.envAabb.setEmpty(),this.envRot.setEmpty()}setCoords(t){this.envAabb.setCoords(t),this.envRot.setCoords({x:C(t),y:S(t)})}setFromPoints(t,e){this.setEmpty(),this.mergePoints(t,e)}mergeNe(t){this.envAabb.mergeNe(t),this.envRot.mergeNeCoords(C(t),S(t))}mergePoints(t,e){this.envAabb.mergePoints(t,e);for(let s=0;s<e;){if(!this.envRot.isEmpty()){for(let n=s;n<e;n++){const e=C(t[n]),s=S(t[n]);this.envRot.mergeNeCoords(e,s)}break}{const e=C(t[s]),n=S(t[s]);this.envRot.setCoords({x:e,y:n}),s++}}}isIntersectingPoint2D(t){return!(!this.envAabb.contains(t)||!this.envRot.containsCoords(C(t),S(t)))}isIntersectingW(t){return this.envAabb.isIntersecting(t.envAabb)&&this.envRot.isIntersecting(t.envRot)}containsW(t){return!(!this.envAabb.containsEnvelope(t.envAabb)||!this.envRot.containsEnvelope(t.envRot))}containsPoint2D(t){return this.isIntersectingPoint2D(t)}intersectW(t){const e=this.envAabb.intersect(t.envAabb),s=this.envRot.intersect(t.envRot);return e&&!s&&this.envAabb.setEmpty(),s&&!e&&this.envRot.setEmpty(),e&&s}inflate(t){this.envAabb.inflateCoords(t,t);const e=t*(0,o.D)();this.envRot.inflateCoords(e,e),e<0&&E.st_reduceEmpty(this)}static st_reduceEmpty(t){const e=t.envAabb.isEmpty(),s=t.envRot.isEmpty();e&&!s?t.envRot.setEmpty():s&&!e&&t.envAabb.setEmpty()}}function C(t){return t.x-t.y}function S(t){return t.x+t.y}class v{constructor(){this.x=o.F.getNAN(),this.y=o.F.getNAN()}static getNAN(){return new v}static constructPoint2D(t){const e=new v;return e.x.set(t.x),e.y.set(t.y),e}static constructCoords(t,e){const s=new v;return s.x.set(t),s.y.set(e),s}static constructCoordsE(t,e){const s=new v;return s.setCoordsE(t,e),s}get 0(){return this.x.clone()}set 0(t){this.x.setE(t)}get 1(){return this.y.clone()}set 1(t){this.y.setE(t)}clone(){return(new v).setE(this)}scaleThis(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}setCoords(t,e){return this.x.set(t),this.y.set(e),this}setCoordsE(t,e){return this.x.setE(t),this.y.setE(e),this}set(t){return this.x.set(t.x),this.y.set(t.y),this}setE(t){return this.x.setE(t.x),this.y.setE(t.y),this}setWithEps(t,e){return this.x.setWithEps(t.x,e),this.y.setWithEps(t.y,e),this}getUnitVector(){const t=this.clone();return t.normalize(),t}sqrLength(){return this.x.sqr().addE(this.y.sqr())}length(){return this.sqrLength().sqrt()}mulE(t){const e=new v;return e.setCoordsE(this.x.mulE(t),this.y.mulE(t)),e}mul(t){const e=new v;return e.setCoordsE(this.x.mul(t),this.y.mul(t)),e}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mulThisE(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}divE(t){return this.clone().divThisE(t)}divThisE(t){return this.x.divThisE(t),this.y.divThisE(t),this}normalize(){const t=this.length();0===t.value()?(this.x=o.G.clone(),this.y=o.H.clone()):(this.x.divThisE(t),this.y.divThisE(t))}addE(t){return this.clone().addThisE(t)}addThisE(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this}subE(t){return this.clone().subThisE(t)}subThisE(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this}static distance(t,e){return t.subE(e).length()}negateThis(){return this.x.negateThis(),this.y.negateThis(),this}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)}isZero(){return this.x.isZero()&&this.y.isZero()}isTrueZero(){return!this.x.value()&&!this.y.value()}rotateDirect(t,e){const s=this.x.mulE(t).subThisE(this.y.mulE(e)),n=this.x.mulE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(n),this}rotateReverse(t,e){const s=this.x.mulE(t).addThisE(this.y.mulE(e)),n=this.x.negate().mulThisE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(n),this}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y))}crossProduct(t){return this.x.mulE(t.y).subE(this.y.mulE(t.x))}value(){return o.P.construct(this.x.value(),this.y.value())}}class b{constructor(){this.a11=new o.F(1),this.a12=new o.F(0),this.a21=new o.F(0),this.a22=new o.F(1)}clone(){const t=new b;return t.a11.setE(this.a11),t.a12.setE(this.a12),t.a21.setE(this.a21),t.a22.setE(this.a22),t}assign(t){return this.a11.setE(t.a11),this.a12.setE(t.a12),this.a21.setE(t.a21),this.a22.setE(t.a22),this}mulThis(t){const e=this.a11.mulE(t.a11).addThisE(this.a12.mulE(t.a21)),s=this.a11.mulE(t.a12).addThisE(this.a12.mulE(t.a22)),n=this.a21.mulE(t.a11).addThisE(this.a22.mulE(t.a21)),i=this.a21.mulE(t.a12).addThisE(this.a22.mulE(t.a22));return this.a11=e,this.a12=s,this.a21=n,this.a22=i,this}mulLeftThis(t){const e=t.clone();return this.assign(e.mulThis(this)),this}det(){return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21))}invertThis(){const t=this.det();if(0!==t.value()){const e=this.a22.divE(t),s=this.a12.negate().divThisE(t),n=this.a21.negate().divThisE(t),i=this.a11.divE(t);this.a11=e,this.a12=s,this.a21=n,this.a22=i}else this.setZero();return!t.isZero()}transposeThis(){return this.a21=(0,o.b)(this.a12,this.a12=this.a21),this}eigenSymmetric(t,e){const s=this.a12.clone();s.addThisE(this.a21),s.mulThisByPower2(.5);let n=new o.F(1),i=new o.F(0);if(s.isZero())t[0].setE(this.a11),t[1].setE(this.a22);else{const e=new o.F(1);if(this.a11.ne(this.a22)){const r=this.a11.subE(this.a22).divE(s);r.mulThisByPower2(.5);const a=r.sqr();e.setE(r),e.absThis(),e.subThisE(a.add(1).sqrtThis()),r.gt(o.H)&&e.negateThis();const h=e.sqr().addThis(1).sqrtThis().invThis();i=e.mulE(h),n.setE(h);const m=e.mulE(s);t[0]=this.a11.addE(m),t[1]=this.a22.subE(m)}else n=new o.F(1/Math.sqrt(2)),i=n.clone(),t[0]=this.a11.addE(s),t[1]=this.a22.subE(s)}e[0].x=n.toDouble(),e[0].y=i.toDouble(),e[1].x=i.negate().toDouble(),e[1].y=n.toDouble(),Math.abs(t[0].toDouble())>Math.abs(t[1].toDouble())&&(t[1]=(0,o.b)(t[0],t[0]=t[1]),e[1]=(0,o.b)(e[0],e[0]=e[1]))}setZero(){this.a11.set(0),this.a21.set(0),this.a12.set(0),this.a22.set(0)}}var I=r.V;function w(t,e){const s=t.getStartXY();if(s.equals(e.getStartXY()))return!0;if(s.equals(e.getEndXY()))return!0;const n=t.getEndXY();return!!n.equals(e.getStartXY())||!!n.equals(e.getEndXY())}function D(t,e){let s=t.calculateLowerLength2D();return!(s>e)&&(!!t.isLine()||(s=t.calculateUpperLength2D(),s<=e||0!==e&&t.calculateLength2D()<=e))}function T(t,e){const s=t.getEndXY().sub(t.getStartXY()).length(),n=t.calculateUpperLength2D()-s<=e[0];return e[0]*=.1,n}function N(t,e,s,n,r,a,h,m){let l=t.calculateUpperLength2D(),u=e.calculateUpperLength2D(),c=t,g=e,d=!1;l>u&&(g=(0,o.b)(c,c=g),n=(0,o.b)(s,s=n),u=(0,o.b)(l,l=u),d=!0);const _=0===s;{h[0]=_?1:0;const t=c.getCoord2D(h[0]);m[0]=g.getClosestCoordinate(t,!1);const e=g.getCoord2D(m[0]);if(o.P.distance(t,e)<=r){const e=[.5,.75,.25,.1,.9];let s=!0;for(let n=0;n<e.length;n++)if(t.assign(c.getCoord2D(e[n])),!g.isCloserThanDistance(t,new o.E(0,1),r)){s=!1;break}if(s)return d&&(m[0]=(0,o.b)(h[0],h[0]=m[0])),1}}if(l<=3*r)return 0;let p=(0,o.c)(Math.max(r/l,.1),0,.5),f=.01*r,P=0,x=0,y=p,E=-1,C=0,S=1/32;for(let v=0;;v++){(0,i.g)(v<4095);const t=_?p:1-p,e=c.getCoord2D(t),s=g.getClosestCoordinate(e,!1);if(s===n)return C;const l=g.getCoord2D(s),u=o.P.distance(e,l);if(0===v&&(E=u),u<=f?(S=.5,x=u,P=p):(y=p,E=u),Math.abs(x-E)>.1*f&&y-P>1e-16)p=(0,o.q)(P,y,S);else{if(h[C]=t,m[C]=s,d&&(m[C]=(0,o.b)(h[C],h[C]=m[C])),1===a||1===C)return 1===C&&h[0]>h[1]&&(h[1]=(0,o.b)(h[0],h[0]=h[1]),m[1]=(0,o.b)(m[0],m[0]=m[1])),C+1;C++,P=y,x=E,y=.8,E=-1,p=.8,S=1/32,f=10*r,v=0}}}function A(t,e,s,n,i,r,a,h,m){if((0,o.J)(s,0,1)&&(0,o.J)(n,0,1)&&0===o.P.distance(t.getCoord2D(s),e.getCoord2D(n))){const m=1e-12,l=new v,u=(0,o.N)();if(t.queryDerivative(new o.F(s,u),l),l.isTrueZero()){const e=1===s?-1e-12:m;t.queryDerivative(new o.F(s,u).add(e),l)}1===s&&l.negateThis();const c=new v;if(e.queryDerivative(new o.F(n,u),c),c.isTrueZero()){const t=1===s?-1e-12:m;e.queryDerivative(new o.F(n,u).add(t),c)}1===n&&c.negateThis(),l.isZero()||l.normalize(),c.isZero()||c.normalize();const g=l.dotProduct(c),d=l.crossProduct(c);d.scaleError(3);const _=()=>{{const s=t.calculateUpperLength2D(),n=e.calculateUpperLength2D();return Math.min(.01*i/Math.min(s,n),1e-10)}};if(g.ge(o.H)&&(d.isZero()||Math.abs(d.value())<_()))return N(t,e,s,n,i,r,a,h)}return 0}function G(t,e){t.m_XStart=e.x,t.m_YStart=e.y}function M(t,e,s){t.m_XStart=e,t.m_YStart=s}function F(t,e){t.m_XEnd=e.x,t.m_YEnd=e.y}function q(t,e,s){t.m_XEnd=e,t.m_YEnd=s}function V(t,e){const s=new r.h;return e?(s.x=t.m_XEnd,s.y=t.m_YEnd):(s.x=t.m_XStart,s.y=t.m_YStart),s.z=function(t,e){return t.m_description.hasZ()?t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)]:I.getDefaultValue(1)}(t,e),s}function Y(t,e,s){t.m_description.hasZ()||t.addAttribute(1),e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified()),t.m_attributes[(t.m_description.getTotalComponentCount()-2)*e]=s.z}function X(t,e,s){s.assignVertexDescription(t.m_description);const n=0===e?t.m_XStart:t.m_XEnd,i=0===e?t.m_YStart:t.m_YEnd;s.setXYCoords(n,i);for(let r=1;r<t.m_description.getAttributeCount();r++){const n=t.m_description.getSemantics(r);for(let i=0,r=I.getComponentCount(n);i<r;i++){const r=R(t,e,n,i);s.setAttributeBasic(n,i,r)}}}function k(t,e,s){s.isEmpty()&&(0,i.u)(""),function(t,e,s){e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified())}(t,e,s.getXY());const n=s.getDescription();n!==t.m_description&&t.mergeVertexDescription(n);for(let i=1,r=n.getAttributeCount();i<r;i++){const r=n.getSemantics(i),o=I.getComponentCount(r);for(let n=0;n<o;n++)H(t,e,r,n,s.getAttributeAsDbl(r,n))}}function R(t,e,s,n){if((e<0||e>1)&&(0,i.n)(""),0===s)return(n<0||n>=2)&&(0,i.n)(""),0===e?0===n?t.m_XStart:t.m_YStart:0===n?t.m_XEnd:t.m_YEnd;const r=I.getComponentCount(s);(n<0||n>=r)&&(0,i.n)("");const o=t.m_description.getAttributeIndex(s);return o>=0?t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(o)-2+n]:I.getDefaultValue(s)}function H(t,e,s,n,r){if((e<0||e>1)&&(0,i.n)(""),0===s)return 0===e?0===n?t.m_XStart=r:1===n?t.m_YStart=r:(0,i.n)(""):1===e?0===n?t.m_XEnd=r:1===n?t.m_YEnd=r:(0,i.n)(""):(0,i.n)(""),void t.endPointModified();const o=I.getComponentCount(s);(n<0||n>=o)&&(0,i.n)("");let a=t.m_description.getAttributeIndex(s);a<0&&(t.addAttribute(s),a=t.m_description.getAttributeIndex(s)),t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(a)-2+n]=r}function L(t,e){if(t===e)return;e.isEmpty()&&(0,i.u)("");const s=e.getDescription();s!==t.m_description&&t.mergeVertexDescription(s);for(let n=1,i=s.getAttributeCount();n<i;n++){const i=s.getSemantics(n),r=I.getComponentCount(i);for(let s=0;s<r;s++){let n=R(e,0,i,s);H(t,0,i,s,n),n=R(e,1,i,s),H(t,1,i,s,n)}}}function B(t){return t.absNorm()*(0,o.g)()}function U(t,e){return Math.max(t.absNorm(),e.absNorm())*(0,o.g)()}function z(t,e,s){const n=new E;t.queryEnvelopeW(o.E.unit(),n);const i=new E;return e.queryEnvelopeW(o.E.unit(),i),i.inflate(s),!n.isIntersectingW(i)}function O(t,e,s){const n=(0,o.L)(t,s),i=(0,o.L)(e,s);n.sort(((t,e)=>t.compare(e))),i.sort(((t,e)=>t.compare(e)));for(let r=0;r<3;r++){if(n[r].compare(i[r])<0)return-1;if(0!==n[r].compare(i[r]))return 1}return 0}var W=r.V;class j{constructor(t){if(t.copy)this.m_XStart=t.copy.m_XStart,this.m_YStart=t.copy.m_YStart,this.m_XEnd=t.copy.m_XEnd,this.m_YEnd=t.copy.m_YEnd,this.m_description=t.copy.m_description,this.m_attributes=null,this.m_description&&this.m_description.getTotalComponentCount()-2&&(this.m_attributes=t.copy.m_attributes.slice());else{if(t.move)return this.m_description=t.move.m_description,t.move.m_description=null,this.m_attributes=t.move.m_attributes,t.move.m_attributes=null,this.m_XStart=t.move.m_XStart,this.m_YStart=t.move.m_YStart,this.m_XEnd=t.move.m_XEnd,void(this.m_YEnd=t.move.m_YEnd);if(void 0!==t.XStart)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_attributes=null,this.m_description=t.vd?t.vd:(0,r.j)(),void(t.vd&&this.setDefaultAttributeValues());if(void 0!==t.ZStart)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_description=t.vd?t.vd:(0,r.w)(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.ZStart,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.ZEnd):this.m_attributes=[t.ZStart,t.ZEnd]);if(t.start)return this.m_XStart=t.start.x,this.m_YStart=t.start.y,this.m_XEnd=t.end.x,this.m_YEnd=t.end.y,this.m_attributes=null,void(this.m_description=(0,r.j)());if(t.start3D)return this.m_XStart=t.start3D.x,this.m_YStart=t.start3D.y,this.m_XEnd=t.end3D.x,this.m_YEnd=t.end3D.y,this.m_description=t.vd?t.vd:(0,r.w)(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.start3D.z,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.end3D.z):this.m_attributes=[t.start3D.z,t.end3D.z]);(0,i.c)("bad constructor params"),this.m_XStart=this.m_YStart=this.m_XEnd=this.m_YEnd=Number.NaN}}setDefaultAttributeValues(){const t=this.m_description.getTotalComponentCount()-2;t>0&&(null===this.m_attributes&&(this.m_attributes=(0,o.d)(2*t,Number.NaN)),(0,o.a)(this.m_attributes,this.m_description.getDefaultPointAttributes(),0,2,t),(0,o.a)(this.m_attributes,this.m_description.getDefaultPointAttributes(),t,2,t))}absNormXYZ(t){return(0,i.b)("not implemented"),0}snapControlPoints3D(){return(0,i.b)("not implemented"),!1}setCoordsForIntersector3D(t,e,s){(0,i.b)("not implemented")}transformAttribute(t,e,s,n,r){(0,i.b)("")}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=(0,r.l)(e,t);this.assignVertexDescription(s)}changeEndPoints(t,e){const s=t.getXY(),n=e.getXY();this.changeEndPoints2D(s,n);let i=t.getDescription();i!==this.getDescription()&&this.mergeVertexDescription(i),i=e.getDescription(),i!==this.getDescription()&&this.mergeVertexDescription(i);for(let r=1,o=i.getAttributeCount();r<o;r++){const s=i.getSemantics(r),n=W.getComponentCount(s);for(let i=0;i<n;i++)H(this,0,s,i,t.getAttributeAsDbl(s,i)),H(this,1,s,i,e.getAttributeAsDbl(s,i))}}getStartXY(){return new o.P(this.m_XStart,this.m_YStart)}setStartXY(t){this.m_XStart=t.x,this.m_YStart=t.y,this.endPointModified()}setStartXYCoords(t,e){this.m_XStart=t,this.m_YStart=e,this.endPointModified()}getStartXYZ(){return V(this,0)}setStartXYZ(t){Y(this,0,t)}setStartXYZCoords(t,e,s){Y(this,0,r.h.construct(t,e,s))}queryStart(t){X(this,0,t)}setStart(t){k(this,0,t)}setStart2D(t){this.setStartXY(t)}getStartAttributeAsDbl(t,e){return R(this,0,t,e)}getStartAttributeAsInt(t,e){return(0,i.g)(0),0}setStartAttribute(t,e,s){H(this,0,t,e,s)}setStartAttributesFromPoint(t,e){const s=t.getDescription();for(let n=e&&s.hasZ()?2:1,i=s.getAttributeCount();n<i;++n){const e=s.getSemantics(n),i=W.getComponentCount(e);for(let s=0;s<i;++s){const n=t.getAttributeAsDbl(e,s);this.setStartAttribute(e,s,n)}}}setEndAttributesFromPoint(t,e){const s=t.getDescription();for(let n=e&&s.hasZ()?2:1,i=s.getAttributeCount();n<i;++n){const e=s.getSemantics(n),i=W.getComponentCount(e);for(let s=0;s<i;++s){const n=t.getAttributeAsDbl(e,s);this.setEndAttribute(e,s,n)}}}getStartX(){return this.m_XStart}getStartY(){return this.m_YStart}getStartZ(){return(0,i.g)(0),0}getEndX(){return this.m_XEnd}getEndY(){return this.m_YEnd}getEndZ(){return(0,i.g)(0),0}getEndXY(){return new o.P(this.m_XEnd,this.m_YEnd)}setEndXY(t){this.m_XEnd=t.x,this.m_YEnd=t.y,this.endPointModified()}setEndXYCoords(t,e){this.m_XEnd=t,this.m_YEnd=e,this.endPointModified()}getEndXYZ(){return V(this,1)}setEndXYZ(t){Y(this,1,t)}setEndXYZCoords(t,e,s){Y(this,1,r.h.construct(t,e,s))}queryEnd(t){X(this,1,t)}setEnd(t){k(this,1,t)}setEnd2D(t){this.setEndXY(t)}getEndAttributeAsDbl(t,e){return R(this,1,t,e)}getEndAttributeAsInt(t,e){return(0,i.g)(0),Math.trunc(0)}setEndAttribute(t,e,s){H(this,1,t,e,s)}getDimension(){return 1}copyTo(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&(0,i.t)("");const e=t;e.assignVertexDescription(this.m_description),e.m_attributes&&(0,o.a)(e.m_attributes,this.m_attributes,0,0,2*(this.m_description.getTotalComponentCount()-2)),e.m_XStart=this.m_XStart,e.m_YStart=this.m_YStart,e.m_XEnd=this.m_XEnd,e.m_YEnd=this.m_YEnd,this.copyToImpl(e)}isEmpty(){return this.isEmptyImpl()}isClosed(){return this.m_XStart===this.m_XEnd&&this.m_YStart===this.m_YEnd}setEmpty(){}calculateArea2D(){return 0}queryInterval(t,e){const s=o.E.constructEmpty();return s.vmin=R(this,0,t,e),s.vmax=s.vmin,s.mergeNeCoordinate(R(this,1,t,e)),s}calculateLength3D(t){return(0,i.g)(0),0}getCoord3D(t){return(0,i.g)(0),{}}getCoord2D(t){const e=o.P.getNAN();return this.queryCoord2D(t,e),e}queryCoord3D(t,e){(0,i.g)(0)}getCoordZ(t){return(0,i.g)(0),0}queryCoord(t,e){e.assignVertexDescription(this.m_description),e.setXY(this.getCoord2D(t));for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const n=this.m_description.getSemantics(s),i=W.getComponentCount(n);for(let s=0;s<i;s++){const i=this.getAttributeAsDbl(t,n,s);e.setAttributeBasic(n,s,i)}}}isCloserThanDistance(t,e,s){const n=a.Envelope2D.constructEmpty();if(this.queryLooseEnvelopeOnInterval(e,n),n.distance(t)>s)return!1;const i=this.getClosestCoordinateOnInterval(t,e,s);return!Number.isNaN(i)&&o.P.distance(t,this.getCoord2D(i))<=s}isMonotoneQuickAndDirty(){return!1}isTrue3D(){return!1}getReversed(){const t=this.clone();return t.reverse(),t}reverse(){this.m_XEnd=(0,o.b)(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=(0,o.b)(this.m_YStart,this.m_YStart=this.m_YEnd),this.reverseImpl();for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t);for(let t=0,s=W.getComponentCount(e);t<s;t++){const s=R(this,0,e,t);H(this,0,e,t,R(this,1,e,t)),H(this,1,e,t,s)}}return this.afterCompletedModification(),this}isEmptyImpl(){return!1}isCircular(){return!1}distance(t,e,s,n){if(!e&&this.isIntersecting(t,0,!1)){if(null!==s||null!==n){const e=(0,o.d)(9,Number.NaN),r=(0,o.d)(9,Number.NaN),a=this.intersect(t,null,e,r,0);(0,i.g)(a<=9),0===a&&(0,i.c)(""),null!==s&&(s[0]=e[0]),null!==n&&(n[0]=r[0])}return 0}let r,a=Number.MAX_VALUE,h=-1,m=a;return r=this.getStartXY(),h=t.getClosestCoordinate(r,!1),r.subThis(t.getCoord2D(h)),m=r.length(),m<a&&(a=m,null!==n&&(n[0]=h),null!==s&&(s[0]=0)),r=this.getEndXY(),h=t.getClosestCoordinate(r,!1),r.subThis(t.getCoord2D(h)),m=r.length(),m<a&&(a=m,null!==n&&(n[0]=h),null!==s&&(s[0]=1)),r=t.getStartXY(),h=this.getClosestCoordinate(r,!1),r.subThis(this.getCoord2D(h)),m=r.length(),m<a&&(a=m,null!==s&&(s[0]=h),null!==n&&(n[0]=0)),r=t.getEndXY(),h=this.getClosestCoordinate(r,!1),r.subThis(this.getCoord2D(h)),m=r.length(),m<a&&(a=m,null!==s&&(s[0]=h),null!==n&&(n[0]=1)),a}calculateSubLengthFromStart(t){return this.tToLength(t)}calculateSubLength(t,e){return e===t?0:this.tToLength(e)-this.tToLength(t)}static recalculateParentT(t,e,s){return(0,o.q)(t,e,s)}moveTo(t){const e=this.isClosed(),s=new h.T;s.setShift(t.sub(this.getStartXY())),this.applyTransformation(s),e?this.changeEndPoints2D(t,t):this.changeEndPoints2D(t,this.getEndXY())}moveTo3D(t){(0,i.g)(0)}getDescription(){return this.m_description}assignVertexDescription(t){!function(t,e){const s=(0,r.p)();(0,r.q)(e,t.m_description,s);let n=null;const i=e.getTotalComponentCount()-2,a=t.m_description?t.m_description.getTotalComponentCount()-2:0;if(i>0&&(n=(0,o.d)(2*i,Number.NaN),(0,o.a)(n,e.getDefaultPointAttributes(),0,2,i),(0,o.a)(n,e.getDefaultPointAttributes(),i,2,i),null!==t.m_description))for(let r=1;r<e.getAttributeCount();r++){const o=s[r];if(-1!==o){const s=t.m_description.getPointAttributeOffset(o)-2,h=e.getPointAttributeOffset(r)-2,m=I.getComponentCount(e.getSemantics(r));for(let e=0;e<m;++e)n[h]=t.m_attributes[s],n[i+h]=t.m_attributes[a+s]}}t.m_attributes=n,t.m_description=e}(this,t)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=(0,r.m)(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=(0,r.r)(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=(0,r.j)();t!==this.m_description&&this.assignVertexDescription(t)}swap(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&(0,i.t)("wrong geometry type");const e=t;e.m_description=(0,o.b)(this.m_description,this.m_description=e.m_description),e.m_XStart=(0,o.b)(this.m_XStart,this.m_XStart=e.m_XStart),e.m_YStart=(0,o.b)(this.m_YStart,this.m_YStart=e.m_YStart),e.m_XEnd=(0,o.b)(this.m_XEnd,this.m_XEnd=e.m_XEnd),e.m_YEnd=(0,o.b)(this.m_YEnd,this.m_YEnd=e.m_YEnd),e.m_attributes=(0,o.b)(this.m_attributes,this.m_attributes=e.m_attributes),this.swapImpl(e)}equals(t,e){if(this.getGeometryType()!==t.getGeometryType())return!1;const s=void 0===e;s&&(e=0);const n=t;if(this===n)return!0;if(this.m_description!==n.m_description)return!1;if(Math.abs(this.m_XStart-n.m_XStart)>e||Math.abs(this.m_XEnd-n.m_XEnd)>e||Math.abs(this.m_YStart-n.m_YStart)>e||Math.abs(this.m_YEnd-n.m_YEnd)>e)return!1;for(let i=0,r=2*(this.m_description.getTotalComponentCount()-2);i<r;i++)if(!(0,o.I)(this.m_attributes[i],n.m_attributes[i],e))return!1;return s?this.equalsImpl(n):this.equalsImplTol(n,e)}getImpl(){return this}setAttributeBasic(t,e,s){if(this.addAttribute(t),0===t&&this.isCurve()){(e<0||e>1)&&(0,i.t)("");const t=new h.T,n=0===e?s:0,r=1===e?s:0;t.setShiftCoords(n,r),0===e?t.xx=0:t.yy=0,this.applyTransformation(t)}else this.setStartAttribute(t,e,s),this.setEndAttribute(t,e,s)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;const s=W.getComponentCount(t);for(let n=0;n<s;n++){const s=this.getStartAttributeAsDbl(t,n);Number.isNaN(s)&&this.setStartAttribute(t,n,e);const i=this.getEndAttributeAsDbl(t,n);Number.isNaN(i)&&this.setEndAttribute(t,n,e)}}}j.s_maxMonotonicPartParams=8;class Z extends m.G{constructor(t,e){super(),this.m_index=-1,this.gc=t,this.dim=e}next(){for(;;){if(this.m_index>=this.gc.getGeometryCount())return null;if(this.m_index++,this.m_index===this.gc.getGeometryCount())return null;const t=this.gc.getGeometry(this.m_index);if(-1===this.dim||1<<t.getDimension()&this.dim)return t}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class Q{constructor(t){this.m_geoms=[],this.m_description=(0,r.j)(),t&&(t.vd?this.m_description=t.vd:t.copy?t.copy.copyTo(this):(0,i.t)("constructor argument not recognized"))}getGeometryCount(){return this.m_geoms.length}reserve(t){}addGeometry(t){if(t.getGeometryType()===i.G.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else this.m_geoms.push(t.clone()),this.mergeVertexDescription(t.getDescription())}addCursor(t){for(let e=t.next();null!==e;e=t.next())this.addGeometry(e)}getGeometry(t){return(t<0||t>=this.m_geoms.length)&&(0,i.t)("Geometry_collection.get_geometry"),this.m_geoms[t]}modifiedElementIndex(t){this.mergeVertexDescription(this.getGeometry(t).getDescription())}modifiedElement(t){this.mergeVertexDescription(t.getDescription())}getGeometryType(){return i.G.enumGeometryCollection}getDimension(){let t=0;for(const e of this.m_geoms)t=Math.max(t,e.getDimension());return t}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}assignVertexDescriptionImpl(t){for(const e of this.m_geoms)e.assignVertexDescription(t);this.m_description=t}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=(0,r.m)(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=(0,r.r)(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=(0,r.j)();t!==this.m_description&&this.assignVertexDescription(t)}queryInterval(t,e){let s=new o.E;const n=new o.E;n.setEmpty();for(const i of this.m_geoms)s=i.queryInterval(t,e),n.merge(s);return n}queryEnvelope(t){if(4===t.m_EnvelopeType){const e=new r.E;t.setEmpty(),t.assignVertexDescription(this.m_description);for(const s of this.m_geoms)s.queryEnvelope(e),t.merge(e)}else if(2===t.m_EnvelopeType){const e=new a.Envelope2D;t.setEmpty();for(const s of this.m_geoms)s.queryEnvelope(e),t.mergeEnvelope2D(e)}(0,i.b)("3d envelope case not implemented")}queryLooseEnvelope(t){if(2===t.m_EnvelopeType){const e=new a.Envelope2D;t.setEmpty();for(const s of this.m_geoms)s.queryLooseEnvelope(e),t.mergeEnvelope2D(e)}(0,i.b)("3d not impl")}isEmpty(){return 0===this.m_geoms.length}setEmpty(){this.m_geoms.length=0}applyTransformation(t){if(1===t.m_TransformationType)for(const e of this.m_geoms)e.applyTransformation(t);(0,i.b)("3d xform not impl")}transformAttribute(t,e,s,n,i){for(const r of this.m_geoms)r.transformAttribute(t,e,s,n,i)}createInstance(){return new Q({vd:this.getDescription()})}copyTo(t){t.getGeometryType()!==i.G.enumGeometryCollection&&(0,i.t)("");const e=t;if(e!==this){e.m_geoms.length=0,e.assignVertexDescription(this.m_description);for(const t of this.m_geoms)e.m_geoms.push(t.clone())}}calculateArea2D(){const t=new o.K(0);for(const e of this.m_geoms)t.pe(e.calculateArea2D());return t.getResult()}calculateLength2D(){const t=new o.K(0);for(const e of this.m_geoms)t.pe(e.calculateLength2D());return t.getResult()}calculateLength3D(t){return(0,i.g)(0),0}getBoundary(){const t=this.createInstance(),e=t;for(const s of this.m_geoms){const t=s.getBoundary();t&&e.m_geoms.push(t)}return t}clone(){return new Q({copy:this})}equals(t,e){if(t===this)return!0;if(t.getGeometryType()!==i.G.enumGeometryCollection)return!1;const s=t;if(this.m_description!==s.m_description)return!1;if(this.m_geoms.length!==s.m_geoms.length)return!1;for(let n=0;n<this.m_geoms.length;++n)if(!this.m_geoms[n].equals(s.m_geoms[n],e))return!1;return!0}swap(t){t.getGeometryType()!==i.G.enumGeometryCollection&&(0,i.t)("");const e=t;e!==this&&(this.m_geoms=(0,o.b)(e.m_geoms,e.m_geoms=this.m_geoms))}setAttributeBasic(t,e,s){for(const n of this.m_geoms)n.setAttributeBasic(t,e,s)}replaceNaNs(t,e){for(const s of this.m_geoms)s.replaceNaNs(t,e)}getImpl(){return this}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=(0,r.l)(e,t);this.assignVertexDescription(s)}}function K(t){return new Z(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}Q.type=i.G.enumGeometryCollection;class J extends j{constructor(t){super(t)}}class $ extends J{isTrue3D(){return!0}constructor(t){super(t)}}function tt(t,e,s){et(e,t.getStartXY(),t.getEndXY(),s)}function et(t,e,s,n){(0,o.Z)(e,s,t,n)}function st(t,e){return(0,o.q)(t.m_XStart,t.m_XEnd,e)}function nt(t,e){return(0,o.q)(t.m_YStart,t.m_YEnd,e)}function it(t,e,s){e.value()<=.5?(0,o.a1)(2,v.constructPoint2D(t.getStartXY()),v.constructPoint2D(t.getEndXY()),e,s):(0,o.a2)(2,v.constructPoint2D(t.getStartXY()),v.constructPoint2D(t.getEndXY()),e,s)}function rt(t,e,s){t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,t.afterCompletedModification()}function ot(t){if(t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart){t.m_XEnd=(0,o.b)(t.m_XStart,t.m_XStart=t.m_XEnd),t.m_YEnd=(0,o.b)(t.m_YStart,t.m_YStart=t.m_YEnd);for(let e=0,s=t.m_description.getTotalComponentCount()-2;e<s;e++)t.m_attributes[e+s]=(0,o.b)(t.m_attributes[e],t.m_attributes[e]=t.m_attributes[e+s])}}function at(t,e,s,n){let i=0;if((t.m_XStart===e.m_XStart&&t.m_YStart===e.m_YStart||t.m_XStart===e.m_XEnd&&t.m_YStart===e.m_YEnd)&&(i++,!n))return 1;if(t.m_XEnd===e.m_XStart&&t.m_YEnd===e.m_YStart||t.m_XEnd===e.m_XEnd&&t.m_YEnd===e.m_YEnd){if(i++,2===i)return 2;if(!n)return 1}return e.isIntersectingPoint(t.getStartXY(),s,!0)||e.isIntersectingPoint(t.getEndXY(),s,!0)||t.isIntersectingPoint(e.getStartXY(),s,!0)||t.isIntersectingPoint(e.getEndXY(),s,!0)?4:n&&i?0:function(t,e){const s=ut(t,e.m_XStart,e.m_YStart),n=ut(t,e.m_XEnd,e.m_YEnd);if(s<0&&n<0||s>0&&n>0)return!1;const i=ut(e,t.m_XStart,t.m_YStart),r=ut(e,t.m_XEnd,t.m_YEnd);return!(i<0&&r<0||i>0&&r>0)&&(dt(t)>dt(e)?gt(t,e):gt(e,t))}(t,e)?4:0}function ht(t,e,s,n,i,r,a,h){null!==n&&(0,o.w)(n,2,Number.NaN),null!==i&&(0,o.w)(i,2,Number.NaN),null!==s&&(0,o.ab)(s,o.P,2);const m=function(t,e,s,n,i,r,a,h,m){const l=lt(t,e.getStartXY(),a,!1),u=lt(t,e.getEndXY(),a,!1),c=lt(e,t.getStartXY(),a,!1),g=lt(e,t.getEndXY(),a,!1);let d=0,_=0;if(!Number.isNaN(l)){let s=!1;h&&(0,o.J)(l,0,1)&&t.getCoord2D(l).isEqualPoint2D(e.getStartXY())&&(d++,s=!0),s||(i&&(i[_]=l),r&&(r[_]=0),n&&n[_].setCoords(e.m_XStart,e.m_YStart),_++)}if(!Number.isNaN(u)){let a=!1;h&&(0,o.J)(u,0,1)&&t.getCoord2D(u).isEqualPoint2D(e.getEndXY())&&(d++,a=!0),a||(s>_&&(i&&(i[_]=u),r&&(r[_]=1),n&&n[_].setCoords(e.m_XEnd,e.m_YEnd)),_++)}if(2!==_&&!Number.isNaN(c)&&!(0===l&&0===c||0===u&&1===c)){let a=!1;h&&(0,o.J)(c,0,1)&&e.getCoord2D(c).isEqualPoint2D(t.getStartXY())&&(d++,a=!0),a||(s>_&&(i&&(i[_]=0),r&&(r[_]=c),n&&n[_].setCoords(t.m_XStart,t.m_YStart)),_++)}if(2!==_&&!Number.isNaN(g)&&!(1===l&&0===g||1===u&&1===g)){let a=!1;h&&(0,o.J)(g,0,1)&&e.getCoord2D(g).isEqualPoint2D(t.getEndXY())&&(d++,a=!0),a||(s>_&&(i&&(i[_]=1),r&&(r[_]=g),n&&n[_].setCoords(e.m_XEnd,e.m_YEnd)),_++)}if(_>0)return m&&(r=(0,o.b)(i,i=r)),2===_&&s>=2&&i&&i[0]>i[1]&&(i[1]=(0,o.b)(i[0],i[0]=i[1]),r&&(r[1]=(0,o.b)(r[0],r[0]=r[1])),n&&(n[1]=(0,o.b)(n[0],n[0]=n[1]))),_;if(d>0)return 0;const p=function(t,e,s){const n=t.m_XEnd-t.m_XStart,i=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,a=e.m_YEnd-e.m_YStart,h=r*i-n*a;if(0===h)return o.P.getNAN();const m=4*(0,o.N)()*(Math.abs(r*i)+Math.abs(n*a)),l=e.m_XStart-t.m_XStart,u=e.m_YStart-t.m_YStart,c=r*u-l*a,g=4*(0,o.N)()*(Math.abs(r*u)+Math.abs(l*a)),d=c/h,_=Math.abs(h),p=(g*_+m*Math.abs(c))/(h*h)+(0,o.N)()*Math.abs(d);if(d<-p||d>1+p)return o.P.getNAN();const f=n*u-l*i,P=f/h,x=(4*(0,o.N)()*(Math.abs(n*u)+Math.abs(l*i))*_+m*Math.abs(f))/(h*h)+(0,o.N)()*Math.abs(P);if(P<-x||P>1+x)return o.P.getNAN();let y=(0,o.c)(d,0,1),E=(0,o.c)(P,0,1);const C=o.P.getNAN();tt(t,y,C);const S=o.P.getNAN();if(tt(e,E,S),!s||o.P.distance(C,S)>s){const n=o.P.getNAN();(0,o.Z)(C,S,.5,n),y=t.getClosestCoordinate(n,!1),E=e.getClosestCoordinate(n,!1);const i=o.P.getNAN();tt(t,y,i);const r=o.P.getNAN();tt(e,E,r),i.subThis(r);const a=i.length(),h=(t.absNorm()+e.absNorm())*(0,o.g)();if(a>Math.max(s,h))return o.P.getNAN()}return new o.P(y,E)}(t,e,a);return Number.isNaN(p.x)?0:(n&&(n[0]=t.getCoord2D(p.x)),i&&(i[0]=p.x),r&&(r[0]=p.y),1)}(t,e,2,s,n,i,r,a,h);return n&&(n.length=m),i&&(i.length=m),s&&(s.length=m),m}function mt(t,e){const s={bIntersect:!1,t1:Number.NaN,t2:Number.NaN},n=t.m_XEnd-t.m_XStart,i=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,o=e.m_YEnd-e.m_YStart,a=r*i-n*o;if(0===a)return s;const h=e.m_XStart-t.m_XStart,m=e.m_YStart-t.m_YStart,l=r*m-h*o,u=n*m-h*i,c=1/a;return s.t1=l*c,s.t2=u*c,s.bIntersect=!0,s}function lt(t,e,s,n){const i=o.P.getNAN(),r=o.P.getNAN();let a=!1;t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart?(i.setCoords(t.m_XEnd,t.m_YEnd),r.setCoords(t.m_XStart,t.m_YStart),a=!0):(i.setCoords(t.m_XStart,t.m_YStart),r.setCoords(t.m_XEnd,t.m_YEnd));const h=a?1:0,m=a?0:1,l=o.P.getNAN();l.setSub(e,i);let u=l.length(),c=3*u*(0,o.N)();if(u<=Math.max(s,c))return n&&0===u?Number.NaN:h;if(l.setSub(e,r),u=l.length(),c=3*u*(0,o.N)(),u<=Math.max(s,c))return n&&0===u?Number.NaN:m;l.setCoords(r.x-i.x,r.y-i.y);const g=l.length();if(g>0){const t=1/g;l.scale(t);const n=o.P.getNAN();n.setSub(e,i);const u=n.dotProduct(l),c=8*n.dotProductAbs(l)*(0,o.N)();l.leftPerpendicularThis();const d=n.dotProduct(l),_=8*n.dotProductAbs(l)*(0,o.N)(),p=Math.max(s,c);if(u<-p||u>g+p)return Number.NaN;const f=Math.max(s,_);if(Math.abs(d)<=f){let n=u*t;n=(0,o.c)(n,0,1);const l=o.P.getNAN();if(et(n,i,r,l),o.P.distance(l,e)<=s){if(n<.5){if(o.P.distance(l,i)<=s&&o.P.distance(e,i)<=s)return h}else if(o.P.distance(l,r)<=s&&o.P.distance(e,r)<=s)return m;return a?1-n:n}}}return Number.NaN}function ut(t,e,s){const n=o.P.getNAN();n.setCoords(e,s),n.subThis(t.getStartXY());const i=o.P.getNAN();i.setSub(t.getEndXY(),t.getStartXY());const r=i.crossProduct(n),a=4*(0,o.N)()*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>a?-1:r<-a?1:0}function ct(t,e,s,n){const i=n?t.m_XStart:t.m_XEnd,r=n?t.m_YStart:t.m_YEnd,a=o.P.getNAN();return a.x=e.getEndX()-i,a.y=e.getEndY()-r,!(s.dotProduct(a)>3*(0,o.N)()*s.dotProductAbs(a))||(a.x=e.getStartX()-i,a.y=e.getStartY()-r,s.dotProduct(a)<=3*(0,o.N)()*s.dotProductAbs(a))}function gt(t,e){const s=o.P.getNAN();return s.x=t.m_XEnd-t.m_XStart,s.y=t.m_YEnd-t.m_YStart,!!ct(t,e,s,!1)&&(s.negateThis(),!!ct(t,e,s,!0))}function dt(t){const e=t.m_XStart-t.m_XEnd,s=t.m_YStart-t.m_YEnd;return e*e+s*s}class _t{constructor(t){if(this.m_segFlagStream=null,this.m_xyStream=null,this.m_bCirculator=!1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_parent=t.parent,this.m_buffer=new this.m_parent.m_segmentBufferCTor,this.m_description=t.parent.getDescription(),this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),void 0!==t.pointIndex){(t.pointIndex<0||t.pointIndex>=t.parent.getPointCount())&&(0,i.n)("");const e=t.parent.getPathIndexFromPointIndex(t.pointIndex);this.m_currentPathIndex=e,this.m_nextPathIndex=e+1,this.m_nextSegmentIndex=t.pointIndex-t.parent.getPathStart(e),this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex)}else if(void 0!==t.pathIndex){(t.pathIndex<0||t.pathIndex>=t.parent.getPathCount()||t.segmentIndex<0)&&(0,i.n)("");const e=t.parent.isClosedPath(t.pathIndex)?0:1;t.segmentIndex>=t.parent.getPathSize(t.pathIndex)-e&&(0,i.n)(""),this.m_nextSegmentIndex=t.segmentIndex,this.m_currentPathIndex=t.pathIndex,this.m_nextPathIndex=this.m_nextSegmentIndex+1,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex)}this.prepare(),this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1,this.m_bStripAttributes=!1,this.m_prevPathIndex=-1,this.m_prevSegmentIndex=-1,this.m_bNeedsUpdate=!1,this.m_currentPathIndex>-1&&(this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex))}stripAttributes(){this.m_bStripAttributes=!0}prepare(){this.m_bCirculator=!1,this.m_parent.isEmptyImpl()?(this.m_segFlagStream=null,this.m_xyStream=null):(this.m_segFlagStream=this.m_parent.getSegmentFlagsStreamRef(),this.m_xyStream=this.m_parent.getAttributeStreamRef(0))}nextPath(){return this.m_currentPathIndex=this.m_nextPathIndex,!(this.m_currentPathIndex>=this.m_parent.getPathCount())&&(this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.m_nextPathIndex++,!0)}previousPath(){return 0!==this.m_nextPathIndex&&(this.m_nextPathIndex--,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),this.m_currentPathIndex=this.m_nextPathIndex,this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.resetToLastSegment(),!0)}getSegmentCount(t){return this.m_parent.isEmptyImpl()?0:this.m_parent.getSegmentCountPath(t)}resetToFirstPath(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}resetToLastPath(){this.m_nextPathIndex=this.m_parent.getPathCount(),this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1}resetToPath(t){(t<0||t>this.m_parent.getPathCount())&&(0,i.n)(""),this.m_nextPathIndex=t,this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}isLastPath(){return this.m_currentPathIndex===this.m_parent.getPathCount()-1}isFirstSegmentInPath(){return 0===this.m_currentSegmentIndex}isLastSegmentInPath(){return this.m_currentSegmentIndex===this.m_segmentCount-1}resetToFirstSegment(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0}resetToLastSegment(){this.m_nextSegmentIndex=this.m_segmentCount,this.m_currentSegmentIndex=-1}resetTo(t){this.m_parent!==t.m_parent&&(0,i.m)(""),this.m_currentSegmentIndex=t.m_currentSegmentIndex,this.m_nextSegmentIndex=t.m_nextSegmentIndex,this.m_currentPathIndex=t.m_currentPathIndex,this.m_nextPathIndex=t.m_nextPathIndex,this.m_segmentCount=t.m_segmentCount,this.m_bCirculator=t.m_bCirculator,this.m_pathBegin=t.m_pathBegin,this.m_bCurrentPathClosed=t.m_bCurrentPathClosed,this.m_bStripAttributes=t.m_bStripAttributes,this.m_description=t.m_description}resetToVertex(t,e){if(this.m_currentPathIndex>=0&&this.m_currentPathIndex<this.m_parent.getPathCount()){const e=this.getPathBegin();if(t>=e&&t<this.m_parent.getPathEnd(this.m_currentPathIndex))return this.m_currentSegmentIndex=-1,void(this.m_nextSegmentIndex=t-e)}let s;s=e>=0&&e<this.m_parent.getPathCount()&&t>=this.m_parent.getPathStart(e)&&t<this.m_parent.getPathEnd(e)?e:this.m_parent.getPathIndexFromPointIndex(t),this.m_nextPathIndex=s+1,this.m_currentPathIndex=s,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=t-this.m_parent.getPathStart(s),this.m_segmentCount=this.getSegmentCount(s),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex)}hasNextSegment(){return this.m_nextSegmentIndex<this.m_segmentCount}hasPreviousSegment(){return this.m_nextSegmentIndex>0}nextSegment(){return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&(0,i.n)("Segment_iterator_impl::next_segment"),this.m_nextSegmentIndex++),this.m_buffer.get()}previousSegment(){return this.m_bCirculator?this.m_nextSegmentIndex=(this.m_segmentCount+this.m_nextSegmentIndex-1)%this.m_segmentCount:(0===this.m_nextSegmentIndex&&(0,i.n)(""),this.m_nextSegmentIndex--),this.m_nextSegmentIndex!==this.m_currentSegmentIndex&&this.updateSegment(),this.m_buffer.get()}nextCurve(){if(!this.m_parent.hasNonLinearSegments())return this.resetToLastSegment(),null;let t=0;for(;;){if(this.m_nextSegmentIndex===this.m_segmentCount||t===this.m_segmentCount)return null;const e=this.getPathBegin()+this.m_nextSegmentIndex;if(1!==(31&this.m_segFlagStream.read(e))){this.updateSegment();break}this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:this.m_nextSegmentIndex++,t++}return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&(0,i.n)(""),this.m_nextSegmentIndex++),this.m_buffer.get()}getPathBegin(){return this.m_pathBegin}getPathIndex(){return this.m_currentPathIndex}getStartPointIndex(){return this.getPathBegin()+this.m_currentSegmentIndex}getEndPointIndex(){return this.isClosingSegment()?this.getPathBegin():this.getStartPointIndex()+1}updateSegment(){(this.m_nextSegmentIndex<0||this.m_nextSegmentIndex>=this.m_segmentCount||this.m_currentPathIndex<0)&&(0,i.n)(""),this.m_currentSegmentIndex=this.m_nextSegmentIndex,this.m_parent.getSegmentFromPath(this.m_currentPathIndex,this.m_currentSegmentIndex,this.m_buffer,this.m_bStripAttributes)}isClosingSegment(){return this.m_bCurrentPathClosed&&this.m_currentSegmentIndex===this.m_segmentCount-1}isCurve(){return null!==this.m_segFlagStream&&1!==(31&this.m_segFlagStream.read(this.m_currentSegmentIndex))}isPathClosed(){return this.m_bCurrentPathClosed}setCirculator(t){this.m_bCirculator=t}getImpl(){return this}}class pt{constructor(t){this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null,this.m_refCount=1,t&&t.copyTo(this)}getRasterizedGeometry(){return this.m_rasterizedGeometry}copyTo(t){t!==this&&((0,i.g)(t.uniqueUse()),t.m_quadTree=this.m_quadTree,t.m_quadTreeForPaths=this.m_quadTreeForPaths,t.m_rasterizedGeometry=this.m_rasterizedGeometry)}clone(){const t=new pt;return this.copyTo(t),t}uniqueUse(){return 1===this.m_refCount}addRef(){++this.m_refCount}release(){0==--this.m_refCount&&(this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null)}setRasterizedGeometry(t){(0,i.g)(this.uniqueUse())}setQuadTree(t){(0,i.g)(this.uniqueUse()),this.m_quadTree=t}setQuadTreeForPaths(t){(0,i.g)(this.uniqueUse()),this.m_quadTreeForPaths=t}getQuadTree(){return this.m_quadTree}getQuadTreeForPaths(){return this.m_quadTreeForPaths}}function ft(t){return!(t.isEmpty()||t.getGeometryType()!==i.G.enumPolyline&&t.getGeometryType()!==i.G.enumPolygon)&&!(t.getPointCount()<20)}function Pt(t){return!(t.isEmpty()||t.getGeometryType()!==i.G.enumPolyline&&t.getGeometryType()!==i.G.enumPolygon)&&!(t.getPointCount()<20)}function xt(t,e){return t.readPoint2D(e+4)}function yt(t){const e=t.getGeometryType();return e===i.G.enumEllipticArc?10:e===i.G.enumBezier?4:e===i.G.enumRationalBezier2?5:e===i.G.enumBezier2?2:void(0,i.c)("")}function Et(t){const e=31&t;return 4===e?10:2===e?4:8===e?5:16===e?2:0}function Ct(t,e,s,n){const r=4*(0,o.N)()*(Math.abs(e.vmin)+Math.abs(e.vmax)),a=(0,o.N)();if(1===t.getMaxDerivative()){(0,i.g)(s>0);const a=wt(t,0,e,(0,o.N)(),r);return n[0]=a.root,a.cRoots}let h,m=[];const l=new o.E(e.vmin-r,e.vmax+r);m.push(new o.P(l.vmin,l.vmax));let u=0;for(let i=t.getMaxDerivative()-1;i>=0;i--){h=m,m=[];for(let l=0,c=h.length;l<c;l++){if(h[l][0]<h[l][1]){let c,g,d;if(i===t.getMaxDerivative()-1?({root:c,funcAtRoot:g,cRoots:d}=wt(t,i,o.E.construct(h[l][0],h[l][1]),a,.5*r)):({root:c,funcAtRoot:g,cRoots:d}=Dt(t,i,o.E.construct(h[l][0],h[l][1]),a,.5*r)),1===d){if(0===i)u<s&&(h[l][0]<=e.vmin&&h[l][1]>=e.vmin&&c!==e.vmin&&0===t.getValue(0,e.vmin)&&(c=e.vmin),h[l][0]<=e.vmax&&h[l][1]>=e.vmax&&c!==e.vmax&&0===t.getValue(0,e.vmax)&&(c=e.vmax),n[u]=e.snapClip(c),u>0?n[u]-n[u-1]>r&&u++:u++);else{const t=o.P.getNAN();t[0]=h[l][0],t[1]=c,m.push(t);const e=o.P.getNAN();e[0]=c,e[1]=h[l][1],m.push(e)}continue}}m.push(h[l])}}return u}function St(t,e,s,n,i,r){const a=(0,o.m)(o.F,2),h=At(new o.F(t),new o.F(e),new o.F(s),n,i,a);return r[0]=a[0].value(),r[1]=a[1].value(),h}function vt(t,e,s,n,i,r,a){const h=(0,o.m)(o.F,3),m=Gt(new o.F(t),new o.F(e),new o.F(s),new o.F(n),i,r,h);return a[0]=h[0].value(),a[1]=h[1].value(),a[2]=h[2].value(),m}function bt(t,e,s,n,i,r,a,h){return function(t,e,s,n,i,r,a,h){const m=(0,o.d)(s*s,Number.NaN);m.fill(0),(0,o.a)(h,n,0,0,s);const l=(0,o.d)(s,Number.NaN),u=(0,o.d)(s,Number.NaN),c=(0,o.d)(s,Number.NaN);let g=t(h,s,e);const d=100;let _=0;for(_=0;_<d;_++){const n=g;for(let t=0;t<s;++t)u[t]=h[t];if(_%s==0){m.fill(0);for(let t=0;t<s;t++)m[t*s+t]=1}let a=0,d=0;for(let o=0;o<s;++o){for(let t=0;t<s;++t)l[t]=m[o*s+t];const n=g;g=Tt(t,e,h,l,i,r,s);const u=n-g;u>a&&(d=o,a=u)}for(let t=0;t<s;t++)l[t]=h[t]-u[t],c[t]=h[t]+(h[t]-u[t]);const p=t(c,s,e);if(p<n&&2*(n-2*g+p)*(0,o.s)(n-g-a)<(0,o.s)(n-p)*a){g=Tt(t,e,h,l,i,r,s);for(let t=0;t<s;++t)m[d*s+t]=m[(s-1)*s+t],m[(s-1)*s+t]=l[t]}if(n<=g)return t(h,s,e)}return g}(t,e,s,n,i,r,0,h)}function It(t,e,s,n,i,r){return function(t,e,s,n,i,r){const a=(0,o.an)();let h=n,m=t(h,e),l=s,u=i,c=t(l,e),g=t(u,e);m>c&&(m=c,h=l),m>g&&(m=g,h=u);let d=l,_=u,p=c,f=g;p>f&&(p=(0,o.b)(f,f=p),_=(0,o.b)(d,d=_));let P=h-d,x=d-_;const y=.5*Math.min(r,u-l),E=2*y,C=100;let S,v=0;for(S=0;S<C&&!(u-l<=E);++S){const s=l+.5*(u-l);let n=v>0;if(!n&&Math.abs(x)<=y&&(n=!0,v=3),!n){const t=h-d,e=h-_,s=t*(m-f);let i=e*(m-p),r=e*i-t*s;i=2*(i-s),i>0&&(r=-r),i=Math.abs(i),0===i||Math.abs(r)>=Math.abs(i*x/2)||r<=i*(l-h)||r>=i*(u-h)?(n=!0,v=3):(x=P,P=r/i)}n&&(x=h>=s?l-h:u-h,P=a*x,v--);let i=h+P;i<l+y?i=l+y:i>u-y&&(i=u-y);const r=t(i,e);r<m?(i>=h?(l=h,c=m):(u=h,g=m),_=d,d=h,h=i,f=p,p=m,m=r):(i<h?(l=i,c=r):(u=i,g=r),r<=p||d===h?(_=d,d=i,f=p,p=r):(r<=f||_===h||_===d)&&(_=i,f=r))}return h}(t,e,s,n,i,r)}function wt(t,e,s,n,r){const a={root:0,funcAtRoot:0,cRoots:0};let h=s.vmin,m=s.vmax,l=0,u=Number.MAX_VALUE,c=t.getValue(e,h),g=t.getValue(e,m),d=0,_=0,p=0;if(c>=0&&g>=0||c<=0&&g<=0)return Math.abs(c)<Math.abs(g)?(a.funcAtRoot=c,a.root=h,a.cRoots=0===c?1:0,a):(a.funcAtRoot=g,a.root=m,a.cRoots=0===g?1:0,a);Math.abs(c)<Math.abs(g)&&(m=(0,o.b)(h,h=m),g=(0,o.b)(c,c=g)),l=h,d=c;let f=!0,P=0;for(;0!==g&&Math.abs(h-m)>n*Math.abs(m)+r;P++){let s=P>64;if(!s){_=c!==d&&g!==d?h*g*d/((c-g)*(c-d))+m*c*d/((g-c)*(g-d))+l*c*g/((d-c)*(d-g)):m-g*(m-h)/(g-c);const t=(3*h+m)/4;if(s=!(_>t&&_<m||_>m&&_<t),!s){const t=n*Math.abs(m)+r;if(f){const e=Math.abs(m-l);s=Math.abs(_-m)>=.5*e||e<t}else{const e=Math.abs(l-u);s=Math.abs(_-m)>=.5*e||e<t}}}if(s?(_=(h+m)/2,f=!0):f=!1,p=t.getValue(e,_),0===p)return a.root=_,a.funcAtRoot=p,a.cRoots=1,a;if(!s){const s=h-_,n=_-m;if(Math.abs(s)>10*Math.abs(n)){let s=m+3*n;for(let n=0;n<2;n++){const n=t.getValue(e,s);(0,o.e)(c)*(0,o.e)(n)>0?(h=s,c=n):s=(0,o.q)(h,m,.75)}}else if(Math.abs(n)>10*Math.abs(s)){let n=h-3*s;for(let s=0;s<2;++s){const s=t.getValue(e,n);(0,o.e)(g)*(0,o.e)(s)>0?(m=n,g=s):n=(0,o.q)(h,m,.25)}}}u=l,l=m,d=g,(0,o.e)(c)*(0,o.e)(p)<0?(m=_,g=p):(h=_,c=p),Math.abs(c)<Math.abs(g)&&(m=(0,o.b)(h,h=m),g=(0,o.b)(c,c=g)),128===P&&(0,i.c)("Root_finder iterations exceeded")}return a.root=m,a.funcAtRoot=g,a.cRoots=1,a}function Dt(t,e,s,n,r){const a={root:0,funcAtRoot:0,cRoots:0};let h=s.vmin,m=t.getValue(e,h),l=s.vmax,u=t.getValue(e,l);if(m>=0&&u>=0||m<=0&&u<=0)return Math.abs(m)<Math.abs(u)?(a.funcAtRoot=m,a.root=h,a.cRoots=0===m?1:0,a):(a.funcAtRoot=u,a.root=l,a.cRoots=0===u?1:0,a);u<0&&(u=(0,o.b)(m,m=u),l=(0,o.b)(h,h=l));let c=.5*(h+l),g=Math.abs(l-h),d=g,_=t.getValue(e,c),p=t.getValue(e+1,c);let f=4;let P=1,x=0,y=0,E=1;let C=0;for(;++C<100;){let s;C>32||0===p||2===E&&x>1||1===E&&f<4?(E=1,P>1&&P--):(E=2,y>1&&Math.abs(2*_)>Math.abs(g*p)&&P++),g=d;let n=!1;if(1===E)do{if(y>2){const t=16*Math.abs(g);if(.5*Math.abs(h-l)>t){const e=Math.min(h,l),n=Math.max(h,l);if(c===e){s=c,c=e+t,d=c-s;break}if(c===n){s=c,c=n-t,d=c-s;break}}}d=.5*(l-h),s=c,c=h+d,n=h===c||l===c}while(0);else for(;;){d=P*_/p,s=c,c-=d,n=c===s;const t=Math.min(h,l),e=Math.max(h,l);if(c<t){if(P>1){c=s,P--;continue}d=s-t,c=t}else if(c>e){if(P>1){c=s,P--;continue}d=s-e,c=e}break}if(n||Math.abs(d)<r){s!==c&&(_=t.getValue(e,c));break}_=t.getValue(e,c),p=t.getValue(e+1,c);const i=h,o=l;_<0?(m=_,h=c):(u=_,l=c),2===E&&(h===i&&l===o||y>1&&Math.abs(d)>=.5001*Math.abs(g))?x++:x=0,1===E?(f++,y=0):(f=0,y++)}return 100===C&&(0,i.c)("Root_finder iterations exceeded"),a.root=c,a.funcAtRoot=_,a.cRoots=1,a}function Tt(t,e,s,n,i,r,a){const h=n.slice(0,a);let m=0;for(let o=0;o<a;o++)m+=n[o]*n[o];if(m=Math.sqrt(m),m>0)for(let o=0;o<a;o++)h[o]/=m;let l=Number.NEGATIVE_INFINITY,u=Number.POSITIVE_INFINITY;{const t=(0,o.d)(a,0);for(let e=0;e<a;e++)t[e]=e;t.sort(((t,e)=>{const s=Math.abs(h[t]),n=Math.abs(h[e]);return s<n?-1:s>n?1:0}));for(let e=0;e<a;e++){const n=t[e];if(0===h[n])continue;let a=(i[n]-s[n])/h[n],m=(r[n]-s[n])/h[n];m<a&&(m=(0,o.b)(a,a=m)),a>l&&(l=a),m<u&&(u=m)}}let c=0;const g=(Math.abs(l)+Math.abs(u))*(0,o.N)()*100,d=(0,o.d)(a,Number.NaN),_=h.slice();function p(n,i){for(let t=0,e=a;t<e;t++)d[t]=s[t]+n*_[t];return t(d,a,e)}g>0&&(c=It(p,null,l,0,u,g));const f=p(c);for(let P=0,x=a;P<x;P++)s[P]=(0,o.c)(d[P],i[P],r[P]);return f}function Nt(t,e,s,n){return t.isZero()?e.isZero()?-1:0:(n.setE(e.clone().negateThis().divThisE(t)),s.containsCoordinate(n.value())?1:0)}function At(t,e,s,n,i,r){if(0===t.value())return i?(r[0].set(1),n.containsCoordinate(r[0].value())?1:0):Nt(e,s,n,r[0]);if(i){let e=2;return r[0].set(1),r[1].setE(s).divThisE(t),r[1].eq(r[0])&&(r[1].set(1),e=1),n.containsCoordinate(r[1].value())||(e=1),n.containsCoordinate(r[0].value())||(e--,r[0].setE(r[1])),2===e&&r[0].value()>r[1].value()&&(r[1]=(0,o.b)(r[0],r[0]=r[1])),e}const a=e.clone().sqrThis().subThisE(t.clone().mulThisE(s).mulThisE(o.ac));if(a.lt(o.H))return 0;const h=new o.F(e.value()>=0?1:-1),m=a.clone().sqrtThis(),l=new o.F(-.5).mulThisE(e.clone().addThisE(h.clone().mulThisE(m)));let u=0;r[0].setE(l.divE(t));const c=new o.F(r[0].value()),g=new o.F(t.value()).mulE(c).addE(new o.F(e.value()).mulE(c).addE(new o.F(s.value())));return g.isZero()||kt(r[0],t,e,s,r[0]),n.containsCoordinate(r[0].value())&&u++,0!==m.value()&&0!==l.value()?(r[u].assign(s.divE(l)),c.set(r[u].value()),g.assign(new o.F(t.value()).mulE(c).addE(new o.F(e.value()).mulE(c).addE(new o.F(s.value())))),g.isZero()||kt(r[u],t,e,s,r[u]),n.containsCoordinate(r[u].value())&&u++,2===u&&r[0].value()>r[1].value()&&(r[1]=(0,o.b)(r[0],r[0]=r[1])),u):u}function Gt(t,e,s,n,r,a,h){if(0===t.value())return At(e,s,n,r,a,h);if(a){let s=1;h[0].set(1);const i=h.slice(s),a=At(t,e.addE(t),n.negate(),r,!1,i);if(a>0){s+=a;for(let t=1;t<s;t++)h[t].eq(o.G)&&(h[s-1]=(0,o.b)(h[t],h[t]=h[s-1]),s--)}const m=h.slice(0,s);m.sort(((t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0));for(let t=0;t<s;++t)h[t]=m[t];return s}return function(t,e,s,n,r,a){const h=(0,o.m)(o.F,3);let m=0;const l=e.negate().divThisE(t.clone().mulThis(3));r.containsCoordinate(l.value())&&(h[0].setE(l),m=1);const u=(0,o.m)(o.F,2),c=At(t.mul(3),e.mul(2),s,r,!1,u);if(c<0)return n.isZero()?-1:0;for(let i=0;i<c;i++)r.containsCoordinate(u[i].value())&&h[m++].setE(u[i]);(0,o.C)(h,0,m,((t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0));const g=(0,o.m)(o.F,5);g[0].set(r.vmin);for(let i=0;i<m;i++)g[1+i].setE(h[i]);g[1+m].set(r.vmax);const d=m+2;let _=1,p=0;{const i=g[0].clone();if(t.clone().mulThisE(i).addThisE(e).mulThisE(i).addThisE(s).mulThisE(i).addThisE(n).isZero()){const r=Ft(t,e,s,n);i.setError(r.estimateError(i.value())),a[p]=i,p++,_++}}for(let o=_;o<d;o++){const h=g[o].clone(),m=t.clone().mulThisE(h).addThisE(e).mulThisE(h).addThisE(s).mulThisE(h).addThisE(n).isZero();if(m||!g[o].eq(g[o-1])){if(m||Yt(g[o-1].value(),g[o].value(),g[o-1].clone().addThisE(g[o]).divThisByPower2(2),t,e,s,n,h)){if(p>0&&h.eq(a[p-1]))continue;if(p>=3&&(0,i.c)("cubic_polynomial_solver_too_many_roots"),m){const i=Ft(t,e,s,n);h.setError(i.estimateError(h.value()))}a[p]=h,p++}if(g[o].value()===r.vmax)break;m&&o++}}return p}(t,e,s,n,r,h)}function Mt(t,e,s,n,r,a){return(a<e||e<0)&&(0,i.t)("nth_degree_real_roots"),function(t,e,s,n,i){const r=new qt(t,e,s,(0,o.N)());let a=0;if(2===r.truePower)a=At(t[2],t[1],t[0],s,n,i);else if(1===r.truePower)a=Nt(t[1],t[0],s,i[0]);else{if(0===r.truePower)return t[0].value()?0:-1;{const t=[];t.length=e,a=Ct(r,s,e,t);for(let e=0;e<a;e++)i[e].set(t[e])}}for(let o=0;o<a;o++)i[o].setError(r.getError(i[o].value()));return a}(t,e,s,n,r)}function Ft(t,e,s,n){return{coef0:t.clone(),coef1:e.clone(),coef2:s.clone(),coef3:n.clone(),calcF(t){return this.coef0.clone().mulThis(t).addThisE(this.coef1).mulThis(t).addThisE(this.coef2).mulThis(t).addThisE(this.coef3)},calcDF(t){return this.coef0.clone().mulThis(3).mulThis(t).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(t).addThisE(this.coef2)},estimateError(t){const e=Math.abs(t),s=((this.coef0.eps()*e+this.coef1.eps())*e+this.coef2.eps())*e+this.coef3.eps()+this.calcF(t).eps(),n=this.coef0.clone().mulThis(t).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(t).addThisE(this.coef2);if(n.isZero()){const e=this.coef0.clone().mulThis(t).mulThis(6).addThisE(this.coef1.clone().mulThis(2));if(e.isZero()){const t=this.coef0.clone().mulThis(6);return Math.pow(6*s/Math.abs(t.value()),1/3)}return Math.sqrt(2*s/Math.abs(e.value()))}return s/Math.abs(n.value())}}}class qt{updateCoefs(t){if(this.lastDeriv1===t)return this.curCoefs=this.derivCoefs1,void(this.lastUsed=1);if(this.lastDeriv2===t)return this.curCoefs=this.derivCoefs2,void(this.lastUsed=2);let e;1===this.lastUsed?(e=this.derivCoefs2,this.lastDeriv2=t,this.lastUsed=2):(e=this.derivCoefs1,this.lastDeriv1=t,this.lastUsed=1),e.length=0;for(let s=0,n=this.truePower-t;s<=n;++s){e.push(this.coefs[s+t].clone());let n=s+t,i=n--;for(let e=1;e<t;e++)i*=n--;e[s].mulThis(i)}this.curCoefs=e}constructor(t,e,s,n){this.derivCoefs1=[],this.derivCoefs2=[],this.lastDeriv1=-1,this.lastDeriv2=-1,this.lastUsed=-1,this.curCoefs=null,this.coefs=t,this.power=e,this.truePower=0;for(let i=e;i>=1;i--)if(0!==this.coefs[i].value()){this.truePower=i;break}}getMaxDerivative(){return this.truePower+1}getValue(t,e){let s=this.coefs;0===t?s=this.coefs:(this.updateCoefs(t),s=this.curCoefs);const n=new o.K(0);let i=1;for(let r=0,o=this.truePower-t;r<=o;++r)n.pe(i*s[r].value()),i*=e;return n.getResult()}getError(t){const e=Math.abs(t),s=new o.K(0),n=new o.F(1),i=new o.F(0);for(let o=0,a=this.power;o<=a;++o)i.addThisE(this.coefs[o].mulE(n)),s.pe(n.value()*this.coefs[o].eps()),n.mulThis(e);s.pe(i.eps());let r=1;for(let a=1;a<=this.truePower;++a){r*=a,this.updateCoefs(a);const e=new o.F(1),n=new o.F(0);for(let s=0,i=this.truePower-a;s<=i;++s)n.addThisE(this.curCoefs[s].mulE(e)),e.mulThis(t);if(!n.isZero())return Math.pow(r*s.getResult()/Math.abs(n.value()),1/a)}return 0}}function Vt(t,e,s,n,i,r){let a=t,h=e,m=h-a;if(!r){let s=n.calcF(t).value(),i=n.calcF(e).value();if((s>0||s>i)&&(h=(0,o.b)(a,a=h),i=(0,o.b)(s,s=i)),s>=0||i<=0)return!1}let l,u=!1,c=s,g=0;for(;g<100;g++){const t=n.calcF(c);if(l=n.calcDF(c),l.isZero())return!1;if(!t.value()||g>3&&t.isZero()){u=!0;break}r||(t.value()<0?a=c:h=c);const e=t.value()/l.value(),s=c-e;r||(s>=a&&s<=h||s>=h&&s<=a)&&Math.abs(e)<=.5*m?(c=s,m=Math.abs(e)):(m=Math.abs(.5*(h-a)),c=.5*(a+h))}return!!u&&(i.set(c,n.estimateError(c)),!0)}function Yt(t,e,s,n,i,r,o,a){return Vt(t,e,s.value(),Ft(n,i,r,o),a,!1)}class Xt{constructor(t,e,s){this.coefs=(0,o.m)(o.F,3),this.coefs[0].setE(t),this.coefs[1].setE(e),this.coefs[2].setE(s)}calcF(t){const e=new o.F(t);return this.coefs[0].mulE(e).addE(this.coefs[1]).mulE(e).addE(this.coefs[2])}calcDF(t){const e=new o.F(t);return o.F.st_mulByPower2(this.coefs[0],2).mulE(e).addE(this.coefs[1])}estimateError(t){const e=Math.abs(t),s=(this.coefs[0].eps()*e+this.coefs[1].eps())*e+this.coefs[2].eps()+this.calcF(t).eps(),n=new o.F(2).mulE(this.coefs[0]).mul(t).addE(this.coefs[1]);if(n.isZero()){const t=this.coefs[0].value();return Math.sqrt(s/Math.abs(t))}return s/Math.abs(n.value())}}function kt(t,e,s,n,i){return Vt(0,0,t.value(),new Xt(e,s,n),i,!0)}var Rt=r.V;class Ht extends J{constructor(t){void 0===t||(0,o.O)(t,"vd")?(super({vd:null===t||void 0===t?void 0:t.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new o.P(0,0)):t.from?(super((0,n.A)({XStart:t.from.x,YStart:t.from.y,XEnd:t.to.x,YEnd:t.to.y},t.vd)),this.m_cp=t.cp.clone()):t.points?(super((0,n.A)({XStart:t.points[0].x,YStart:t.points[0].y,XEnd:t.points[2].x,YEnd:t.points[2].y},t.vd)),this.m_cp=t.points[1].clone()):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone()):(0,i.c)("unexpected constructor args")}getBoundary(){return ii(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}construct(t,e,s){this.setStartXY(t),this.m_cp.assign(e),this.setEndXY(s),Es(this)}constructPoints(t){this.setStartXY(t[0]),this.m_cp.assign(t[1]),this.setEndXY(t[2]),Es(this)}getGeometryType(){return i.G.enumBezier2}queryEnvelope(t){if(2!==t.m_EnvelopeType)(0,i.b)("env type not impl");else{if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=Gs(this);if(null!==e){const s=new o.P;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s)}else{const e=[];Ss(this,e);const s=new o.P;for(const n of e)this.queryCoord2D(n,s),t.mergeNe(s)}}}applyTransformation(t){if(1===t.m_TransformationType){const e=(0,o.m)(o.P,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}(0,i.g)(0)}createInstance(){return new Ht({vd:this.m_description})}calculateLength2D(){return vs(this,1,!1)}calculateLowerLength2D(){return o.P.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return o.P.distance(this.getStartXY(),this.m_cp)+o.P.distance(this.getEndXY(),this.m_cp)}queryCoord2D(t,e){this.queryCoord2DExtended(t,e,!1)}queryCoord2DExtended(t,e,s){const n=(0,o.m)(o.P,3);this.queryControlPoints(n),Zs(n,t,e,s)}queryCoord2DE(t,e){!function(t,e,s){const n=(0,o.m)(o.P,3);t.queryControlPoints(n),function(t,e,s){if(e.value()<=.5){const n=v.constructPoint2D(t[1]),i=new v;(0,o.a1)(2,v.constructPoint2D(t[0]),n,e,i);const r=new v;(0,o.a1)(2,n,v.constructPoint2D(t[2]),e,r);const a=new v;(0,o.a1)(2,i,r,e,a),s.setE(a)}else{const n=v.constructPoint2D(t[1]),i=new v;(0,o.a2)(2,v.constructPoint2D(t[0]),n,e,i);const r=new v;(0,o.a2)(2,n,v.constructPoint2D(t[2]),e,r);const a=new v;(0,o.a2)(2,i,r,e,a),s.setE(a)}}(n,e,s)}(this,t,e)}getCoordX(t){if(t<0||t>1){const e=new o.P;return this.queryCoord2DExtended(t,e,!0),e.x}if(t<=.5){const e=(0,o.Q)(this.getStartX(),this.m_cp.x,t),s=(0,o.Q)(this.m_cp.x,this.getEndX(),t);return(0,o.Q)(e,s,t)}{const e=(0,o.R)(this.getStartX(),this.m_cp.x,t),s=(0,o.R)(this.m_cp.x,this.getEndX(),t);return(0,o.R)(e,s,t)}}getCoordY(t){if(t<0||t>1){const e=new o.P;return this.queryCoord2DExtended(t,e,!0),e.y}if(t<=.5){const e=(0,o.Q)(this.getStartX(),this.m_cp.x,t),s=(0,o.Q)(this.m_cp.x,this.getEndX(),t);return(0,o.Q)(e,s,t)}{const e=(0,o.R)(this.getStartY(),this.m_cp.y,t),s=(0,o.R)(this.m_cp.y,this.getEndY(),t);return(0,o.R)(e,s,t)}}cut(t,e,s){const n=new to;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createQuadraticBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=Rt.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=Rt.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){!function(t,e,s){const n=(0,o.m)(o.P,4);t.queryControlPoints(n),function(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(function(t,e,s){{const e=v.constructPoint2D(t[1]).subE(v.constructPoint2D(t[0])),n=new o.F(1).subE(s),i=v.constructPoint2D(t[2]).subE(v.constructPoint2D(t[1])),r=e.mulE(n).addE(i.mulE(s));return r.mulThisE(new o.F(2)),r}}(t,0,e))}(n,e,s)}(this,t,e)}cutBezierIgnoreAttributes(t,e,s){if((t<0||e>1||t>e)&&(0,i.t)("Quadratic_bezier.cut_bezier_ignore_attributes"),0===t&&1===e)return s.setStartXY(this.getStartXY()),s.m_cp.assign(this.m_cp),void s.setEndXY(this.getEndXY());const n=(0,o.m)(o.P,3);this.queryControlPoints(n),Hs(n,t,e,n),s.constructPoints(n)}splitBezierIgnoreAttributes(t,e,s){(0,i.g)(0)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=Rt.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),h=this.getEndAttributeAsDbl(e,s);return(0,o.T)(r,a,h,i,Rt.getDefaultValue(e))}getClosestCoordinate(t,e){return Fs(this,t,o.E.unit(),e)}getClosestCoordinateOnInterval(t,e){return Fs(this,t,e,!1)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&(0,i.t)("");const s=Cs(this);let n=0;if(2===s.specialPointsCount())return 0;(0,i.g)(t.length>=s.specialPointsCount()-1);for(let i=1,r=s.specialPointsCount();i<r;++i)this.queryCut(s.specialPoints[i-1],s.specialPoints[i],t[n],e),n++;for(let i=0;i<n;++i)Xs(t[i].get());return n}intersectionWithAxis2D(t,e,s,n){const i=(0,o.m)(o.F,3),r=(0,o.m)(o.F,2),a=new o.E(0,1);let h=0;if(t){if(i[0]=new o.F(this.getStartY()).sub(e),i[1]=new o.F(this.m_cp.y).subE(new o.F(this.getStartY())).mulThisByPower2(2),i[2]=new o.F(this.getStartY()).add(this.getEndY()).subE(new o.F(this.m_cp.y).mulThisByPower2(2)),h=At(i[2],i[1],i[0],a,!1,r),s)for(let o=0;o<h;o++)s[o]=this.getCoordX(r[o].value())}else if(i[0]=new o.F(this.getStartX()).sub(e),i[1]=new o.F(this.m_cp.x).subE(new o.F(this.getStartX())).mulThisByPower2(2),i[2]=new o.F(this.getStartX()).add(this.getEndX()).subE(new o.F(this.m_cp.x).mulThisByPower2(2)),h=At(i[2],i[1],i[0],a,!1,r),s)for(let o=0;o<h;o++)s[o]=this.getCoordY(r[o].value());if(n)for(let o=0;o<h;o++)n[o]=r[o].value();else s&&(0,o.U)(s,h);return h}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0],n=this.intersectionWithAxis2D(!0,t,s,null);return(0,i.g)(2!==n),-1===n?e:s[0]}isCurve(){return!0}isLine(){return!1}isDegenerate(t){return D(this,t)}isDegenerate3D(t,e){return(0,i.g)(0),!1}queryLooseEnvelope(t){if(2===t.m_EnvelopeType)return t.setCoords(this.getStartXY()),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY());(0,i.g)(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=new a.Envelope2D;this.queryEnvelope(t);const s=new o.E;return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=(0,o.m)(o.P,4);this.queryControlPoints(s),Hs(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),n=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):n&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return vs(this,t,!0)}lengthToT(t){return function(t,e){const s=vs(t,1,!1);if(e<=0)return e;if(e>=s)return e-s+1;const n=[0];return 1!==Ct(new xs(t,e),o.E.unit(),1,n)&&(0,i.c)(""),n[0]}(this,t)}calculateWeightedAreaCentroid2D(t){const e=(0,o.m)(o.P,3);!function(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=(0,o.m)(o.P,3);t.queryControlPoints(n),Ws(n,e,s)}(this,e);const s=e[2],n=e[1],i=new o.P,r=s.y*n.x-s.x*n.y;i.x=-(4*s.x+5*n.x)*r/60,i.y=-(4*s.y+5*n.y)*r/60;const a=Ns(this);return i.x+=(e[0].x-t.x)*a,i.y+=(e[0].y-t.y)*a,i}calculateWeightedCentroid2D(){const t=new o.P;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){const e=o.P.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,e,s){void 0===s&&(s=e,e=0);const n=new o.P;if(e<0||s>1)return n.setNAN(),n;if(e>s&&(0,i.t)("calculate_sub_weighted_centroid"),e===s||t.isDegenerate(0))return n.setCoords(0,0),n;const r=Cs(t),a=B(t),h=Math.min(a/t.calculateUpperLength2D(),1e-7);let m=e,l=0;for(let i=1,o=r.specialPointsCount();i<o;i++)if(e<r.specialPoints[i]){l=i-1;break}n.setCoords(0,0);for(let i=l+1,o=r.specialPointsCount();i<o;i++){const e=Math.min(r.specialPoints[i],s),o=ys(t,m,e,h,a);if(n.addThis(o),m=e,s<=r.specialPoints[i])break}return n.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}setControlPoints(t){for(let e=0;e<3;e++)t[e].isNAN()&&(0,i.t)("NaN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp.setCoordsPoint2D(t[1]),this.m_XEnd=t[2].x,this.m_YEnd=t[2].y,this.afterCompletedModification()}getTangent(t){const e=(0,o.c)(t,0,1);let s=Ds(this,1,e);return s.isZero()&&(s=Ds(this,2,e),1===e&&s.negateThis()),s}getDerivative(t){return Ds(this,1,(0,o.c)(t,0,1))}getCurvature(t){const e=Ds(this,1,t),s=Ds(this,2,t),n=e.sqrLength();return 0===n?Number.NaN:(e.divThis(Math.sqrt(n)),e.crossProduct(s)/n)}isIntersecting(t,e,s){return 0!==Br(!1,this,t,e,s)}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;const n=new a.Envelope2D;if(this.queryLooseEnvelope(n),n.inflateCoords(e,e),!n.contains(t))return!1;const i=this.getClosestCoordinate(t,!1),r=new o.P;return this.queryCoord2D(i,r),o.P.distance(r,t)<=e}isIntersectingPoint3D(t,e,s,n){return(0,i.g)(0),!1}isMonotoneQuickAndDirty(){return!1}getMonotonicPartParams(t,e){const s=Cs(this),n=s.specialPointsCount();if(!e)return s.specialPointsCount();t<n&&(0,i.t)("");for(let i=0;i<n;i++)e[i]=s.specialPoints[i];return n}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){(0,o.b)(this.m_XStart,this.m_XStart=this.m_XEnd),(0,o.b)(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=(0,o.b)(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isDegenerateToLineHelper(t){const e=[t];if(!T(this,e))return!1;const s=this.getEndXY().sub(this.getStartXY()),n=s.length(),i=this.getControlPoint1();return i.sub(this.getStartXY()),!(Math.abs(i.crossProduct(s))/n>e[0])}copyIgnoreAttributes(t){const e=(0,o.m)(o.P,3);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return Ns(this)}absNorm(){return(t=this).getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp.norm(1);var t}queryEnvelopeW(t,e){const s=(0,o.m)(o.P,3);this.queryControlPoints(s),Vs(s,t,e)}setSegmentFromCoords(t,e){this.construct(t[0],this.getControlPoint1(),t[e-1])}snapControlPoints(t){return function(t,e){const s=(0,o.m)(o.P,3);t.queryControlPoints(s);const n=o.P.sqrDistance(s[1],s[0]),i=o.P.sqrDistance(s[1],s[2]);let r=s[0].clone(),a=n;n>i&&(r=s[2].clone(),a=i);let h=!1;return a<=e&&0!==a&&(h=!0,t.setControlPoint1(r)),h}(this,t)}writeInBufferStream(t,e){const s=new Float64Array(2);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(2);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_cachedValues=null}needsSnapControlPoints(t){return function(t,e){if(!e)return!1;const s=(0,o.m)(o.P,3);t.queryControlPoints(s);const n=o.P.sqrDistance(s[1],s[0]),i=o.P.sqrDistance(s[1],s[2]);s[0].clone();let r=n;return n>i&&(s[2].clone(),r=i),r<=e&&0!==r}(this,t)}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return Xs(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new h.T,a=(0,o.m)(o.P,3);a[0].setCoords(t.m_XStart,t.m_YStart),a[2].setCoords(t.m_XEnd,t.m_YEnd);const m=new o.P;m.setSub(a[2],a[0]),m.leftPerpendicularThis(),a[1].setAdd(a[0],m);const l=(0,o.m)(o.P,3);l[0].setCoordsPoint2D(e),l[2].setCoordsPoint2D(s),m.setSub(l[2],l[0]),m.leftPerpendicularThis(),l[1].setAdd(l[0],m),r.setFromTwoTriangles(a,l)?r.transformInPlace(t.m_cp):(0,o.Z)(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),i&&Xs(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),Ms(e,Gs(this))}reverseImpl(){}equalsImplTol(t,e){const s=t;return!!this.m_cp.isEqualPoint2D(s.m_cp,e)}equalsImpl(t){const e=t;return!!this.m_cp.equals(e.m_cp)}swapImpl(t){const e=t;e.m_cp=(0,o.b)(this.m_cp,this.m_cp=e.m_cp),function(t,e){e.m_cachedValues=(0,o.b)(t.m_cachedValues,t.m_cachedValues=e.m_cachedValues)}(this,e)}afterCompletedModification(){Es(this)}intersect(t,e,s,n,i){return Wr(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return function(t,e,s,n,i){const r=new E;if(function(t,e,s){const n=(0,o.m)(o.P,3);t.queryControlPoints(n),Vs(n,e,s)}(t,o.E.unit(),r),r.inflate(i),!r.isIntersectingPoint2D(e))return 0;const a=new o.P,h=Fs(t,e,o.E.unit(),!1);return t.queryCoord2D(h,a),o.P.distance(a,e)<=i?(n&&(n[0]=h),1):0}(this,t,e.length,e,s)}endPointModified(){Es(this)}clearEndPointModified(){}}Ht.type=i.G.enumBezier2;var Lt=r.V;class Bt extends J{constructor(t){var e;return void 0===t||(0,o.O)(t,"vd")?(super({vd:null===(e=t)||void 0===e?void 0:e.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new o.P(0,0),void(this.m_weights=[1,0,1])):(t.fromPoint&&t.weight?t={fromPoint:t.fromPoint,controlPoint1:t.controlPoint1,toPoint:t.toPoint,weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weight?t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weights&&(t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:t.weights[0],weight1:t.weights[1],weight2:t.weights[2]}),t.fromPoint&&t.weight0?(super({start:t.fromPoint,end:t.toPoint}),(t.weight0<=0||t.weight1<0||t.weight2<=0)&&(0,i.t)("weights"),this.m_cp=t.controlPoint1.clone(),void(this.m_weights=[t.weight0,t.weight1,t.weight2])):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone(),void(this.m_weights=t.copy.m_weights.slice())):t.move?(super(t),this.m_cp=t.move.m_cp.clone(),void(this.m_weights=t.move.m_weights.slice())):void(0,i.b)("unexpected constructor param"))}getBoundary(){return ii(this)}assignMove(t){return this}assignCopy(t){return t.copyTo(this),this}construct(t,e,s,n){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,1,n,1),we(this)}constructWeights(t,e,s,n,i,r){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,n,i,r),we(this)}constructArray(t,e){this.construct(t[0],t[1],t[2],e)}constructArrayWeights(t,e){this.dropAllAttributes(),this.setCpsAndWeightsArray(t,e),we(this)}convertToStandardForm(){}getStandardFormWeight(){return this.m_weights[1]/Math.sqrt(this.m_weights[0]*this.m_weights[2])}getGeometryType(){return i.G.enumRationalBezier2}queryEnvelope(t){if(t instanceof a.Envelope2D){if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=Re(this);if(null!==e){const s=new o.P;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s)}else{const e=[],s=(0,o.m)(o.P,3);this.queryControlPoints(s),Te(s,this.m_weights,e);const n=new o.P;for(const i of e)this.queryCoord2D(i,n),t.mergeNe(n)}}}applyTransformation(t){if(t instanceof h.T){const e=(0,o.m)(o.P,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}}createInstance(){return new Bt({vd:this.m_description})}calculateLength2D(){return Ne(this,1,!1)}calculateLowerLength2D(){return o.P.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return this.m_weights[1]>0?o.P.distance(this.getStartXY(),this.m_cp)+o.P.distance(this.getEndXY(),this.m_cp):o.P.distance(this.getStartXY(),this.getEndXY())}queryCoord2D(t,e){return this.queryCoord2DExtension(t,e,!0)}queryCoord2DE(t,e){!function(t,e,s){const n=(0,o.m)(o.P,3);t.queryControlPoints(n);const i=[0,0,0];t.queryWeights(i),function(t,e,s,n){if(0===s.value())return void n.setE(t[0]);if(1===s.value())return void n.setE(t[2]);const i=[t[0].x.mulE(e[0]),t[1].x.mulE(e[1]),t[2].x.mulE(e[2])],r=[t[0].y.mulE(e[0]),t[1].y.mulE(e[1]),t[2].y.mulE(e[2])],a=[e[0].clone(),e[1].clone(),e[2].clone()],h=new o.F,m=new o.F,l=new o.F;if(s.value()<=.5){const t=(0,o._)(i[0],i[1],s),e=(0,o._)(i[1],i[2],s);h.setE((0,o._)(t,e,s));const n=(0,o._)(r[0],r[1],s),u=(0,o._)(r[1],r[2],s);m.setE((0,o._)(n,u,s));const c=(0,o._)(a[0],a[1],s),g=(0,o._)(a[1],a[2],s);l.setE((0,o._)(c,g,s))}else{const t=(0,o.$)(i[0],i[1],s),e=(0,o.$)(i[1],i[2],s);h.setE((0,o.$)(t,e,s));const n=(0,o.$)(r[0],r[1],s),u=(0,o.$)(r[1],r[2],s);m.setE((0,o.$)(n,u,s));const c=(0,o.$)(a[0],a[1],s),g=(0,o.$)(a[1],a[2],s);l.setE((0,o.$)(c,g,s))}h.divThisE(l),m.divThisE(l);const u=new o.P(h.value(),m.value());ps([t[0].value(),t[1].value(),t[2].value()],u),n.x.set(u.x,h.eps()),n.y.set(u.y,m.eps())}([v.constructPoint2D(n[0]),v.constructPoint2D(n[1]),v.constructPoint2D(n[2])],[new o.F(i[0]),new o.F(i[1]),new o.F(i[2])],e,s)}(this,t,e)}queryCoord2DExtension(t,e,s){if(s){if(t<0)return void tt(new $r({start:this.getStartXY(),end:this.getStartXY().add(this.getTangent(0).getUnitVector())}),t,e);if(t>1)return void tt(new $r({start:this.getEndXY(),end:this.getEndXY().add(this.getTangent(1).getUnitVector())}),t-1,e)}const n=(0,o.m)(o.P,3);this.queryControlPoints(n),ms(n,this.m_weights,t,e)}getCoordX(t){const e=new o.P;return this.queryCoord2DExtension(t,e,!0),e.x}getCoordY(t){const e=new o.P;return this.queryCoord2DExtension(t,e,!0),e.y}cut(t,e,s){const n=new to;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createQuadraticRationalBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=Lt.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=Lt.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){!function(t,e,s){const n=(0,o.m)(o.P,3);t.queryControlPoints(n);const r=(0,o.d)(3,Number.NaN);t.queryWeights(r),function(t,e,s,n){s.value()<0&&s.set(0,s.eps()),s.value()>1&&s.set(1,s.eps());const r=(0,o.m)(v,4);(function(t,e,s,n,r){const a=[v.constructPoint2D(t[0]),v.constructPoint2D(t[1]),v.constructPoint2D(t[2])];a[2].subThisE(a[0]),a[1].subThisE(a[0]),a[0].setCoords(0,0),function(t,e,s,n,r){(0,i.g)(s>0);const a=[t[0].clone(),t[1].clone(),t[2].clone()];if(!a[0].isZero()){for(let t=1;t<3;++t)a[t].subThisE(a[0]);a[0]=v.constructCoords(0,0)}const h=Fe(a,e,0,n),m=function(t,e,s){if(s.toDouble()<=.5){const e=(0,o._)(t[0],t[1],s),n=(0,o._)(t[1],t[2],s);return(0,o._)(e,n,s)}{const e=(0,o.$)(t[0],t[1],s),n=(0,o.$)(t[1],t[2],s);return(0,o.$)(e,n,s)}}(e,0,n),l=h.divE(m);r[0].setE(l);const u=[e[1].mulE(e[0]),e[2].mulE(e[0]).mul(.5),e[1].mulE(e[2])],c=Fe([t[1].subE(t[0]),t[2].subE(t[0]),t[2].subE(t[1])],u,0,n).mul(2),g=m.sqr(),d=c.divE(g);r[1].setE(d)}(a,[new o.F(e[0]),new o.F(e[1]),new o.F(e[2])],s,n,r)})(t,e,1,s,r),n.setE(r[1])}(n,r,e,s)}(this,t,e)}cutBezierIgnoreAttributes(t,e,s){(t<0||e>1||t>e)&&(0,i.t)("Quadratic_rational_bezier.cut_bezier_ignore_attributes");const n=(0,o.m)(o.P,3);this.queryControlPoints(n);const r=[0,0,0];Qe(n,this.m_weights,t,e,n,r),s.setControlPointsAndWeights(n,r)}splitBezierIgnoreAttributes(t,e,s){}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=Lt.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),h=this.getEndAttributeAsDbl(e,s);return(0,o.T)(r,a,h,i,Lt.getDefaultValue(e))}getClosestCoordinate(t,e){return Le(this,t,o.E.unit(),e,-1)}getClosestCoordinateOnInterval(t,e){return Le(this,t,e,!1,arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&(0,i.t)("");const s=De(this);let n=0;if(2===s.specialPointsCount())return 0;(0,i.g)(t.length>=s.specialPointsCount()-1);for(let i=1,r=s.specialPointsCount();i<r;++i)this.queryCut(s.specialPoints[i-1],s.specialPoints[i],t[n],e),n++;for(let i=0;i<n;++i)We(t[i].get());return n}intersectionWithAxis2D(t,e,s,n){s&&(s.length=9),n&&(n.length=9);const i=new Array(3),r=(0,o.m)(o.F,2),a=new o.E(0,1);let h=0;const m=(0,o.m)(o.P,3);if(this.queryControlPoints(m),t){if(i[0]=new o.F(m[0].y).sub(e).mul(this.m_weights[0]),i[1]=new o.F(m[1].y).sub(e).mul(this.m_weights[1]),i[2]=i[0].subE(i[1].mul(2)).addE(new o.F(m[2].y).sub(e).mul(this.m_weights[2])),i[1]=i[1].subE(i[0]).mulThisByPower2(2),h=At(i[2],i[1],i[0],a,!1,r),s)for(let o=0;o<h;o++)s[o]=this.getCoordX(r[o].value())}else if(i[0]=new o.F(m[0].x).sub(e).mul(this.m_weights[0]),i[1]=new o.F(m[1].x).sub(e).mul(this.m_weights[1]),i[2]=i[0].subE(i[1].mul(2)).addE(new o.F(m[2].x).sub(e).mul(this.m_weights[2])),i[1]=i[1].subE(i[0]).mulThisByPower2(2),h=At(i[2],i[1],i[0],a,!1,r),s)for(let o=0;o<h;o++)s[o]=this.getCoordY(r[o].value());if(n)for(let o=0;o<h;o++)n[o]=r[o].value();else s&&(0,o.C)(s,0,h,o.X);return h}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[Number.NaN,Number.NaN],n=this.intersectionWithAxis2D(!0,t,s,null);return(0,i.g)(2!==n),-1===n?e:s[0]}isCurve(){return!0}isDegenerate(t){return D(this,t)}isDegenerate3D(t,e){return!1}queryLooseEnvelope(t){if(t instanceof a.Envelope2D)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY())}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=a.Envelope2D.constructEmpty();this.queryEnvelope(t);const s=o.E.constructEmpty();return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=(0,o.m)(o.P,3);this.queryControlPoints(s);Qe(s,this.m_weights,t.vmin,t.vmax,s,[0,0,0]),e.setFromPoints(s,3)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),n=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):n&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return Ne(this,t,!0)}lengthToT(t){return function(t,e){const s=Ne(t,1,!1);if(e<=0)return e;if(e>=s)return e-s+1;const n=[0];return 1!==Ct(new Ye(t,e),o.E.unit(),1,n)&&(0,i.c)(""),n[0]}(this,t)}calculateWeightedAreaCentroid2D(t){const e=function(t){const e=(0,o.m)(o.P,3),s=[0,0,0];return t.queryControlPoints(e),t.queryWeights(s),function(t,e){const s=us(e);if(1===s){const e=(0,o.m)(o.P,3);Ws(t,e);const s=e[2].clone(),n=e[1].clone(),i=new o.P,r=s.y*n.x-s.x*n.y;return i.x=-(4*s.x+5*n.x)*r/60,i.y=-(4*s.y+5*n.y)*r/60,i}if(0===s)return new o.P(0,0);(0,i.g)(s>0);const n=t[1].sub(t[0]),r=t[2].sub(t[0]);if(s<1){const t=Math.sqrt(1-s),e=Math.sqrt(1+s),i=(n.y*r.x-n.x*r.y)*s/Math.pow(t*e,5)/12,o=Math.atan2(t,e),a=s*t*e,h=s*s,m=n.mul(2*(2+h)),l=r.mul(2*h-5),u=m.add(l).mul(a),c=r.sub(n.mul(2*h)).mul(6*o);return u.add(c).mul(i)}{const t=Math.sqrt(s-1),e=Math.sqrt(s+1),i=(n.y*r.x-n.x*r.y)*s/Math.pow(t*e,5)/12,o=Math.atanh(t/e),a=s*t*e,h=s*s,m=n.mul(4).sub(r.mul(5)),l=n.add(r).mul(2*h),u=m.add(l).mul(a),c=r.sub(n.mul(2*h)).mul(6*o);return u.add(c).mul(i)}}(e,s)}(this),s=Xe(this);return e.x+=(this.getStartX()-t.x)*s,e.y+=(this.getStartY()-t.y)*s,e}calculateWeightedCentroid2D(){const t=new o.P;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){if(0===t.m_weights[1])return!0;const e=o.P.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,e,s){void 0===s&&(s=e,e=0);const n=new o.P;if(e<0||s>1)return n.setNAN(),n;if(e>s&&(0,i.t)("calculate_sub_weighted_centroid"),e===s||t.isDegenerate(0))return n.setCoords(0,0),n;const r=De(t),a=ke(t),h=a/t.calculateUpperLength2D();let m=e,l=0;for(let i=1,o=r.specialPointsCount();i<o;i++)if(e<r.specialPoints[i]){l=i-1;break}n.setCoords(0,0);for(let i=l+1,o=r.specialPointsCount();i<o;i++){const e=Math.min(r.specialPoints[i],s),o=Ie(t,m,e,h,a);if(n.addThis(o),m=e,s<=r.specialPoints[i])break}return n.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryWeights(t){for(let e=0;e<3;++e)t[e]=this.m_weights[e]}setWeights(t){}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}setControlPointsAndWeights(t,e){this.setCpsAndWeightsArray(t,e),this.afterCompletedModification()}getTangent(t){const e=(0,o.m)(o.P,3);return this.queryControlPoints(e),Ve(e,this.m_weights,t)}getDerivative(t){const e=(0,o.c)(t,0,1),s=(0,o.m)(o.P,4);return Ae(this,1,e,s),s[1]}getCurvature(t){const e=(0,o.m)(o.P,4);Ae(this,2,t,e);const s=e[1].sqrLength();return 0===s?Number.NaN:(e[1].divThis(Math.sqrt(s)),e[1].crossProduct(e[2])/s)}isIntersecting(t,e,s){return!1}isIntersectingPoint(t,e,s){return!1}isIntersectingPoint3D(t,e,s,n){return!1}isMonotoneQuickAndDirty(){const t=(0,o.m)(o.P,3);return this.queryControlPoints(t),Oe(t)}getMonotonicPartParams(t,e){const s=De(this),n=s.specialPointsCount();if(!e)return s.specialPointsCount();t<n&&(0,i.t)("");for(let i=0;i<n;i++)e[i]=s.specialPoints[i];return n}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=(0,o.b)(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=(0,o.b)(this.m_YStart,this.m_YStart=this.m_YEnd),this.m_weights[2]=(0,o.b)(this.m_weights[0],this.m_weights[0]=this.m_weights[2]);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=(0,o.b)(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isLine(){return!1}isDegenerateToLineHelper(t){const e=[t];return!!T(this,e)&&function(t,e){const s=t.getEndXY().sub(t.getStartXY()),n=s.length(),i=t.getControlPoint1();return i.subThis(t.getStartXY()),!(Math.abs(i.crossProduct(s))/n>e)}(this,e[0])}copyIgnoreAttributes(t){const e=(0,o.m)(o.P,3);this.queryControlPoints(e);const s=[0,0,0];this.queryWeights(s),t.setControlPointsAndWeights(e,s)}calculateArea2DHelper(){return Xe(this)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)+this.m_cp.norm(1)}absNormXYZ(t){return(0,i.g)(0),0}queryEnvelopeW(t,e){Ue(this,t,e)}setSegmentFromCoords(t,e){const s=[0,0,0];this.queryWeights(s),this.constructWeights(t[0],this.getControlPoint1(),t[e-1],s[0],s[1],s[2])}writeInBufferStream(t,e){const s=new Float64Array(5);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,s[2]=this.m_weights[0],s[3]=this.m_weights[1],s[4]=this.m_weights[2],t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(5);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_weights[0]=s[2],this.m_weights[1]=s[3],this.m_weights[2]=s[4],this.m_cachedValues=null}snapControlPoints(t){const e=(0,o.m)(o.P,3);this.queryControlPoints(e);const s=o.P.sqrDistance(e[1],e[0]),n=o.P.sqrDistance(e[1],e[2]);let i=e[0].clone(),r=s;s>n&&(i=e[2].clone(),r=n);let a=!1;return r<=t&&0!==r&&(a=!0,this.setControlPoint1(i)),a}needsSnapControlPoints(t){if(!t)return!1;const e=(0,o.m)(o.P,3);this.queryControlPoints(e);const s=o.P.sqrDistance(e[1],e[0]),n=o.P.sqrDistance(e[1],e[2]);e[0].clone();let i=s;return s>n&&(e[2].clone(),i=n),i<=t&&0!==i}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return We(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new h.T,a=(0,o.m)(o.P,3);a[0].setCoords(t.m_XStart,t.m_YStart),a[2].setCoords(t.m_XEnd,t.m_YEnd);const m=new o.P;m.setSub(a[2],a[0]),m.leftPerpendicularThis(),a[1].setAdd(a[0],m);const l=(0,o.m)(o.P,3);l[0].setCoordsPoint2D(e),l[2].setCoordsPoint2D(s),m.setSub(l[2],l[0]),m.leftPerpendicularThis(),l[1].setAdd(l[0],m),r.setFromTwoTriangles(a,l)?r.transformInPlace(t.m_cp):(0,o.Z)(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),i&&We(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),e.m_weights[0]=this.m_weights[0],e.m_weights[1]=this.m_weights[1],e.m_weights[2]=this.m_weights[2],He(e,Re(this))}reverseImpl(){this.m_weights[2]=(0,o.b)(this.m_weights[0],this.m_weights[0]=this.m_weights[2])}equalsImpl(t){const e=t;if(!this.m_cp.equals(e.m_cp))return!1;for(let s=0;s<3;s++)if(this.m_weights[s]!==e.m_weights[s])return!1;return!0}equalsImplTol(t,e){const s=t;if(!this.m_cp.isEqualPoint2D(s.m_cp,e))return!1;const n=(0,o.m)(o.P,3);this.queryControlPoints(n);const i=(0,o.m)(o.P,3);s.queryControlPoints(i);const a=[s.m_weights[0],s.m_weights[1],s.m_weights[2]];for(let o=0;o<3;o++){const t=new r.h;t.setCoordsPoint2DZ(n[o].mul(this.m_weights[o]),this.m_weights[o]);const s=new r.h;if(s.setCoordsPoint2DZ(i[o].mul(a[o]),a[o]),!t.isEqual(s,e))return!1}return!0}swapImpl(t){const e=t;e.m_cp=(0,o.b)(this.m_cp,this.m_cp=e.m_cp),e.m_weights=(0,o.b)(this.m_weights,this.m_weights=e.m_weights),function(t,e){e.m_cachedValues=(0,o.b)(t.m_cachedValues,t.m_cachedValues=e.m_cachedValues)}(this,e)}afterCompletedModification(){we(this)}intersect(t,e,s,n,i){return Wr(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return function(t,e,s,n){const r=new E;if(Ue(t,o.E.unit(),r),r.inflate(n),!r.isIntersectingPoint2D(e))return 0;const a=De(t);let h=0;const m=[];let l=a.specialPoints[0];for(let o=1,u=a.specialPoints.length;o<u;++o){const s=a.specialPoints[o],n=be(t,e,l,s);if(0===m.length)m.push(n);else if(n.t===n.tmin)(0,i.g)(m.at(-1).d<=n.d),m.at(-1).tmax=n.tmax;else if(m.at(-1).t===m.at(-1).tmax){(0,i.g)(m.at(-1).d>=n.d);const t=m.at(-1).tmin;m[m.length-1]=n,m.at(-1).tmin=t}else m.push(n);l=s}for(const i of m)if(i.d<=n){const t=i.t;s?(s[h]=t,h++):h++}return h}(this,t,e,s)}endPointModified(){we(this)}clearEndPointModified(){}setCpsAndWeights(t,e,s,n,r,o){(n<=0||o<=0||r<0)&&(0,i.t)("weights"),(t.isNAN()||e.isNAN()||s.isNAN())&&(0,i.t)("NAN control points in bezier are not supported"),this.setStartXY(t),this.m_cp.assign(e),this.m_weights[0]=n,this.m_weights[1]=r,this.m_weights[2]=o,this.setEndXY(s)}setCpsAndWeightsArray(t,e){this.setCpsAndWeights(t[0],t[1],t[2],e[0],e[1],e[2])}}Bt.type=i.G.enumRationalBezier2;class Ut{static constructPoint2D(t){return new Ut(o.M.constructDouble(t.x),o.M.constructDouble(t.y))}constructor(t,e){if(void 0===t)return this.x=(new o.M).setNAN(),void(this.y=(new o.M).setNAN());this.x=t.clone(),this.y=e.clone()}assignPoint2D(t){return this.x.setDouble(t.x),this.y.setDouble(t.y),this}setCoords(t,e){return this.x.setThis(t),this.y.setThis(e),this}asPoint2D(){return new o.P(this.x.value(),this.y.value())}crossProduct(t){return this.x.mul(t.y).sub(this.y.mul(t.x))}leftPerpendicularThis(){const t=this.x.clone();this.x=this.y.clone().negate(),this.y=t}clone(){return new Ut(this.x,this.y)}dotProduct(t){return this.x.mul(t.x).add(this.y.mul(t.y))}add(t){return new Ut(this.x.add(t.x),this.y.add(t.y))}sub(t){return new Ut(this.x.sub(t.x),this.y.sub(t.y))}sqrLength(){return this.x.sqr().addThis(this.y.sqr())}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mul(t){return this.clone().mulThis(t)}}class zt{constructor(t){return t.coefsT?(this.m_zeroCtor=t.zeroCtor,this.m_elements=t.coefsT.map((t=>t.clone())),(0,i.g)(this.m_elements.length===t.power+1),void this.updatePower()):t.coef0?(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[t.coef0.clone()])):t.copy?(this.m_zeroCtor=t.copy.m_zeroCtor,void(this.m_elements=t.copy.m_elements.map((t=>t.clone())))):(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[new this.m_zeroCtor]))}construct(t,e){return this.m_elements=t.map((t=>t.clone())),this.updatePower(),this}construct0(t){return this.m_elements.length=0,this.m_elements.push(t.clone()),this.updatePower(),this}assignCopy(t){return this.m_elements=t.m_elements.map((t=>t.clone())),this.updatePower(),this}assignMove(t){return this.m_elements=t.m_elements,t.m_elements=[],this.updatePower(),this}power(){return this.m_elements.length-1}addElement(t){this.m_elements.push(t.clone())}fmSubThis(t,e){return(0,i.g)(0),this}addThis(t){const e=Math.min(this.power(),t.power());for(let n=0;n<=e;++n)this.m_elements[n].addThis(t.m_elements[n]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n];return this.updatePower(),this}add0(t){return this.m_elements[0].addThis(t),this.updatePower(),this}addNumber0(t){return(0,i.g)(0),this}sub(t){const e=Math.min(this.power(),t.power());for(let n=0;n<=e;++n)this.m_elements[n].subThis(t.m_elements[n]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n].clone(),this.m_elements[n].negateThis();return this.updatePower(),this}sub0(t){return(0,i.g)(0),this}subNumber0(t){return(0,i.g)(0),this}subShifted(t,e){const s=this.power(),n=t.power()+e,i=Math.min(this.power(),n);let r=0;for(let o=e;o<=i;++o)this.m_elements[o].subThis(t.m_elements[r]),r++;if(n<=s)return this.updatePower(),this;this.m_elements.length=n+1;for(let o=s+1;o<this.m_elements.length;++o)this.m_elements[o]=new this.m_zeroCtor;for(let o=i+1;o<=n;++o)this.m_elements[o].subThis(t.m_elements[r++]);return this.updatePower(),this}subShiftedWithCoef(t,e,s){const n=this.power(),i=t.power()+s,r=Math.min(this.power(),i);let o=0;for(let a=s;a<=r;++a)this.m_elements[a].fmSubThis(t.m_elements[o],e),o++;if(i<=n)return this.updatePower(),this;this.m_elements.length=i+1;for(let a=n+1;a<this.m_elements.length;++a)this.m_elements[a]=new this.m_zeroCtor;for(let a=r+1;a<=i;++a)this.m_elements[a].fmSubThis(t.m_elements[o++],e);return this.updatePower(),this}mulThis(t){if(this.constructor===t.constructor){const e=t,s=[];for(let t=0,n=this.power();t<=n;t++)for(let i=0,r=e.power();i<=r;i++){const n=this.m_elements[t].clone();n.mulThis(e.m_elements[i]),t+i<s.length?s[t+i].addThis(n):s.push(n)}this.m_elements=s}else for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulElementThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulNumber0(t){return(0,i.g)(0),this}mulBigint0(t){return(0,i.g)(0),this}mulBigIntThis(t){return(0,i.g)(0),this}mulInt320(t){return(0,i.g)(0),this}div0(t){return(0,i.g)(0),this}absThis(){return(0,i.g)(0),this}div(t,e,s){if(this.power()<t.power())return s.assignCopy(this),void e.setZero();s.setZero(),e.setZero();const n=t.getElement(t.power()),i=this.clone();let r=i.power();const a=i.power()-t.power();let h=a;for(e.m_elements=(0,o.m)(e.m_zeroCtor,a+1);;){if(r<t.power()){s.assignMove(i);break}if(r===i.power()){const s=i.getElement(i.power());s.divThis(n),i.subShiftedWithCoef(t,s,i.power()-t.power()),e.m_elements[h]=s.clone()}h--,r--}s.updatePower(),e.updatePower()}divThis(t){return(0,i.g)(0),this}subThis(t){const e=Math.min(this.power(),t.power());for(let n=0;n<=e;++n)this.m_elements[n].subThis(t.m_elements[n]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n].clone(),this.m_elements[n].negateThis();return this.updatePower(),this}sub0This(t){return this.m_elements[0].subThis(t),this.updatePower(),this}subFrom(t,e){(0,i.g)(0)}isZero(){return 0===this.power()&&this.m_elements[0].isZero()}negateThis(){for(let t=this.m_elements.length-1;t>=0;t--)this.m_elements[t].negateThis();return this}getElement(t){return this.m_elements[t].clone()}setElement(t,e){return this.m_elements[t]=e.clone(),this}evaluate(t){const e=this.power(),s=this.m_elements[e].clone();for(let n=e-1;n>=0;--n)s.mulThis(t),s.addThis(this.m_elements[n]);return s}equals(t){if(this===t)return!0;if(this.power()!==t.power())return!1;for(let e=this.m_elements.length-1;e>=0;e--)if(!this.m_elements[e].equals(t.m_elements[e]))return!1;return!0}updatePower(){for(let t=this.m_elements.length-1;t>0&&this.m_elements[t].isZero();t--)this.m_elements.pop();return this}setZero(){return this.m_elements.length=1,this.m_elements[0]=new this.m_zeroCtor,this.updatePower(),this}derivative(t){if(this.power()<t)return this.clone().setZero();if(0===t)return this.clone();const e=new this.constructor({coefsT:this.m_elements.slice(t),power:this.power()-t});for(let s=t,n=this.power();s<=n;s++){let n=BigInt(s);for(let e=s-1,i=s-t;e>i;--e)n*=BigInt(e);e.m_elements[s-t].mulBigIntThis(n)}return e.updatePower(),e}derivative1This(){if(this.m_elements.length>1){this.m_elements=this.m_elements.slice(1);for(let t=1,e=this.power();t<=e;t++)this.m_elements[t].mulThis(o.M.constructInt32(t+1))}else this.m_elements.length=0,this.m_elements.push(new this.m_zeroCtor);return this}limitPrecisionThis(t){for(let e=this.power();e>=0;--e)this.m_elements[e].limitPrecisionThis(t);return this.updatePower(),this}hiBitIndex(){return this.m_elements.reduce(((t,e)=>{const s=e.hiBitIndex();return t<s?s:t}),0)}shiftRight(t){return this.m_elements.splice(0,t),this.updatePower(),this}static evaluateCoefs(t,e,s){const n=t.power();s.construct0(t.getElement(0).evaluate(e));for(let i=1;i<=n;++i)s.addElement(t.getElement(i).evaluate(e));s.updatePower()}}class Ot extends zt{constructor(t){super(void 0===t?{zeroCtor:o.M}:(0,n.A)((0,n.A)({},t),{},{zeroCtor:o.M}))}clone(){return new Ot({copy:this})}absEvaluate(t){const e=this.power(),s=this.m_elements[e].clone();s.absThis();const n=t.clone();n.absThis();for(let i=e-1;i>=0;--i)s.mulThis(n),s.addThis(this.m_elements[i].abs());return s}}class Wt extends zt{constructor(t){super(void 0===t?{zeroCtor:Ot}:(0,n.A)((0,n.A)({},t),{},{zeroCtor:Ot}))}clone(){return new Wt({copy:this})}constructFromMPValues(t,e){this.m_elements.length=0;for(let s=0;s<=e;++s)this.m_elements.push(new Ot({coef0:t[s]}));return this.updatePower(),this}}function jt(t,e,s,n,r,a,h,m,l,u,c,g,d,_,p,f,P){let x=arguments.length>17&&void 0!==arguments[17]&&arguments[17];const y={polypoly1:new Wt,polypoly2:new Wt,polyX2:new Ot,polyY2:new Ot,polyX2Deriv:new Ot,polyY2Deriv:new Ot,polypolyX1:new Wt,polypolyY1:new Wt,polypolyX1Deriv:new Wt,polypolyY1Deriv:new Wt,lazyPolypolyD1:new Wt,lazyPolypolyD1Deriv:new Wt,lazyPolyD2:new Ot,lazyPolyD2Deriv:null,polypoly11:new Wt,polypoly12:new Wt,tempPp:new Wt,tempPp1:new Wt,tempPp2:new Wt,tempP:new Ot,tempP1:new Ot,tempP2:new Ot};y.polyX2.construct(h,m),y.polyY2.construct(l,u),y.polypolyX1.constructFromMPValues(t,e),y.polypolyY1.constructFromMPValues(s,n),y.polypoly11.assignCopy(y.polypolyX1),y.polypoly12.assignCopy(y.polypolyY1),c&&(y.lazyPolyD2.construct(c,g),y.polypoly11.mulElementThis(y.lazyPolyD2),y.polypoly12.mulElementThis(y.lazyPolyD2)),r?(y.lazyPolypolyD1.constructFromMPValues(r,a),y.lazyPolypolyD1Deriv=new Wt({copy:y.lazyPolypolyD1}),y.lazyPolypolyD1Deriv.derivative1This(),y.tempPp.assignCopy(y.lazyPolypolyD1),y.tempPp.mulElementThis(y.polyX2),y.polypoly11.subThis(y.tempPp),y.tempPp.assignCopy(y.lazyPolypolyD1),y.tempPp.mulElementThis(y.polyY2),y.polypoly12.subThis(y.tempPp)):(y.polypoly11.sub0This(y.polyX2),y.polypoly12.sub0This(y.polyY2)),y.polypolyX1Deriv.assignCopy(y.polypolyX1),y.polypolyX1Deriv.derivative1This(),y.polypolyY1Deriv.assignCopy(y.polypolyY1),y.polypolyY1Deriv.derivative1This(),r&&(y.polypolyX1Deriv.mulThis(y.lazyPolypolyD1),y.tempPp2.assignCopy(y.lazyPolypolyD1Deriv),y.tempPp2.mulThis(y.polypolyX1),y.polypolyX1Deriv.subThis(y.tempPp2),y.polypolyY1Deriv.mulThis(y.lazyPolypolyD1),y.tempPp2.assignCopy(y.lazyPolypolyD1Deriv),y.tempPp2.mulThis(y.polypolyY1),y.polypolyY1Deriv.subThis(y.tempPp2)),y.polyX2Deriv.assignCopy(y.polyX2),y.polyX2Deriv.derivative1This(),y.polyY2Deriv.assignCopy(y.polyY2),y.polyY2Deriv.derivative1This(),c&&((0,i.g)(null===y.lazyPolyD2Deriv),y.lazyPolyD2Deriv=new Ot({copy:y.lazyPolyD2}),y.lazyPolyD2Deriv.derivative1This(),y.polyX2Deriv.mulThis(y.lazyPolyD2),y.tempP1.assignCopy(y.lazyPolyD2Deriv),y.tempP1.mulThis(y.polyX2),y.polyX2Deriv.subThis(y.tempP1),y.polyY2Deriv.mulThis(y.lazyPolyD2),y.tempP1.assignCopy(y.lazyPolyD2Deriv),y.tempP1.mulThis(y.polyY2),y.polyY2Deriv.subThis(y.tempP1)),y.polypoly1.assignCopy(y.polypoly11),y.polypoly1.mulElementThis(y.polyX2Deriv),y.tempPp.assignCopy(y.polypoly12),y.tempPp.mulElementThis(y.polyY2Deriv),y.polypoly1.addThis(y.tempPp),y.polypoly2.assignCopy(y.polypolyX1Deriv),y.polypoly2.mulElementThis(y.polyY2Deriv),y.tempPp.assignCopy(y.polypolyY1Deriv),y.tempPp.mulElementThis(y.polyX2Deriv),y.polypoly2.subThis(y.tempPp);let E=[];const C=[];P||(P=[]),f||(f=[]),se(y.polypoly11,y.polypoly12,y.tempP);let S=57,v=.25*Number.EPSILON;const b=[];let I=ne(y.tempP,d,p,v,S,b);if(I<0)return-1;for(let N=0;N<I;N++){Ot.evaluateCoefs(y.polypoly11,o.M.constructDouble(b[N]),y.tempP1);const t=[];let e=ne(y.tempP1,d,_,v,S,t);if(0!==e)if(Ot.evaluateCoefs(y.polypoly12,o.M.constructDouble(b[N]),y.tempP2),e<0){e=ne(y.tempP2,d,_,v,S,t),e<0&&(0,i.c)("mp_curve_proximity");for(let s=0;s<e;s++)C.push((0,o.n)(t[s],b[N]))}else{const s=y.tempP2.absEvaluate(o.ae);s.mulThis(o.M.constructDouble(1e-12));for(let n=0;n<e;n++){const e=y.tempP2.evaluate(o.M.constructDouble(t[n]));e.absThis(),e.lt(s)&&C.push((0,o.n)(t[n],b[N]))}}}I=C.length,se(y.polypoly1,y.polypoly2,y.tempP),S=57,v=.25*Number.EPSILON;const w=[];let D=ne(y.tempP,d,p,v,S,w);D<0&&(D=0);for(let i=0;i<D;i++){Ot.evaluateCoefs(y.polypoly1,o.M.constructDouble(w[i]),y.tempP1);const t=[];let e=ne(y.tempP1,d,_,v,S,t);if(0!==e)if(Ot.evaluateCoefs(y.polypoly2,o.M.constructDouble(w[i]),y.tempP2),e<0){if(e=ne(y.tempP2,d,_,v,S,t),e<0)continue;for(let s=0;s<e;s++)E.push((0,o.n)(t[s],w[i]))}else{const s=y.tempP2.absEvaluate(o.ae);s.mulThis(o.M.constructDouble(1e-12));for(let n=0;n<e;n++){const e=y.tempP2.evaluate(o.M.constructDouble(t[n]));e.absThis(),e.lt(s)&&E.push((0,o.n)(t[n],w[i]))}}}if(D=E.length,0===I&&0===D)return 0;E=E.concat(C),E.sort(((t,e)=>x?(0,o.X)(t.second,e.second):(0,o.X)(t.first,e.first)));const T=(0,o.u)(E,((t,e)=>t.first===e.first&&t.second===e.second));E=E.slice(0,T),f.length=0,P.length=0;for(const i of E)f.push(i.first),P.push(i.second);return(0,i.g)(f.length===P.length),P.length}function Zt(t,e,s,n,i,r,a,h,m,l,u){const c={polyIntersect:new Ot,polyX1:new Ot,polyY1:new Ot,polyX1Deriv:new Ot,polyY1Deriv:new Ot,lazyPolyD1:new Ot,lazyPolyD1Deriv:new Ot,tempP:new Ot,tempP1:new Ot,tempP2:new Ot,polypoly1Proximity:new Wt,polypoly2Proximity:new Wt};c.polyX1.construct(t,e),c.polyY1.construct(s,n),c.polyX1Deriv.assignCopy(c.polyX1),c.polyX1Deriv.derivative1This(),c.polyY1Deriv.assignCopy(c.polyY1),c.polyY1Deriv.derivative1This(),c.polyIntersect.assignCopy(c.polyX1),c.polyIntersect.mulThis(c.polyX1),c.polyIntersect.mulElementThis(a[0]),c.tempP.assignCopy(c.polyY1),c.tempP.mulThis(c.polyY1),c.tempP.mulElementThis(a[1]),c.polyIntersect.addThis(c.tempP),i?(c.lazyPolyD1.construct(i,r),c.tempP.assignCopy(c.lazyPolyD1),c.tempP.mulThis(c.lazyPolyD1),c.tempP.mulElementThis(a[2]),c.polyIntersect.addThis(c.tempP)):c.polyIntersect.add0(a[2]);{const i=a[0].clone(),r=i.clone();r.sqrThis();const h=a[1].clone(),m=h.clone();m.sqrThis();const l=a[2].clone(),u=i.clone();u.subThis(h),c.polyX1.construct(t,e),c.polyX1Deriv.assignCopy(c.polyX1),c.polyX1Deriv.derivative1This(),c.polyY1.construct(s,n),c.polyY1Deriv.assignCopy(c.polyY1),c.polyY1Deriv.derivative1This(),c.tempP.assignCopy(c.polyX1),c.tempP.mulThis(c.polyX1),c.tempP.mulElementThis(m),c.tempP.mulElementThis(l),c.polypoly1Proximity.construct0(c.tempP),c.tempP.assignCopy(c.polyX1),c.tempP.mulThis(h.mul(u).mul(l).ldexpThis(1)),c.polypoly1Proximity.addElement(c.tempP),c.tempP.assignCopy(c.polyX1),c.tempP.mulThis(c.polyX1),c.tempP.mulElementThis(i.mul(m)),c.tempP1.assignCopy(c.polyY1),c.tempP1.mulThis(c.polyY1),c.tempP1.mulElementThis(r.mul(h)),c.tempP.addThis(c.tempP1),c.tempP.add0(u.mul(u).mul(l)),c.polypoly1Proximity.addElement(c.tempP),c.tempP.assignCopy(c.polyX1),c.tempP.mulElementThis(u.mul(i).mul(h).ldexpThis(1)),c.polypoly1Proximity.addElement(c.tempP),c.tempP.construct0(i.mul(u).mul(u)),c.polypoly1Proximity.addElement(c.tempP),c.polypoly1Proximity.updatePower(),c.tempP.construct0(o.ad),c.polypoly2Proximity.construct0(c.tempP),c.tempP.assignCopy(c.polyX1),c.tempP.mulThis(c.polyX1Deriv),c.tempP1.assignCopy(c.polyY1),c.tempP1.mulThis(c.polyY1Deriv),c.tempP.addThis(c.tempP1),c.tempP.mulElementThis(i.mul(h)),c.polypoly2Proximity.addElement(c.tempP),c.tempP.assignCopy(c.polyX1Deriv),c.tempP.mulElementThis(u.mul(i)),c.polypoly2Proximity.addElement(c.tempP),c.polypoly2Proximity.updatePower()}const g=[],d=[];u||(u=[]);let _=2*c.polyIntersect.power()+58;const p=.5*Number.EPSILON,f=ne(c.polyIntersect,h,m,p,_,d);if(f<0)return-1;se(c.polypoly1Proximity,c.polypoly2Proximity,c.tempP),_=2*c.tempP.power()+58;let P=ne(c.tempP,h,m,p,_,g);if(P<0&&(P=0),0===f&&0===P)return 0;const x=g.concat(d);u.length=x.length,(0,o.a)(u,x,0,0,x.length),(0,o.v)(u);const y=(0,o.u)(u,((t,e)=>0===(0,o.X)(t,e)));return u.length=y,u.length}function Qt(t,e,s,n){return t.isZero()?e.isZero()?-1:0:(n.setThis(e),n.negateThis(),n.divThis(t),s.isEmpty()||s.containsCoordinate(n.value())?1:0)}function Kt(t,e,s,n,i,r,a){if(t.isZero())return r?(a[0].setInt32(1),i.containsCoordinate(1)?1:0):Qt(e,s,i,a[0]);if(r){let e=2;return a[0].setInt32(1),s.equals(t)?(a[1].setInt32(1),e=1):a[1].setThis(s.div(t)),i.containsCoordinate(a[1].value())||(e=1),i.containsCoordinate(a[0].value())||(e--,a[0].setThis(a[1])),2===e&&a[0].value()>a[1].value()&&(a[1]=(0,o.b)(a[0],a[0]=a[1])),e}const h=e.clone();h.sqrThis();const m=t.clone();if(m.mulThis(s).ldexpThis(2).negateThis().addThis(h),m.LZ())return 0;const l=n+2,u=o.M.sqrt(m,l),c=u.clone();e.LZ()&&c.negateThis(),c.addThis(e).limitPrecisionThis(l).ldexpThis(-1).negateThis();let g=0;return a[0].setThis(c).divThis(o.M.constructAssign(t,l)).limitPrecisionThis(n),(i.isEmpty()||i.containsCoordinate(a[0].value()))&&g++,u.isZero()||c.isZero()||(a[g].setThis(s).divThis(c).limitPrecisionThis(n),(i.isEmpty()||i.containsCoordinate(a[g].value()))&&g++,2===g&&a[0].gt(a[1])&&(a[1]=(0,o.b)(a[0],a[0]=a[1]))),g}function Jt(t,e,s,n,r,a,h,m){if(t.isZero())return Kt(e,s,n,r,a,h,m);const l=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)m[t].equals(m[0])&&(m[s-1]=(0,o.b)(m[t],m[t]=m[s-1]),s--);e=s}return(0,o.C)(m,0,e,((t,e)=>t.compare(e))),e};if(n.isZero()){let n=0;return a.containsCoordinate(0)&&(m[0].setInt32(0),n=1),l(Kt(t,e,s,r,a,h,m.slice(1)),n)}if(h){let s=0;a.containsCoordinate(1)&&(m[0].setInt32(1),s=1);const i=e.add(t),o=n.negate(),h=t.add(i).add(o).isZero();return l(Kt(t,i,o,r,a,h,m.slice(s)),s)}const u=new o.M,c=new o.M,g=new o.M,d=e.clone();if(d.isZero())c.setThis(s),c.divThis(t),g.setThis(n),c.divThis(t);else{d.divThis(t).divDoubleThis(3).negateThis();const i=e.clone();i.sqrThis();const r=t.clone();r.sqrThis(),c.setThis(t),c.mulThis(s).mulDoubleThis(3).subThis(i).divThis(r).divDoubleThis(3),g.setThis(i),g.mulThis(e),g.ldexpThis(1),u.setThis(t),u.mulThis(e).mulThis(s).mulDoubleThis(9),g.subThis(u),u.setThis(r),u.mulThis(n).mulDoubleThis(27),g.addThis(u),g.divThis(r).divThis(t).divDoubleThis(27)}if(c.isZero()){const t=g.clone();return t.negateThis(),t.isZero()?(m[0].setThis(d),le(a,r,m,1)):(m[0].setThis(o.M.cubicRoot(g,r).add(d)),le(a,r,m,1))}const _=g.clone();if(_.sqrThis().ldexpThis(-2),u.setThis(c.clone()),u.sqrThis().mulThis(c).divDoubleThis(27),_.addThis(u),_.isZero())return m[0].setThis(g),m[0].mulDoubleThis(3).divThis(c),m[1].setThis(m[0]),m[1].negateThis(),m[1].ldexpThis(-1),m[0].addThis(d),m[1].addThis(d),le(a,r,m,2);if(_.GZ())return _.setThis(o.M.sqrt(_,r+8)),u.setThis(g),u.ldexpThis(-1).negateThis(),u.addThis(_),m[0].setThis(o.M.cubicRoot(u,r+8)),u.setThis(g),u.ldexpThis(-1).negateThis(),u.subThis(_),m[0].addThis(o.M.cubicRoot(u,r+8)),m[0].addThis(d),le(a,r,m,1);u.setThis(c),u.divDoubleThis(3).negateThis(),(0,i.g)(u.GEZ());const p=o.M.sqrt(u,r+8),f=p.clone();f.negateThis(),f.addThis(d),p.addThis(d);const P=o.M.constructDouble(a.isEmpty()?-Number.MAX_VALUE:a.vmin),x=o.M.constructDouble(a.isEmpty()?Number.MAX_VALUE:a.vmax),y=new Ot({zeroCtor:o.M});y.construct0(n),y.addElement(s),y.addElement(e),y.addElement(t);const E=new Ot({copy:y});E.derivative1This();let C=0;const S=(0,o.m)(o.M,4);S[C++].setThis(P),f.gt(P)&&f.lt(x)&&S[C++].setThis(f),p.gt(P)&&p.lt(x)&&S[C++].setThis(p),S[C++].setThis(x);const v=3*r;let b=52,I=Number.EPSILON;for(;b<v;)2*b<=v?(I*=I,b*=2):(I*=Number.EPSILON,b+=52);b+=2;let w=0,D=!1;for(let i=1;i<C;i++)if(oe(y,E,S[i-1],S[i],I,b,m[0])){w=1,D=i+1<C;break}if(!w)return 0;if(D){const t=new Ot({zeroCtor:o.M,coef0:m[0]});t.negateThis(),t.addElement(o.ae);const e=new Ot({zeroCtor:o.M}),s=new Ot({zeroCtor:o.M});y.div(t,e,s),(0,i.g)(2===e.power()),(0,i.g)(0===s.power());const n=Kt(e.getElement(2),e.getElement(1),e.getElement(0),r,a,!1,m.slice(1));(0,i.g)(n>=0&&n<=2),w+=n}return le(a,r,m,w)}function $t(t,e,s,n,i,r,a,h,m){if(t.isZero())return Jt(e,s,n,i,r,a,h,m);const l=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)m[t].equals(m[0])&&(m[s-1]=(0,o.b)(m[t],m[t]=m[s-1]),s--);e=s}return(0,o.C)(m,0,e,((t,e)=>t.compare(e))),e};if(i.isZero()){let i=0;return a.containsCoordinate(0)&&(m[0].setInt32(0),i=1),l(Jt(t,e,s,n,r,a,h,m.slice(i)),i)}const u=new Ot({zeroCtor:o.M,coef0:i});if(u.addElement(n),u.addElement(s),u.addElement(e),u.addElement(t),h){let t=0;a.containsCoordinate(1)&&(m[0].setInt32(1),t=1);const e=new Ot({zeroCtor:o.M,coef0:o.M.constructInt32(-1)});e.addElement(o.M.constructInt32(1));const s=new Ot({zeroCtor:o.M}),n=new Ot({zeroCtor:o.M});return u.div(e,s,n),l(Jt(3===s.power()?s.getElement(3):o.ad.clone(),s.power()>=2?s.getElement(2):o.ad.clone(),s.power()>=1?s.getElement(1):o.ad.clone(),s.getElement(0),r,a,s.evaluate(o.ae).isZero(),m.slice(t)),t)}if(u.getElement(0).isZero()){let t=0;for(a.containsCoordinate(0)&&(t=1,m[0].setDouble(0));u.getElement(0).isZero()&&u.power()>0;)u.shiftRight(1);const e=Jt(3===u.power()?u.getElement(3):o.ad.clone(),u.power()>=2?u.getElement(2):o.ad.clone(),u.power()>=1?u.getElement(1):o.ad.clone(),u.getElement(0),r,a,!1,m.slice(t));return e>0&&(t+=e),(0,o.C)(m,0,t,((t,e)=>t.compare(e))),t}let c=52,g=Number.EPSILON;for(;c<r;)2*c<=r?(g*=g,c*=2):(g*=Number.EPSILON,c+=52);c+=2;const d=me(u),_=o.M.constructDouble(Math.max(Math.abs(a.vmax),Math.abs(a.vmin)));return g=(d.lt(_)?d:_).mul(o.M.constructDouble(g)).toDouble(),he(u,a,g,c,h,!1,m,4)}function te(t,e){let s=t,n=e;n.power()>s.power()&&(n=(0,o.b)(s,s=n));const i=s.power()-n.power(),r=new Ot({copy:s.getElement(s.power())});s.mulThis(n.getElement(n.power()));for(let o=0,a=s.power();o<a;o++)if(o>=i){const t=new Ot({copy:n.getElement(o-i)});t.mulThis(r);const e=s.getElement(o).sub(t);s.setElement(o,e)}s.setElement(s.power(),s.getElement(s.power()).setZero()),s.updatePower(),ee(s)}function ee(t){let e=0;for(;e<t.power()&&t.getElement(e).isZero();)e++;return e>0&&(t.shiftRight(e),!0)}function se(t,e,s){const n=t.clone(),i=e.clone();for(ee(n),ee(i);0!==n.power()||0!==i.power();)te(n,i);s.assignMove(n.getElement(0))}function ne(t,e,s,n,i,r){r.length=0;const a=t.power(),h=(0,o.m)(o.M,2*a+4),m=function(t,e,s,n,i,r,a){if(0===t.power())return t.isZero()?-1:0;const h=t.evaluate(o.M.constructInt32(1)).isZero();if(1===t.power()){const s=Qt(t.getElement(1),t.getElement(0),e,r.at(0));return r[0].limitPrecisionThis(n),1!==s?0:(r[0].limitPrecisionThis(n),1)}return 2===t.power()?Kt(t.getElement(2),t.getElement(1),t.getElement(0),n,e,h,r):3===t.power()?Jt(t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),n,e,h,r):4===t.power()?$t(t.getElement(4),t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),n,e,h,r):he(t,e,s,n,h,i,r,a)}(t,s||o.E.unit(),n,i,!1,h,h.length);if(m>0){r.length=0;for(let t=0;t<m;t++){const e=h[t].value();t>0&&e<=r.at(-1)||r.push(e)}return r.length}return m}function ie(t,e,s){if((0,i.g)(s>=1),0===t.power())return t.isZero()?-1:0;const n=t.getElement(0);return n.negateThis(),n.divThis(t.getElement(1)),e[0].setThis(n),1}function re(t,e,s,n){if(t.power()<2)return ie(t,s,n);(0,i.g)(n>=1);let r=t.getElement(1);r.mulThis(t.getElement(1));const a=t.getElement(0);if(a.mulThis(t.getElement(2)),a.ldexpThis(2),r.subThis(a),r.LZ())return 0;if(r.isZero()){const n=t.getElement(1);return n.negateThis(),n.divThis(t.getElement(2)),n.ldexpThis(-1),n.limitPrecisionThis(e),s[0].setThis(n),1}(0,i.g)(n>=2),r=o.M.sqrt(r,e+8);const h=t.getElement(1);h.negateThis();const m=h.clone();m.subThis(r),m.divThis(t.getElement(2)),m.ldexpThis(-1),m.limitPrecisionThis(e);const l=h.clone();return l.addThis(r),l.divThis(t.getElement(2)),l.ldexpThis(-1),l.limitPrecisionThis(e),m.lt(l)?(s[0].setThis(m),s[1].setThis(l)):(s[1].setThis(m),s[0].setThis(l)),2}function oe(t,e,s,n,r,a,h){let m=s.clone(),l=n.clone();m.limitPrecisionThis(a),l.limitPrecisionThis(a);let u=t.evaluate(m);u.limitPrecisionThis(a+2);let c=t.evaluate(l);if(c.limitPrecisionThis(a+2),u.GEZ()&&c.GEZ()||u.LEZ()&&c.LEZ())return u.absLessAbs(c)?(h=m,u.isZero()):(h=l,c.isZero());const g=c.LZ();g&&(c=(0,o.b)(u,u=c),l=(0,o.b)(m,m=l));const d=g?l:m,_=g?m:l,p=m.add(l).ldexpThis(-1);p.limitPrecisionThis(a);const f=l.sub(m);f.limitPrecisionThis(a),f.absThis();const P=f.clone();let x=t.evaluate(p),y=e.evaluate(p);const E=new Ot({copy:t}),C=new Ot({copy:e});{const s=Math.max(t.hiBitIndex(),e.hiBitIndex()),n=o.ae.clone();n.ldexpThis(-(a+2));for(let i=64;i<s;){E.limitPrecisionThis(i),C.limitPrecisionThis(i);const r=E.evaluate(p),o=C.evaluate(p),a=r.sub(x),h=o.sub(y);if(a.divThis(x).absThis().lt(n)&&(y.isZero()||h.divThis(y).absThis().lt(n)))break;E.assignCopy(t),C.assignCopy(e),i=Math.min(i+64,s)}x.limitPrecisionThis(a+2),y.limitPrecisionThis(a+2)}let S=4;let v=1,b=0,I=0,w=1;const D=o.M.constructDouble(.25*r),T=o.M.constructDouble(.5001);let N=0;for(;++N<300;){if(N>32&&b>0||y.isZero()||2===w&&b>1||1===w&&S<4)w=1,v>1&&v--;else if(w=2,I>1){const t=f.mul(y);t.absThis(),t.ldexpThis(-3),t.absLessAbs(x)&&v++}f.setThis(P);const t=new o.M;let e=!1;if(1===w)do{if(I>2){const e=f.clone();if(e.absThis(),e.ldexpThis(4),_.sub(d).ldexpThis(-1).gt(e)){if(p.equals(d)){t.setThis(p),p.setThis(d.add(e)),p.limitPrecisionThis(a),P.setThis(p.sub(t));break}if(p.equals(_)){t.setThis(p),p.setThis(_.sub(e)),p.limitPrecisionThis(a),P.setThis(p.sub(t));break}}}P.setThis(l.sub(m)),P.ldexpThis(-1),P.limitPrecisionThis(a),t.setThis(p),p.setThis(m.add(P)),p.limitPrecisionThis(a),p.lt(d)?p.setThis(d):p.gt(_)&&p.setThis(_),e=m.equals(p)||l.equals(p)}while(0);else for(;;){if(P.setThis(x.div(y)),P.limitPrecisionThis(a),1!==v&&P.mulDoubleThis(v),t.setThis(p),p.subThis(P),p.limitPrecisionThis(a),e=p.equals(t),p.lt(d)){if(v>1){p.setThis(t),v--;continue}P.setThis(t.sub(d)),p.setThis(d)}else if(p.gt(_)){if(v>1){p.setThis(t),v--;continue}P.setThis(t.sub(_)),p.setThis(_)}break}if(e||P.absLessAbs(D)){t.equals(p)||(x=E.evaluate(p),x.limitPrecisionThis(a+2));break}x=E.evaluate(p),x.limitPrecisionThis(a+2),y=C.evaluate(p),y.limitPrecisionThis(a+2);const s=m.clone(),n=l.clone();x.LZ()?(u.setThis(x),m.setThis(p)):(c.setThis(x),l.setThis(p)),2===w&&(m.equals(s)&&l.equals(n)||I>1&&!P.absLessAbs(T.mul(f)))?b++:b=0,1===w?(S++,I=0):(S=0,I++)}return N>=300&&(0,i.c)("Root_finder iterations exceeded"),h.setThis(p),!0}function ae(t,e,s,n,i){const r=t.evaluate(s);if(r.isZero())return!0;const a=o.M.constructDouble(.5*n),h=s.clone();h.subThis(a);const m=t.evaluate(h),l=s.clone();l.addThis(a);const u=t.evaluate(l);if(m.LZ()&&u.GZ()||m.GZ()&&u.LZ())return!0;if(r.GZ()?m.LEZ()||u.LEZ():m.GEZ()||u.GEZ())return!0;const c=m.LEZ()&&u.LEZ(),g=m.GEZ()&&u.GEZ();let d=!1;return c?r.gt(m)&&r.gt(u)&&(d=!0):g&&r.lt(m)&&r.lt(u)&&(d=!0),!!d&&r.absThis().lt(o.M.constructDouble(1e-17))}function he(t,e,s,n,r,a,h,m){(0,i.g)(s>0),(0,i.g)(m>=t.power());const l=h,u=[];let c=[];const g=new Ot({zeroCtor:t.m_zeroCtor}),d=new Ot({zeroCtor:t.m_zeroCtor}),_=new Ot({zeroCtor:t.m_zeroCtor}),p=o.M.constructDouble(s),f=o.M.constructDouble(e.vmin),P=o.M.constructDouble(e.vmax),x=f.sub(p),y=P.add(p),E=me(t),C=E.clone();if(C.negateThis(),x.lt(C))x.setThis(C.sub(p));else if(x.gt(E))return 0;if(y.gt(E))y.setThis(E.add(p));else if(y.lt(C))return 0;let S=t,v=null;if(r){const e=new Ot({coef0:o.M.constructInt32(-1)});e.addElement(o.ae),v=new Ot,S=v;const s=new Ot,n=new Ot;for(t.div(e,s,n),v.assignCopy(s);S.evaluate(o.ae).isZero();)S.div(e,s,n),v.assignCopy(s)}let b=!1;if(S.power()>0&&S.getElement(0).isZero())for(b=!0,v||(v=new Ot({copy:S}),S=v);S.getElement(0).isZero();)v.shiftRight(1);let I=n+2*S.power()+2,w=s/Math.pow(2,S.power()+2),D=I;if(o.ad.gt(x)&&o.ad.lt(y))for(let i=0,M=S.power();i<M;i++)if(S.getElement(i).isZero()){u.push(o.ad.clone());break}for(let M=S.power()-1;M>0;M--)if(w*=2,I-=2,D-=2,S.power()-M!=1)if(S.power()-M!=2){d.assignMove(_),_.assignMove(S.derivative(M-1));let t=[];for(let e=0,s=c.length;e<s;++e)if(c[e].first.lte(c[e].second)){const s=new o.M;if(oe(d,g,c[e].first,c[e].second,w,I,s)){u.push(s);let n=s.sub(p);n.limitPrecisionThis(D),t.push((0,o.n)(c[e].first,n)),n=s.add(p),n.limitPrecisionThis(D),t.push((0,o.n)(n,c[e].second))}else t.push(c[e])}c=t,t=[],g.assignMove(d)}else{d.assignMove(S.derivative(M));const t=re(d,I,l,m);(0,i.g)(t>=0&&t<=2);for(let e=0;e<t;e++)l[e].gt(x)&&l[e].lt(y)&&!l[e].isZero()&&u.push(l[e].clone());if(u.length>1&&u.sort(((t,e)=>t.compare(e))),u.length>0){let t=u[0].sub(p);t.limitPrecisionThis(D),c.push((0,o.n)(x.clone(),t));let e=1===u.length?y.clone():u[1].sub(p);t=u[0].add(p),t.limitPrecisionThis(D),e.limitPrecisionThis(D),c.push((0,o.n)(t,e)),u.length>1&&(e=2===u.length?y.clone():u[2].sub(p),e.limitPrecisionThis(D),t=u[1].add(p),t.limitPrecisionThis(D),c.push((0,o.n)(t,e)),u.length>2&&(t=u[2].add(p),t.limitPrecisionThis(D),c.push((0,o.n)(t,y.clone()))))}else c.push((0,o.n)(x.clone(),y.clone()));g.assignCopy(d),_.assignMove(S.derivative(M-1))}else d.assignMove(S.derivative(M)),1===ie(d,l,m)&&(l[0].gt(x)&&l[0].lt(y)&&!l[0].isZero()&&u.push(l[0].clone()),g.assignMove(d),_.assignMove(S.derivative(M-1)));u.sort(((t,e)=>t.compare(e))),0===c.length&&(g.assignMove(S.derivative(S.power())),g.isZero()||c.push((0,o.n)(x.clone(),y.clone())));let T=0,N=0,A=0;const G=new o.M;for(;;){if(N<c.length){if(c[N].first.gt(c[N].second)){N++;continue}let t=!1;if(A<u.length&&u[A].lt(c[N].first)&&(t=!0),!t){oe(S,g,c[N].first,c[N].second,s,n,G)&&(G.lt(f)?l[T++].setThis(f):G.gt(P)?l[T++].setThis(P):l[T++].setThis(G)),N++;continue}}if(!(A<u.length))break;0!==A&&u[A-1].equals(u[A])||ae(S,0,u[A],s)&&(G.setThis(u[A]),G.lt(f)?G.setThis(f):G.gt(P)&&G.setThis(P),0!==T&&l[T].equals(G)||l[T++].setThis(G)),A++}return b&&o.ad.gt(x)&&o.ad.lt(y)&&(l[T++].setThis(o.ad),(0,o.C)(l,0,T,((t,e)=>t.compare(e)))),r&&o.ae.gt(x)&&o.ae.lt(y)&&(l[T++].setThis(o.ae),(0,o.C)(l,0,T,((t,e)=>t.compare(e)))),T}function me(t){const e=t.getElement(t.power());e.limitPrecisionThis(53);const s=o.ad.clone();for(let n=0,i=t.power();n<i;n++){const i=t.getElement(n);i.limitPrecisionThis(53),i.divThis(e).absThis(),i.gt(s)&&s.setThis(i)}return s.addThis(o.ae),s.mulThis(o.M.constructDouble(1+100*Number.EPSILON)),s}function le(t,e,s,n){let i=n;if(!t.isEmpty()){i=0;for(let e=0;e<n;++e)t.containsCoordinate(s[e].value())&&(i!==e&&s[i].setThis(s[e]),i++)}i>1&&(s[0].gt(s[1])&&(s[1]=(0,o.b)(s[0],s[0]=s[1])),i>2&&(s[0].gt(s[2])&&(s[2]=(0,o.b)(s[0],s[0]=s[2])),s[1].gt(s[2])&&(s[2]=(0,o.b)(s[1],s[1]=s[2]))));for(let r=0;r<i;++r)s[r].limitPrecisionThis(e);return i}const ue=[[.33998104358485626,.6521451548625461],[.8611363115940526,.34785484513745385]],ce=[[.1834346424956498,.362683783378362],[.525532409916329,.31370664587788727],[.7966664774136267,.22238103445337448],[.9602898564975363,.10122853629037626]],ge=[[.09501250983763744,.1894506104550685],[.2816035507792589,.18260341504492358],[.45801677765722737,.16915651939500254],[.6178762444026438,.14959598881657674],[.755404408355003,.12462897125553388],[.8656312023878318,.09515851168249279],[.9445750230732326,.062253523938647894],[.9894009349916499,.027152459411754096]],de=[[.04830766568773832,.0965400885147278],[.1444719615827965,.09563872007927486],[.23928736225213706,.09384439908080457],[.33186860228212767,.09117387869576389],[.42135127613063533,.08765209300440381],[.5068999089322294,.08331192422694675],[.5877157572407623,.07819389578707031],[.6630442669302152,.0723457941088485],[.7321821187402897,.06582222277636185],[.7944837959679424,.058684093478535544],[.84936761373257,.050998059262376175],[.8963211557660521,.04283589802222668],[.9349060759377397,.03427386291302143],[.9647622555875064,.02539206530926206],[.9856115115452684,.01627439473090567],[.9972638618494816,.007018610009470096]],_e=[[.024350292663424433,.048690957009139724],[.07299312178779904,.04857546744150343],[.12146281929612056,.048344762234802954],[.16964442042399283,.04799938859645831],[.21742364374000708,.04754016571483031],[.2646871622087674,.04696818281621002],[.31132287199021097,.046284796581314416],[.3572201583376681,.04549162792741814],[.4022701579639916,.044590558163756566],[.4463660172534641,.04358372452932345],[.48940314570705296,.04247351512365359],[.5312794640198946,.04126256324262353],[.571895646202634,.03995374113272034],[.6111553551723933,.038550153178615626],[.6489654712546573,.03705512854024005],[.6852363130542333,.035472213256882386],[.7198818501716109,.033805161837141606],[.7528199072605319,.03205792835485155],[.7839723589433414,.030234657072402478],[.8132653151227975,.028339672614259483],[.8406292962525803,.02637746971505466],[.8659993981540928,.024352702568710874],[.8893154459951141,.022270173808383253],[.9105221370785028,.02013482315353021],[.9295691721319396,.017951715775697343],[.9464113748584028,.015726030476024718],[.9610087996520538,.013463047896718643],[.973326827789911,.011168139460131128],[.983336253884626,.008846759826363947],[.9910133714767443,.006504457968978363],[.9963401167719553,.004147033260562468],[.9993050417357722,.001783280721696433]],pe=[[.012223698960615764,.024446180196262518],[.03666379096873349,.024431569097850044],[.06108196960413957,.02440235563384958],[.08546364050451549,.024358557264690626],[.10979423112764375,.024300200167971867],[.13405919946118777,.02422731922281525],[.15824404271422493,.024139957989019287],[.18233430598533718,.024038168681024052],[.2063155909020792,.023922012136703457],[.23017356422666,.023791557781003402],[.2538939664226943,.023646883584447616],[.2774626201779044,.02348807601653591],[.3008654388776772,.02331522999406276],[.32408843502441337,.023128448824387027],[.3471177285976355,.022927844143686846],[.369939555349859,.02271353585023646],[.39254027503326744,.022485652032744968],[.414906379552275,.022244328893799764],[.43702450103710416,.02198971066846049],[.4588814198335522,.021721949538052076],[.48046407240417205,.02144120553920846],[.5017595591361445,.02114764646822135],[.5227551520511755,.02084144778075115],[.5434383024128103,.02052279248696007],[.5637966482266181,.020191871042130043],[.5838180216287631,.01984888123283086],[.6034904561585486,.019494028058706602],[.6228021939105849,.019127523609950944],[.6417416925623075,.01874958694054471],[.660297632272646,.01836044393733134],[.6784589224477192,.017960327185008687],[.6962147083695144,.017549475827117706],[.7135543776835874,.01712813542311138],[.7304675667419088,.016696557801589205],[.746944166797062,.016255000909785187],[.7629743300440948,.015803728659399347],[.7785484755064119,.015343010768865144],[.7936572947621933,.014873122602147314],[.8082917575079137,.014394345004166847],[.8224431169556439,.013906964132951985],[.8361029150609068,.013411271288616333],[.8492629875779689,.012907562739267348],[.8619154689395485,.012396139543950923],[.8740527969580318,.01187730737274028],[.8856677173453972,.011351376324080417],[.8967532880491582,.010818660739503076],[.9073028834017568,.010279479015832158],[.9173101980809605,.009734153415006806],[.9267692508789478,.009183009871660874],[.9356743882779164,.00862637779861675],[.9440202878302202,.008064589890486059],[.9518019613412644,.0074979819256347285],[.9590147578536999,.006926892566898814],[.9656543664319652,.006351663161707189],[.9717168187471366,.005772637542865698],[.9771984914639074,.00519016183267633],[.9820961084357185,.004604584256702955],[.9864067427245862,.004016254983738642],[.9901278184917344,.0034255260409102157],[.9932571129002129,.0028327514714579912],[.9957927585349812,.0022382884309626186],[.997733248625514,.0016425030186690294],[.9990774599773758,.0010458126793403489],[.9998248879471319,.00044938096029209035]];function fe(t,e,s,n){const i=.5*(n-s),r=s+i,a=new o.K(0);for(let h=0,m=Math.trunc(t/2);h<m;++h){let s,n;switch(t){case 4:s=ue[h][0],n=ue[h][1];break;case 8:s=ce[h][0],n=ce[h][1];break;case 16:s=ge[h][0],n=ge[h][1];break;case 32:s=de[h][0],n=de[h][1];break;case 64:s=_e[h][0],n=_e[h][1];break;case 128:s=pe[h][0],n=pe[h][1];break;default:throw new Error("Quadrature_integral: invalid n")}const m=(0,o.aj)(-.5,s,r),l=(0,o.aj)(i,s,r);a.pe(e(m)*n),a.pe(e(l)*n)}return a.getResult()*i}function Pe(t,e,s,n,r,a){return function(t,e,s,n,r,a){if(s<e&&(0,i.t)("xTo < xFrom"),s===e)return 0;const h=[0];let m=Number.MAX_VALUE;const l=[Number.MAX_VALUE];let u=0;const c=32,g=(0,o.d)(c+1,Number.NaN),d=(0,o.d)(c+1,Number.NaN),_=[0];g[0]=1;let p=0,f=0;for(let o=0;o<c;o++){if(u=xe(e,s,n,0===o,u,_),d[o]=u,o+1>=t){ye(o+1-t,t,g,d,0,h,l)||(0,i.c)("polynomial_interpolation");const e=r*Math.abs(h[0])+a,s=Math.abs(m-h[0]);if(s<=e&&Math.abs(l[0])<=e){if(p++,p>1&&(s<=.1*f||0===f||p>2))return h[0]}else p=0;f=s,m=h[0]}d[o+1]=d[o],g[o+1]=.25*g[o]}return h[0]}(t,e,s,a,n,r)}function xe(t,e,s,n,i,r){let a=i;if(n)return r[0]=1,a=.5*(e-t)*(s(t)+s(e)),a;const h=r[0],m=(e-t)/h,l=t,u=new o.K(0);for(let o=1;o<=r[0];++o){const t=(o-.5)*m;u.add(s(l+t))}return a=.5*(a+(e-t)*u.getResult()/h),r[0]*=2,a}function ye(t,e,s,n,i,r,a){let h=0,m=Math.abs(i-s[t]);const l=(0,o.d)(e,Number.NaN),u=(0,o.d)(e,Number.NaN);for(let o=0;o<e;++o){const e=Math.abs(i-s[t+o]);e<m&&(h=o,m=e),l[o]=n[t+o],u[o]=n[t+o]}let c=0,g=0,d=0;r[0]=n[t+h],h--;for(let o=1;o<e;o++){for(let n=0;n<e-o;n++){if(g=s[t+n]-i,d=s[t+n+o]-i,c=g-d,0===c)return!1;const e=(l[n+1]-u[n])/c;l[n]=g*e,u[n]=d*e}if(2*(h+1)<e-o){const t=h+1;a[0]=l[t]}else{const t=h;a[0]=u[t],h--}r[0]+=a[0]}return!0}class Ee{constructor(){this.length=Number.NaN,this.area=Number.NaN,this.centroidX=Number.NaN,this.centroidY=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}function Ce(t,e,s,n,r,a,h,m){for(;;){const l=o.P.distance(e[0],e[2]),u=o.P.distance(e[0],e[1])+o.P.distance(e[1],e[2]);if(u-l<=r+n*u)return t+(0,o.q)(l,u,.5);const c=(0,o.m)(o.P,4),g=t=>(Ge(e,s,1,t,c),c[1].length());if(0===h&&m<8){(0,i.g)(m<8);let l=g(0),c=g(1);a[0]+=2,l>c&&(c=(0,o.b)(l,l=c),e[2]=(0,o.b)(e[0],e[0]=e[2]),s[2]=(0,o.b)(s[0],s[0]=s[2]));let d=l/(l+c),_=1,p=u;for(;d<1/32&&p>=r+n*p;){_/=4;const t=g(_);a[0]++,d=l/(t+l);const n=new o.P;if(ms(e,s,.5*_,n),p=o.P.distance(n,e[0]),p<=r){const t=new o.P;ms(e,s,_,t),p+=o.P.distance(t,n)}}if(1!==_){const i=(0,o.m)(o.P,3),l=[0,0,0];Ze(e,s,_,e,s,i,l),t=Ce(t,i,l,n,r,a,0,m+1),h++,m++;continue}}let d=!1;const _=8;a[0]+=_;const p=fe(_,g,0,1),f=16;a[0]+=f;const P=fe(f,g,0,1);if(d=Math.abs(p-P)>r+n*u,!d)return t+P;if(h<8&&m<9){const i=(0,o.m)(o.P,3),l=[0,0,0];Ze(e,s,.5,e,s,i,l),t=Ce(t,i,l,n,r,a,h+1,m+1),h++,m++;continue}const x=32;a[0]+=x;const y=fe(x,g,0,1);if(d=Math.abs(P-y)>r+n*u,!d)return t+y;const E=64;a[0]+=E;const C=fe(E,g,0,1);if(d=Math.abs(y-C)>r+n*u,!d)return t+C;const S=128;a[0]+=S;const v=fe(S,g,0,1);return d=Math.abs(C-v)>r+n*u,t+v}}function Se(t,e,s,n,i){if(s===e)return 0;const r=(0,o.m)(o.P,3),a=[0,0,0];t.queryControlPoints(r),t.queryWeights(a);const h=[0,0,0],m=(0,o.m)(o.P,3);return Qe(r,a,e,s,m,h),Ce(0,m,h,n,i,[0],0,0)}let ve=class{constructor(t,e,s){this.controlPoints=(0,o.L)(t,3),this.weights=[0,0,0],(0,o.a)(this.weights,e,0,0,3),this.point=s.clone()}getMaxDerivative(){return 3}getValue(t,e){if(0===t){const t=new o.P;ms(this.controlPoints,this.weights,e,t);const s=(0,o.m)(o.P,4);return Ge(this.controlPoints,this.weights,1,e,s),2*t.sub(this.point).dotProduct(s[1])}if(1===t){const t=new o.P;ms(this.controlPoints,this.weights,e,t);const s=(0,o.m)(o.P,4);return Ge(this.controlPoints,this.weights,2,e,s),2*(t.sub(this.point).dotProduct(s[2])+s[1].dotProduct(s[1]))}if(2===t){const t=new o.P;ms(this.controlPoints,this.weights,e,t);const s=(0,o.m)(o.P,4);return Ge(this.controlPoints,this.weights,3,e,s),2*(t.sub(this.point).dotProduct(s[3])+3*s[1].dotProduct(s[2]))}return 0}getError(t){return(0,i.g)(0),0}};function be(t,e,s,n){const i=function(t,e,s,n,i){return{tmin:t,tmax:e,t:s,d:n,pt:i.clone()}}(0,0,0,0,o.P.getNAN()),r=(0,o.d)(18,Number.NaN),a=(0,o.m)(o.P,3);t.queryControlPoints(a),a[2].subThis(e),a[1].subThis(e),a[0].subThis(e);const h=[0,0,0];t.queryWeights(h);const m=[1,us(h),1],l=gs(h,s),u=gs(h,n),c=Ct(new ve(a,m,new o.P(0,0)),o.E.construct(l,u),18,r);ms(a,m,l,i.pt),i.t=l,i.d=o.P.distance(i.pt,new o.P(0,0));const g=new o.P;ms(a,m,u,g);const d=o.P.distance(g,new o.P(0,0));d<i.d&&(i.d=d,i.t=u,i.pt.assign(g));for(let _=0;_<c;_++){ms(a,m,r[_],g);const t=o.P.distance(g,new o.P(0,0));t<i.d&&(i.d=t,i.t=cs(h,r[_]),i.pt.assign(g))}return i}function Ie(t,e,s,n,i){let r=!0;const a=(0,o.m)(o.P,4),h=Pe(5,e,s,n,i,(e=>(Ae(t,1,e,a),(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*a[1].length())));r=!1;const m=Pe(5,e,s,n,i,(e=>(Ae(t,1,e,a),(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*a[1].length())));return new o.P(h,m)}function we(t){t.m_cachedValues=null}function De(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new Ee,s=(0,o.m)(o.P,3);t.queryControlPoints(s);const n=[0,0,0];return t.queryWeights(n),Te(s,n,e.specialPoints),He(t,e),e}function Te(t,e,s){if(0===e[1])return s.length=0,s.push(0),void s.push(1);const n=(0,o.m)(o.F,8);n[0].set(0);let i=1;{const s=new o.F(t[1].x).subThis(t[0].x).mulThis(e[1]).mulThis(e[0]),r=new o.F(t[2].x).subThis(t[0].x).mulThis(e[2]).mulThis(e[0]),a=s.subE(r).addThisE(new o.F(t[2].x).subThis(t[1].x).mulThis(e[2]).mulThis(e[1]));r.subThisE(s.mul(2));const h=(0,o.m)(o.F,2);let m=At(a,r,s,new o.E(0,1),!1,h);m<0&&(m=0);for(let t=0;t<m;t++)(0,o.J)(h[t].value(),0,1)||(n[i]=h[t],i++)}{const s=new o.F(t[1].y).subThis(t[0].y).mulThis(e[1]).mulThis(e[0]),r=new o.F(t[2].y).subThis(t[0].y).mulThis(e[2]).mulThis(e[0]),a=s.subE(r).addThisE(new o.F(t[2].y).subThis(t[1].y).mulThis(e[2]).mulThis(e[1]));r.subThisE(s.mul(2));const h=(0,o.m)(o.F,2);let m=At(a,r,s,new o.E(0,1),!1,h);m<0&&(m=0);for(let t=0;t<m;t++)(0,o.J)(h[t].value(),0,1)||(n[i]=h[t],i++)}if(n[i].set(1),i++,i>2){(0,o.C)(n,0,i,((t,e)=>(0,o.X)(t.value(),e.value())));let t=0,e=n[0].value(),s=1;for(let r=1;r<i;r++)n[r].eq(n[r-1])?(e+=n[r].value(),s++):(s>1&&(e/=s,n[t].set(e)),t++,n[t]=n[r],e=n[r].value(),s=1);t++,i=t}n[0].set(0),n[i-1].set(1),s.length=i;for(let r=0;r<i;r++)s[r]=n[r].value()}function Ne(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+Ne(t,1,!1)}if(t.isDegenerate(0))return 0;const n=1===e,i=De(t);if(n&&!Number.isNaN(i.length))return i.length;const r=ke(t),o=r/t.calculateUpperLength2D();let a=0,h=0;for(let m=1,l=i.specialPointsCount();m<l;m++){const s=i.specialPoints[m];if(a+=Se(t,h,Math.min(e,s),o,r),e<=s)break;h=s}return n&&(i.length=a),a}function Ae(t,e,s,n){const i=(0,o.m)(o.P,3);t.queryControlPoints(i);const r=[0,0,0];t.queryWeights(r),Ge(i,r,e,s,n)}function Ge(t,e,s,n,r){const a=[t[0],t[1],t[2]],h=[e[0],e[1],e[2]],m=(0,o.m)(o.P,4);!function(t,e,s,n,r){(0,i.g)(s>0);const o=[t[0].clone(),t[1].clone(),t[2].clone()];if(!o[0].isZero()){for(let t=1;t<3;++t)o[t].subThis(o[0]);o[0].setCoords(0,0)}const a=Me(o,e,0,n),h=qe(e,0,n),m=a.divide(h);if(r[0].assign(m),0===s)return;const l=[e[1]*e[0],e[2]*e[0]*.5,e[1]*e[2]],u=[t[1].sub(t[0]),t[2].sub(t[0]),t[2].sub(t[1])],c=h*h,g=Me(u,l,0,n).mul(2).divide(c);if(r[1].assign(g),1===s)return;const d=qe(e,1,n),_=2*h*d,p=Me(u,l,1,n).mul(2).sub(g.mul(_)).divide(c);if(r[2].assign(p),2===s)return;const f=Me(u,l,2,n).mul(2),P=2*(d*d+h*qe(e,2,n)),x=f.sub(p.mul(_).mul(2)).sub(g.mul(P)).divide(c);r[3].assign(x),3!==s&&(0,i.c)("")}(a,h,s,n,m);for(let i=0;i<=s;i++)r[i].setCoords(m[i].x,m[i].y)}function Me(t,e,s,n){if(0===s){if(n<=.5){const s=new o.P;(0,o.V)(2,t[0].mul(e[0]),t[1].mul(e[1]),n,s);const i=new o.P;(0,o.V)(2,t[1].mul(e[1]),t[2].mul(e[2]),n,i);const r=new o.P;return(0,o.V)(2,s,i,n,r),r}{const s=new o.P;(0,o.W)(2,t[0].mul(e[0]),t[1].mul(e[1]),n,s);const i=new o.P;(0,o.W)(2,t[1].mul(e[1]),t[2].mul(e[2]),n,i);const r=new o.P;return(0,o.W)(2,s,i,n,r),r}}if(1===s){const s=t[1].mul(e[1]),i=s.sub(t[0].mul(e[0])).mul(1-n).add(t[2].mul(e[2]).sub(s).mul(n));return i.mulThis(2),i}if(2===s){const s=t[1].mul(e[1]),n=t[2].mul(e[2]).sub(s).sub(s.sub(t[0].mul(e[0])));return n.mulThis(2),n}(0,i.c)("")}function Fe(t,e,s,n){if(n.toDouble()<=.5){const s=new v;(0,o.a1)(2,t[0].mulE(e[0]),t[1].mulE(e[1]),n,s);const i=new v;(0,o.a1)(2,t[1].mulE(e[1]),t[2].mulE(e[2]),n,i);const r=new v;return(0,o.a1)(2,s,i,n,r),r}{const s=new v;(0,o.a2)(2,t[0].mulE(e[0]),t[1].mulE(e[1]),n,s);const i=new v;(0,o.a2)(2,t[1].mulE(e[1]),t[2].mulE(e[2]),n,i);const r=new v;return(0,o.a2)(2,s,i,n,r),r}}function qe(t,e,s){if(0===e){const e=(0,o.q)(t[0],t[1],s),n=(0,o.q)(t[1],t[2],s);return(0,o.q)(e,n,s)}return 1===e?2*((1-s)*(t[1]-t[0])+(t[2]-t[1])*s):2===e?2*(t[2]-t[1]-(t[1]-t[0])):void(0,i.c)("")}function Ve(t,e,s){const n=(0,o.c)(s,0,1),i=(0,o.m)(o.P,4);if(Ge(t,e,3,n,i),i[1].isZero()){if(i[2].isZero())return i[3];{const t=i[2].clone();return 1===n&&t.negateThis(),t}}return i[1]}let Ye=class{constructor(t,e){this.len=0,this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-Ne(this.b,e,!1):0}getError(t){return(0,i.g)(0),0}};function Xe(t){const e=(0,o.m)(o.P,3),s=[0,0,0];return t.queryControlPoints(e),t.queryWeights(s),function(t,e){const s=us(e);if(1===s)return As(t);if(0===s)return 0;const n=[new o.P(0,0),t[1].sub(t[0]),t[2].sub(t[0])],r=n[1].crossProduct(n[2]);if(s<1){(0,i.g)(s>0);const t=1-s;let e;if(t<.01)e=-1/3+t*(2/15+t*(3/35+t*(16/315+t*(20/693+t*(16/1001+t*(56/6435))))));else{const n=t*(1+s),i=Math.atan2(Math.sqrt(t),Math.sqrt(1+s));e=s*(.5*s-(0,o.ak)(n)*i)/n}return r*e}{const t=(s-1)*(s+1);return.25*s/Math.pow(t,1.5)*(-2*s*Math.sqrt(t)*r-4*n[1].y*n[2].x*Math.atanh(Math.sqrt((s-1)/(s+1)))-n[1].x*n[2].y*Math.log(2*s*(s-Math.sqrt(t))-1))}}(e,s)}function ke(t){return function(t){return 256*(0,o.N)()*t}(t.calculateUpperLength2D())}function Re(t){return t.m_cachedValues}function He(t,e){t.m_cachedValues=e}function Le(t,e,s,n,i){const r=(0,o.m)(o.P,3);t.queryControlPoints(r);const a=[0,0,0];t.queryWeights(a);const h=[0];return 1===Be(r,a,e,o.E.unit(),n,i,1,h)?h[0]:Number.NaN}function Be(t,e,s,n,a,h,m,l){(0,i.w)(o.E.unit().contains(n)&&m>0,""),(h<0||Number.isNaN(h))&&(h=Number.MAX_VALUE);const u=new Array(3);for(let i=0;i<3;++i)u[i]=t[i].sub(s);const c=us(e),g=Ut.constructPoint2D(u[0]),d=Ut.constructPoint2D(u[1]),_=Ut.constructPoint2D(u[2]),p=o.M.constructDouble(c),f=p.clone();f.ldexpThis(1);const P=g.dotProduct(d.sub(g)).mul(p),x=p.mul(p.addDouble(2)),y=_.sub(d.mul(x.ldexp(1))),E=d.sqrLength().mul(p.mul(p).ldexp(1)).add(g.sqrLength().mul(p.ldexp(2).subDouble(1))).add(g.dotProduct(y)),C=_.sub(d.mul(f)).add(g.mul(f.subDouble(1))),S=d.mul(p).sub(g).dotProduct(C).mulDouble(3),v=d.dotProduct(_).mul(p.subDouble(3).mul(p)).ldexp(1),b=d.sqrLength().mul(p.mul(p).ldexp(2)),I=g.sqrLength().mul(p.ldexp(2).subDouble(3)),w=g.dotProduct(_.sub(d.mul(p.mulDouble(3).subDouble(1)).mul(p))).ldexp(1),D=_.sqrLength().addThis(v).addThis(b).addThis(I).addThis(w),T=g.add(_).sub(d.mul(f)),N=p.subDouble(1),A=_.sub(g).dotProduct(T).mul(N),G=new o.P(0,0),M=[];let F=new o.P;ms(u,e,n.vmin,F);let q=o.P.distance(F,G);if(q<=h&&M.push(new o.P(n.vmin,q)),n.vmin!==n.vmax&&(ms(u,e,n.vmax,F),q=o.P.distance(F,G),q<=h&&M.push(new o.P(n.vmax,q))),n.width()>0){const t=u[2].isZero(),s=(0,o.m)(o.M,4),i=$t(A,D,S,E,P,58,n,t,s);for(let r=0;r<i;r++){if(!n.containsExclusiveCoordinate(s[r].toDouble()))continue;let t=s[r].toDouble();t=cs(e,t);const i=new o.P;ms(u,e,t,i),q=o.P.distance(i,G),q<=h&&M.push(new o.P(t,q))}}if(a){(0,i.g)(n.equals(o.E.unit()));{ms(u,e,-1,F,!0);const t=new o.P;ms(u,e,0,t);const s=new $r({start:F,end:t}),n=s.getClosestCoordinate(G,!0);n<1&&(F=s.getCoord2D(n),q=o.P.distance(F,G),q<=h&&M.push(new o.P(n-1,q)))}{ms(u,e,2,F,!0);const t=new o.P;ms(u,e,n.vmax,t);const s=new $r({start:t,end:F}),i=s.getClosestCoordinate(G,!0);i>0&&(F=s.getCoord2D(i),q=o.P.distance(F,G),q<=h&&M.push(new o.P(1+i,q)))}}if(!M.length)return 0;M.sort(((t,e)=>t.compare(e)));let V=0;const Y=M[0].x;if(l[V++]=Y,V<m){const t=(0,r.x)(u,4,!1).total(),e=M[0].y;for(let s=1,n=M.length;s<n;s++)if(M[s].y>e+t){M.length=s;break}M.sort(((t,e)=>(0,o.X)(t.x,e.x))),V=0,l[V++]=M[0].x;for(let s=1,n=M.length;s<n;s++)M[s].x!==l[V-1]&&V<m&&(l[V++]=M[s].x)}return V}function Ue(t,e,s){const n=(0,o.m)(o.P,3);t.queryControlPoints(n);const i=[0,0,0];t.queryWeights(i),ze(n,i,e,s)}function ze(t,e,s,n){if(s.equalsRange(0,1))return void n.setFromPoints(t,3);const i=(0,o.m)(o.P,3);Qe(t,e,s.vmin,s.vmax,i,[0,0,0]),n.setFromPoints(i,3)}function Oe(t){const e=(0,o.Y)(t[0].y,t[1].y),s=(0,o.Y)(t[1].y,t[2].y);if(e>=0&&s>=0||e<=0&&s<=0){const e=(0,o.Y)(t[0].x,t[1].x),s=(0,o.Y)(t[1].x,t[2].x);if(e>=0&&s>=0||e<=0&&s<=0)return!0}return!1}function We(t){const e=(0,o.m)(o.P,3);t.queryControlPoints(e);const s=je(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function je(t){let e=!1;for(let s=0;s<2;s++){const n=(0,o.Y)(t[0][s],t[2][s]);n>0?((0,o.Y)(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),(0,o.Y)(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):n<0?((0,o.Y)(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),(0,o.Y)(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function Ze(t,e,s,n,a,h,m){(0,i.g)(s>=0&&s<=1&&n!==h&&a!==m),(0,i.g)(e[0]>0&&e[2]>0&&e[1]>=0);const l=[1,us(e),1],u=gs(e,s),c=(0,o.L)(t,3),g=(0,o.m)(r.h,3);os(c,l,g);const d=(0,o.m)(r.h,3),_=(0,o.m)(r.h,3);ds(g,u,n?d:null,h?_:null),_s(e,s,a,m);const p=Oe(c);if(n){for(let t=0;t<3;++t)hs(d[t],n[t]);fs(c,n),p&&je(n)}if(h){for(let t=0;t<3;++t)hs(_[t],h[t]);fs(c,h),p&&je(h)}}function Qe(t,e,s,n,a,h){if((0,i.g)(s>=0&&n<=1&&s<=n),s===n){const n=new o.P,i=as(t,e,s,n);return ps(t,n),a[0].assign(n),a[1].assign(n),a[2].assign(n),h[0]=i,h[1]=i,void(h[2]=i)}if(0===s&&1===n)return a[0].assign(t[0]),a[1].assign(t[1]),a[2].assign(t[2]),h[0]=e[0],h[1]=e[1],void(h[2]=e[2]);const m=(0,o.m)(r.h,3);{const i=[1,us(e),1],r=gs(e,s),o=gs(e,n);os(t,i,m),ds(m,o,m,null),ds(m,r>=o?1:r/o,null,m)}const l=[0,0,0];_s(e,n,l,null),_s(l,s/n,null,l);const u=Oe(t),c=(0,o.m)(o.P,3);hs(m[1],c[1]),ms(t,e,s,c[0]),ms(t,e,n,c[2]),fs(t,c);for(let i=0;i<3;++i)a[i].assign(c[i]),h[i]=l[i];u&&je(a)}function Ke(t,e,s){const n=us(e),i=[1,n,1],r=4*n/(3*(1+n));s[0].assign(t[0]),s[3].assign(t[2]),(0,o.Z)(t[0],t[1],r,s[1]),(0,o.Z)(t[2],t[1],r,s[2]),new $s({cp:s}),new Bt({points:t,weight:n});let a=0,h=.1,m=0;for(let l=0;l<9;l++,h+=.1){const e=new o.P;ms(t,i,h,e);const n=new o.P;bn(s,h,n);const r=o.P.sqrDistance(e,n);r>a&&(a=r,m=h)}{const e=new o.P;ms(t,i,m,e);const n=[0];Rn(s,e,o.E.unit(),!1,-1,1,n);const r=new o.P;return bn(s,n[0],r),a=o.P.sqrDistance(e,r),Math.sqrt(a)}}function Je(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==es(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function $e(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==ss(t,e,s,null,null,null,n,null!==i&&void 0!==i&&i,!0,!1)?4:0}function ts(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==is(t,e,s,null,null,null,n,null!==i&&void 0!==i&&i,!0,!1)?4:0}function es(t,e,s,n,r,a,h,m,l,u){if(null!==r&&(r.length=0),null!==a&&(a.length=0),null!==n&&(n.length=0),s.isDegenerate(0)){const t=[0,0],i=e.intersectPoint(s.getStartXY(),t,h);if(i>0){if(null!==r)for(let e=0;e<i;e++)r.push(t[e]);if(null!=a)for(let t=0;t<i;t++)a.push(0);if(null!=n)for(let s=0;s<i;s++){const i=new o.P;e.queryCoord2D(t[s],i),n.push(i)}}return i}const c=U(e,s);if(h=Math.max(h,c),e.isDegenerateToLineHelper(c)){const t=new $r({start:e.getStartXY(),end:e.getEndXY()}),i=ht(t,s,n,r,a,h,m,u);if(r)for(let s=0;s<i;++s){const n=t.getCoord2D(r[s]);r[s]=e.getClosestCoordinate(n,!1)}return i}if(z(e,s,h))return 0;const g=(0,o.m)(o.P,3);e.queryControlPoints(g);const d=[0,0,0];e.queryWeights(d);const _=[1,us(d),1],p=s.getEndXY().sub(s.getStartXY()),f=p.clone();f.leftPerpendicularThis();const P=g[0].clone(),x=g[1].clone(),y=g[2].clone(),E=x.sub(P),C=y.sub(P),S=y.sub(x),v=_[0],b=_[1],I=_[2],w=v*b,D=v*I,T=b*I,N=E.dotProduct(f)*w,A=C.dotProduct(f)*D;let G=N,M=A-2*N,F=S.dotProduct(f)*T+A-A;const q=(0,o.d)(13,Number.NaN),V=(0,o.d)(13,Number.NaN);let Y=St(F,M,G,o.E.unit(),!1,q);Y<0&&(q[0]=0,q[1]=1,Y=2);let X=0;for(let i=0,B=X;i<Y;++i){const t=new o.P;ms(g,_,q[i+B],t),V[X]=s.getClosestCoordinate(t,!1),o.P.distance(t,s.getCoord2D(V[X]))<=h&&(q[X]=q[i+B],X++)}const k=(0,o.m)(o.P,3),R=(0,o.m)(o.P,3);if(e.queryControlPoints(R),R[0].subThis(s.getStartXY()),R[1].subThis(s.getStartXY()),R[2].subThis(s.getStartXY()),function(t,e,s){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const i=(0,o.m)(o.P,3);n?(i[0].setCoordsPoint2D(t[0]),i[1].setCoordsPoint2D(t[1]),i[1].subThis(i[0]),i[2].setCoordsPoint2D(t[2]),i[2].subThis(i[0]),i[0].setCoords(0,0)):(i[0].setCoordsPoint2D(t[0]),i[1].setCoordsPoint2D(t[1]),i[2].setCoordsPoint2D(t[2])),i[0].mulThis(e[0]),i[1].mulThis(e[1]),i[2].mulThis(e[2]),s[1].setCoords(i[1].x-i[0].x,i[1].y-i[0].y),s[2].setCoordsPoint2D(i[2].sub(i[1])),s[2].subThis(s[1]),s[1].x*=2,s[1].y*=2,s[0].setCoordsPoint2D(i[0])}(R,_,k,!1),Math.abs(p.x)>=Math.abs(p.y)){const t=p.y/p.x;F=k[2].y-k[2].x*t,M=k[1].y-k[1].x*t,G=k[0].y-k[0].x*t}else{const t=p.x/p.y;F=k[2].x-k[2].y*t,M=k[1].x-k[1].y*t,G=k[0].x-k[0].y*t}const H=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),L=[0,0];Y=St(F,M,G,o.E.unit(),H,L);for(let i=0,B=X;i<Y;++i){q[i+B]=L[i];const t=new o.P;ms(g,_,q[i+B],t),V[X]=s.getClosestCoordinate(t,!1),o.P.distance(t,s.getCoord2D(V[X]))<=h&&(q[X]=q[i+B],X++)}(0,i.g)(X<q.length+4);for(let i=0;i<X;i++)q[i]=cs(d,q[i]);Y=e.intersectPoint(s.getStartXY(),L,h);for(let i=0;i<Y;i++)q[X]=L[i],V[X++]=0;Y=e.intersectPoint(s.getEndXY(),L,h);for(let i=0;i<Y;i++)q[X]=L[i],V[X++]=1;Y=s.intersectPoint(e.getStartXY(),L,h);for(let i=0;i<Y;i++)V[X]=L[i],q[X++]=0;Y=s.intersectPoint(e.getEndXY(),L,h);for(let i=0;i<Y;i++)V[X]=L[i],q[X++]=1;return 0===X?0:Zr(t,e,s,q,V,X,n,r,a,h,m,l,u)}function ss(t,e,s,n,i,r,a,m,l,u){if(Zi(s))return es(t,e,new $r({start:s.getStartXY(),end:s.getEndXY()}),n,i,r,a,m,l,u);const c=U(e,s);if(z(e,s,a=Math.max(a,c)))return 0;const g=[],d=[],_=(0,o.m)(o.P,4);{e.queryControlPoints(_);const t=(0,o.m)(o.P,4),n=new h.T;s.canonicToWorldTransformation(n);const i=new h.T;i.setInvert(n),i.transformPoints2D(_,4,t);const r=(0,o.m)(o.M,3),m=(0,o.m)(o.M,3),l=(0,o.m)(o.M,3),u=[0,0,0];e.queryWeights(u),rs(t,u,r,m,l);const c=(0,o.m)(o.M,3);c[0].setDouble(s.getSemiMinorAxis()),c[0].sqrThis(),c[1].setDouble(s.getSemiMajorAxis()),c[1].sqrThis(),c[2].setThis(c[0]),c[2].mulThis(c[1]),c[2].negateThis();const p=Zt(r,2,m,2,l,2,c,!0,o.E.unit(),o.E.unit(),g);if(p>0){let t=0;for(let n=0;n<p;n++){const i=new o.P;e.queryCoord2D(g[n],i);const r=s.getClosestCoordinate(i,!1),h=new o.P;s.queryCoord2D(r,h),o.P.distance(i,h)<=a&&(g[t]=g[n],d.push(r),t++)}g.length=t}}const p=[0,1];for(let h=0;h<2;h++){const t=0===h?s.getStartXY():s.getEndXY(),n=Le(e,t,o.E.unit(),!1,-1),i=new o.P;e.queryCoord2D(n,i),o.P.distance(t,i)<=a&&(g.push(n),d.push(p[h]))}for(let h=0;h<2;h++){const t=[0,3];{const e=s.getClosestCoordinate(_[t[h]],!1),n=new o.P;s.queryCoord2D(e,n),o.P.distance(_[t[h]],n)<=a&&(g.push(p[h]),d.push(e))}}return Zr(t,e,s,g,d,g.length,n,i,r,a,m,l,u)}function ns(t,e,s,n,r,a,h,m,l,u){const c=(0,o.m)(o.P,3);e.queryControlPoints(c);const g=(0,o.m)(o.P,3);if(s.queryControlPoints(g),O(c,g,3)<0)return ns(t,s,e,n,a,r,h,m,l,!u);const d=U(e,s);if(e.isDegenerateToLineHelper(d)){const i=new $r({start:e.getStartXY(),end:e.getEndXY()}),o=es(t,s,i,n,a,r,h,m,l,!u);if(r)for(let t=0;t<o;++t){const s=i.getCoord2D(r[t]);r[t]=e.getClosestCoordinate(s,!1)}return o}if(s.isDegenerateToLineHelper(d)){const i=new $r({start:s.getStartXY(),end:s.getEndXY()}),o=es(t,e,i,n,r,a,h,m,l,u);if(a)for(let t=0;t<o;++t){const e=i.getCoord2D(a[t]);a[t]=s.getClosestCoordinate(e,!1)}return o}if(z(e,s,h=Math.max(h,d)))return 0;const _=(0,o.d)(3,Number.NaN);e.queryWeights(_);const p=(0,o.d)(3,Number.NaN);s.queryWeights(p);const f=[1,us(_),1],P=[1,us(p),1],x=new o.E(0,1),y=new o.E(0,1);{const t=E.constructEmpty();ze(c,f,new o.E(0,1),t);const e=E.constructEmpty();ze(g,P,new o.E(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*h),e.inflate(3*h),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(ls(c,f,t,x),ls(g,P,t,y),x.isEmpty()||y.isEmpty())return 0;Qe(c,f,x.vmin,x.vmax,c,f),Qe(g,P,y.vmin,y.vmax,g,P)}}const C=Kr(c,2,g,2,h);if(0===C)return 0;const S=[],v=[];if(-1===C){const t=(0,o.m)(o.M,3),e=(0,o.m)(o.M,3),s=(0,o.m)(o.M,3);rs(c,f,t,e,s);const n=(0,o.m)(o.M,3),i=(0,o.m)(o.M,3),r=(0,o.m)(o.M,3);rs(g,P,n,i,r);const a=[],m=[],l=jt(t,2,e,2,s,2,n,2,i,2,r,2,!0,o.E.unit(),o.E.unit(),a,m);if(l>0)for(let u=0;u<l;u++){const t=new o.P;ms(g,P,m[u],t);const e=new o.P;ms(c,f,a[u],e),o.P.distance(e,t)<=h&&(S.push(a[u]),v.push(m[u]))}}for(let E=0;E<2;E++){let t,e,s;0===E?(t=c,e=g,s=P):(t=g,e=c,s=f);for(let n=0;n<2;n++){const r=0===n?0:t.length-1,a=new o.P,m=[0],l=Be(e,s,t[r],o.E.unit(),!1,-1,1,m);(0,i.g)(1===l),ms(e,s,m[0],a),o.P.distance(t[r],a)<=h&&(0===E?(S.push(0===r?0:1),v.push(m[0])):(v.push(0===r?0:1),S.push(m[0])))}}if(0===S.length)return 0;if(!x.equalsRange(0,1))for(let i=0;i<S.length;++i)S[i]=Bt.recalculateParentT(x.vmin,x.vmax,S[i]);if(!y.equalsRange(0,1))for(let i=0;i<v.length;++i)v[i]=Bt.recalculateParentT(y.vmin,y.vmax,v[i]);for(let i=0;i<S.length;++i)S[i]=cs(_,S[i]);for(let i=0;i<v.length;++i)v[i]=cs(p,v[i]);return Zr(t,e,s,S,v,S.length,n,r,a,h,m,l,u)}function is(t,e,s,n,i,r,a,h,m,l){if(e.isLine())return Us(t,s,new $r({start:e.getStartXY(),end:e.getEndXY()}),n,r,i,a,h,m,!l);if(s.isLine())return es(t,e,new $r({start:s.getStartXY(),end:s.getEndXY()}),n,i,r,a,h,m,l);const u=U(e,s);if(z(e,s,a=Math.max(a,u)))return 0;const c=(0,o.m)(o.P,3);e.queryControlPoints(c);const g=(0,o.m)(o.P,3);s.queryControlPoints(g);const d=Kr(c,2,g,2,a);if(0===d)return 0;const _=[],p=[];if(-1===d){const t=(0,o.m)(o.M,3),n=(0,o.m)(o.M,3),i=(0,o.m)(o.M,3),r=[0,0,0];e.queryWeights(r),rs(c,r,t,n,i);const h=(0,o.m)(Ut,3);js(g,h);const m=jt(t,2,n,2,i,2,[h[0].x,h[1].x,h[2].x],2,[h[0].y,h[1].y,h[2].y],2,null,0,!0,o.E.unit(),o.E.unit(),_,p);if(m>0){let t=0;for(let n=0;n<m;n++){const i=new o.P;s.queryCoord2D(p[n],i);const r=new o.P;e.queryCoord2D(_[n],r),o.P.distance(r,i)<=a&&(_[t]=_[n],p[t]=p[n],t++)}_.length=t,p.length=t}}for(let f=0;f<2;f++){let t;t=0===f?c:g;for(let n=0;n<2;n++){const i=0===n?0:t.length-1;let r;const h=new o.P;0===f?(r=Fs(s,t[i],o.E.unit(),!1),s.queryCoord2D(r,h)):(r=Le(e,t[i],o.E.unit(),!1,-1),e.queryCoord2D(r,h)),o.P.distance(t[i],h)<=a&&(0===f?(_.push(0===i?0:1),p.push(r)):(p.push(0===i?0:1),_.push(r)))}}return Zr(t,e,s,_,p,_.length,n,i,r,a,h,m,l)}function rs(t,e,s,n,i){const r=o.M.constructDouble(e[0]),a=o.M.constructDouble(e[1]),h=o.M.constructDouble(e[2]);s[0].setDouble(t[0].x),s[0].mulThis(r),s[1].setDouble(t[1].x),s[1].mulThis(a),s[2].setDouble(t[2].x),s[2].mulThis(h),s[2].subThis(s[1]),s[1].subThis(s[0]),s[2].subThis(s[1]),s[1].ldexpThis(1),n[0].setDouble(t[0].y),n[0].mulThis(r),n[1].setDouble(t[1].y),n[1].mulThis(a),n[2].setDouble(t[2].y),n[2].mulThis(h),n[2].subThis(n[1]),n[1].subThis(n[0]),n[2].subThis(n[1]),n[1].ldexpThis(1),i[0].setDouble(e[0]),i[1].setDouble(e[1]),i[2].setThis(i[1]),i[2].ldexpThis(1),i[2].negateThis(),i[2].addThis(i[0]),i[2].addDoubleThis(e[2]),i[1].subThis(i[0]),i[1].ldexpThis(1)}function os(t,e,s){for(let n=0;n<3;++n)s[n].setCoordsPoint2DZ(t[n].mul(e[n]),e[n])}function as(t,e,s,n){if(0===s)return n.assign(t[0]),e[0];if(1===s)return n.assign(t[2]),e[2];const i=[t[0].x*e[0],t[1].x*e[1],t[2].x*e[2]],r=[t[0].y*e[0],t[1].y*e[1],t[2].y*e[2]],a=[e[0],e[1],e[2]],h=s;let m,l,u;if(s<=.5){const t=(0,o.Q)(i[0],i[1],h),e=(0,o.Q)(i[1],i[2],h);m=(0,o.q)(t,e,h);const s=(0,o.Q)(r[0],r[1],h),n=(0,o.Q)(r[1],r[2],h);l=(0,o.q)(s,n,h);const c=(0,o.Q)(a[0],a[1],h),g=(0,o.Q)(a[1],a[2],h);u=(0,o.Q)(c,g,h)}else{const t=(0,o.R)(i[0],i[1],h),e=(0,o.R)(i[1],i[2],h);m=(0,o.R)(t,e,h);const s=(0,o.R)(r[0],r[1],h),n=(0,o.R)(r[1],r[2],h);l=(0,o.R)(s,n,h);const c=(0,o.R)(a[0],a[1],h),g=(0,o.R)(a[1],a[2],h);u=(0,o.R)(c,g,h)}return m/=u,l/=u,n.setCoords(m,l),ps(t,n),u}function hs(t,e){return e.setCoords(t.x/t.z,t.y/t.z),t.z}function ms(t,e,s,n,i){if(i){if(s<0)return void tt(new $r({start:t[0],end:t[0].add(Ve(t,e,0).getUnitVector())}),s,n);if(s>1)return void tt(new $r({start:t[2],end:t[2].add(Ve(t,e,1).getUnitVector())}),s-1,n)}as(t,e,s,n)}function ls(t,e,s,n){n.setEmpty();const i=[];i.push(new o.E(0,1));const r=.5*Math.max(s.width(),s.height());for(;i.length;){const a=i.at(-1);i.pop();const h=new E;if(ze(t,e,a,h),h.isIntersectingW(s)){const t=Math.max(h.width(),h.height());if(s.containsW(h)||t<=r||a.width()<1e-12)n.merge(a);else{const t=a.getCenter();i.push(o.E.construct(a.vmin,t)),i.push(o.E.construct(t,a.vmax))}}}}function us(t){return t[1]/Math.sqrt(t[0]*t[2])}function cs(t,e){const s=Math.sqrt(t[2]/t[0]);return e/(0,o.q)(s,1,e)}function gs(t,e){const s=Math.sqrt(t[0]/t[2]);return e/(0,o.q)(s,1,e)}function ds(t,e,s,n){(0,i.g)(e>=0&&e<=1),(new r.h).setCoordsPoint3D(t[0]),(new r.h).setCoordsPoint3D(t[1]),(new r.h).setCoordsPoint3D(t[2]);const a=new r.h,h=new r.h,m=new r.h;(0,o.a0)(3,t[0],t[1],e,a),(0,o.a0)(3,t[1],t[2],e,h),(0,o.a0)(3,a,h,e,m);const l=t[2].clone();s&&(s[0].assign(t[0]),s[1].assign(a),s[2].assign(m)),n&&(n[0].assign(m),n[1].assign(h),n[2].assign(l))}function _s(t,e,s,n){const r=[t[0],t[1],t[2]];(0,i.g)(e>=0&&e<=1&&s!==n);const a=(0,o.q)(r[0],r[1],e),h=(0,o.q)(r[1],r[2],e),m=(0,o.q)(a,h,e);s&&(s[0]=r[0],s[1]=a,s[2]=m),n&&(n[0]=m,n[1]=h,n[2]=r[2])}function ps(t,e){const s=o.E.constructEmpty();s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e.x=(0,o.c)(e.x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e.y=(0,o.c)(e.y,s.vmin,s.vmax)}function fs(t,e){const s=new o.E;s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e[0].x=(0,o.c)(e[0].x,s.vmin,s.vmax),e[1].x=(0,o.c)(e[1].x,s.vmin,s.vmax),e[2].x=(0,o.c)(e[2].x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e[0].y=(0,o.c)(e[0].y,s.vmin,s.vmax),e[1].y=(0,o.c)(e[1].y,s.vmin,s.vmax),e[2].y=(0,o.c)(e[2].y,s.vmin,s.vmax)}class Ps{constructor(){this.area=Number.NaN,this.centroid_x=Number.NaN,this.centroid_y=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}class xs{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-vs(this.b,e,!1):0}getError(t){return(0,i.g)(0),0}}function ys(t,e,s,n,i){let r=!0;const a=(0,o.m)(o.P,3);t.queryControlPoints(a);let h=r?0:1,m=a[1][h]-a[0][h],l=a[2][h]-a[0][h];const u=Pe(5,e,s,n,i,(t=>{let e;if(t<=.5){const s=(0,o.Q)(0,m,t),n=(0,o.Q)(m,l,t);e=(0,o.Q)(s,n,t)}else{const s=(0,o.R)(0,m,t),n=(0,o.R)(m,l,t);e=(0,o.R)(s,n,t)}return e*Ts(a,1,t).length()}));r=!1,h=r?0:1,m=a[1][h]-a[0][h],l=a[2][h]-a[0][h];const c=Pe(5,e,s,n,i,(t=>{let e;if(t<=.5){const s=(0,o.Q)(0,m,t),n=(0,o.Q)(m,l,t);e=(0,o.Q)(s,n,t)}else{const s=(0,o.R)(0,m,t),n=(0,o.R)(m,l,t);e=(0,o.R)(s,n,t)}return e*Ts(a,1,t).length()}));return new o.P(u,c)}function Es(t){t.m_cachedValues=null}function Cs(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new Ps;return Ss(t,e.specialPoints),Ms(t,e),e}function Ss(t,e){const s=(0,o.m)(o.P,3);t.queryControlPoints(s);const n=(0,o.m)(o.F,8);n[0].set(0);let i=1;{const t=(0,o.m)(o.F,3);!function(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=0,i=new o.F(t[1][n]).subE(new o.F(t[0][n]));e[1]=i.mul(2),e[2]=new o.F(t[2][n]).subE(new o.F(t[1][n])).subE(i),s?e[0].set(0):e[0].set(t[0][n])}(s,t,!1);const e=(0,o.m)(o.F,2),r=new o.E(0,1);let a=Nt(t[2].mul(2),t[1],r,e[0]);a<0&&(a=0);for(let s=0;s<a;s++)(0,o.J)(e[s].value(),0,1)||(n[i]=e[s],i++)}{const t=(0,o.m)(o.F,3);!function(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=1,i=new o.F(t[1][n]).subE(new o.F(t[0][n]));e[1]=i.mul(2),e[2]=new o.F(t[2][n]).subE(new o.F(t[1][n])).subE(i),s?e[0].set(0):e[0].set(t[0][n])}(s,t,!1);const e=(0,o.m)(o.F,2),r=new o.E(0,1);let a=Nt(t[2].mul(2),t[1],r,e[0]);a<0&&(a=0);for(let s=0;s<a;s++)(0,o.J)(e[s].value(),0,1)||(n[i]=e[s],i++)}if(n[i].set(1),i++,i>2){(0,o.C)(n,0,i,((t,e)=>t.value()-e.value()));let t=0,e=n[0].value(),s=1;for(let r=1;r<i;r++)n[r].eq(n[r-1])?(e+=n[r].value(),s++):(s>1&&(e/=s,n[t].set(e)),t++,n[t]=n[r],e=n[r].value(),s=1);t++,i=t}n[0].set(0),n[i-1].set(1),e.length=i;for(let r=0;r<i;r++)e[r]=n[r].value()}function vs(t,e,s){const n=(0,o.m)(o.P,3);return t.queryControlPoints(n),bs(n,e,s)}function bs(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+bs(t,1,!1)}if(1===e)return Is(t);const n=(0,o.m)(o.P,3);return Rs(t,e,n,null),Is(n)}function Is(t){if(t[0].equals(t[1]))return o.P.distance(t[2],t[0]);if(t[1].equals(t[2]))return o.P.distance(t[0],t[2]);const e=o.P.distance(t[0],t[1])+o.P.distance(t[2],t[1]),s=o.P.distance(t[0],t[2]);if(e-s<=e*Number.EPSILON)return s;const n=(0,o.m)(o.P,3);Ws(t,n,!0);const i=4*((0,o.s)(n[2].x)+(0,o.s)(n[2].y)),r=2*(n[2].x*n[1].x+n[2].y*n[1].y),a=(0,o.s)(n[1].x)+(0,o.s)(n[1].y);if(1e-14*(Math.abs(r)+Math.abs(a))>=Math.abs(i))return 1e-14*Math.abs(a)>=Math.abs(r)?1*Math.sqrt(a):2/(3*r)*(Math.pow(1*r+a,1.5)-Math.pow(a,1.5));const h=r/i,m=a/i,l=m-h*h,u=1+h;if(0===l)return h>=0&&u>=0||h<=0&&u<=0?Math.abs(.5*Math.sqrt(i)*(u*u-h*h)):.5*Math.sqrt(i)*(u*u+h*h);const c=Math.sqrt(l+u*u),g=Math.sqrt(m);return.5*Math.sqrt(i)*(u*c-h*g+l*Math.log(Math.abs((u+c)/(h+g))))}function ws(t,e){const s=(0,o.c)(e,0,1);let n=Ts(t,1,s);return n.isZero()&&(n=Ts(t,2,s)),n}function Ds(t,e,s){const n=(0,o.m)(o.P,3);return t.queryControlPoints(n),Ts(n,e,s)}function Ts(t,e,s){if(1===e){const e=t[1].sub(t[0]).mul(1-s).add(t[2].sub(t[1]).mul(s));return e.mulThis(2),e}return 2===e?t[2].sub(t[1]).sub(t[1].sub(t[0]).mul(2)):o.P.construct(0,0)}function Ns(t){const e=(0,o.m)(o.P,3);return t.queryControlPoints(e),As(e)}function As(t){return-t[1].sub(t[0]).crossProduct(t[2].sub(t[0]))/3}function Gs(t){return t.m_cachedValues}function Ms(t,e){t.m_cachedValues=e}function Fs(t,e,s,n,r){(0,i.w)(o.E.unit().contains(s),"QuadraticBezierHelper::getClosestCoordinateSegment");const a=(0,o.m)(o.P,3);t.queryControlPoints(a);let h=Number.MAX_VALUE;const m=[0],l=qs(a,e,m);if(s.containsCoordinate(m[0]))h=o.P.distance(e,l);else{m[0]=s.vmin,Zs(a,m[0],l),h=o.P.distance(l,e);const t=new o.P;Zs(a,s.vmax,t);const n=o.P.distance(t,e);h>n&&(l.setCoordsPoint2D(t),m[0]=s.vmax,h=n)}if(!n)return m[0];if(s.vmin<=0){const n=new o.P;t.queryCoord2DExtended(-1,n,!0);const i=new o.P;t.queryCoord2D(s.vmin,i);const r=new $r({start:n,end:i}),a=r.getClosestCoordinate(e,!0);if(a<1){const t=r.getCoord2D(a),s=o.P.distance(t,e);s<h&&(h=s,m[0]=a-1,l.assign(t))}}if(s.vmin>=1){const n=new o.P;t.queryCoord2DExtended(2,n,!0);const i=new o.P;t.queryCoord2D(s.vmax,i);const r=new $r({start:i,end:n}),a=r.getClosestCoordinate(e,!0);if(a>0){const t=r.getCoord2D(a),s=o.P.distance(t,e);s<h&&(h=s,m[0]=1+a,l.assign(t))}}return m[0]}function qs(t,e,s){const n=t[2].sub(t[1]).sub(t[1].sub(t[0])),i=t[1].sub(t[0]),r=t[0].sub(e),a=r.dotProduct(i),h=r.dotProduct(n)+2*i.dotProduct(i),m=3*i.dotProduct(n),l=n.dotProduct(n),u=(0,o.d)(3,Number.NaN),c=vt(l,m,h,a,o.E.unit(),!1,u),g=t[0].clone();let d=0,_=o.P.sqrDistance(t[0],e),p=o.P.sqrDistance(t[2],e);p<_&&(d=1,g.assign(t[2]),_=p);for(let f=0;f<c;f++){const s=new o.P;Zs(t,u[f],s),p=o.P.sqrDistance(s,e),p<_&&(_=p,g.assign(s),d=u[f])}return s&&(s[0]=d),g}function Vs(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,3);const n=(0,o.m)(o.P,3);Hs(t,e.vmin,e.vmax,n),s.setFromPoints(n,3)}function Ys(t,e,s){s.setEmpty();const n=[];n.push(new o.E(0,1));const i=.5*Math.max(e.width(),e.height());for(;n.length;){const r=n.at(-1);n.pop();const a=new E;if(Vs(t,r,a),a.isIntersectingW(e)){const t=Math.max(a.width(),a.height());if(e.containsW(a)||t<=i||r.width()<1e-12)s.merge(r);else{const t=r.getCenter();n.push(o.E.construct(r.vmin,t)),n.push(o.E.construct(t,r.vmax))}}}}function Xs(t){const e=(0,o.m)(o.P,3);t.queryControlPoints(e);const s=ks(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function ks(t){let e=!1;for(let s=0;s<2;s++){const n=(0,o.Y)(t[0][s],t[2][s]);n>0?((0,o.Y)(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),(0,o.Y)(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):n<0?((0,o.Y)(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),(0,o.Y)(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function Rs(t,e,s,n){(new o.P).setCoordsPoint2D(t[0]),(new o.P).setCoordsPoint2D(t[1]),(new o.P).setCoordsPoint2D(t[2]);const i=new o.P,r=new o.P,a=new o.P;if((0,o.Z)(t[0],t[1],e,i),(0,o.Z)(t[1],t[2],e,r),(0,o.Z)(i,r,e,a),s&&(s[0].assign(t[0]),s[1].assign(i),s[2].assign(a)),n){const e=t[2];n[0].assign(a),n[1].assign(r),n[2].assign(e)}}function Hs(t,e,s,n){if(e===s){const s=new o.P;return Zs(t,e,s),n[0]=s,n[1]=s,void(n[2]=s)}const i=(0,o.m)(o.P,3);Rs(t,s,i,null),Rs(i,e/s,null,i),Zs(t,e,i[0]),Zs(t,s,i[2]),n[0].setCoordsPoint2D(i[0]),n[1].setCoordsPoint2D(i[1]),n[2].setCoordsPoint2D(i[2])}function Ls(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==Us(t,e,s,null,null,null,n,null!==i&&void 0!==i&&i,!0,!1)?4:0}function Bs(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==zs(t,e,s,null,null,null,n,null!==i&&void 0!==i&&i,!0,!1)?4:0}function Us(t,e,s,n,r,a,h,m,l,u){if(null!=r&&(r.length=0),null!==a&&(a.length=0),null!==n&&(n.length=0),s.isDegenerate(0)){const t=[0,0],i=e.intersectPoint(s.getStartXY(),t,h);if(i>0){if(null!==r)for(let e=0;e<i;e++)r.push(t[e]);if(null!==a)for(let t=0;t<i;t++)a.push(0);if(null!==n)for(let s=0;s<i;s++){const i=new o.P;e.queryCoord2D(t[s],i),n.push(i)}}return i}const c=U(e,s);if(h=Math.max(h,c),e.isDegenerateToLineHelper(c)){const t=new $r({start:e.getStartXY(),end:e.getEndXY()}),i=ht(t,s,n,r,a,h,m,u);if(r)for(let s=0;s<i;++s){const n=t.getCoord2D(r[s]);r[s]=e.getClosestCoordinate(n,!1)}return i}if(z(e,s,h))return 0;const g=Ut.constructPoint2D(s.getStartXY()),d=Ut.constructPoint2D(s.getEndXY()).sub(g),_=d.clone();_.leftPerpendicularThis();const p=Ut.constructPoint2D(e.m_cp).sub(Ut.constructPoint2D(e.getStartXY())),f=Ut.constructPoint2D(e.getEndXY()).sub(Ut.constructPoint2D(e.m_cp));let P=p.dotProduct(_).toDouble(),x=f.sub(p).dotProduct(_).toDouble();const y=(0,o.d)(12,Number.NaN),E=(0,o.d)(12,Number.NaN);let C=function(t,e,s,n){const i=new o.F,r=Nt(new o.F(t),new o.F(e),s,i);return n[0]=i.value(),r}(x,P,o.E.unit(),y);C<0&&(y[0]=0,y[1]=1,C=2);let S,v=0;for(let i=0,D=v;i<C;++i){const t=e.getCoord2D(y[i+D]);E[v]=s.getClosestCoordinate(t,!1),o.P.distance(t,s.getCoord2D(E[v]))<=h&&(y[v]=y[i+D],v++)}const b=(0,o.m)(o.P,3);e.queryControlPoints(b);{const t=(0,o.m)(Ut,3);if(js(b,t,!1),t[0]=t[0].sub(g),d.x.abs().gte(d.y.abs())){const e=d.y.div(d.x);x=t[2].y.sub(t[2].x.mul(e)).toDouble(),P=t[1].y.sub(t[1].x.mul(e)).toDouble(),S=t[0].y.sub(t[0].x.mul(e)).toDouble()}else{const e=d.x.div(d.y);x=t[2].x.sub(t[2].y.mul(e)).toDouble(),P=t[1].x.sub(t[1].y.mul(e)).toDouble(),S=t[0].x.sub(t[0].y.mul(e)).toDouble()}}const I=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),w=[0,0];C=St(x,P,S,o.E.unit(),I,w);for(let i=0,D=v;i<C;++i){y[i+D]=w[i];const t=e.getCoord2D(y[i+D]);E[v]=s.getClosestCoordinate(t,!1),o.P.distance(t,s.getCoord2D(E[v]))<=h&&(y[v]=y[i+D],v++)}(0,i.g)(v<y.length+4),C=e.intersectPoint(s.getStartXY(),w,h);for(let i=0;i<C;i++)y[v]=w[i],E[v++]=0;C=e.intersectPoint(s.getEndXY(),w,h);for(let i=0;i<C;i++)y[v]=w[i],E[v++]=1;C=s.intersectPoint(e.getStartXY(),w,h);for(let i=0;i<C;i++)E[v]=w[i],y[v++]=0;C=s.intersectPoint(e.getEndXY(),w,h);for(let i=0;i<C;i++)E[v]=w[i],y[v++]=0;return 0===v?0:Zr(t,e,s,y,E,v,n,r,a,h,m,l,u)}function zs(t,e,s,n,i,r,a,m,l,u){if(Zi(s))return Us(t,e,new $r({start:s.getStartXY(),end:s.getEndXY()}),n,i,r,a,m,l,u);const c=U(e,s);if(z(e,s,a=Math.max(a,c)))return 0;const g=[],d=[],_=(0,o.m)(o.P,3);{e.queryControlPoints(_);const t=(0,o.m)(o.P,3),n=new h.T;s.canonicToWorldTransformation(n);const i=new h.T;i.setInvert(n),i.transformPoints2D(_,3,t);const r=(0,o.m)(Ut,3);js(t,r);const m=[r[0].x,r[1].x,r[2].x],l=[r[0].y,r[1].y,r[2].y],u=(0,o.m)(o.M,3);u[0].setDouble(s.getSemiMinorAxis()),u[0].sqrThis(),u[1].setDouble(s.getSemiMajorAxis()),u[1].sqrThis(),u[2]=u[0],u[2].mul(u[1]),u[2].negate();const c=Zt(m,2,l,2,null,0,u,!0,o.E.unit(),o.E.unit(),g);if(c>0){let t=0;for(let n=0;n<c;n++){const i=new o.P;e.queryCoord2D(g[n],i);const r=s.getClosestCoordinate(i,!1),h=new o.P;s.queryCoord2D(r,h),o.P.distance(i,h)<=a&&(g[t]=g[n],d.push(r),t++)}g.length=t}}const p=[0,1];for(let h=0;h<2;h++){const t=0===h?s.getStartXY():s.getEndXY(),e=[0];qs(_,t,e);const n=new o.P;Zs(_,e[0],n),o.P.distance(t,n)<=a&&(g.push(e[0]),d.push(p[h]))}for(let h=0;h<2;h++){const t=[0,2];{const e=s.getClosestCoordinate(_[t[h]],!1),n=new o.P;s.queryCoord2D(e,n),o.P.distance(_[t[h]],n)<=a&&(g.push(p[h]),d.push(e))}}return Zr(t,e,s,g,d,g.length,n,i,r,a,m,l,u)}function Os(t,e,s,n,i,r,a,h,m,l){const u=(0,o.m)(o.P,3);e.queryControlPoints(u);const c=(0,o.m)(o.P,3);if(s.queryControlPoints(c),O(u,c,3)<0)return Os(t,s,e,n,r,i,a,h,m,!l);const g=U(e,s);if(z(e,s,a=Math.max(a,g)))return 0;if(function(t,e,s,n,i,r,a,h,m){const l=(0,o.m)(o.P,3);t.queryControlPoints(l);const u=(0,o.m)(o.P,3);if(e.queryControlPoints(u),l[0].equals(u[0])){if(l[1].equals(u[1])&&l[2].equals(u[2]))return s&&(s.length=0,s.push(l[0]),s.push(l[2])),n&&(n.length=0,n.push(0),n.push(1)),i&&(i.length=0,i.push(0),i.push(1)),!0;if(!l[0].equals(u[2]))return!1}return!!(l[0].equals(u[2])&&l[1].equals(u[1])&&l[2].equals(u[0]))&&(n&&(n.length=0,n.push(0),n.push(1),m&&(n[1]=(0,o.b)(n[0],n[0]=n[1]))),i&&(i.length=0,i.push(1),i.push(0),m&&(i[1]=(0,o.b)(i[0],i[0]=i[1]))),s&&(s.length=0,s.push(l[0]),s.push(l[2]),m&&(s[1]=(0,o.b)(s[0],s[0]=s[1]))),!0)}(e,s,n,i,r,0,0,0,l))return 2;const d=new o.E(0,1),_=new o.E(0,1);{const t=new E;Vs(u,o.E.unit(),t);const e=new E;Vs(c,o.E.unit(),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Ys(u,t,d),Ys(c,t,_),d.isEmpty()||_.isEmpty())return 0;Hs(u,d.vmin,d.vmax,u),Hs(c,_.vmin,_.vmax,c)}}const p=Kr(u,2,c,2,a);if(0===p)return 0;const f=[],P=[];if(-1===p){const t=(0,o.m)(Ut,3);js(u,t);const e=[t[0].x,t[1].x,t[2].x],s=[t[0].y,t[1].y,t[2].y],n=(0,o.m)(Ut,3);js(c,n);const i=jt(e,2,s,2,null,0,[n[0].x,n[1].x,n[2].x],2,[n[0].y,n[1].y,n[2].y],2,null,0,!0,o.E.unit(),o.E.unit(),f,P,l);if(i>0){let t=0;for(let e=0;e<i;e++){const s=new o.P,n=new o.P;Zs(c,P[e],n),Zs(u,f[e],s),o.P.distance(s,n)<=a&&(f[t]=f[e],P[t]=P[e],t++)}f.length=t,P.length=t}}for(let x=0;x<2;x++){const t=0===x?u:c,e=0===x?c:u;for(let s=0;s<2;s++){const n=0===s?0:2,i=[0];qs(e,t[n],i);const r=new o.P;Zs(e,i[0],r),o.P.distance(t[n],r)<=a&&(0===x?(f.push(0===n?0:1),P.push(i[0])):(P.push(0===n?0:1),f.push(i[0])))}}if(0===f.length)return 0;if(!d.equalsRange(0,1))for(let o=0;o<f.length;++o)f[o]=Ht.recalculateParentT(d.vmin,d.vmax,f[o]);if(!_.equalsRange(0,1))for(let o=0;o<P.length;++o)P[o]=Ht.recalculateParentT(_.vmin,_.vmax,P[o]);return Zr(t,e,s,f,P,f.length,n,i,r,a,h,m,l)}function Ws(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=t[1].sub(t[0]);e[1].assign(n.mul(2)),e[2].assign(t[2].sub(t[1]).sub(n)),s?e[0].setCoords(0,0):e[0].assign(t[0])}function js(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Ut.constructPoint2D(t[1]),i=n.sub(Ut.constructPoint2D(t[0]));e[1]=i.mul(o.M.constructInt32(2)),e[2]=Ut.constructPoint2D(t[2]).sub(n).sub(i),e[0]=s?new Ut(o.ad,o.ad):Ut.constructPoint2D(t[0])}function Zs(t,e,s,n){if(n){if(e<0)return void tt(new $r({start:t[0],end:t[0].add(ws(t,0).getUnitVector())}),e,s);if(e>1)return void tt(new $r({start:t[2],end:t[2].add(ws(t,1).getUnitVector())}),e-1,s)}if(e<=.5){const n=t[1].clone(),i=new o.P;(0,o.V)(2,t[0],n,e,i);const r=new o.P;(0,o.V)(2,n,t[2],e,r);const a=new o.P;(0,o.V)(2,i,r,e,a),s.assign(a)}else{const n=t[1].clone(),i=new o.P;(0,o.W)(2,t[0],n,e,i);const r=new o.P;(0,o.W)(2,n,t[2],e,r);const a=new o.P;(0,o.W)(2,i,r,e,a),s.assign(a)}}function Qs(t,e){let s=1;t[1].isEqualPoint2D(t[0])&&(s=2,t[2].isEqualPoint2D(t[0])&&(s=3));let n=2;t[2].isEqualPoint2D(t[3])&&(n=1,t[1].isEqualPoint2D(t[3])&&(n=0)),e[0].assign(t[0]),e[2].assign(t[3]);const i=o.P.intersectLinesAtOnePoint(t[0],t[s],t[n],t[3]),r=new o.P;(0,o.Z)(t[0],t[3],.5,r);const a=new o.P;bn(t,.5,a);const h=new o.P;e[1].assign(i),Zs(e,.5,h);const m=new o.P;e[1].assign(r),Zs(e,.5,m);const l=o.P.sqrDistance(a,h),u=o.P.sqrDistance(a,m);return l<u?(e[1].setCoordsPoint2D(i),Math.sqrt(l)):(e[1].setCoordsPoint2D(r),Math.sqrt(u))}function Ks(t,e,s){s[0].assign(t[0]),s[1].assign(t[1]),s[2].assign(t[2]);const n=new o.P;ms(t,e,.5,n);const i=new o.P;Zs(s,.5,i);const r=o.P.sqrDistance(n,i);return Math.sqrt(r)}var Js=r.V;class $s extends J{constructor(t){t&&t.cp?(super({start:t.cp[0],end:t.cp[3],vd:t.vd}),this.m_cp=(0,o.m)(o.P,2),this.m_cp[0].assign(t.cp[1]),this.m_cp[1].assign(t.cp[2])):void 0===t||(0,o.O)(t,"vd")?(super({vd:null===t||void 0===t?void 0:t.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=(0,o.m)(o.P,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)):t.from?(super({start:t.from,end:t.to,vd:t.vd}),this.m_cp=(0,o.m)(o.P,2),this.m_cp[0].assign(t.cp1),this.m_cp[1].assign(t.cp2)):(super({XStart:0,YStart:0,XEnd:0,YEnd:0,vd:t.vd}),(0,i.c)("unrecognized constructor params"),this.m_cp=(0,o.m)(o.P,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)),this.m_cachedValues=0}getBoundary(){return ii(this)}construct(t,e,s,n){this.m_XStart=t.x,this.m_YStart=t.y,this.m_XEnd=n.x,this.m_YEnd=n.y,this.m_cp[0].assign(e),this.m_cp[1].assign(s),this.afterCompletedModification()}constructPoints(t){this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.m_cp[0].assign(t[1]),this.m_cp[1].assign(t[2]),this.afterCompletedModification()}constructFromQuadratic(t){const e=(0,o.m)(o.P,4);(function(t,e){e[0].assign(t[0]),e[3].assign(t[2]),(0,o.Z)(t[0],t[1],2/3,e[1]),(0,o.Z)(t[1],t[2],1/3,e[2])})(t,e),this.constructPoints(e)}constructFromQuadraticSegment(t){this.dropAllAttributes(),this.assignVertexDescription(t.getDescription()),this.m_XStart=t.getStartX(),this.m_YStart=t.getStartY(),this.m_XEnd=t.getEndX(),this.m_YEnd=t.getEndY(),(0,o.a0)(2,t.getStartXY(),t.getControlPoint1(),2/3,this.m_cp[0]),(0,o.a0)(2,t.getControlPoint1(),t.getEndXY(),1/3,this.m_cp[1]),this.afterCompletedModification(),L(this,t)}getGeometryType(){return i.G.enumBezier}queryEnvelope(t){if(2!==t.m_EnvelopeType)return void(0,i.g)(0);if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp[0])&&t.contains(this.m_cp[1]))return;const e=un(this);if(null!==e){const s=new o.P;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s);return}const s=(0,o.m)(o.F,8),n=(0,o.m)(o.P,4);this.queryControlPoints(n);const r=Ln(n,s),a=new o.P;for(let i=1;i<r-1;i++)this.queryCoord2D(s[i].value(),a),t.mergeNe(a)}applyTransformation(t){if(1===t.m_TransformationType){const e=(0,o.m)(o.P,4);return this.queryControlPoints(e),t.transformPoints2D(e,4,e),this.setStartXY(e[0]),this.m_cp[0].assign(e[1]),this.m_cp[1].assign(e[2]),this.setEndXY(e[3]),void gn(this)}(0,i.g)(0)}createInstance(){return new $s({vd:this.m_description})}calculateLength2D(){return mn(this,1,!1)}calculateLowerLength2D(){return o.P.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return o.P.distance(this.getStartXY(),this.m_cp[0])+o.P.distance(this.m_cp[0],this.m_cp[1])+o.P.distance(this.getEndXY(),this.m_cp[1])}queryCoord2D(t,e){return this.queryCoord2DExtends(t,e,!0)}queryCoord2DExtends(t,e,s){const n=(0,o.m)(o.P,4);this.queryControlPoints(n),bn(n,t,e,s)}queryCoord2DE(t,e){!function(t,e,s){const n=(0,o.m)(o.P,4);t.queryControlPoints(n),function(t,e,s){if(e.value()<=.5){const n=new v;(0,o.a1)(2,v.constructPoint2D(t[0]),v.constructPoint2D(t[1]),e,n);const i=new v;(0,o.a1)(2,v.constructPoint2D(t[1]),v.constructPoint2D(t[2]),e,i);const r=new v;(0,o.a1)(2,v.constructPoint2D(t[2]),v.constructPoint2D(t[3]),e,r);const a=new v;(0,o.a1)(2,n,i,e,a);const h=new v;(0,o.a1)(2,i,r,e,h),(0,o.a1)(2,a,h,e,s)}else{const n=new v;(0,o.a2)(2,v.constructPoint2D(t[0]),v.constructPoint2D(t[1]),e,n);const i=new v;(0,o.a2)(2,v.constructPoint2D(t[1]),v.constructPoint2D(t[2]),e,i);const r=new v;(0,o.a2)(2,v.constructPoint2D(t[2]),v.constructPoint2D(t[3]),e,r);const a=new v;(0,o.a2)(2,n,i,e,a);const h=new v;(0,o.a2)(2,i,r,e,h),(0,o.a2)(2,a,h,e,s)}}(n,e,s)}(this,t,e)}getCoordX(t){if(t<0||t>1){const e=new o.P;return this.queryCoord2DExtends(t,e,!0),e.x}const e=(0,o.q)(this.getStartX(),this.m_cp[0].x,t),s=(0,o.q)(this.m_cp[0].x,this.m_cp[1].x,t),n=(0,o.q)(this.m_cp[1].x,this.getEndX(),t),i=(0,o.q)(e,s,t),r=(0,o.q)(s,n,t);return(0,o.q)(i,r,t)}getCoordY(t){if(t<0||t>1){const e=new o.P;return this.queryCoord2DExtends(t,e,!0),e.y}const e=(0,o.q)(this.getStartY(),this.m_cp[0].y,t),s=(0,o.q)(this.m_cp[0].y,this.m_cp[1].y,t),n=(0,o.q)(this.m_cp[1].y,this.getEndY(),t),i=(0,o.q)(e,s,t),r=(0,o.q)(s,n,t);return(0,o.q)(i,r,t)}cut(t,e,s){const n=new to;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createCubicBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=Js.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=Js.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){wn(this,t,e)}cutBezierIgnoreAttributes(t,e,s){(t<0||e>1||t>e)&&(0,i.t)("Cubic_bezier.cut_bezier_ignore_attributes");const n=(0,o.m)(o.P,4);this.queryControlPoints(n);const r=(0,o.m)(o.P,4);vn(n,t,e,r),s.setControlPoints(r)}splitBezierIgnoreAttributes(t,e,s){this===e&&this===s&&(0,i.t)("Cubic_bezier.split_bezier_ignore_attributes");const n=(0,o.m)(o.P,4);this.queryControlPoints(n);const r=(0,o.m)(o.P,4),a=(0,o.m)(o.P,4);Sn(n,t,r,a),e&&e.setControlPoints(r),s&&s.setControlPoints(a)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const n=this.getStartAttributeAsDbl(e,s),i=this.getEndAttributeAsDbl(e,s),r=this.calculateLength2D(),a=r>0?this.tToLength(t)/r:0,h=Js.getInterpolation(e);return(0,o.T)(h,n,i,a,Js.getDefaultValue(e))}getClosestCoordinate(t,e){const s=[Number.NaN];return Hn(this,t,o.E.unit(),e,-1,1,s),s[0]}getClosestCoordinateOnInterval(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;const n=[Number.NaN];return 0===Hn(this,t,e,!1,s,1,n)?Number.NaN:n[0]}getYMonotonicParts(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&(0,i.t)("");const s=ln(this);if(2===s.specialPointsCount()&&this.isMonotoneQuickAndDirty())return 0;let n=0;(0,i.g)(t.length>=s.specialPointsCount()-1);for(let i=1,r=s.specialPointsCount();i<r;++i)this.queryCut(s.specialPoints[i-1],s.specialPoints[i],t[n],e),n++;for(let i=0;i<n;++i)yn(t[i].get());return n}intersectionWithAxis2D(t,e,s,n){const i=(0,o.m)(o.P,4);return this.queryControlPoints(i),function(t,e,s,n,i){const r=(0,o.m)(o.F,4),a=(0,o.m)(o.F,3),h=new o.E(0,1);let m=0;if(e){if(an(t,r,!1),m=Gt(r[3],r[2],r[1],r[0].sub(s),h,!1,a),n)for(let l=0;l<m;l++){const e=new o.P;bn(t,a[l].value(),e),n[l]=e.x}}else if(on(t,r,!1),m=Gt(r[3],r[2],r[1],r[0].sub(s),h,!1,a),n)for(let l=0;l<m;l++){const e=new o.P;bn(t,a[l].value(),e),n[l]=e.y}if(i)for(let o=0;o<m;o++)i[o]=a[o].value();else n&&(0,o.C)(n,0,m,o.X);return m}(i,t,e,s,n)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0],n=this.intersectionWithAxis2D(!0,t,s,null);return(0,i.g)(2!==n),-1===n?e:s[0]}isCurve(){return!0}isDegenerate(t){return D(this,t)}isDegenerate3D(t,e){return(0,i.g)(0),!1}queryLooseEnvelope(t){if(2===t.m_EnvelopeType)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp[0]),t.mergeNe(this.m_cp[1]),void t.mergeNe(this.getEndXY());(0,i.g)(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=a.Envelope2D.constructEmpty();this.queryEnvelope(t);const s=o.E.constructEmpty();return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=(0,o.m)(o.P,4);this.queryControlPoints(s),vn(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp[0].isEqual(this.m_XStart,this.m_YStart),n=this.m_cp[0].isEqual(this.m_XEnd,this.m_YEnd),i=this.m_cp[1].isEqual(this.m_XStart,this.m_YStart),r=this.m_cp[1].isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp[0].setCoordsPoint2D(t):n&&this.m_cp[0].setCoordsPoint2D(e),r?this.m_cp[1].setCoordsPoint2D(e):i&&this.m_cp[1].setCoordsPoint2D(t),this.normalizeAfterEndpointChange()}tToLength(t){return mn(this,t,!0)}lengthToT(t){return function(t,e){const s=mn(t,1,!1);if(e<=0)return e;if(e>=s)return e-s+1;const n=[0];return 1!==Ct(new Un(t,e),o.E.unit(),1,n)&&(0,i.c)(""),n[0]}(this,t)}calculateWeightedAreaCentroid2D(t){const e=(0,o.m)(o.P,4);sn(this,e);const s=e[3],n=e[2],i=e[1],r=new o.P;r.x=(5*s.x*s.x*(7*n.y+16*i.y)+s.x*(-35*s.y*n.x+40*n.x*n.y-80*s.y*i.x+140*n.x*i.y+112*i.x*i.y)-2*(s.y*(20*n.x*n.x+70*n.x*i.x+56*i.x*i.x)-7*(4*n.x+5*i.x)*(-n.y*i.x+n.x*i.y)))/840,r.y=(-5*s.y*s.y*(7*n.x+16*i.x)+s.y*(5*s.x*(7*n.y+16*i.y)-4*(10*n.x*n.y+35*n.y*i.x+28*i.x*i.y))+2*(-7*(4*n.y+5*i.y)*(n.y*i.x-n.x*i.y)+s.x*(20*n.y*n.y+70*n.y*i.y+56*i.y*i.y)))/840;const a=xn(this);return r.x+=(e[0].x-t.x)*a,r.y+=(e[0].y-t.y)*a,r}calculateWeightedCentroid2D(){const t=new o.P;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){const e=o.P.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,e,s){void 0===s&&(s=e,e=0);const n=new o.P;if(e<0||s>1)return n.setNAN(),n;if(e>s&&(0,i.t)("calculate_sub_weightedCentroid"),e===s||t.isDegenerate(0))return n.setCoords(0,0),n;const r=ln(t),a=en(t),h=a/t.calculateUpperLength2D();let m=e,l=0;for(let i=1,o=r.specialPointsCount();i<o;i++)if(e<r.specialPoints[i]){l=i-1;break}n.setCoords(0,0);for(let i=l+1,o=r.specialPointsCount();i<o;i++){const e=Math.min(r.specialPoints[i],s),o=Wn(t,m,e,h,a);if(n.addThis(o),m=e,s<=r.specialPoints[i])break}return n.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp[0].clone()}setControlPoint1(t){this.m_cp[0].setCoordsPoint2D(t),this.afterCompletedModification()}getControlPoint2(){return this.m_cp[1].clone()}setControlPoint2(t){this.m_cp[1].setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp[0]),t[2].assign(this.m_cp[1]),t[3].assign(this.getEndXY())}setControlPoints(t){for(let e=0;e<4;e++)t[e].isNAN()&&(0,i.t)("NAN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp[0].setCoordsPoint2D(t[1]),this.m_cp[1].setCoordsPoint2D(t[2]),this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.afterCompletedModification()}getTangent(t){const e=(0,o.m)(o.P,4);return this.queryControlPoints(e),In(e,t)}getDerivative(t){const e=(0,o.m)(o.P,4);return this.queryControlPoints(e),pn(e,1,t)}getCurvature(t){const e=Pn(this,1,t),s=Pn(this,2,t),n=e.sqrLength();return 0===n?Number.NaN:(e.divThis(Math.sqrt(n)),e.crossProduct(s)/n)}isIntersectingPoint(t,e,s){if(s&&(t.equals(this.getStartXY())||t.equals(this.getEndXY())))return!1;const n=new a.Envelope2D;if(this.queryLooseEnvelope(n),n.inflateCoords(e,e),!n.contains(t))return!1;const i=this.getClosestCoordinate(t,!1),r=new o.P;return this.queryCoord2D(i,r),o.P.distance(r,t)<=e}isIntersectingPoint3D(t,e,s,n){return(0,i.g)(0),!1}isMonotoneQuickAndDirty(){const t=(0,o.m)(o.P,4);return this.queryControlPoints(t),function(t){const e=(0,o.Y)(t[0].y,t[1].y),s=(0,o.Y)(t[1].y,t[2].y),n=(0,o.Y)(t[2].y,t[3].y);if(e>=0&&s>=0&&n>=0||e<=0&&s<=0&&n<=0){const e=(0,o.Y)(t[0].x,t[1].x),s=(0,o.Y)(t[1].x,t[2].x),n=(0,o.Y)(t[2].x,t[3].x);if(e>=0&&s>=0&&n>=0||e<=0&&s<=0&&n<=0)return!0}return!1}(t)}getMonotonicPartParams(t,e){const s=ln(this),n=s.specialPointsCount();if((0,i.g)(j.s_maxMonotonicPartParams>=n),!e)return s.specialPointsCount();t<n&&(0,i.t)("");for(let i=0;i<n;i++)e[i]=s.specialPoints[i];return n}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=(0,o.b)(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=(0,o.b)(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=(0,o.b)(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cp[1]=(0,o.b)(this.m_cp[0],this.m_cp[0]=this.m_cp[1]),this.m_cachedValues=null}}findMinDeriv(){const t=new o.F;return _n(this,t),t.value()}isLine(){return!1}isDegenerateToLineHelper(t){const e=this.getEndXY().sub(this.getStartXY()),s=e.length(),n=.1*t;let i=this.getControlPoint1();i.subThis(this.getStartXY());let r=Math.abs(i.crossProduct(e))/s;return!(r>n)&&(i=this.getControlPoint2(),i.subThis(this.getStartXY()),r=Math.abs(i.crossProduct(e))/s,!(r>n))}copyIgnoreAttributes(t){const e=(0,o.m)(o.P,4);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return xn(this)}absNorm(){return(t=this).getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp[0].norm(1)+t.m_cp[1].norm(1);var t}queryEnvelopeW(t,e){Yn(this,t,e)}setSegmentFromCoords(t,e){!function(t,e,s){if((0,i.g)(s>=2),2===s){const n=new o.P;(0,o.Z)(e[0],e[s-1],1/3,n);const i=new o.P;return(0,o.Z)(e[0],e[s-1],2/3,i),void t.construct(e[0],n,i,e[s-1])}const n=e[0],r=e[s-1],a=[0,0],h=Hn(t,n,o.E.unit(),!1,Number.NaN,2,a),m=[0,0],l=Hn(t,r,o.E.unit(),!1,Number.NaN,2,m),u=[];for(let i=0;i<h;i++)for(let h=0;h<l;h++){const l=a[i],c=m[h],g=(i,a)=>{const h=(0,o.d)(s-2,Number.NaN),m=()=>{let t=0;for(let n=1,i=s-1;n<i;n++){t+=o.P.distance(e[n-1],e[n]);const s=t;h[n-1]=s}t+=o.P.distance(e[s-2],e[s-1]);for(let e=1,n=s-1;e<n;e++)h[e-1]/=t};let u=!1,g=!1;{const e=new to;l<=c?(t.queryCut(l,c,e,!0),i.assign(e.get().getControlPoint1()),a.assign(e.get().getControlPoint2())):(t.queryCut(c,l,e,!0),i.assign(e.get().getControlPoint2()),a.assign(e.get().getControlPoint1())),n.equals(i)&&(u=!0),r.equals(a)&&(g=!0)}m();let d=Number.MAX_VALUE;const _=i.clone(),p=a.clone();for(let t=0;t<5;t++)d=jn(!0,!1,n,_,p,r,u,g,h,s-2,e,s);for(let t=0;t<30;t++){const t=_.clone();p.clone();const i=jn(!0,!0,n,_,p,r,u,g,h,s-2,e,s);if(d<=i&&t.equals(_)&&t.equals(p))break;d=i}m();let f=!1,P=Number.EPSILON;const x=i.clone(),y=a.clone();for(let t=0;t<30;t++){const t=x.clone();y.clone();const i=jn(f,!0,n,x,y,r,u,g,h,s-2,e,s);if(P<=i&&t.equals(x)&&t.equals(y))break;f=!0,P=i}return P<d?(i.assign(x),a.assign(y)):(i.assign(_),a.assign(p),P=d),P},d=new o.P,_=new o.P,p=[g(d,_),o.P.distance(n,d)+o.P.distance(d,_)+o.P.distance(_,r),d.x,d.y,_.x,_.y];u.splice(u.length,0,...p)}let c=u[0],g=u[1],d=0;for(let i=6;i<u.length;i+=6)u[i]<c&&(c=u[i],g=u[i+1],d=i);let _=d;for(let i=0;i<u.length;i+=6)i!==d&&u[i+1]<g&&Math.abs(c-u[i])<10*c&&(g=u[i+1],_=i);t.construct(n,new o.P(u[_+2],u[_+3]),new o.P(u[_+4],u[_+5]),r)}(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(4);return this.writeInBuffer_(s),t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}writeInBuffer_(t){return t[0]=this.m_cp[0].x,t[1]=this.m_cp[0].y,t[2]=this.m_cp[1].x,t[3]=this.m_cp[1].y,4}readFromBufferStream(t,e){const s=new Float64Array(4);t.queryRange(e,s.length,s,!0,1),this.readFromBuffer_(s)}readFromBuffer_(t){this.m_cp=(0,o.m)(o.P,2),this.m_cp[0].x=t[0],this.m_cp[0].y=t[1],this.m_cp[1].x=t[2],this.m_cp[1].y=t[3],this.m_cachedValues=null}snapControlPoints(t){const e=(0,o.m)(o.P,4);this.queryControlPoints(e);const s=(e,s,n)=>{let i=!1;return o.P.sqrDistance(e,n)<=t&&(i=!e.equals(n),e.setCoordsPoint2D(n),o.P.sqrDistance(s,n)<=t&&(i||(i=!s.equals(n)),s.setCoordsPoint2D(n))),i},n=s(e[1],e[2],e[0]),i=s(e[2],e[1],e[3]);return(n||i)&&this.setControlPoints(e),n||i}needsSnapControlPoints(t){if(!t)return!1;const e=(0,o.m)(o.P,4);this.queryControlPoints(e);const s=(e,s,n)=>{let i=!1;return o.P.sqrDistance(e,n)<=t&&(i=!e.equals(n),e.setCoordsPoint2D(n),o.P.sqrDistance(s,n)<=t&&(i||(i=!s.equals(n)),s.setCoordsPoint2D(n))),i},n=s(e[1],e[2],e[0]),i=s(e[2],e[1],e[3]);return n||i}calculateSpecialPointsForCracking(t,e){return function(t,e,s){s.length=0;{const e=new o.F;_n(t,e);const n=new v;if(wn(t,e,n),n.isZero())return e.isZero()||e.eq(new o.F(1))?0:(s.push(e.value()),1)}const n=(0,o.m)(o.F,4);nn(t,n,!0);const i=(0,o.m)(o.F,4);rn(t,i,!0);const r=(0,o.m)(o.F,6),a=n[3].negate().mulE(i[1]).addE(n[2].mulE(i[2]).mul(2)).addE(n[1].mulE(i[3])),h=n[3].negate().mulE(i[1]).subE(n[2].mulE(i[2]).mul(2)).addE(n[1].mulE(i[3])),m=n[2].mulE(n[2]).subE(i[2].mulE(i[2]));r[0]=i[1].mulE(i[1]).mulE(a).addE(n[1].mulE(n[1]).mulE(h)).addE(n[1].mulE(i[1]).mulE(m).mul(2)).mul(6),r[1]=n[2].mulE(i[1]).subE(n[1].mulE(i[2])).mulE(n[2].mulE(n[2]).addE(n[1].mulE(n[3]).mul(2)).addE(i[2].mulE(i[2])).addE(i[1].mulE(i[3]).mul(2))).mul(24);const l=n[1].mulE(i[2]).mulE(i[2]).mulE(i[3]),u=n[2].mulE(n[2]).mulE(n[3]).mulE(i[1]).subE(l).mul(156),c=n[3].mulE(i[1]).subE(n[1].mulE(i[3])),g=n[3].mulE(i[1]).subE(n[1].mulE(i[3])),d=n[1].mulE(n[3]).mulE(g).addE(i[1].mulE(i[3]).mulE(c)).mul(72),_=i[1].mulE(i[3]).subE(n[1].mulE(n[3])),p=n[2].mulE(i[2]).mulE(_).mul(120),f=n[1].mulE(n[2]).mulE(n[2]).mulE(i[3]),P=n[3].mulE(i[1]).mulE(i[2]).mulE(i[2]).subE(f).mul(36);r[2]=u.addE(d).addE(p).addE(P);const x=n[2].mulE(n[3]).mulE(n[3]).mulE(i[1]).subE(n[1].mulE(i[2]).mulE(i[3]).mulE(i[3])).mul(360),y=n[2].mulE(i[2]).mulE(n[2].mulE(n[3]).subE(i[2].mulE(i[3]))).addE(n[3].mulE(i[2]).mulE(i[2]).mulE(i[2])).subE(n[2].mulE(n[2]).mulE(n[2]).mulE(i[3])).mul(24),E=n[2].mulE(i[1]).mulE(i[3]).mulE(i[3]).subE(n[1].mulE(n[3]).mulE(n[3]).mulE(i[2])).mul(72),C=n[3].mulE(i[3]).mulE(i[1].mulE(i[2]).subE(n[1].mulE(n[2]))).mul(288);r[3]=x.addE(y).addE(E).addE(C),r[4]=i[3].mulE(i[3]).addE(n[3].mulE(n[3])).mulE(n[3].mulE(i[1]).subE(n[1].mulE(i[3]))).mul(270).addE(n[3].mulE(i[2]).subE(n[2].mulE(i[3]))).mulE(n[2].mulE(n[3]).addE(i[2].mulE(i[3]))).mul(180),r[5]=n[3].mulE(i[2]).subE(n[2].mulE(i[3])).mulE(n[3].mulE(n[3]).addE(i[3].mulE(i[3]))).mul(216);const S=(0,o.m)(o.F,5),b=Mt(r,5,new o.E(0,1),!1,S,5);if(b>0){let n=Math.abs(t.getCurvature(0)),i=0;const r=Math.abs(t.getCurvature(1));(r>n||!Number.isFinite(r))&&(i=1);for(let e=0;e<b;e++){const s=Math.abs(t.getCurvature(S[e].value()));t.getCoord2D(S[e].value()),(s>n||!Number.isFinite(s))&&(n=s,i=S[e].value())}if((!Number.isFinite(n)||1/n<e)&&!(0,o.J)(i,0,1)){const e=t.getCoord2D(i);if(!e.equals(t.getStartXY())&&!e.equals(t.getEndXY()))return s.push(i),1}}return 0}(this,t,e)}ensureXYMonotone(){return yn(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new h.T,a=(0,o.m)(o.P,3);a[0].setCoords(t.m_XStart,t.m_YStart),a[2].setCoords(t.m_XEnd,t.m_YEnd);const m=new o.P;m.setSub(a[2],a[0]),m.leftPerpendicularThis(),a[1].setAdd(a[0],m);const l=(0,o.m)(o.P,3);l[0].setCoordsPoint2D(e),l[2].setCoordsPoint2D(s),m.setSub(l[2],l[0]),m.leftPerpendicularThis(),l[1].setAdd(l[0],m),r.setFromTwoTriangles(a,l)?r.transformPoints2D(t.m_cp,2,t.m_cp):((0,o.Z)(e,s,1/3,t.m_cp[0]),(0,o.Z)(e,s,2/3,t.m_cp[1])),t.changeEndPoints2D(e,s),i&&yn(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp[0].assign(this.m_cp[0]),e.m_cp[1].assign(this.m_cp[1]),cn(e,un(this))}reverseImpl(){this.m_cp[1]=(0,o.b)(this.m_cp[0],this.m_cp[0]=this.m_cp[1])}equalsImpl(t){const e=t;return!!this.m_cp[0].equals(e.m_cp[0])&&!!this.m_cp[1].equals(e.m_cp[1])}equalsImplTol(t,e){const s=t;return!!this.m_cp[0].isEqualPoint2D(s.m_cp[0],e)&&!!this.m_cp[1].isEqualPoint2D(s.m_cp[1],e)}swapImpl(t){const e=t;e.m_cp[0]=(0,o.b)(this.m_cp[0],this.m_cp[0]=e.m_cp[0]),e.m_cp[1]=(0,o.b)(this.m_cp[1],this.m_cp[1]=e.m_cp[1]),function(t,e){e.m_cachedValues=(0,o.b)(t.m_cachedValues,t.m_cachedValues=e.m_cachedValues)}(this,e)}afterCompletedModification(){gn(this)}isIntersecting(t,e,s){return 0!==Br(!1,this,t,e,s)}intersect(t,e,s,n,i){return Wr(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return function(t,e,s,n){const r=new E;if(Yn(t,o.E.unit(),r),r.inflate(n),!r.isIntersectingPoint2D(e))return 0;const a=ln(t);let h=0,m=a.specialPoints[0];const l=[];for(let o=1,u=a.specialPoints.length;o<u;++o){const s=a.specialPoints[o],n=dn(t,e,m,s);if(0===l.length)l.push(n);else if(n.t===n.tmin)(0,i.g)(l.at(-1).d<=n.d),l.at(-1).tmax=n.tmax;else if(l.at(-1).t===l.at(-1).tmax){(0,i.g)(l.at(-1).d>=n.d);const t=l.at(-1).tmin;l[l.length-1]=n,l.at(-1).tmin=t}else l.push(n);m=s}for(const o of l)if(o.d<=n){const t=o.t;s?(h>=s.length&&(0,i.n)(""),s[h]=t,h++):h++}return h}(this,t,e,s)}endPointModified(){gn(this)}clearEndPointModified(){}}$s.type=i.G.enumBezier;class tn{constructor(){this.length=Number.NaN,this.specialPoints=[]}specialPointsCount(){return this.specialPoints.length}}function en(t){return function(t){return 256*(0,o.N)()*t}(t.calculateUpperLength2D())}function sn(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];e[1].setCoords(t.m_cp[0].x-t.getStartX(),t.m_cp[0].y-t.getStartY()),e[1].mulThis(3),e[2].setCoords(t.m_cp[1].x-t.m_cp[0].x,t.m_cp[1].y-t.m_cp[0].y),e[2].mulThis(3),e[3]=t.getEndXY().sub(t.getStartXY()),e[3].subThis(e[2]),e[2].subThis(e[1]),s?e[0].setCoords(0,0):e[0]=t.getStartXY()}function nn(t,e,s){const n=(0,o.m)(o.P,4);t.queryControlPoints(n),on(n,e,s)}function rn(t,e,s){const n=(0,o.m)(o.P,4);t.queryControlPoints(n),an(n,e,s)}function on(t,e,s){let n=t[1].x;n-=t[0].x,n*=3;let i=t[2].x;i-=t[1].x,i*=3;let r=t[3].x;r-=t[0].x,r-=i,i-=n,e[3].setWithEps(r),e[2].setWithEps(i),e[1].setWithEps(n),s?e[0].set(0):e[0].set(t[0].x)}function an(t,e,s){let n=t[1].y;n-=t[0].y,n*=3;let i=t[2].y;i-=t[1].y,i*=3;let r=t[3].y;r-=t[0].y,r-=i,i-=n,e[3].setWithEps(r),e[2].setWithEps(i),e[1].setWithEps(n),s?e[0].set(0):e[0].set(t[0].y)}function hn(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=(0,o.m)(Ut,4);n[0].assignPoint2D(t[0]),n[1].assignPoint2D(t[1]),n[2].assignPoint2D(t[2]),n[3].assignPoint2D(t[3]),e[1].setCoords(n[1].x.sub(n[0].x),n[1].y.sub(n[0].y)),e[1].mulThis(o.M.constructInt32(3)),e[2].setCoords(n[2].x.sub(n[1].x),n[2].y.sub(n[1].y)),e[2].mulThis(o.M.constructInt32(3)),e[3]=n[3].sub(n[0]),e[3]=e[3].sub(e[2]),e[2]=e[2].sub(e[1]),s?e[0].setCoords(o.ad,o.ad):e[0]=n[0].clone()}function mn(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+mn(t,1,!1)}if(t.isDegenerate(0))return 0;const n=1===e,i=ln(t);if(n&&!Number.isNaN(i.length)&&!Number.isNaN(i.length))return i.length;const r=en(t),o=r/t.calculateUpperLength2D();let a=0,h=0;for(let m=1,l=i.specialPointsCount();m<l;m++){const s=i.specialPoints[m];if(a+=On(t,h,Math.min(e,s),o,r),e<=s)break;h=s}return n&&(i.length=a),a}function ln(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new tn,s=(0,o.m)(o.F,8),n=(0,o.m)(o.P,4);t.queryControlPoints(n);const i=Ln(n,s);e.specialPoints=[];for(let r=0;r<i;r++)e.specialPoints.push(s[r].value());return cn(t,e),e}function un(t){let e=null;return e=t.m_cachedValues,e}function cn(t,e){t.m_cachedValues=e}function gn(t){t.m_cachedValues=null}function dn(t,e,s,n){const i=(0,o.d)(18,Number.NaN),r=(0,o.m)(o.P,4);t.queryControlPoints(r);const a=Ct(new kn(r,e),o.E.construct(s,n),18,i),h=new o.P;t.queryCoord2D(s,h);let m=s,l=o.P.distance(h,e);const u=new o.P;t.queryCoord2D(n,u);const c=o.P.distance(u,e);c<l&&(l=c,m=n,h.assign(u));for(let g=0;g<a;g++){t.queryCoord2D(i[g],u);const s=o.P.distance(u,e);s<l&&(l=s,m=i[g],h.assign(u))}return function(t,e,s,n,i){return{tmin:t,tmax:e,t:s,d:n,pt:i.clone()}}(s,n,m,l,h)}function _n(t,e){const s=(0,o.m)(o.F,4);nn(t,s,!0);const n=(0,o.m)(o.F,4);rn(t,n,!0);const r=s[3].clone(),a=s[2].clone(),h=s[1].clone(),m=n[3].clone(),l=n[2].clone(),u=n[1].clone(),c=a.mulE(h).addE(l.mulE(u)).mul(4),g=a.mulE(a).mul(8).addE(r.mulE(h).mul(12)).addE(l.mulE(l).mul(8).addE(m.mulE(u).mul(12))),d=r.mulE(a).addE(m.mulE(l)).mul(36),_=r.mulE(r).addE(m.mulE(m)).mul(36),p=(0,o.m)(o.F,3),f=Gt(_,d,g,c,new o.E(0,1),!1,p);if((0,i.g)(f<=3),f>0){const s=Pn(t,1,0).sqrLength(),n=Pn(t,1,1).sqrLength();let i=s;e.set(0),i<n&&(i=n,e.set(1));for(let r=0;r<f;r++){const s=Pn(t,1,p[r].value()).sqrLength();s<i&&(i=s,e=p[r])}}}function pn(t,e,s){const n=new o.P;return function(t,e,s,n){if(1===e){const e=1-s,i=e*e,r=s*s,o=t[1].sub(t[0]),a=t[2].sub(t[1]),h=t[3].sub(t[2]),m=o.mul(i).add(a.mul(2*e*s)).add(h.mul(r));n.assign(m.mul(3))}else if(2===e){const e=1-s,i=t[2].sub(t[1]).sub(t[1].sub(t[0])),r=t[3].sub(t[2]).sub(t[2].sub(t[1])),o=i.mul(e).add(r.mul(s));n.assign(o.mul(6))}else if(3===e){const e=t[2].sub(t[1]),s=t[3].sub(e.mul(3)).sub(t[0]);n.assign(s.mul(6))}else n.setCoords(0,0)}(t,e,s,n),n}function fn(t,e,s){const n=[v.constructPoint2D(t[0]),v.constructPoint2D(t[1]),v.constructPoint2D(t[2]),v.constructPoint2D(t[3])],i=new v;return function(t,e,s,n){{const e=o.G.subE(s),i=e.sqr(),r=s.sqr(),a=t[1].subE(t[0]).mulE(i).addE(t[2].subE(t[1]).mulE(new o.F(2).mulE(e).mulE(s))).addE(t[3].subE(t[2]).mulE(r));n.setE(a.mulE(new o.F(3)))}}(n,0,s,i),i}function Pn(t,e,s){const n=(0,o.m)(o.P,4);return t.queryControlPoints(n),pn(n,e,s)}function xn(t){const e=t.m_cp[0].sub(t.getStartXY()),s=t.m_cp[1].sub(t.m_cp[0]),n=t.getEndXY().sub(t.getStartXY());return e.mulThis(3),s.mulThis(3),n.subThis(s),s.subThis(e),(3*n.x*(2*s.y+5*e.y)-3*n.y*(2*s.x+5*e.x)+10*(s.x*e.y-s.y*e.x))/60}function yn(t){const e=(0,o.m)(o.P,4);t.queryControlPoints(e);const s=En(e);return s&&(t.m_cp[0].setCoordsPoint2D(e[1]),t.m_cp[1].setCoordsPoint2D(e[2]),t.afterCompletedModification()),s}function En(t){let e=!1;for(let s=0;s<2;s++){const n=(0,o.Y)(t[0][s],t[3][s]);n>0?((0,o.Y)(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),(0,o.Y)(t[1][s],t[3][s])<0&&(t[1][s]=t[3][s],e=!0),(0,o.Y)(t[0][s],t[2][s])<0&&(t[2][s]=t[0][s],e=!0),(0,o.Y)(t[2][s],t[3][s])<0&&(t[2][s]=t[3][s],e=!0),(0,o.Y)(t[1][s],t[2][s])<0&&(t[2][s]=t[1][s],e=!0)):n<0?((0,o.Y)(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),(0,o.Y)(t[1][s],t[3][s])>0&&(t[1][s]=t[3][s],e=!0),(0,o.Y)(t[0][s],t[2][s])>0&&(t[2][s]=t[0][s],e=!0),(0,o.Y)(t[2][s],t[3][s])>0&&(t[2][s]=t[3][s],e=!0),(0,o.Y)(t[1][s],t[2][s])>0&&(t[2][s]=t[1][s],e=!0)):t[1][s]===t[0][s]&&t[2][s]===t[0][s]||(t[1][s]=t[0][s],t[2][s]=t[0][s],e=!0)}return e}function Cn(t,e,s){const n=new o.P,i=new o.P,r=new o.P,a=new o.P,h=new o.P;e<=.5?((0,o.V)(2,t[0],t[1],e,n),(0,o.V)(2,t[1],t[2],e,i),(0,o.V)(2,t[2],t[3],e,r),(0,o.V)(2,n,i,e,a),(0,o.V)(2,i,r,e,h),(0,o.V)(2,a,h,e,s)):((0,o.W)(2,t[0],t[1],e,n),(0,o.W)(2,t[1],t[2],e,i),(0,o.W)(2,t[2],t[3],e,r),(0,o.W)(2,n,i,e,a),(0,o.W)(2,i,r,e,h),(0,o.W)(2,a,h,e,s))}function Sn(t,e,s,n){(0,i.g)(e>=0&&e<=1);const r=new o.P,a=new o.P,h=new o.P,m=new o.P,l=new o.P,u=new o.P;e<=.5?((0,o.V)(2,t[0],t[1],e,r),(0,o.V)(2,t[1],t[2],e,a),(0,o.V)(2,t[2],t[3],e,h),(0,o.V)(2,r,a,e,m),(0,o.V)(2,a,h,e,l),(0,o.V)(2,m,l,e,u)):((0,o.W)(2,t[0],t[1],e,r),(0,o.W)(2,t[1],t[2],e,a),(0,o.W)(2,t[2],t[3],e,h),(0,o.W)(2,r,a,e,m),(0,o.W)(2,a,h,e,l),(0,o.W)(2,m,l,e,u));const c=t[3].clone();s&&(s[0].assign(t[0]),s[1].assign(r),s[2].assign(m),s[3].assign(u)),n&&(n[0].assign(u),n[1].assign(l),n[2].assign(h),n[3].assign(c))}function vn(t,e,s,n){if((0,i.g)(e>=0&&s<=1&&e<=s),e===s){const s=new o.P;return bn(t,e,s),n[0].assign(s),n[1].assign(s),n[2].assign(s),void n[3].assign(s)}if(0===e&&1===s){for(let e=0;e<4;++e)n[e].assign(t[e]);return}const r=(0,o.m)(o.P,4);Sn(t,s,r,null),Sn(r,s>0?e/s:0,null,r),bn(t,e,r[0]),bn(t,s,r[3]),n[0].setCoordsPoint2D(r[0]),n[1].setCoordsPoint2D(r[1]),n[2].setCoordsPoint2D(r[2]),n[3].setCoordsPoint2D(r[3])}function bn(t,e,s,n){if(n){if(e<0)return void tt(new $r({start:t[0],end:t[0].add(In(t,0).getUnitVector())}),e,s);if(e>1)return void tt(new $r({start:t[3],end:t[3].add(In(t,1).getUnitVector())}),e-1,s)}if(e<=.5){const n=new o.P;(0,o.V)(2,t[0],t[1],e,n);const i=new o.P;(0,o.V)(2,t[1],t[2],e,i);const r=new o.P;(0,o.V)(2,t[2],t[3],e,r);const a=new o.P;(0,o.V)(2,n,i,e,a);const h=new o.P;(0,o.V)(2,i,r,e,h),(0,o.V)(2,a,h,e,s)}else{const n=new o.P;(0,o.W)(2,t[0],t[1],e,n);const i=new o.P;(0,o.W)(2,t[1],t[2],e,i);const r=new o.P;(0,o.W)(2,t[2],t[3],e,r);const a=new o.P;(0,o.W)(2,n,i,e,a);const h=new o.P;(0,o.W)(2,i,r,e,h),(0,o.W)(2,a,h,e,s)}}function In(t,e){const s=(0,o.c)(e,0,1);let n=pn(t,1,s);return n.isZero()&&(n=pn(t,2,s),n.isZero()?n=pn(t,3,s):1===s&&n.negateThis()),n}function wn(t,e,s){const n=(0,o.m)(o.P,4);t.queryControlPoints(n),function(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(fn(t,0,e))}(n,e,s)}function Dn(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==Gn(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function Tn(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==Mn(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function Nn(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==qn(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function An(t,e,s,n,i){if(i){if(0!==zr(e,s))return t?4:2}else if(w(e,s))return 1;return 0!==Vn(t,e,s,null,null,null,n,null!==i&&void 0!==i&&i,!0,!1)?4:0}function Gn(t,e,s,n,i,r,a,h,m,l){if(null!==i&&(i.length=0),null!=r&&(r.length=0),null!==n&&(n.length=0),s.isDegenerate(0)){const t=[0,0,0],h=e.intersectPoint(s.getStartXY(),t,a);if(h>0){if(null!==i)for(let e=0;e<h;e++)i.push(t[e]);if(null!==r)for(let t=0;t<h;t++)r.push(0);if(null!=n)for(let s=0;s<h;s++){const i=new o.P;e.queryCoord2D(t[s],i),n.push(i)}}return h}const u=U(e,s);if(z(e,s,a=Math.max(a,u)))return 0;const c=(0,o.m)(o.P,4);sn(e,c);const g=s.getEndXY();g.subThis(s.getStartXY());const d=g.clone();d.leftPerpendicularThis();let _=3*c[3].dotProduct(d),p=2*c[2].dotProduct(d),f=c[1].dotProduct(d);const P=(0,o.d)(15,Number.NaN),x=(0,o.d)(15,Number.NaN);let y=St(_,p,f,o.E.unit(),!1,P);y<0&&(P[0]=0,P[1]=1,y=2);let E,C=0;for(let b=0,I=C;b<y;++b){const t=e.getCoord2D(P[b+I]);x[C]=s.getClosestCoordinate(t,!1),o.P.distance(t,s.getCoord2D(x[C]))<=a&&(P[C]=P[b+I],C++)}if(c[0].subThis(s.getStartXY()),Math.abs(g.x)>=Math.abs(g.y)){const t=g.y/g.x;_=c[3].y-c[3].x*t,p=c[2].y-c[2].x*t,f=c[1].y-c[1].x*t,E=c[0].y-c[0].x*t}else{const t=g.x/g.y;_=c[3].x-c[3].y*t,p=c[2].x-c[2].y*t,f=c[1].x-c[1].y*t,E=c[0].x-c[0].y*t}const S=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),v=[0,0,0];y=vt(_,p,f,E,o.E.unit(),S,v);for(let b=0,I=C;b<y;++b){P[b+I]=v[b];const t=e.getCoord2D(P[b+I]);x[C]=s.getClosestCoordinate(t,!1),o.P.distance(t,s.getCoord2D(x[C]))<=a&&(P[C]=P[b+I],C++)}y=e.intersectPoint(s.getStartXY(),v,a);for(let o=0;o<y;o++)P[C]=v[o],x[C++]=0;y=e.intersectPoint(s.getEndXY(),v,a);for(let o=0;o<y;o++)P[C]=v[o],x[C++]=1;return 0!==s.intersectPoint(e.getStartXY(),v,a)&&(x[C]=v[0],P[C++]=0),0!==s.intersectPoint(e.getEndXY(),v,a)&&(x[C]=v[0],P[C++]=1),0===C?0:Zr(t,e,s,P,x,C,n,i,r,a,h,m,l)}function Mn(t,e,s,n,i,r,a,m,l,u){if(Zi(s))return Gn(t,e,new $r({start:s.getStartXY(),end:s.getEndXY()}),n,i,r,a,m,l,u);const c=U(e,s);if(z(e,s,a=Math.max(a,c)))return 0;const g=[],d=[],_=[],p=(0,o.m)(o.P,4);{e.queryControlPoints(p);const t=(0,o.m)(o.P,4),n=new h.T;s.canonicToWorldTransformation(n);const i=new h.T;i.setInvert(n),i.transformPoints2D(p,4,t);const r=(0,o.m)(Ut,4);hn(t,r);const m=[r[0].x,r[1].x,r[2].x,r[3].x],l=[r[0].y,r[1].y,r[2].y,r[3].y],u=(0,o.m)(o.M,3);u[0].setDouble(s.getSemiMinorAxis()),u[0].sqrThis(),u[1].setDouble(s.getSemiMajorAxis()),u[1].sqrThis(),u[2].setThis(u[0]),u[2].mulThis(u[1]),u[2].negateThis();const c=Zt(m,3,l,3,null,0,u,!0,o.E.unit(),o.E.unit(),d);if(c>0){let t=0;for(let n=0;n<c;n++){const i=new o.P;e.queryCoord2D(d[n],i);const r=s.getClosestCoordinate(i,!1),h=new o.P;s.queryCoord2D(r,h),o.P.distance(i,h)<=a&&(g.push(i.clone()),d[t]=d[n],_.push(r),t++)}d.length=t,g.length=t}}const f=[0,1];for(let h=0;h<2;h++){const t=0===h?s.getStartXY():s.getEndXY(),e=[0];Rn(p,t,o.E.unit(),!1,-1,1,e);const n=new o.P;bn(p,e[0],n),o.P.distance(t,n)<=a&&(d.push(e[0]),_.push(f[h]),g.push(n.clone()))}for(let h=0;h<2;h++){const t=[0,3];{const e=s.getClosestCoordinate(p[t[h]],!1),n=new o.P;s.queryCoord2D(e,n),o.P.distance(p[t[h]],n)<=a&&(d.push(f[h]),_.push(e),g.push(n.clone()))}}return Zr(t,e,s,d,_,d.length,n,i,r,a,m,l,u)}function Fn(t,e,s,n,r,a,h,m,l,u){const c=(0,o.m)(o.P,4);e.queryControlPoints(c);const g=(0,o.m)(o.P,4);if(s.queryControlPoints(g),O(c,g,4)<0)return Fn(t,s,e,n,a,r,h,m,l,!u);const d=U(e,s);if(z(e,s,h=Math.max(h,d)))return 0;if(function(t,e,s,n,i,r,a,h,m){const l=(0,o.m)(o.P,4);t.queryControlPoints(l);const u=(0,o.m)(o.P,4);if(e.queryControlPoints(u),l[0].equals(u[0])){if(l[1].equals(u[1])&&l[2].equals(u[2])&&l[3].equals(u[3]))return s&&(s.length=0,s.push(l[0]),s.push(l[3])),n&&(n.length=0,n.push(0),n.push(1)),i&&(i.length=0,i.push(0),i.push(1)),!0;if(!l[0].equals(u[3]))return!1}return!!(l[0].equals(u[3])&&l[1].equals(u[2])&&l[2].equals(u[1])&&l[3].equals(u[0]))&&(n&&(n.length=0,n.push(0),n.push(1),m&&(n[1]=(0,o.b)(n[0],n[0]=n[1]))),i&&(i.length=0,i.push(1),i.push(0),m&&(i[1]=(0,o.b)(i[0],i[0]=i[1]))),s&&(s.length=0,s.push(l[0]),s.push(l[3]),m&&(s[1]=(0,o.b)(s[0],s[0]=s[1]))),!0)}(e,s,n,r,a,0,0,0,u))return 2;const _=new o.E(0,1),p=new o.E(0,1);{const t=new E;Xn(c,new o.E(0,1),t);const e=new E;Xn(g,new o.E(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*h),e.inflate(3*h),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Bn(c,t,_),Bn(g,t,p),_.isEmpty()||p.isEmpty())return 0;vn(c,_.vmin,_.vmax,c),vn(g,p.vmin,p.vmax,g)}}const f=Kr(c,3,g,3,h);if(0===f)return 0;const P=[],x=[],y=[];let C=!1;if(-1===f){const t=(0,o.m)(Ut,4);hn(c,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],n=(0,o.m)(Ut,4);hn(g,n);const i=[],r=[],a=jt(e,3,s,3,null,0,[n[0].x,n[1].x,n[2].x,n[3].x],3,[n[0].y,n[1].y,n[2].y,n[3].y],3,null,0,!0,o.E.unit(),o.E.unit(),i,r);if(a>0)for(let m=0;m<a;m++){const t=new o.P;bn(g,r[m],t);const e=new o.P;bn(c,i[m],e),o.P.distance(e,t)<=h&&(P.push(e.clone()),y.push(r[m]),x.push(i[m]))}else-1===a&&(C=!0)}for(let i=0;i<2;i++){const t=0===i?c:g,e=0===i?g:c;for(let s=0;s<2;s++){const n=0===s?0:3,r=[0];Rn(e,t[n],o.E.unit(),!1,-1,1,r);const a=new o.P;bn(e,r[0],a),o.P.distance(t[n],a)<=h&&(0===i?(x.push(0===n?0:1),y.push(r[0])):(y.push(0===n?0:1),x.push(r[0])),P.push(a.clone()))}}if(0===x.length&&C){const t=e.calculateUpperLength2D()>s.calculateUpperLength2D();{const n=[0,0];if(2===function(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=(0,o.m)(o.P,4);t.queryControlPoints(n);const i=(0,o.m)(Ut,4);let r,a,h;hn(n,i,!0);const m=i[3].x.isZero(),l=i[3].y.isZero();if(m||l)if(m&&!l){if(i[2].x.isZero())return 0;r=i[1].x.div(i[2].x).negate(),a=i[2].y.div(i[3].y),h=i[1].y.div(i[3].y)}else{if(m||!l)return 0;if(i[2].y.isZero())return 0;r=i[1].y.div(i[2].y).negate(),a=i[2].x.div(i[3].x),h=i[1].x.div(i[3].x)}else{i[2].x.divThis(i[3].x),i[1].x.divThis(i[3].x),i[2].y.divThis(i[3].y),i[1].y.divThis(i[3].y);const t=i[2].x.sub(i[2].y);if(t.isZero())return 0;r=i[1].x.sub(i[1].y).div(t).negate(),a=i[2].x.clone(),h=i[1].x.clone()}if(!s&&r.abs().value()>2)return 0;const u=[0,0],c=t.getStartXY().equals(t.getEndXY()),g=St(1,-r.toDouble(),r.add(a).mul(r).add(h).toDouble(),o.E.unit(),c,u);if(0===g)return 0;if(u[0]>=0&&u[0]<=1){const t=r.toDouble()-u[0];if(s||t>=0&&t<=1)return e[0]=u[0],e[1]=t,e[0]>e[1]&&(e[1]=(0,o.b)(e[0],e[0]=e[1])),2}if(2===g&&u[1]>=0&&u[1]<=1){const t=r.toDouble()-u[1];if(s||t>=0&&t<=1)return e[0]=u[1],e[1]=t,e[0]>e[1]&&(e[1]=(0,o.b)(e[0],e[0]=e[1])),2}return 0}(t?e:s,n,!0)&&((0,i.g)(o.E.unit().containsCoordinate(n[0])),!o.E.unit().containsCoordinate(n[1]))){const e=new o.P;bn(t?c:g,n[0],e);const s=[0,0];1===Rn(t?g:c,e,o.E.unit(),!1,-1,2,s)&&(P.push(e.clone()),x.push(t?n[0]:s[0]),y.push(t?s[0]:n[0]))}}}if(0===x.length)return 0;if(!_.equalsRange(0,1))for(let i=0;i<x.length;++i)x[i]=$s.recalculateParentT(_.vmin,_.vmax,x[i]);if(!p.equalsRange(0,1))for(let i=0;i<y.length;++i)y[i]=$s.recalculateParentT(p.vmin,p.vmax,y[i]);return Zr(t,e,s,x,y,x.length,n,r,a,h,m,l,u)}function qn(t,e,s,n,r,a,h,m,l,u){const c=U(e,s);if(s.isDegenerateToLineHelper(c)){const i=new $r({start:s.getStartXY(),end:s.getEndXY()}),o=Gn(t,e,i,n,r,a,h,m,l,u);if(a)for(let t=0;t<o;++t){const e=i.getCoord2D(a[t]);a[t]=s.getClosestCoordinate(e,!1)}return o}if(z(e,s,h=Math.max(h,c)))return 0;const g=(0,o.m)(o.P,4);e.queryControlPoints(g);const d=(0,o.m)(o.P,3);s.queryControlPoints(d);const _=new o.E(0,1),p=new o.E(0,1),f=[0,0,0];s.queryWeights(f);const P=[1,us(f),1];{const t=new E;Xn(g,new o.E(0,1),t);const e=new E;ze(d,P,new o.E(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*h),e.inflate(3*h),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Bn(g,t,_),ls(d,P,t,p),_.isEmpty()||p.isEmpty())return 0;vn(g,_.vmin,_.vmax,g),Qe(d,P,p.vmin,p.vmax,d,P)}}const x=Kr(g,3,d,2,h);if(0===x)return 0;const y=[],C=[],S=[];if(-1===x){const t=(0,o.m)(Ut,4);hn(g,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],n=(0,o.m)(o.M,3),i=(0,o.m)(o.M,3),r=(0,o.m)(o.M,3);rs(d,P,n,i,r);const a=[],m=[],l=jt(n,2,i,2,r,2,e,3,s,3,null,0,!0,o.E.unit(),o.E.unit(),m,a);if(l>0)for(let u=0;u<l;u++){const t=new o.P;bn(g,a[u],t);const e=new o.P;ms(d,P,m[u],e),o.P.distance(t,e)<=h&&(y.push(t.clone()),C.push(a[u]),S.push(m[u]))}}for(let E=0;E<2;E++){let t,e;0===E?(t=g,e=d):(e=g,t=d);for(let s=0;s<2;s++){const n=0===s?0:t.length-1,r=[0],a=new o.P;if(0===E){const s=Be(e,P,t[n],o.E.unit(),!1,-1,1,r);(0,i.g)(1===s),ms(e,P,r[0],a)}else{const s=Rn(e,t[n],o.E.unit(),!1,-1,1,r);(0,i.g)(1===s),bn(e,r[0],a)}o.P.distance(t[n],a)<=h&&(0===E?(C.push(0===n?0:1),S.push(r[0])):(S.push(0===n?0:1),C.push(r[0])),y.push(a.clone()))}}if(0===C.length)return 0;if(!_.equalsRange(0,1))for(let i=0;i<C.length;++i)C[i]=$s.recalculateParentT(_.vmin,_.vmax,C[i]);if(!p.equalsRange(0,1))for(let i=0;i<S.length;++i)S[i]=Bt.recalculateParentT(p.vmin,p.vmax,S[i]);for(let i=0;i<S.length;++i)S[i]=cs(f,S[i]);return Zr(t,e,s,C,S,C.length,n,r,a,h,m,l,u)}function Vn(t,e,s,n,r,a,h,m,l,u){const c=U(e,s);if(z(e,s,h=Math.max(h,c)))return 0;const g=(0,o.m)(o.P,4);e.queryControlPoints(g);const d=(0,o.m)(o.P,3);s.queryControlPoints(d);const _=Kr(g,3,d,2,h);if(0===_)return 0;const p=[],f=[],P=[];if(-1===_){const t=(0,o.m)(Ut,4);hn(g,t);const n=[t[0].x,t[1].x,t[2].x,t[3].x],i=[t[0].y,t[1].y,t[2].y,t[3].y],r=(0,o.m)(Ut,3);js(d,r);const a=jt([r[0].x,r[1].x,r[2].x],2,[r[0].y,r[1].y,r[2].y],2,null,0,n,3,i,3,null,0,!0,o.E.unit(),o.E.unit(),P,f);if(a>0){let t=0;for(let n=0;n<a;n++){const i=new o.P;e.queryCoord2D(f[n],i);const r=new o.P;s.queryCoord2D(P[n],r),o.P.distance(i,r)<=h&&(p.push(i.clone()),f[t]=f[n],P[t]=P[n],t++)}f.length=t,p.length=t}}for(let x=0;x<2;x++){let t,e;0===x?(t=g,e=d):(e=g,t=d);for(let s=0;s<2;s++){const n=0===s?0:t.length-1,r=[0],a=new o.P;if(0===x)qs(e,t[n],r),Zs(e,r[0],a);else{const s=Rn(e,t[n],o.E.unit(),!1,-1,1,r);(0,i.g)(1===s),bn(e,r[0],a)}o.P.distance(t[n],a)<=h&&(0===x?(f.push(0===n?0:1),P.push(r[0])):(P.push(0===n?0:1),f.push(r[0])),p.push(a.clone()))}}return Zr(t,e,s,f,P,f.length,n,r,a,h,m,l,u)}function Yn(t,e,s){const n=(0,o.m)(o.P,4);t.queryControlPoints(n),Xn(n,e,s)}function Xn(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,4);const n=(0,o.m)(o.P,4);vn(t,e.vmin,e.vmax,n),s.setFromPoints(n,4)}class kn{constructor(t,e){this.controlPoints=t,this.point=e.clone()}getMaxDerivative(){return 6}getValue(t,e){switch(t){case 0:{const t=new o.P;bn(this.controlPoints,e,t);const s=pn(this.controlPoints,1,e);return 2*t.sub(this.point).dotProduct(s)}case 1:{const t=new o.P;bn(this.controlPoints,e,t);const s=pn(this.controlPoints,1,e),n=pn(this.controlPoints,2,e);return 2*(t.sub(this.point).dotProduct(n)+s.dotProduct(s))}case 2:{const t=new o.P;bn(this.controlPoints,e,t);const s=pn(this.controlPoints,1,e),n=pn(this.controlPoints,2,e),i=pn(this.controlPoints,3,e);return 2*(t.sub(this.point).dotProduct(i)+3*s.dotProduct(n))}case 3:{const t=pn(this.controlPoints,1,e),s=pn(this.controlPoints,2,e),n=pn(this.controlPoints,3,e);return 2*(4*t.dotProduct(n)+3*s.sqrLength())}case 4:{const t=pn(this.controlPoints,2,e),s=pn(this.controlPoints,3,e);return 10*t.dotProduct(s)*2}case 5:{const t=pn(this.controlPoints,3,e);return 10*t.dotProduct(t)*2}default:return 0}}getError(t){return 0}}function Rn(t,e,s,n,a,h,m){(0,i.w)(o.E.unit().contains(s)&&h>0,"getClosestCoordinate"),(a<0||Number.isNaN(a))&&(a=Number.MAX_VALUE);const l=[],u=new o.P;bn(t,s.vmin,u);let c=o.P.distance(u,e);if(c<=a&&l.push(new o.P(s.vmin,c)),s.vmin!==s.vmax&&(bn(t,s.vmax,u),c=o.P.distance(u,e),c<=a&&l.push(new o.P(s.vmax,c))),s.width()>0){const n=(0,o.d)(18,Number.NaN),i=Ct(new kn(t,e),s,18,n);for(let s=0;s<i;s++)bn(t,n[s],u),c=o.P.distance(u,e),c>a||l.push(new o.P(n[s],c))}if(n){(0,i.g)(s.equals(o.E.unit()));{bn(t,-1,u,!0);const s=new o.P;bn(t,0,s);const n=new $r({start:u,end:s}),i=n.getClosestCoordinate(e,!0);i<1&&(u.assign(n.getCoord2D(i)),c=o.P.distance(u,e),c<=a&&l.push(new o.P(i-1,c)))}{bn(t,2,u,!0);const n=new o.P;bn(t,s.vmax,n);const i=new $r({start:n,end:u}),r=i.getClosestCoordinate(e,!0);r>0&&(u.assign(i.getCoord2D(r)),c=o.P.distance(u,e),c<=a&&l.push(new o.P(1+r,c)))}}if(!l.length)return 0;l.sort(((t,e)=>t.compare(e)));let g=0;const d=l[0].x;if(m[g++]=d,g<h){const e=(0,r.x)(t,4,!1).total(),s=l[0].y;for(let t=1,n=l.length;t<n;t++)if(l[t].y>s+e){l.length=t;break}l.sort(((t,e)=>(0,o.X)(t.x,e.x))),g=0,m[g++]=l[0].x;for(let t=1,n=l.length;t<n;t++)l[t].x!==m[g-1]&&g<h&&(m[g++]=l[t].x)}return g}function Hn(t,e,s,n,i,r,a){const h=(0,o.m)(o.P,4);return t.queryControlPoints(h),Rn(h,e,s,n,i,r,a)}function Ln(t,e){e[0].set(0);let s=1;const n=(0,o.m)(o.F,4);on(t,n,!0);const r=(0,o.m)(o.F,4);an(t,r,!0);{const t=n[3].mul(3),i=n[2].mul(2),r=n[1].clone(),a=(0,o.m)(o.F,2);let h=At(t,i,r,new o.E(0,1),!1,a);h<0&&(h=0);for(let n=0;n<h;n++)(0,o.J)(a[n].value(),0,1)||(e[s]=a[n],s++)}{const t=r[3].mul(3),n=r[2].mul(2),i=r[1].clone(),a=(0,o.m)(o.F,2);let h=At(t,n,i,new o.E(0,1),!1,a);h<0&&(h=0);for(let r=0;r<h;r++)(0,o.J)(a[r].value(),0,1)||(e[s]=a[r],s++)}if(s+=function(t,e,s){const n=t[1].mulE(e[2]).subThisE(t[2].mulE(e[1])),i=t[1].mulE(e[3]).subThisE(t[3].mulE(e[1])).mulThis(3),r=t[2].mulE(e[3]).subThisE(t[3].mulE(e[2])).mulThis(3),a=(0,o.m)(o.F,2);let h=At(r,i,n,new o.E(0,1),!1,a);h<0&&(h=0);let m=0;for(let l=0;l<h;l++)(0,o.J)(a[l].value(),0,1)||(s[m].setE(a[l]),m++);return m}(n,r,e.slice(s)),e[s].set(1),s++,s>2){(0,o.C)(e,0,s,((t,e)=>{const s=t.value(),n=e.value();return s<n?-1:s>n?1:0}));let n=0;const i=e[0].clone();let r=0;const a=function(t){return t[0].norm(1)+t[1].norm(1)+t[2].norm(1)+t[3].norm(1)}(t)*(0,o.N)(),h=new o.P;Cn(t,e[0].value(),h);for(let m=1;m<s;m++){const s=new o.P;if(Cn(t,e[m].value(),s),e[m].eq(i)||s.isEqualPoint2D(h,a)){if(0!==n){if(0===e[m].eps())i.setE(e[m]),r=0;else if(0!==r){const t=(0,o.s)(1/e[m].eps()),s=1/r,n=t+s;i.set((e[m].value()*t+i.value()*s)/n),r=1/n,i.setError(Math.sqrt(r))}e[n].setE(i),Cn(t,i.value(),h)}}else n++,e[n].setE(e[m]),i.setE(e[m]),Cn(t,i.value(),h),r=(0,o.s)(e[m].eps())}n++,s=n}return 1===s&&(s=2,e[1].set(1)),(0,i.g)(0===e[0].value()),(0,i.g)(1===e[s-1].value()),s}function Bn(t,e,s){s.setEmpty();const n=[];n.push(new o.E(0,1));const i=.5*Math.max(e.width(),e.height());for(;n.length;){const r=n.at(-1);n.pop();const a=new E;if(Xn(t,r,a),a.isIntersectingW(e)){const t=Math.max(a.width(),a.height());if(e.containsW(a)||t<=i||r.width()<1e-12)s.merge(r);else{const t=r.getCenter();n.push(o.E.construct(r.vmin,t)),n.push(o.E.construct(t,r.vmax))}}}}class Un{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-mn(this.b,e,!1):0}getError(t){return 0}}function zn(t,e,s,n,r,a,h){for(;;){const m=o.P.distance(e[0],e[3]),l=o.P.distance(e[0],e[1])+o.P.distance(e[1],e[2])+o.P.distance(e[2],e[3]);if(l-m<=n+s*l)return t+(0,o.q)(m,l,.5);const u=t=>pn(e,1,t).length();if(0===a){(0,i.g)(h<8);let m=u(0),c=u(1);r[0]+=2,m>c&&(c=(0,o.b)(m,m=c),e[3]=(0,o.b)(e[0],e[0]=e[3]),e[2]=(0,o.b)(e[1],e[1]=e[2]));let g=m/(m+c),d=1,_=l;for(;g<1/32&&_>=32*(n+s*_);){d/=4;const t=u(d);r[0]++,g=m/(t+m);const s=new o.P;if(bn(e,.5*d,s),_=o.P.distance(s,e[0]),_<=n){const t=new o.P;bn(e,d,t),_+=o.P.distance(t,s)}}if(1!==d){const i=(0,o.m)(o.P,4);Sn(e,d,e,i),t=zn(t,i,s,n,r,0,h+1),a++,h++;continue}}const c=8;r[0]+=c;const g=fe(c,u,0,1),d=16;r[0]+=d;const _=fe(d,u,0,1);let p=Math.abs(g-_)>n+s*l;if(!p)return t+_;if(a<3){const i=(0,o.m)(o.P,4);Sn(e,.5,e,i),t=zn(t,i,s,n,r,a+1,h+1),a++,h++;continue}const f=32;r[0]+=f;const P=fe(f,u,0,1);if(p=Math.abs(_-P)>n+s*l,!p)return t+P;const x=64;r[0]+=x;const y=fe(x,u,0,1);if(p=Math.abs(P-y)>n+s*l,!p)return t+y;const E=128;r[0]+=E;const C=fe(E,u,0,1);return p=Math.abs(y-C)>n+s*l,t+C}}function On(t,e,s,n,i){if(s===e)return 0;const r=(0,o.m)(o.P,4);t.queryControlPoints(r);const a=(0,o.m)(o.P,4);return vn(r,e,s,a),zn(0,a,n,i,[0],0,0)}function Wn(t,e,s,n,i){let r=!0;const a=Pe(5,e,s,n,i,(e=>{const s=Pn(t,1,e);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()}));r=!1;const h=Pe(5,e,s,n,i,(e=>{const s=Pn(t,1,e);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()}));return new o.P(a,h)}function jn(t,e,s,n,i,r,a,h,m,l,u,c){let g=0,d=0,_=0,p=0,f=0,P=0,x=0;for(let E=1,C=c-1;E<C;E++){let e,a,h,l,c,y,C=-1,S=m[E-1];t&&(E>2?(S=(0,o.c)(2*m[E-2]-m[E-3],0,1),m[E-1]=S):2===E&&S<=m[0]&&(S=m[0]));for(let g=0;g<11&&(e=m[E-1],a=e*e,h=a*e,l=1-e,c=l*l,y=c*l,t)&&!(Math.abs(e-C)<1e-12)&&10!==g;g++){const t=s.x-2*n.x+i.x,h=s.x-3*n.x+3*i.x-r.x,l=s.y-2*n.y+i.y,g=s.y-3*n.y+3*i.y-r.y,d=s.x-n.x-2*t*e+h*a,_=-u[E].x+s.x*y+e*(3*n.x*c+e*(3*i.x-3*i.x*e+r.x*e)),p=s.y-n.y-2*l*e+g*a,f=-u[E].y+s.y*y+e*(3*n.y*c+e*(3*i.y-3*i.y*e+r.y*e));C=e;const P=e- -6*(d*_+p*f)/(6*(3*(0,o.s)(d)-(-2*t+2*h*e)*_)+6*(3*(0,o.s)(p)-(-2*l+2*g*e)*f));m[E-1]=(0,o.c)(P,E>1?m[E-2]:0,1)}g+=3*a*c*c,d+=3*h*y,_+=3*a*a*c;const v=-(y*s.x+h*r.x-u[E].x);p+=v*e*c,f+=v*a*l;const b=-(y*s.y+h*r.y-u[E].y);P+=b*e*c,x+=b*a*l}if(e){const t=g*_-d*d;Math.abs(t)>=1e-12*(Math.abs(g*_)+Math.abs(d*d))+1e-10?(a||(n.x=(p*_-f*d)/t,n.y=(P*_-x*d)/t),h||(i.x=(g*f-d*p)/t,i.y=(g*x-d*P)/t)):((0,o.Z)(s,r,.3,n),(0,o.Z)(s,r,.6,i))}let y=0;for(let E=1,C=c-1;E<C;E++){const t=m[E-1],e=1-t,a=s.mul((0,o.af)(e)),h=n.mul(3*t*e*e),l=i.mul(3*t*t*e),c=r.mul((0,o.af)(t));y+=a.add(h).add(l).add(c).sub(u[E]).sqrLength()}return y}function Zn(t,e,s,n){const i=t.getPathStart(e),r=t.getPathEnd(e);if(r-i<3)return;const a=2*i,h=o.P.getNAN();s.queryPoint2D(a,h);const m=h.x,l=h.y,u=o.P.getNAN();s.queryPoint2D(a+2,u);const c=o.P.getNAN();for(let o=a+4,g=2*r;o<g;o+=2)s.queryPoint2D(o,c),n.pe((c.x-h.x)*(u.y-l)),h.setCoordsPoint2D(u),u.setCoordsPoint2D(c);n.pe((m-h.x)*(u.y-l))}function Qn(t,e,s){for(;e.hasNextSegment();){const t=e.nextCurve();if(null===t)break;s.pe(2*t.calculateArea2DHelper())}}var Kn=r.V;class Jn{static toSegType(t){let e=0;switch(t){case i.G.enumLine:e=1;break;case i.G.enumBezier:e=2;break;case i.G.enumEllipticArc:e=4;break;case i.G.enumRationalBezier2:e=8;break;case i.G.enumBezier2:e=16;break;default:(0,i.c)("")}return e}constructor(){this.m_segmentFlags=null,this.m_segmentParamIndex=null,this.m_segmentParams=null,this.m_curveCount=0,this.m_bezierCount=0,this.m_arcCount=0,this.m_rbezier2Count=0,this.m_bezier2Count=0,this.m_curveParamWritePoint=0}assignCopy(t){return this.m_segmentFlags=t.m_segmentFlags,this.m_segmentParamIndex=t.m_segmentParamIndex,this.m_segmentParams=t.m_segmentParams,this.m_curveCount=t.m_curveCount,this.m_bezierCount=t.m_bezierCount,this.m_arcCount=t.m_arcCount,this.m_rbezier2Count=t.m_rbezier2Count,this.m_bezier2Count=t.m_bezier2Count,this.m_curveParamWritePoint=t.m_curveParamWritePoint,this}}class $n extends x{constructor(t){super(t),this.m_cachedRingAreas2D=null,this.m_paths=null,this.m_pathFlags=null,this.m_curveData=null,t.move?(this.m_bPolygon=t.move.m_bPolygon,this.m_cachedLength2D=t.move.m_cachedLength2D,this.m_cachedArea2D=t.move.m_cachedArea2D,this.m_currentPathIndex=t.move.m_currentPathIndex,this.m_cachedRingAreas2D=t.move.m_cachedRingAreas2D,this.m_paths=t.move.m_paths,this.m_pathFlags=t.move.m_pathFlags,this.m_curveData=t.move.m_curveData,t.move.m_curveData=null,t.move.setEmpty()):(this.m_bPolygon=t.bPolygon,this.m_cachedLength2D=0,this.m_cachedArea2D=0,this.m_currentPathIndex=0)}getGeometryType(){return this.m_bPolygon?i.G.enumPolygon:i.G.enumPolyline}getDimension(){return this.m_bPolygon?2:1}changeRingStartPoint(t){(0,i.g)(this.m_bPolygon);const e=this.getPathIndexFromPointIndex(t),s=this.getPathStart(e);if(s===t)return;const n=this.getPathEnd(e);(t>=n||t<s)&&(0,i.t)("change_ring_start_point");for(let i=0,r=this.m_description.getAttributeCount();i<r;i++){const e=this.m_description.getSemantics(i),r=Kn.getComponentCount(e);this.m_vertexAttributes.get(i).rotate(s*r,t*r,n*r)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.rotate(s,t,n),this.m_curveData.m_segmentParamIndex.rotate(s,t,n))}setFillRule(t){this.m_bFillRule=1===t}getFillRule(){return this.m_bFillRule?1:0}isExteriorRingOGC(t){return!!this.m_bPolygon&&(this.updateOGCFlagsProtected(),!!(8&this.m_pathFlags.read(t)))}isExteriorRing(t){return this.calculateRingArea2D(t)>0}calculateRingArea2D(t){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedRingAreas2D.read(t)):0}updateRingAreas2DProtected(){if(!this.hasDirtyFlag(1024))return;const t=this.getPathCount();if(0===t)return this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=0),void this.setDirtyFlagProtected(1024,!1);const e=new r.y(t),s=new o.K(0),n=new o.K(0);if(0!==this.m_pointCount){const i=this.getAttributeStreamRef(0);if(this.hasNonLinearSegments()){const t=new _t({parent:this});for(t.stripAttributes();t.nextPath();){n.reset();const r=t.getPathIndex();Zn(this,r,i,n),Qn(0,t,n);const o=.5*n.getResult();s.add(o),e.write(r,o)}}else for(let r=0;r<t;r++){n.reset(),Zn(this,r,i,n);const t=.5*n.getResult();s.add(t),e.write(r,t)}}this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=s.getResult(),this.m_cachedRingAreas2D=e,this.setDirtyFlagProtected(1024,!1))}getOGCPolygonCount(){if(!this.m_bPolygon)return 0;this.updateOGCFlagsProtected();let t=0;const e=this.getPathCount();for(let s=0;s<e;s++)8&this.m_pathFlags.read(s)&&t++;return t}getHashCodeImpl(){return(0,i.g)(0),0}equalsImpl(t){const e=t,s=this.getPathCount();if(s!==e.getPathCount())return!1;const n=this.hasNonLinearSegments();if(n!==e.hasNonLinearSegments())return!1;if(n){if(this.m_curveData.m_curveCount!==e.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==e.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(e.m_paths,0,s+1))return!1;if(this.m_bFillRule!==e.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(e.m_pathFlags,0,s))return!1;if(this.hasNonLinearSegments()){if(!this.m_curveData.m_segmentFlags.equals(e.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;for(let t=0,s=this.getPointCount();t<s;t++){const s=this.m_curveData.m_segmentFlags.read(t);if(!$n.isNonLinearSegmentFlag(s))continue;const n=this.m_curveData.m_segmentParamIndex.read(t),i=e.m_curveData.m_segmentParamIndex.read(t),r=Et(s);for(let t=0;t<r;t++){const s=this.m_curveData.m_segmentParams.read(n+t),r=e.m_curveData.m_segmentParams.read(i+t);if(!(0,o.a3)(s,r))return!1}}}return!0}equalsImplTol(t,e){const s=t,n=this.getPathCount();if(n!==s.getPathCount())return!1;const i=this.hasNonLinearSegments();if(i!==s.hasNonLinearSegments())return!1;if(i){if(this.m_curveData.m_curveCount!==s.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==s.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(s.m_paths,0,n+1))return!1;if(this.m_bFillRule!==s.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(s.m_pathFlags,0,n))return!1;if(!i)return!0;if(!this.m_curveData.m_segmentFlags.equals(s.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;const r=this.querySegmentIterator(),o=s.querySegmentIterator();for(;r.nextPath();){if(!o.nextPath())return!1;for(;r.hasNextSegment();){const t=r.nextCurve(),s=o.nextCurve();if(!(t&&s&&t.equals(s,e))){if(!t&&!s)break;return!1}}}return!0}reserveImplImpl(t,e){this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(t,1),this.m_curveData.m_segmentParamIndex.resize(t,-1),this.checkCompactSegmentParams())}verifyStreamsAfterSizeChangeExtraImpl(){this.m_paths||(this.m_paths=(0,r.z)(1,0),this.m_pathFlags=(0,r.D)(1,0)),this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount,1),this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount,-1),this.checkCompactSegmentParams())}copyToImpl(t,e){const s=t;s.m_bPathStarted=!1,s.m_bFillRule=this.m_bFillRule,this.m_paths?s.m_paths=e?this.m_paths:this.m_paths.clone():s.m_paths=null,this.m_pathFlags?s.m_pathFlags=e?this.m_pathFlags:this.m_pathFlags.clone():s.m_pathFlags=null,this.m_curveData&&(s.m_curveData||(s.m_curveData=new Jn),s.m_curveData.assignCopy(this.m_curveData),s.m_curveData.m_curveCount=0,s.updateCurveCounter(this.m_curveData.m_curveCount),e||(this.m_curveData.m_segmentParamIndex?s.m_curveData.m_segmentParamIndex=this.m_curveData.m_segmentParamIndex.clone():s.m_curveData.m_segmentParamIndex=null,this.m_curveData.m_segmentFlags?s.m_curveData.m_segmentFlags=this.m_curveData.m_segmentFlags.clone():s.m_curveData.m_segmentFlags=null,this.m_curveData.m_segmentParams?s.m_curveData.m_segmentParams=this.m_curveData.m_segmentParams.clone():s.m_curveData.m_segmentParams=null)),s.hasDirtyFlag(512)||(s.m_cachedLength2D=this.m_cachedLength2D),s.m_cachedRingAreas2D=null,s.hasDirtyFlag(1024)||(s.m_cachedArea2D=this.m_cachedArea2D,null!==this.m_cachedRingAreas2D&&(s.m_cachedRingAreas2D=e?this.m_cachedRingAreas2D:this.m_cachedRingAreas2D.clone()))}calculateArea2D(){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedArea2D):0}calculateLength2D(){if(!this.hasDirtyFlag(512))return this.m_cachedLength2D;const t=this.querySegmentIterator(),e=new o.K(0);for(;t.nextPath();)for(;t.hasNextSegment();)e.add(t.nextSegment().calculateLength2D());return this.hasDirtyFlag(512)&&(this.m_cachedLength2D=e.getResult()),this.setDirtyFlagProtected(512,!1),e.getResult()}calculatePathLength2D(t){const e=this.querySegmentIteratorAtVertex(this.getPathStart(t)),s=new o.K(0);for(;e.hasNextSegment();)s.add(e.nextSegment().calculateLength2D());return s.getResult()}calculateLength3D(t){return(0,i.g)(0),0}calculatePathLength3D(t,e){return(0,i.g)(0),0}copyTo(t){(0,i.h)(t.getGeometryType())||(0,i.t)(""),this!==t&&super.copyTo(t)}swap(t){(0,i.g)(0)}hasNonLinearSegments(){return 0!==this.getCurveCount()}getSegmentCount(){let t=this.getPointCount();if(!this.m_bPolygon){t-=this.getPathCount();for(let e=0,s=this.getPathCount();e<s;e++)this.isClosedPath(e)&&t++}return t}getSegmentCountPath(t){let e=this.getPathSize(t);return!this.isClosedPath(t)&&e>0&&e--,e}add(t,e){this===t&&(0,i.t)("Multi_path_impl::add");for(let s=0,n=t.getPathCount();s<n;s++)this.addPath(t,s,!e)}addPath(t,e,s){this.insertPath(-1,t,e,s)}addPathPoint2D(t,e,s){this.insertPath2D(-1,t,0,e,s)}addPathMultiPoint(t,e,s,n){s<0&&(s=t.getPointCount()-e),this.insertPointsFromMultipoint(-1,0,t,e,s,n)}addSegmentsFromPath(t,e,s,n,r){if(this===t&&(0,i.t)("Multi_path_impl.add_segments_from_path"),r||0!==this.getPathCount()||(r=!0),e<0&&(e=t.getPathCount()-1),(e>=t.getPathCount()||s<0||n<0||s+n>t.getSegmentCountPath(e))&&(0,i.n)("add_segments_from_path"),0===n)return;const o=t.getPathStart(e),a=t.isClosedPath(e)&&s+n===t.getSegmentCountPath(e);this.m_bPathStarted=!1,this.mergeVertexDescription(t.getDescription());let h=n;const m=o+s;let l=m+1;r&&(h++,l--),!r&&t.hasNonLinearSegments()&&1!==t.m_curveData.m_segmentFlags.read(m)&&(t.getXY(m).equals(this.getXY(this.m_pointCount-1))||(0,i.t)("add_segments_from_path: start point mismatch"));const u=this.m_pointCount;if(this.resizeImpl(this.m_pointCount+h),this.verifyAllStreamsAfterSizeChange(),r){if(0===h)return;this.m_paths.add(this.m_pointCount);let s=t.m_pathFlags.read(e);this.m_bPolygon&&(s|=1),this.m_pathFlags.write(this.m_pathFlags.size()-1,s),this.m_pathFlags.add(0)}else this.m_paths.write(this.m_pathFlags.size()-1,this.m_pointCount);const c=a?h-1:h;for(let i=0,g=this.m_description.getAttributeCount();i<g;i++){const e=this.m_description.getSemantics(i),s=Kn.getComponentCount(e),n=t.m_description.getAttributeIndex(e);if(c>0){if(n<0||!t.m_vertexAttributes.get(n)){const t=Kn.getDefaultValue(e);this.m_vertexAttributes.get(i).insertRange(s*u,t,c*s,s*u),a&&this.m_vertexAttributes.get(i).insertRange(s*u+c*s,t,s,s*u);continue}this.m_vertexAttributes.get(i).insertRangeFromStream(s*u,t.m_vertexAttributes.get(n),s*l,c*s,!0,s,s*u)}a&&this.m_vertexAttributes.get(i).insertRangeFromStream(s*(u+c),t.m_vertexAttributes.get(n),s*o,s,!0,s,s*(u+c))}if(this.hasNonLinearSegments()&&this.initSegmentData(0),t.hasNonLinearSegments()){let e=0;for(let s=0,i=m;s<n;s++)e+=Et(t.m_curveData.m_segmentFlags.read(i)),i++;if(e>0){this.initSegmentData(e);let s=m,i=u-(r?0:1),o=0;for(let e=0;e<n;e++){const e=t.m_curveData.m_segmentFlags.read(s);if(this.m_curveData.m_segmentFlags.write(i,e),$n.isNonLinearSegmentFlag(e)){o++;let n=t.m_curveData.m_segmentParamIndex.read(s);const r=Et(e);this.m_curveData.m_segmentParamIndex.write(i,this.m_curveData.m_curveParamWritePoint);for(let e=0;e<r;e++){const e=t.m_curveData.m_segmentParams.read(n);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,e),this.m_curveData.m_curveParamWritePoint++,n++}this.incCurveType(e,1)}else this.m_curveData.m_segmentParamIndex.write(i,-1);i++,s++}this.modifyCurveCounter(o)}}if(a){const t=this.getPathCount()-1,e=this.getPathStart(t),s=this.getPathEnd(t)-1,n=this.getXY(e),i=this.getXY(s);n.isEqualPoint2D(i)&&(--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount))}this.notifyModifiedFlags(2001)}reverseAllPaths(){for(let t=0,e=this.getPathCount();t<e;t++)this.reversePath(t)}reversePath(t){t>=this.getPathCount()&&(0,i.t)("");const e=this.getPathSize(t);if(0===e)return;const s=this.getPathStart(t),n=this.isClosedPath(t);if(this.hasNonLinearSegments()){let t=s;const i=new this.m_segmentBufferCTor;let r=!1;for(let s=0;s<e;s++,t++){const e=this.m_curveData.m_segmentFlags.read(t);if(!$n.isNonLinearSegmentFlag(e))continue;r=!0,this.querySegment(t,i,!0),i.get().reverse();const s=this.m_curveData.m_segmentParamIndex.read(t);i.get().writeInBufferStream(this.m_curveData.m_segmentParams,s)}if(r){const t=n?0:1;this.m_curveData.m_segmentFlags.reverseRange(s,e-t,1),this.m_curveData.m_segmentParamIndex.reverseRange(s,e-t,1)}}const r=n?1:0;for(let i=0,a=this.m_description.getAttributeCount();i<a;i++)if(this.m_vertexAttributes.get(i)){const t=this.m_description.getSemantics(i),n=Kn.getComponentCount(t);this.m_vertexAttributes.get(i).reverseRange(n*(s+r),n*(e-r),n)}const o=6&this.m_pathFlags.read(t);if(o){let e=0;4&o&&(e|=2),2&o&&(e|=4),this.m_pathFlags.clearBits(t,6),this.m_pathFlags.setBits(t,e)}this.notifyModifiedFlags(1233)}removePath(t){const e=this.getPathCount();t<0&&(t=e-1),t>=e&&(0,i.t)("");const s=this.getPathStart(t),n=this.getPathSize(t);for(let i=0,r=this.m_description.getAttributeCount();i<r;i++)if(this.m_vertexAttributes.get(i)){const t=this.m_description.getSemantics(i),e=Kn.getComponentCount(t);this.m_vertexAttributes.get(i).eraseRange(e*s,e*n,e*this.m_pointCount)}if(this.hasNonLinearSegments()){let t=0;for(let e=s,i=s+n;e<i;e++){const s=this.m_curveData.m_segmentFlags.read(e);$n.isNonLinearSegmentFlag(s)&&(this.incCurveType(s,-1),t++)}this.modifyCurveCounter(-t),this.m_curveData.m_segmentFlags.eraseRange(s,n,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(s,n,this.m_pointCount)}for(let i=t+1;i<=e;i++){const t=this.m_paths.read(i);this.m_paths.write(i-1,t-n)}if(this.m_pathFlags)for(let i=t+1;i<=e;i++){const t=this.m_pathFlags.read(i);this.m_pathFlags.write(i-1,t)}this.m_paths.resize(e),this.m_pathFlags.resize(e),this.m_pointCount-=n,this.m_reservedPointCount-=n,t===e-1&&(this.m_bPathStarted=!1),this.notifyModifiedFlags(2001),this.checkCompactSegmentParams(),this.dbgVerifyCurves()}dbgVerifyCurves(){}insertPath(t,e,s,n){this===e&&(0,i.t)("Multi_path_impl::insert_path");const o=this.getPathCount();if(!n&&e.hasNonLinearSegmentsPath(s))return t=this.insertPath(t,e,s,!0),this.reversePath(t),t;s>=e.getPathCount()&&(0,i.t)(""),t>o&&(0,i.t)(""),t<0&&(t=o),s<0&&(s=e.getPathCount()-1),this.m_bPathStarted=!1,this.mergeVertexDescription(e.getDescription());const a=e.getPathStart(s),h=e.getPathSize(s);if(0===h)return this.insertPath2D(t,null,0,0,!0);const m=this.m_pointCount,l=e.isClosedPath(s)&&!n?1:0;this.resizeImpl(this.m_pointCount+h),this.verifyAllStreamsAfterSizeChange();const u=t<o?this.getPathStart(t):m;for(let i=0,r=this.m_description.getAttributeCount();i<r;i++){const t=this.m_description.getSemantics(i),s=e.getDescription().getAttributeIndex(t),r=Kn.getComponentCount(t);if(s>=0&&e.m_vertexAttributes.get(s))0!==l&&this.m_vertexAttributes.get(i).insertRangeFromStream(u*r,e.m_vertexAttributes.get(s),r*a,r,!0,r,r*m),this.m_vertexAttributes.get(i).insertRangeFromStream((u+l)*r,e.m_vertexAttributes.get(s),r*(a+l),r*(h-l),n,r,r*(m+l));else{const e=Kn.getDefaultValue(t);this.m_vertexAttributes.get(i).insertRange(u*r,e,r*h,r*m)}}const c=m+h;this.m_paths.add(c);for(let i=o;i>=t+1;i--){const t=this.m_paths.read(i-1);this.m_paths.write(i,t+h)}this.m_pathFlags.add(0);for(let i=o-1;i>=t+1;i--){let t=this.m_pathFlags.read(i);t&=-9,this.m_pathFlags.write(i+1,t)}let g=e.getPathFlagsStreamRef().read(s);if(g&=-9,this.m_bPolygon&&(g|=1),this.m_pathFlags.write(t,g),e.hasNonLinearSegments()){this.initSegmentData(0);let t=a,s=0;for(let n=0;n<h;n++)s+=Et(e.m_curveData.m_segmentFlags.read(t)),t++;if(s>0){null===this.m_curveData.m_segmentFlags?(this.m_curveData.m_segmentFlags=(0,r.D)(this.m_pointCount,1),this.m_curveData.m_segmentParamIndex=(0,r.z)(this.m_pointCount,-1)):(this.m_curveData.m_segmentFlags.insertRange(u,1,h,m),this.m_curveData.m_segmentParamIndex.insertRange(u,-1,h,m)),this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint+s):this.m_curveData.m_segmentParams=(0,r.F)(s),t=a;let n=u,i=0;for(let s=0;s<h;s++){const s=e.m_curveData.m_segmentFlags.read(t);if($n.isNonLinearSegmentFlag(s)){this.m_curveData.m_segmentFlags.write(n,s),this.m_curveData.m_segmentParamIndex.write(n,this.m_curveData.m_curveParamWritePoint);const r=Et(s);let o=e.m_curveData.m_segmentParamIndex.read(t);for(let t=0;t<r;t++){const t=e.m_curveData.m_segmentParams.read(o);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,t),this.m_curveData.m_curveParamWritePoint++,o++}i++,this.incCurveType(s,1)}t++,n++}this.modifyCurveCounter(i)}}return this.notifyModifiedFlags(2001),t}insertPath2D(t,e,s,n,r){const o=this.getPathCount();(t>o||s<0)&&(0,i.t)(""),t<0&&(t=o),this.m_bPathStarted=!1;const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+n),0===n&&this.notifyModifiedFlags(32),this.verifyAllStreamsAfterSizeChange();const h=t<o?this.getPathStart(t):a;if(e)this.m_vertexAttributes.get(0).insertRangeFromPoints(2*h,e,s,n,r,2*a);else{const t=Kn.getDefaultValue(0);this.m_vertexAttributes.get(0).insertRange(2*h,t,2*n,2*a)}for(let i=1,m=this.m_description.getAttributeCount();i<m;i++){const t=this.m_description.getSemantics(i),e=Kn.getComponentCount(t),s=Kn.getDefaultValue(t);this.m_vertexAttributes.get(i).insertRange(h*e,s,e*n,e*a)}this.m_paths.add(this.m_pointCount);for(let i=o;i>=t+1;i--){const t=this.m_paths.read(i-1);this.m_paths.write(i,t+n)}this.m_pathFlags.add(0);for(let i=o-1;i>=t+1;i--){let t=this.m_pathFlags.read(i);t&=-9,this.m_pathFlags.write(i+1,t)}return this.m_bPolygon&&this.m_pathFlags.write(t,1),this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h,1,n,a),this.m_curveData.m_segmentParamIndex.insertRange(h,-1,n,a)),this.notifyModifiedFlags(2001),t}insertPathFromMultipoint(t,e,s,n,r){const o=e.getImpl(),a=this.getPathCount();(t>a||s<0)&&(0,i.t)("");const h=n<0?o.getPointCount()-s:n;if(h>o.getPointCount()&&(0,i.t)(""),s>=o.getPointCount()&&(0,i.t)("pointsOffset"),t<0&&(t=a),this.m_bPathStarted=!1,this.mergeVertexDescription(o.getDescription()),0===h)return void this.insertPath2D(t,null,0,0,!0);const m=this.m_pointCount,l=s;this.resizeImpl(this.m_pointCount+h),this.verifyAllStreamsAfterSizeChange();const u=t<a?this.getPathStart(t):m;for(let i=0,d=this.m_description.getAttributeCount();i<d;i++){const t=this.m_description.getSemantics(i),e=o.getDescription().getAttributeIndex(t),s=Kn.getComponentCount(t);if(e>=0){const e=o.getAttributeStreamRef(t);this.m_vertexAttributes.get(i).insertRangeFromStream(u*s,e,s*l,s*h,r,s,s*m)}else{const e=Kn.getDefaultValue(t);this.m_vertexAttributes.get(i).insertRange(u*s,e,s*h,s*m)}}const c=m+h;this.m_paths.add(c);for(let i=a;i>=t+1;i--){const t=this.m_paths.read(i-1);this.m_paths.write(i,t+h)}this.m_pathFlags.add(0);for(let i=a-1;i>=t+1;i--){let t=this.m_pathFlags.read(i);t&=-9,this.m_pathFlags.write(i+1,t)}let g=0;this.m_bPolygon&&(g|=1),this.m_pathFlags.write(t,g),this.notifyModifiedFlags(2001)}insertPoints(t,e,s,n,r,o,a){if(this===s&&(0,i.t)("Multi_path_impl.insert_points"),t<0&&(t=this.getPathCount()),n<0&&(n=s.getPathCount()-1),(t>this.getPathCount()||e>=0&&e>this.getPathSize(t)||n>=s.getPathCount()||o>s.getPathSize(n))&&(0,i.n)(""),!o)return;if(this.mergeVertexDescription(s.m_description),t===this.getPathCount()){this.m_paths.add(this.m_pointCount);let t=s.m_pathFlags.read(n);t&=-9,this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}e<0&&(e=this.getPathSize(t));const h=this.m_pointCount;this.resizeImpl(this.m_pointCount+o),this.verifyAllStreamsAfterSizeChange();const m=this.getPathStart(t),l=m+e;o<0&&(o=s.getPathSize(n));const u=s.getPathStart(n),c=u+o;for(let i=0,d=this.m_description.getAttributeCount();i<d;i++){var g;const t=this.m_description.getSemantics(i),n=Kn.getComponentCount(t),d=s.m_description.getAttributeIndex(t);if(d<0||!s.m_vertexAttributes.get(d)){const e=Kn.getDefaultValue(t);this.m_vertexAttributes.get(i).insertRange(n*l,e,c*n,n*h)}else null===(g=this.m_vertexAttributes.get(i))||void 0===g||g.insertRangeFromStream(n*(m+e),s.m_vertexAttributes.get(d),n*(u+r),o*n,a,n,n*h)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(m+e,1,o,h),this.m_curveData.m_segmentParamIndex.insertRange(m+e,-1,o,h),e>0&&this.isNonLinearSegment(m+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(m+e-1),-1),this.m_curveData.m_segmentFlags.write(m+e-1,1),this.m_curveData.m_segmentParamIndex.write(m+e-1,-1),this.modifyCurveCounter(-1)));for(let i=t+1,d=this.getPathCount();i<=d;i++){const t=this.m_paths.read(i);this.m_paths.write(i,t+o)}this.notifyModifiedFlags(2001)}insertPointsFromPoints(t,e,s,n,r,o){if(t<0&&(t=this.getPathCount()),(t>this.getPathCount()||e>this.getPathSize(t)||n<0)&&(0,i.n)(""),!r)return;t===this.getPathCount()&&(this.m_paths.add(this.m_pointCount),this.m_bPolygon?this.m_pathFlags.add(1):this.m_pathFlags.add(0)),e<0&&(e=this.getPathSize(t));const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const h=this.getPathStart(t);this.m_vertexAttributes.get(0).insertRangeFromPoints(2*(h+e),s,n,r,o,2*a);for(let i=1,m=this.m_description.getAttributeCount();i<m;i++){const t=this.m_description.getSemantics(i),s=Kn.getComponentCount(t),n=Kn.getDefaultValue(t);this.m_vertexAttributes.get(i).insertRange((h+e)*s,n,s*r,s*a)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h+e,1,r,a),this.m_curveData.m_segmentParamIndex.insertRange(h+e,-1,r,a),e>0&&this.isNonLinearSegment(h+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(h+e-1),-1),this.m_curveData.m_segmentFlags.write(h+e-1,1),this.m_curveData.m_segmentParamIndex.write(h+e-1,-1),this.modifyCurveCounter(-1)));for(let i=t+1,m=this.getPathCount();i<=m;i++)this.m_paths.write(i,this.m_paths.read(i)+r);this.notifyModifiedFlags(2001)}insertPointsFromMultipoint(t,e,s,n,r,o){const a=s.getImpl(),h=this.getPathCount();t<0&&(t=this.getPathCount());const m=a.getPointCount();if((n<0||n>m)&&(0,i.n)(""),(r<0||n+r>m)&&(r=m-n),e<0&&(e=t<h?this.getPathSize(t):0),(t>h||t<h&&e>this.getPathSize(t)||t===h&&e>0||r<0)&&(0,i.n)(""),!r)return;if(this.mergeVertexDescription(a.getDescription()),t===h){this.m_paths.add(this.m_pointCount);const t=0;this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}e<0&&(e=this.getPathSize(t));const l=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const u=this.getPathStart(t),c=u+e,g=0+r;for(let i=0,d=this.m_description.getAttributeCount();i<d;i++){const t=this.m_description.getSemantics(i),s=Kn.getComponentCount(t);if(a.getDescription().getAttributeIndex(t)<0){const e=Kn.getDefaultValue(t);this.m_vertexAttributes.get(i).insertRange(s*c,e,g*s,s*l);continue}const h=a.getAttributeStreamRef(t);this.m_vertexAttributes.get(i).insertRangeFromStream(s*(u+e),h,s*(0+n),r*s,o,s,s*l)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(u+e,1,r,l),this.m_curveData.m_segmentParamIndex.insertRange(u+e,-1,r,l),e>0&&this.isNonLinearSegment(u+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(u+e-1),-1),this.m_curveData.m_segmentFlags.write(u+e-1,1),this.m_curveData.m_segmentParamIndex.write(u+e-1,-1),this.modifyCurveCounter(-1)));for(let i=t+1,d=this.getPathCount();i<=d;i++){const t=this.m_paths.read(i);this.m_paths.write(i,t+r)}this.notifyModifiedFlags(2001)}insertPoint2D(t,e,s){const n=this.getPathCount();t<0&&(t=n),(t>n||t<n&&e>this.getPathSize(t))&&(0,i.n)(""),t===n&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o,h=this.m_vertexAttributes.get(0);if(a===r)this.m_paths.write(t+1,r+1),h.writePoint2D(2*a,s);else{h.insert(2*a,s,2*r);for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=Kn.getComponentCount(e),n=Kn.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(s*a,n,s,s*r)}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let e=t+1,s=n;e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}insertPoint(t,e,s){const n=this.getPathCount();t<0&&(t=n),(t>n||t<n&&e>this.getPathSize(t))&&(0,i.n)(""),t===n&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o;if(a===r)this.m_paths.write(t+1,r+1),this.setPointByVal(a,s);else{const e=s.getDescription();this.m_description!==e&&this.mergeVertexDescription(e);for(let t=0,n=this.m_description.getAttributeCount();t<n;t++){const n=this.m_description.getSemantics(t),i=Kn.getComponentCount(n);if(e.hasAttribute(n))this.m_vertexAttributes.get(t).insertAttributes(i*a,s,n,i*r);else{const e=Kn.getDefaultValue(n);this.m_vertexAttributes.get(t).insertRange(i*a,e,i,i*r)}}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let s=t+1,i=n;s<=i;s++)this.m_paths.write(s,this.m_paths.read(s)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}removePointFromPath(t,e){const s=this.getPathCount();t<0&&(t=s-1),(t>=s||e>=this.getPathSize(t))&&(0,i.n)("Multi_path.remove_point");const n=this.getPathStart(t),r=this.isClosedPath(t);e<0&&(e=this.getPathSize(t)-1),e<0&&(0,i.n)("Multi_path.remove_point");const o=n+e;for(let i=0,a=this.m_description.getAttributeCount();i<a;i++)if(this.m_vertexAttributes.get(i)){const t=this.m_description.getSemantics(i),e=Kn.getComponentCount(t);this.m_vertexAttributes.get(i).eraseRange(e*o,e,e*this.m_pointCount)}if(this.m_curveData&&this.m_curveData.m_segmentFlags){this.checkCompactSegmentParams();let e=0;if(o>n&&this.isNonLinearSegment(o-1))e+=1,this.incCurveType(this.m_curveData.m_segmentFlags.read(o-1),-1),this.m_curveData.m_segmentFlags.write(o-1,1),this.m_curveData.m_segmentParamIndex.write(o-1,-1);else{const s=this.getPathEnd(t);r&&n+1<s&&this.isNonLinearSegment(s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(s-1),-1),this.m_curveData.m_segmentFlags.write(s-1,1),this.m_curveData.m_segmentParamIndex.write(s-1,-1),e+=1)}this.isNonLinearSegment(o)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(o),-1),e+=1),e>0&&this.modifyCurveCounter(-e),this.m_curveData.m_segmentFlags.eraseRange(o,1,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(o,1,this.m_pointCount)}for(let i=s;i>=t+1;i--){const t=this.m_paths.read(i);this.m_paths.write(i,t-1)}this.m_pointCount--,this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}removePoint(t){let e;e=t<0?this.getPathCount()-1:this.getPathIndexFromPointIndex(t),this.removePointFromPath(e,t-this.getPathStart(e))}getNumberOfCurves(t){if(!this.hasNonLinearSegments())return 0;let e=0;for(let s=this.getPathStart(t),n=this.getPathEnd(t);s<n;s++)$n.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s))&&++e;return e}getPathCount(){return this.m_paths?this.m_paths.size()-1:0}getPathSize(t){return this.m_paths.read(t+1)-this.m_paths.read(t)}getPathStart(t){return this.m_paths.read(t)}getPathEnd(t){return this.m_paths.read(t+1)}getPathIndexFromPointIndex(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;-1===e&&(e=this.m_currentPathIndex);const s=this.getPathCount(),n=$n.getPathIndexFromPointIndexImpl(this.m_paths,s,t,e);return this.m_currentPathIndex=n,n}startPathCoords(t,e){this.startPathPoint(new r.P({x:t,y:e}))}startPath(t){this.startPathPoint(new r.P({pt:t}))}startPath3D(t){this.startPathPoint(new r.P({x:t.x,y:t.y,z:t.z}))}startPath3DCoords(t,e,s){this.startPathPoint(new r.P({x:t,y:e,z:s}))}startPathPoint(t){t.isEmpty()&&(0,i.t)("");const e=t.getDescription();let s;if(this.m_description!==e){this.mergeVertexDescription(e);const n=new r.P({vd:this.m_description});t.copyCommonAttributesTo(n),s=n}else s=t;this.m_bPathStarted?this.setPointByVal(this.m_pointCount-1,s):(this.insertPoint(-1,-1,s),this.m_bPathStarted=!0)}beforeNewSegmentHelper2(){this.m_paths=(0,r.z)(2),this.m_paths.write(0,0),this.m_pathFlags=(0,r.D)(2,0),this.m_bPolygon&&this.m_pathFlags.write(0,1)}beforeNewSegmentHelper1(){null!==this.m_paths?(this.m_paths.add(0),this.m_pathFlags.add(0),this.m_bPolygon&&this.m_pathFlags.write(this.m_pathFlags.size()-2,1)):this.beforeNewSegmentHelper2()}beforeNewSegment(t){0!==this.m_pointCount||this.m_bPathStarted||this.startPathCoords(0,0);const e=this.m_pointCount,s=this.m_paths.size()-1,n=e+t;this.m_paths.write(s,n),this.resizeImpl(n),this.m_bPathStarted&&(this.m_bPathStarted=!1)}finishLineTo(){if(this.hasNonLinearSegments()){const t=this.m_curveData.m_segmentFlags.read(this.m_pointCount-1);1!==t&&(this.m_curveData.m_segmentFlags.write(this.m_pointCount-1,1),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-1,-1),this.modifyCurveCounter(-1),this.incCurveType(t,-1))}}lineToCoords(t,e){if(this.beforeNewSegment(1),1===this.m_description.getAttributeCount())this.setXYCoords(this.m_pointCount-1,t,e);else{const s=(0,r.o)(),n=new r.P({vd:this.m_description,attribBuffer:s,initDefaultValues:!0});n.setXYCoords(t,e),this.setPointByVal(this.m_pointCount-1,n)}this.finishLineTo()}lineTo(t){this.lineToCoords(t.x,t.y)}lineTo3D(t){this.beforeNewSegment(1);const e=(0,r.l)(this.m_description,(0,r.w)()),s=(0,r.o)(),n=new r.P({vd:e,attribBuffer:s,initDefaultValues:!0});n.setXYZ(t),this.setPointByVal(this.m_pointCount-1,n),this.finishLineTo()}lineTo3DCoords(t,e,s){this.lineTo3D(new r.h(t,e,s))}lineToPoint(t){if(this.beforeNewSegment(1),this.m_description===t.getDescription())this.setPointByVal(this.m_pointCount-1,t);else{this.mergeVertexDescription(t.getDescription());const e=(0,r.o)(),s=new r.P({vd:this.m_description,attribBuffer:e,initDefaultValues:!1});t.copyCommonAttributesTo(s),this.setPointByVal(this.m_pointCount-1,s)}this.finishLineTo()}openPathAndDuplicateStartVertex(t){this.m_bPolygon&&(0,i.c)("");const e=this.getPathCount();if(t>e&&(0,i.t)(""),!this.isClosedPath(t))return;this.m_pathFlags||(0,i.c)("");const s=this.m_pointCount,n=this.getPathStart(t),r=this.getPathEnd(t);if(r-n!=0){this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),i=Kn.getComponentCount(e);this.m_vertexAttributes.get(t).insertRangeFromStream(i*r,this.m_vertexAttributes.get(t),i*n,i,!0,1,i*s)}for(let s=e;s>t;s--){const t=this.m_paths.read(s);this.m_paths.write(s,t+1)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(r,1,1,s),this.m_curveData.m_segmentParamIndex.insertRange(r,-1,1,s)),this.m_pathFlags.clearBits(t,1)}}openPath(t){this.m_bPolygon&&(0,i.c)(""),t>this.getPathCount()&&(0,i.t)(""),this.m_pathFlags||(0,i.c)(""),this.m_pathFlags.clearBits(t,1)}isStrongPathStart(t){return!!(2&this.m_pathFlags.read(t))}setStrongPathStart(t,e){e?this.m_pathFlags.setBits(t,2):this.m_pathFlags.clearBits(t,2)}isStrongPathEnd(t){return!!(4&this.m_pathFlags.read(t))}setStrongPathEnd(t,e){e?this.m_pathFlags.setBits(t,4):this.m_pathFlags.clearBits(t,4)}clearStrongPathEnds(){for(let t=0,e=this.getPathCount();t<e;++t)this.m_pathFlags.clearBits(t,6)}openAllPathsAndDuplicateStartVertex(){if(this.m_bPolygon&&(0,i.c)(""),this.isEmpty())return;this.m_pathFlags||(0,i.c)("");let t=0;const e=this.getPathCount();for(let i=0;i<e;i++)this.isClosedPath(i)&&(this.getPathSize(i)>0?t++:this.m_pathFlags.clearBits(i,1));if(0===t)return;const s=this.hasNonLinearSegments();let n=0;const o=this.getPathCount(),a=this.m_description.getAttributeCount(),h=new Array(a);let m=null,l=null;for(let i=0;i<o;++i){const e=this.getPathStart(i),o=this.getPathSize(i),u=this.isClosedPath(i);if(o>0){const i=e+n;for(let s=0;s<a;s++)if(this.m_vertexAttributes.get(s)){const n=this.m_description.getSemantics(s),a=Kn.getComponentCount(n);if(!h[s]){const e=a*(this.m_pointCount+t),i=(0,r.u)(n,e);h[s]=i}h[s].writeRange(i*a,o*a,this.m_vertexAttributes.get(s),e*a,!0,1),u&&h[s].writeRange((i+o)*a,a,this.m_vertexAttributes.get(s),e*a,!0,1)}if(s){if(null===m){const e=this.m_pointCount+t;m=(0,r.D)(e),l=(0,r.z)(e)}m.writeRange(i,o,this.m_curveData.m_segmentFlags,e,!0,1),l.writeRange(i,o,this.m_curveData.m_segmentParamIndex,e,!0,1),u&&(m.write(i+o,1),l.write(i+o,-1))}}this.m_paths.write(i,e+n),u&&(this.m_pathFlags.clearBits(i,1),++n)}this.m_paths.write(o,this.m_pointCount+t),this.m_pathFlags.clearBits(o,1);for(let i=0;i<a;i++)this.m_vertexAttributes.get(i)&&this.m_vertexAttributes.set(i,h[i]);s&&(this.m_curveData.m_segmentFlags=m,this.m_curveData.m_segmentParamIndex=l),this.m_pointCount+=t,this.m_reservedPointCount>0&&(this.m_reservedPointCount=this.m_pointCount)}closePathWithLine(t){void 0===t&&(t=this.getPathCount()-1),this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&(0,i.t)("close_path_with_line"),t===this.getPathCount()-1&&(this.m_bPathStarted=!1);const e=this.m_pathFlags.read(t);if(1&e||this.m_pathFlags.write(t,1|e),this.m_curveData&&this.m_curveData.m_segmentFlags){const e=this.getPathEnd(t)-1,s=this.m_curveData.m_segmentFlags.read(e);1!==s&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),1!==s&&(this.incCurveType(s,-1),this.modifyCurveCounter(-1)))}this.notifyModifiedFlags(2001)}closeLastPathWithSegment(t){this.closePathWithSegment(this.getPathCount()-1,t)}closePathWithSegment(t,e){if(this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&(0,i.t)("close_path_with_line"),e.getEndXY().equals(this.getXY(this.getPathStart(t)))||(0,i.t)("close_path_with_segment: end point mismatch"),t===this.getPathCount()-1)this.m_bPathStarted=!1,this.addSegment(e,!1),--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount);else{this.mergeVertexDescription(e.getDescription());const s=e.getStartXY(),n=this.getPathEnd(t)-1;s.equals(this.getXY(n))||(0,i.t)("close_path_with_segment: start point mismatch");const r=e.getGeometryType();if(r===i.G.enumLine)return void this.closePathWithLine(t);{const t=yt(e);this.initSegmentData(t);const s=Jn.toSegType(r),i=this.m_curveData.m_segmentFlags.read(n);if(i!==s)this.m_curveData.m_segmentParamIndex.write(n,this.m_curveData.m_curveParamWritePoint),e.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=t,this.incCurveType(s,1),1!==i?this.incCurveType(i,-1):this.modifyCurveCounter(1);else{const t=this.m_curveData.m_segmentParamIndex.read(n);e.writeInBufferStream(this.m_curveData.m_segmentParams,t)}this.m_curveData.m_segmentFlags.write(n,s)}}const s=this.m_pathFlags.read(t);1&s||this.m_pathFlags.write(t,1|s),this.notifyModifiedFlags(2001)}closeAllPaths(){if(this.m_bPolygon||this.isEmptyImpl())return;this.m_bPathStarted=!1;let t=!1;for(let e=0,s=this.m_paths.size()-1;e<s;e++){if(this.isClosedPath(e))continue;const s=this.m_pathFlags.read(e);this.m_pathFlags.write(e,1|s),t=!0}t&&this.notifyModifiedFlags(512)}isClosedPath(t){return!!(1&this.m_pathFlags.read(t))}isClosedPathInXYPlane(t){if(this.isClosedPath(t))return!0;const e=this.getPathStart(t),s=this.getPathEnd(t)-1;if(e>s)return!1;const n=this.getXY(e),i=this.getXY(s);return n.isEqualPoint2D(i)}isClosedPathIn3D(t){return(0,i.g)(0),!1}hasNonLinearSegmentsPath(t){if(!this.hasNonLinearSegments())return!1;for(let e=this.getPathStart(t),s=this.getPathEnd(t);e<s;e++)if($n.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e)))return!0;return!1}isNonLinearSegment(t){return!(1&this.getSegmentFlags(t))}addEnvelope(t,e){if(t.isEmpty())return;const s=0===this.m_pointCount;if(t instanceof a.Envelope2D)this.startPathCoords(t.xmin,t.ymin),e?(this.lineToCoords(t.xmax,t.ymin),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmin,t.ymax)):(this.lineToCoords(t.xmin,t.ymax),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmax,t.ymin));else{const s=t.getDescription(),n=(0,r.o)(),i=new r.P({vd:s,attribBuffer:n,initDefaultValues:!1});for(let r=0,o=4;r<o;r++){const s=e?o-r-1:r;t.queryCornerByVal(s,i),0===r?this.startPathPoint(i):this.lineToPoint(i)}}this.closePathWithLine(),this.m_bPathStarted=!1,s&&!e&&(this.setDirtyFlagProtected(256,!1),this.m_bPolygon&&Math.min(t.width(),t.height())>0&&this.setIsSimple(3,0))}addPathFromClosedSegment(t,e){if(t.isClosed()||(0,i.t)("add_path_from_closedSegment: segment must be closed"),e){const e=t.getReversed(),s=new r.P;e.queryStart(s),this.startPathPoint(s),this.closeLastPathWithSegment(e)}else{const e=new r.P;t.queryStart(e),this.startPathPoint(e),this.closeLastPathWithSegment(t)}}addSegment_(t,e){const s=t.getDescription();this.mergeVertexDescription(s);const n=(0,r.o)(),o=new r.P({vd:s,attribBuffer:n,initDefaultValues:!1}),a=t.getGeometryType();if(a===i.G.enumLine)(e||this.isEmptyImpl())&&(t.queryStart(o),this.startPathPoint(o)),t.queryEnd(o),this.lineToPoint(o);else{let s=!1;if((e||this.isEmptyImpl())&&(s=!0),s||t.getStartXY().equals(this.getXY(this.m_pointCount-1))||(0,i.t)("add_segment: start point mismatch"),s&&(t.queryStart(o),this.startPathPoint(o)),this.beforeNewSegment(1),t.queryEnd(o),o.getDescription()===this.m_description)this.setPointByVal(this.m_pointCount-1,o);else{const t=(0,r.o)(),e=new r.P({vd:this.m_description,attribBuffer:t,initDefaultValues:!1});o.copyCommonAttributesTo(e),this.setPointByVal(this.m_pointCount-1,e)}const n=yt(t);this.initSegmentData(n),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-2,this.m_curveData.m_curveParamWritePoint),t.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=n;const h=Jn.toSegType(a);this.incCurveType(h,1),this.modifyCurveCounter(1),this.m_curveData.m_segmentFlags.write(this.m_pointCount-2,h)}}addSegment(t,e,s){s?e?this.addPathFromClosedSegment(t,!1):this.closeLastPathWithSegment(t):this.addSegment_(t,e)}interpolateAttributesRange(t,e,s,n){for(let a=t;a<s-1;a++)this.isClosedPath(a)&&(0,i.t)("cannot interpolate across closed paths");const r=this.m_description.getAttributeCount();if(1===r)return;const o=this.calculateSubLength2D(t,e,s,n);if(0!==o)for(let i=1;i<r;i++){const r=this.m_description.getSemantics(i);this.interpolateAttributesSemanticsImpl(r,t,e,s,n,o)}}interpolateAttributesSemantics(t,e,s,n,r){if(0===t)return;this.hasAttribute(t)||(0,i.t)("does not have the given attribute"),2===Kn.getInterpolation(t)&&(0,i.t)("angular interpolation");for(let a=e;a<n-1;a++)this.isClosedPath(a)&&(0,i.t)("cannot interpolate across closed paths");const o=this.calculateSubLength2D(e,s,n,r);0!==o&&this.interpolateAttributesSemanticsImpl(t,e,s,n,r,o)}interpolateAttributesPath(t,e,s){const n=this.m_description.getAttributeCount();if(1===n)return;if(e===s)return;const i=this.calculatePathSubLength2D(t,e,s);for(let r=1;r<n;r++){const n=this.m_description.getSemantics(r);this.interpolateAttributesSemanticsPathImpl(n,t,e,s,i)}}interpolateAttributesSemanticsPath(t,e,s,n){if(0===t)return;this.hasAttribute(t)||(0,i.t)("does not have the given attribute"),2===Kn.getInterpolation(t)&&(0,i.t)("angular interpolation");const r=this.calculatePathSubLength2D(e,s,n);0!==r&&this.interpolateAttributesSemanticsPathImpl(t,e,s,n,r)}interpolateAttributesSemanticsImpl(t,e,s,n,i,r){const a=this.querySegmentIterator(),h=this.getPathStart(e)+s,m=this.getPathStart(n)+i,l=Kn.getComponentCount(t),u=(0,o.d)(Kn.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,h,u,l);const c=(0,o.d)(Kn.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,m,c,l);const g=(0,o.d)(Kn.maxComponentCount(),Number.NaN);(0,o.a)(g,u,0,0,l);let d=0;const _=Kn.getDefaultValue(t),p=Kn.getInterpolation(t);a.resetToVertex(h,e);do{if(a.hasNextSegment()){if(a.nextSegment(),a.getStartPointIndex()===m)return;this.setAttributeFromArray(t,a.getStartPointIndex(),g,l),a.previousSegment();do{const e=a.nextSegment();if(a.getEndPointIndex()===m)return;d+=e.calculateLength2D(),(0,o.B)(p,u,c,g,0,l,d/r,_),a.isClosingSegment()||this.setAttributeFromArray(t,a.getEndPointIndex(),g,l)}while(a.hasNextSegment())}}while(a.nextPath())}interpolateAttributesSemanticsPathImpl(t,e,s,n,i){const r=this.querySegmentIterator(),a=Kn.getInterpolation(t),h=this.getPathStart(e)+s,m=this.getPathStart(e)+n;if(m===h)return;const l=Kn.getComponentCount(t),u=(0,o.d)(Kn.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,h,u,l);const c=(0,o.d)(Kn.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,m,c,l);const g=new o.K(0);r.resetToVertex(h,e),r.setCirculator(this.isClosedPath(e));const d=Kn.getDefaultValue(t),_=(0,o.d)(Kn.maxComponentCount(),Number.NaN);(0,o.a)(_,u,0,0,l);const p=0===i;let f=.5;do{const e=r.nextSegment();if(this.setAttributeFromArray(t,r.getStartPointIndex(),_,l),!p){const t=e.calculateLength2D();g.pe(t),f=g.getResult()/i}(0,o.B)(a,u,c,_,0,l,f,d)}while(r.getEndPointIndex()!==m)}querySegment(t,e,s){const n=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(n);r>=this.getSegmentCountPath(n)&&(0,i.t)("get_segment"),this.getSegmentFromPath(n,r,e,s)}getSegment(t,e){const s=new this.m_segmentBufferCTor;return this.getSegmentBuffer(t,s,e),s.releaseSegment()}getSegmentType(t){const e=this.getPathIndexFromPointIndex(t),s=t-this.getPathStart(e);return s>=this.getSegmentCountPath(e)&&(0,i.t)("get_segment"),this.getSegmentTypeFromPath(e,s)}getSegmentFromPath(t,e,s,n){const o=this.getPathStart(t)+e,a=this.getSegmentFlagsStreamRef();let h=1;switch(a&&(h=31&a.read(o)),h){case 1:s.createLine();break;case 2:s.createCubicBezier();break;case 4:s.createEllipticArc();break;case 8:s.createQuadraticRationalBezier();break;case 16:s.createQuadraticBezier();break;default:(0,i.c)("")}const m=s.get();let l,u=null;if(n?(u=(0,r.j)(),m.assignVertexDescription(u)):m.assignVertexDescription(this.m_description),l=o===this.getPathEnd(t)-1&&this.isClosedPath(t)?this.getPathStart(t):o+1,G(m,this.getXY(o)),F(m,this.getXY(l)),!n)for(let i=1,r=this.m_description.getAttributeCount();i<r;i++){const t=this.m_description.getSemantics(i),e=Kn.getComponentCount(t);for(let s=0;s<e;s++){const e=this.getAttributeAsDbl(t,o,s);m.setStartAttribute(t,s,e);const n=this.getAttributeAsDbl(t,l,s);m.setEndAttribute(t,s,n)}}if($n.isNonLinearSegmentFlag(h)){const t=this.m_curveData.m_segmentParamIndex.read(o);m.readFromBufferStream(this.m_curveData.m_segmentParams,t)}}replaceLinearEllipticalArcsWithTrueLines(){if(!this.hasNonLinearSegments())return!1;if(0===this.m_curveData.m_arcCount)return!1;let t=!1;for(let e=0,s=this.getPointCount();e<s;e++)if(4===this.m_curveData.m_segmentFlags.read(e)){const s=this.m_curveData.m_segmentParamIndex.read(e);xt(this.m_curveData.m_segmentParams,s).isNAN()&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),this.incCurveType(4,-1),this.modifyCurveCounter(-1),t=!0)}return t&&this.checkCompactSegmentParams(),t}queryPointAlongPath(t,e,s){const n={iSegment:-1},r=arguments.length>3&&void 0!==arguments[3]&&arguments[3]?n:{iSegment:-1,tSegment:0};if(s.setEmpty(),this.isEmpty())return n;if((t<0||t>=this.getPathCount())&&(0,i.t)("query_point_along_path"),e<0)return n;const a=this.getPathSize(t);if(0===a)return n;if(1===a)return this.getPointByVal(this.getPathStart(t),s),r.tSegment=0,n.iSegment=this.getPathStart(t),n;const h=this.querySegmentIteratorAtVertex(this.getPathStart(t)),m=new o.K(0);for(;h.hasNextSegment();){const t=h.nextSegment(),i=t.calculateLength2D(),o=m.getResult();if(m.add(i),m.getResult()>=e){let a=e-o;a>i&&(a=i);const m=t.lengthToT(a);return t.queryCoord(m,s),r.tSegment=m,n.iSegment=h.getStartPointIndex(),n}}if(this.isClosedPath(t)){const e=this.getPathStart(t);return this.getPointByVal(e,s),r.tSegment=1,n.iSegment=this.getPathEnd(t)-1,n}{const e=this.getPathEnd(t)-1;return this.getPointByVal(e,s),this.getPathSize(t)>1?(r.tSegment=1,n.iSegment=this.getPathEnd(t)-2,n):(r.tSegment=0,n.iSegment=this.getPathStart(t),n)}}queryPointsAlongPath(t,e,s,n,r,a){{let t=0;for(let o=0;o<e;++o)n&&n[o].setEmpty(),r&&(r[o]=-1),a&&(a[o]=0),t>s[o]&&(0,i.t)("query_points_along"),t=s[o]}const h=this.getPathSize(t);if(0===e||0===h)return 0;if(1===h){const e=this.getPathStart(t);return n&&this.getPointByVal(e,n[0]),a&&(a[0]=0),r&&(r[0]=e),1}const m=this.getPathStart(t),l=new o.K(0),u=this.querySegmentIteratorAtVertex(m);let c=0,g=0,d=s[c];for(;u.hasNextSegment();){const t=u.nextSegment(),i=t.calculateLength2D(),o=l.getResult();for(l.add(i);l.getResult()>=d;){let h=d-o;h>i&&(h=i);const m=t.lengthToT(h);if(n&&t.queryCoord(m,n[g]),a&&(a[g]=m),r&&(r[g]=u.getStartPointIndex()),g++,c++,d=s[c],c===e)return g}}if(this.isClosedPath(t)){const e=this.getPathStart(t),s=0;n&&this.getPointByVal(e,n[g]),a&&(a[g]=s),r&&(r[g]=e),g++}else if(this.getPathSize(t)>1){const e=this.getPathEnd(t)-2,s=1;n&&this.getPointByVal(e+1,n[g]),a&&(a[g]=s),r&&(r[g]=e),g++}return g}queryPointsAlong(t,e,s,n,r){{let o=0;for(let a=0;a<t;++a)s&&s[a].setEmpty(),n&&(n[a]=-1),r&&(r[a]=0),o>e[a]&&(0,i.t)("query_points_along"),o=e[a]}if(0===t)return 0;const a=new o.K(0),h=this.querySegmentIterator();let m=-1,l=0,u=0,c=e[l];for(;h.nextPath();)for(;h.hasNextSegment();){m=h.getPathIndex();const i=h.nextSegment(),o=i.calculateLength2D(),g=a.getResult();for(a.add(o);a.getResult()>=c;){let a=c-g;a>o&&(a=o);const m=i.lengthToT(a);if(s&&i.queryCoord(m,s[u]),r&&(r[u]=m),n&&(n[u]=h.getStartPointIndex()),u++,l++,c=e[l],l===t)return u}}if(m<0)return 0;if(this.isClosedPath(m)){const t=this.getPathStart(m),e=0;s&&this.getPointByVal(t,s[u]),r&&(r[u]=e),n&&(n[u]=t),u++}else if(this.getPathSize(m)>1){const t=this.getPathEnd(m)-2,e=1;s&&this.getPointByVal(t+1,s[u]),r&&(r[u]=e),n&&(n[u]=t),u++}return u}querySegmentIterator(){return new _t({parent:this})}querySegmentIteratorAtVertex(t){return new _t({parent:this,pointIndex:t})}queryPathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!0)}queryLoosePathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!1)}queryPathEnvelopeImpl(t,e,s){if(e instanceof r.E&&(0,i.g)(0,"not implemented for Envelope"),e instanceof r.n&&(0,i.g)(0,"not implemented for Envelope3D"),(t>=this.getPathCount()||t<0)&&(0,i.t)(""),this.isEmpty())return void e.setEmpty();const n=this.getAttributeStreamRef(0),o=a.Envelope2D.constructEmpty();o.setEmpty();for(let r=2*this.getPathStart(t),a=2*this.getPathEnd(t);r<a;){const t=a-r;(0,i.g)(!(1&t)),o.mergePointsInterleaved(n,r/2,t/2),r+=t}if(e.setCoords({env2D:o}),this.hasNonLinearSegmentsPath(t)){const n=this.querySegmentIterator();if(n.resetToPath(t),n.nextPath())for(;n.hasNextSegment();){const t=n.nextCurve();if(!t)break;{const n=a.Envelope2D.constructEmpty();s?t.queryEnvelope(n):t.queryLooseEnvelope(n),e.mergeEnvelope2D(n)}}else(0,i.g)(0)}}checkCompactSegmentParams(){if(!this.m_curveData||null===this.m_curveData.m_segmentParams)return!1;if(this.m_curveData.m_segmentParams.size()<=this.m_vertexAttributes.get(0).size())return!1;const t=Et(4)*this.m_curveData.m_arcCount+Et(2)*this.m_curveData.m_bezierCount+Et(8)*this.m_curveData.m_rbezier2Count+Et(16)*this.m_curveData.m_bezier2Count;return this.m_curveData.m_segmentParams.size()>Math.max(3*t>>1,10)?(this.forceCompactSegmentParams(),!0):(0===this.m_pointCount&&(this.m_curveData.m_curveParamWritePoint=0),!1)}forceCompactSegmentParams(){let t=0;for(let n=0,i=this.getPointCount();n<i;n++){const e=this.m_curveData.m_segmentFlags.read(n);$n.isNonLinearSegmentFlag(e)&&(t+=Et(e))}const e=(0,r.F)(t);let s=0;for(let n=0,i=this.getPointCount();n<i;n++){const t=this.m_curveData.m_segmentFlags.read(n);if($n.isNonLinearSegmentFlag(t)){let i=this.m_curveData.m_segmentParamIndex.read(n);this.m_curveData.m_segmentParamIndex.write(n,s);const r=Et(t);for(let t=0;t<r;t++)e.write(s,this.m_curveData.m_segmentParams.read(i)),s++,i++}}this.m_curveData.m_segmentParams=e,this.m_curveData.m_curveParamWritePoint=s}setEmpty(){this.m_curveData&&(this.removeAllCurvesFromGlobalCounter(),this.m_curveData=null),this.m_bPathStarted=!1,this.m_paths=null,this.m_pathFlags=null,this.setEmptyImpl()}applyTransformation(t){this.applyTransformationToPath(t,-1)}applyTransformation3D(t){(0,i.g)(0)}getImpl(){return this}reserve(t){this.reserveImpl(t),t>0&&!this.m_paths&&(this.m_paths=(0,r.z)(0),this.m_pathFlags=(0,r.D)(0),this.m_paths.reserve(2),this.m_pathFlags.reserve(2),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0))}reserveParts(t,e){this.reserveImpl(t),e>0&&(this.m_paths?(this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1)):(this.m_paths=(0,r.z)(0),this.m_pathFlags=(0,r.D)(0),this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0)))}clone(){const t=this.createInstance();return this.copyTo(t),t}queryLimitedSegmentIterator(t){return new ti(this,t)}getPathStreamRef(){return this.throwIfEmpty(),this.m_paths}setPathStreamRef(t){this.m_paths=t}getSegmentFlagsStreamRef(){return this.throwIfEmpty(),null!=this.m_curveData?this.m_curveData.m_segmentFlags:null}getPathFlagsStreamRef(){return this.throwIfEmpty(),this.m_pathFlags}setPathFlagsStreamRef(t){this.m_pathFlags=t}getSegmentIndexStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParamIndex:null}getSegmentDataStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParams:null}setSegmentData(t,e,s,n){this.m_curveData||(this.m_curveData=new Jn),this.m_curveData.m_segmentFlags=s,this.m_curveData.m_segmentParams=e,this.m_curveData.m_segmentParamIndex=t,this.m_curveData.m_curveParamWritePoint=n}static getPathIndexFromPointIndexImpl(t,e,s,n){if(n>=0&&n<e){if(s>=t.read(n)){if(s<t.read(n+1))return n;n++}else n--;if(n>=0&&n<e&&s>=t.read(n)&&s<t.read(n+1))return n}if(e<5){for(let n=0;n<e;n++)if(s<t.read(n+1))return n;(0,i.k)("")}let r=0,o=e-1;for(;o>r;){const e=r+(o-r>>1);if(s<t.read(e))o=e-1;else{if(!(s>=t.read(e+1)))return e;r=e+1}}return r}getHighestPointIndex(t){(0,i.g)(t>=0&&t<this.getPathCount());const e=this.getAttributeStreamRef(0),s=this.getPathEnd(t),n=this.getPathStart(t);let r=-1;const a=new o.P;a.y=Number.NEGATIVE_INFINITY,a.x=Number.NEGATIVE_INFINITY;for(let i=n+0;i<s;i++){const t=e.readPoint2D(2*i);-1===a.compare(t)&&(r=i,a.setCoordsPoint2D(t))}return r}applyTransformationToPath(t,e){if(e>=this.getPathCount()&&(0,i.t)("apply_transformation"),this.isEmpty())return;if(t.isIdentity())return;const s=this.m_vertexAttributes.get(0);if(!(e<0?this.hasNonLinearSegments():this.hasNonLinearSegmentsPath(e))){let n,i;return e<0?(n=0,i=this.m_pointCount):(n=this.getPathStart(e),i=this.getPathEnd(e)),s.applyTransformation(t,2*n,i-n),void this.notifyModifiedFlags(2001)}const n=new this.m_segmentBufferCTor,r=this.getPathCount();let a=e<0?0:e;do{const i=this.getPathStart(a),r=this.getPathEnd(a),h=this.isClosedPath(a),m=s.readPoint2D(2*i);if(!this.hasNonLinearSegmentsPath(a)){s.applyTransformation(t,2*i,r-i);continue}const l=o.P.getNAN();for(let e=i;e<r;++e){if(1!==(31&this.m_curveData.m_segmentFlags.read(e))){const o=h&&e+1===r;o&&s.writePoint2D(2*i,m),this.getSegmentBuffer(e,n,!0),n.get().applyTransformation(t);const a=this.m_curveData.m_segmentParamIndex.read(e);n.get().writeInBufferStream(this.m_curveData.m_segmentParams,a),s.writePoint2D(2*e,n.get().getStartXY()),o&&s.writePoint2D(2*i,n.get().getEndXY());continue}const o=2*e;s.queryPoint2D(o,l),t.transformInPlace(l),s.writePoint2D(o,l)}if(a===e)break}while(++a<r);this.notifyModifiedFlags(2001)}calculateSubLength2D(t,e,s,n){const r=this.getPathStart(t)+e,o=this.getPathStart(s)+n;(o<r||r<0||o>this.getPointCount()-1)&&(0,i.m)("");const a=this.querySegmentIterator();let h=0;a.resetToVertex(r,t);do{for(;a.hasNextSegment();){const t=a.nextSegment();if(a.getStartPointIndex()===o)break;h+=t.calculateLength2D()}if(a.getStartPointIndex()===o)break}while(a.nextPath());return h}calculatePathSubLength2D(t,e,s){const n=this.getPathStart(t)+e,r=this.getPathStart(t)+s;(n<0||r>this.getPointCount()-1)&&(0,i.m)("");const o=this.querySegmentIterator();if(n>r&&(this.isClosedPath(t)||(0,i.t)("cannot iterate across an open path"),o.setCirculator(!0)),n===r)return 0;let a=0,h=0;o.resetToVertex(n,t);do{h+=a,a=o.nextSegment().calculateLength2D()}while(o.getStartPointIndex()!==r);return h}calculateEnvelope2D(t){return this.updateXYImpl(t)}updateXYImpl(t){const e=super.updateXYImpl(t);if(this.hasNonLinearSegments()){const s=a.Envelope2D.constructEmpty(),n=this.querySegmentIterator();for(;n.nextPath();)for(;n.hasNextSegment();){const i=n.nextCurve();if(!i)break;t?i.queryEnvelope(s):i.queryLooseEnvelope(s),e.mergeEnvelope2D(s)}}return e}notifyModifiedAllImpl(){null!==this.m_paths&&this.m_paths.size()?this.m_pointCount=this.m_paths.read(this.m_paths.size()-1):this.m_pointCount=0}setDirtyOGCFlags(t){this.setDirtyFlagProtected(16,t)}hasDirtyOGCStartFlags(){return this.hasDirtyFlag(16)}setDirtyRingAreas2D(t){this.setDirtyFlagProtected(1024,t)}hasDirtyRingAreas2D(){return this.hasDirtyFlag(1024)}static isNonLinearSegmentFlag(t){return!(1&t)}addAndExplicitlyOpenAllPaths(t,e){this===t&&(0,i.t)("Multi_path_impl::add");let s=this.getPathCount();for(let n=0,i=t.getPathCount();n<i;n++)this.addPath(t,n,!e),this.openPathAndDuplicateStartVertex(s),s++}getSegmentFlags(t){return null!==this.m_curveData&&null!==this.m_curveData.m_segmentFlags?this.m_curveData.m_segmentFlags.read(t):1}getSegmentBuffer(t,e,s){const n=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(n);r>=this.getSegmentCountPath(n)&&(0,i.t)("getSegmentBuffer"),this.getSegmentFromPath(n,r,e,s)}getSegmentTypeFromPath(t,e){const s=this.getPathStart(t)+e,n=this.getSegmentFlagsStreamRef();let r=1;switch(n&&(r=31&n.read(s)),r){case 1:return i.G.enumLine;case 2:return i.G.enumBezier;case 4:return i.G.enumEllipticArc;case 8:return i.G.enumRationalBezier2;case 16:return i.G.enumBezier2;default:(0,i.c)("")}}ensureXYMonotoneSegments(){if(!this.m_curveData)return!1;let t=!1;for(let e=0,s=this.getPathCount();e<s;e++){const s=this.getPathStart(e),n=this.getPathEnd(e),r=n-s;for(let e=s;e<n;e++){const n=31&this.m_curveData.m_segmentFlags.read(e);if(1===n)continue;2!==n&&(0,i.b)("ensure_xy_monotone_segments");const a=(e-s+1)%r+s,h=this.m_curveData.m_segmentParamIndex.read(e),m=(0,o.m)(o.P,4);m[0]=this.getXY(e),m[3]=this.getXY(a),m[1].x=this.m_curveData.m_segmentParams.read(h),m[1].y=this.m_curveData.m_segmentParams.read(h+1),m[2].x=this.m_curveData.m_segmentParams.read(h+2),m[2].y=this.m_curveData.m_segmentParams.read(h+3),En(m)&&(t=!0,this.m_curveData.m_segmentParams.write(h,m[1].x),this.m_curveData.m_segmentParams.write(h+1,m[1].y),this.m_curveData.m_segmentParams.write(h+2,m[2].x),this.m_curveData.m_segmentParams.write(h+3,m[2].y))}}return t&&this.notifyModifiedFlags(2001),t}buildRasterizedGeometryAccelerator(t,e){return!1}buildQuadTreeAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new pt),null!==this.m_accelerators.getQuadTree())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTree(null);const e=(0,r.G)(this);return this.m_accelerators.setQuadTree(e),!0}buildQuadTreeForPathsAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new pt),null!==this.m_accelerators.getQuadTreeForPaths())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTreeForPaths(null);const e=(0,r.H)(this);return this.m_accelerators.setQuadTreeForPaths(e),!0}updateCurveCounter(t){this.modifyCurveCounter(t-this.getCurveCount())}removeAllCurvesFromGlobalCounter(){this.m_curveData&&($n.st_totalCurveCount-=this.m_curveData.m_curveCount,this.m_curveData.m_curveCount=0,this.m_curveData.m_bezierCount=0,this.m_curveData.m_arcCount=0,this.m_curveData.m_bezier2Count=0,this.m_curveData.m_rbezier2Count=0,this.m_curveData.m_curveParamWritePoint=0)}modifyCurveCounter(t){t&&(this.m_curveData||(this.m_curveData=new Jn),$n.st_totalCurveCount+=t,this.m_curveData.m_curveCount+=t)}getCurveCount(){return this.m_curveData?this.m_curveData.m_curveCount:0}incCurveType(t,e){this.m_curveData||(this.m_curveData=new Jn),2&t?this.m_curveData.m_bezierCount+=e:4&t?this.m_curveData.m_arcCount+=e:8&t?this.m_curveData.m_rbezier2Count+=e:16&t&&(this.m_curveData.m_bezier2Count+=e)}getCurveWritePoint(){return null!==this.m_curveData?this.m_curveData.m_curveParamWritePoint:0}initSegmentData(t){null===this.m_curveData&&(this.m_curveData=new Jn);const e=this.m_reservedPointCount>0?this.m_reservedPointCount:this.m_pointCount;null===this.m_curveData.m_segmentParamIndex&&(this.m_curveData.m_segmentFlags=(0,r.D)(e,1),this.m_curveData.m_segmentParamIndex=(0,r.z)(e,-1));const s=this.m_curveData.m_curveParamWritePoint+t;null===this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams=(0,r.F)(s):s!==this.m_curveData.m_segmentParams.size()&&this.m_curveData.m_segmentParams.resize(s,0),this.m_curveData.m_segmentFlags.size()<e&&(this.m_curveData.m_segmentFlags.resize(e,1),this.m_curveData.m_segmentParamIndex.resize(e,-1))}updateCurveWritePoint(t){null===this.m_curveData&&(this.m_curveData=new Jn),this.m_curveData.m_curveParamWritePoint=t}updateOGCFlagsHelper(){const t=this.getPathCount();if(0===t)return;const e=this.m_pathFlags;let s=0;for(let n=0;n<t;n++){const t=this.m_cachedRingAreas2D.read(n);0===s&&(s=(0,o.e)(t)),t*s>0||0===s?e.setBits(n,8):e.clearBits(n,8)}}updateOGCFlagsProtected(){this.hasDirtyFlag(16)&&(this.updateRingAreas2DProtected(),this.updateOGCFlagsHelper(),this.setDirtyFlagProtected(16,!1))}replaceSegment(t,e,s){(t<0||t>=this.getPointCount())&&(0,i.t)("Multi_path_impl.replace_segment"),(0,i.g)(e.isCurve());const n=this.getPathIndexFromPointIndex(t),a=this.getPathStart(n),h=(t-a+1)%this.getPathSize(n)+a;{const s=this.getXY(t),n=this.getXY(h),r=!s.isEqualPoint2D(e.getStartXY())||!n.isEqualPoint2D(e.getEndXY());(0,i.g)(!r)}const m=e.getDescription();this.mergeVertexDescription(m);const l=(0,o.d)(32,Number.NaN),u=new r.P({vd:m,attribBuffer:l,initDefaultValues:!1}),c=null===this.m_curveData?1:31&this.m_curveData.m_segmentFlags.read(t),g=Et(c),d=yt(e);let _,p=!1;g>=d?((0,i.g)(null!==this.m_curveData),p=!0,_=this.m_curveData.m_segmentParamIndex.read(t)):(this.initSegmentData(d),p=!1,_=this.m_curveData.m_curveParamWritePoint);const f=e.getGeometryType(),P=Jn.toSegType(f);s||(e.queryStart(u),this.setPointByVal(t,u),e.queryEnd(u),this.setPointByVal(h,u)),this.m_curveData.m_segmentParamIndex.write(t,1!==P?_:-1),this.m_curveData.m_segmentFlags.write(t,P),1!==P&&e.writeInBufferStream(this.m_curveData.m_segmentParams,_),p||(this.m_curveData.m_curveParamWritePoint+=d),c!==P&&(this.incCurveType(c,-1),this.incCurveType(P,1),this.modifyCurveCounter(1===c?1:-1))}setAttributeImpl(t,e,s){if(this.addAttribute(t),!this.isEmpty())if(this.hasNonLinearSegments()&&0===t){(e<0||e>1)&&(0,i.t)("");const t=new h.T,n=0===e?s:0,r=0===e?0:1;t.setShiftCoords(n,r),0===e?t.xx=0:t.yy=0,this.applyTransformation(t)}else super.setAttributeImpl(t,e,s)}}$n.st_totalCurveCount=0;class ti{constructor(t,e){this.m_segIter=null,this.m_quadTree=null,this.m_qtIter=null,this.m_extentOfInterest=new a.Envelope2D(e),this.m_bfirst=!0,this.m_prevIndex=-100,this.m_parent=t}nextSegment(){return this.m_bfirst&&this.prepare_(),this.m_quadTree?this.nextSegmentQt():this.nextSegmentNoQt()}getPathIndex(){return this.m_segIter.getPathIndex()}getStartPointIndex(){return this.m_segIter.getStartPointIndex()}getEndPointIndex(){return this.m_segIter.getEndPointIndex()}isClosingSegment(){return this.m_segIter.isClosingSegment()}isPathClosed(){return this.m_segIter.isPathClosed()}prepare_(){const t=this.m_parent.getAccelerators();t&&(this.m_quadTree=t.getQuadTree(),this.m_quadTree&&(this.m_qtIter=this.m_quadTree.getSortedIterator(this.m_extentOfInterest,0))),this.m_segIter=this.m_parent.querySegmentIterator()}nextSegmentQt(){this.m_bfirst=!1;const t=this.m_qtIter.next();if(-1===t)return null;const e=this.m_quadTree.getElement(t);return(e!==this.m_prevIndex+1||this.m_segIter.isLastSegmentInPath())&&(this.m_segIter.resetToVertex(e,this.m_segIter.getPathIndex()),this.m_prevIndex=e),this.m_segIter.nextSegment()}nextSegmentNoQt(){for(;;){if(!this.m_bfirst&&this.m_segIter.hasNextSegment()){const t=this.m_segIter.nextSegment(),e=a.Envelope2D.constructEmpty();if(t.queryLooseEnvelope(e),!e.isIntersecting(this.m_extentOfInterest))continue;return t}if(this.m_bfirst=!1,!this.m_segIter.nextPath())return null}}}class ei extends $n{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!1}),this.m_segmentBufferCTor=to):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=to,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=to):t.start?(super({vd:t.start.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=to,this.startPathPoint(t.start),this.lineToPoint(t.end)):t.path?(super({bPolygon:!1}),this.m_segmentBufferCTor=to,this.addPathPoint2D(t.path,t.pointCount,t.bForward)):(0,i.c)("bad constructor arg"):(super({bPolygon:!1}),this.m_segmentBufferCTor=to)}getBoundary(){return ii(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}assignMove(t){return t.copyTo(this),this}getGeometryType(){return ei.type}getDimension(){return 1}createInstance(){return new ei({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}ei.type=i.G.enumPolyline;var si=i.G;function ni(t,e){if(t.isEmpty())return!1;const s=t.getGeometryType();if(s===si.enumPolygon)return 0!==t.calculateArea2D();if(s===si.enumPolyline)return ri(t.getImpl(),e,!0).bNotEmpty;if(s===si.enumEnvelope)return!0;if((0,i.f)(s))return!!t.isClosed();if((0,i.e)(s))return!1;if(s===si.enumGeometryCollection){const s=t;for(let t=0,n=s.getGeometryCount();t<n;t++)if(ni(s.getGeometry(t),e))return!0;return!1}(0,i.b)("")}function ii(t,e){const s=t.getGeometryType();if(s===si.enumPolygon){const e=new ei({vd:t.getDescription()});return t.isEmpty()||t.copyToUnchecked(e),e}if(s===si.enumPolyline)return ri(t.getImpl(),e,!1).boundary;if(s===si.enumEnvelope){const e=new ei({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if((0,i.f)(s)){const e=new y({vd:t.getDescription()});if(!t.isEmpty()&&!t.isClosed()){const s=new r.P;e.reserve(2),t.queryStart(s),e.add(s),t.queryEnd(s),e.add(s)}return e}if(s===si.enumGeometryCollection){const s=t;let n=null;for(let i=0,r=s.getGeometryCount();i<r;i++){const r=ii(s.getGeometry(i),e);if(null!==r){null===n&&(n=t.createInstance());const e=r;n.addGeometry(e)}}return n}if((0,i.e)(s))return new r.P({vd:t.getDescription()});(0,i.b)("")}function ri(t,e,s){const n=!1,i=t;let a=null;if(s||(a=new y({vd:i.getDescription()})),!i.isEmpty()){const t=new r.A(0);for(let e=0,s=i.getPathCount();e<s;e++)if(i.getPathSize(e)>0&&!i.isClosedPathInXYPlane(e)){const s=i.getPathStart(e);t.add(s);const n=i.getPathEnd(e)-1;t.add(n)}if(t.size()>0){const e=new r.B,n=i.getAttributeStreamRef(0),h={userSort(t,e,s){const i=o.P.getNAN(),r=o.P.getNAN();s.sort(t,e,((t,e)=>(n.queryPoint2D(2*t,i),n.queryPoint2D(2*e,r),i.compare(r))))},getValue:t=>n.read(2*t+1)};e.sort(t,0,t.size(),h);let m=n.readPoint2D(2*t.read(0)),l=0,u=1;const c=new r.P;for(let i=1,r=t.size();i<r;i++){const e=n.readPoint2D(2*t.read(i));if(e.isEqualPoint2D(m))t.read(l)>t.read(i)?(t.write(l,(0,o.j)()),l=i):t.write(i,(0,o.j)()),u++;else{if(1&u){if(s)return{bNotEmpty:!0,boundary:new y({})}}else t.write(l,(0,o.j)());m=e,l=i,u=1}}if(1&u){if(s)return{bNotEmpty:!0,boundary:new y({})}}else t.write(l,(0,o.j)());if(!s){t.sort(0,t.size());for(let e=0,s=t.size();e<s&&t.read(e)!==(0,o.j)();e++)i.getPointByVal(t.read(e),c),a.add(c)}}}return s?{bNotEmpty:n,boundary:new y({})}:{bNotEmpty:n,boundary:a}}const oi=o.a4/180,ai=180/o.a4;function hi(t){let e=t;return e=function(t){let e=t;return e>=-360&&e<720?(e<0?e+=360:e>=360&&(e-=360),e):(e=(0,o.o)(e,360),e<0&&(e+=360),e)}(e),e>180&&(e-=360),e}function mi(t){return t*oi}function li(t){return t*ai}function ui(t){const e=(0,o.a8)();let s=t;return s>=-e&&s<2*e?(s<0&&(s+=e),s>=e&&(s-=e),s):(s=(0,o.o)(s,e),s<0&&(s+=e),s)}function ci(t){const e=(0,o.a5)();let s=t;return s>-e&&s<=e||(s=ui(s),s>e&&(s-=(0,o.a8)())),s}function gi(t,e){return hi(e-t)}var di=r.V;class _i extends J{constructor(t){if(void 0===t||(0,o.O)(t,"vd"))return super({vd:null===t||void 0===t?void 0:t.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_semiMajorAxis=0,this.m_minorMajorRatio=1,this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,this.m_center=new o.P(0,0),this.m_sweepAngle=0,this.m_startAngle=0,this.m_interior=new o.P(0,0),void(this.m_bits=0);if(t.copy)return super(t),void(this!==t.copy&&(this.m_center=new o.P(0,0),this.m_interior=new o.P(0,0),t.copy.copyToImpl(this)));if(t.move)super(t),this.m_semiMajorAxis=t.move.m_semiMajorAxis,this.m_minorMajorRatio=t.move.m_minorMajorRatio,this.m_rotation=t.move.m_rotation,this.m_cosr=t.move.m_cosr,this.m_sinr=t.move.m_sinr,this.m_center=t.move.m_center.clone(),this.m_sweepAngle=t.move.m_sweepAngle,this.m_startAngle=t.move.m_startAngle,this.m_interior=t.move.m_interior.clone(),this.m_bits=t.move.m_bits,this.m_cachedValues=t.move.m_cachedValues,t.move.m_cachedValues=null;else{if(t.fromPoint)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new o.P(0,0),this.m_interior=new o.P(0,0),void this.constructCircularArcThreePoint(t.fromPoint,t.toPoint,t.interiorPoint);if(t.center)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new o.P(0,0),this.m_interior=new o.P(0,0),void this.constructCircleRadius(t.radius,t.center,t.bIsCounterClockwise);if(t.semiMajorAxis)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),void this.constructEllipticArcEndPoints(t.fromPoint,t.toPoint,t.semiMajorAxis,t.minorMajorRatio,t.axisXRotationRad,t.bBigArc,t.bIsCounterClockwise)}}getBoundary(){return ii(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}constructCircleRadius(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return this.constructEllipse(t,1,e,0,s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircleCenterAndPoint(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=o.P.distance(t,e);return this.constructEllipticArcEndPointsCenter(e,e,n,1,0,!0,s,t),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructTwoPointCircle(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=o.P.lerp(t,e,.5);return this.constructCircleCenterAndPoint(n,t,s),this}constructLineEllipticArc(t,e){return ji(this,t,e,1),this}constructLineCircularArc(t,e){return ji(this,t,e,0),this}constructEllipse(t,e,s,n){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const r=new o.P(0,this.m_minorMajorRatio*this.m_semiMajorAxis),a=Math.cos(n),h=Math.sin(n);return r.rotateDirect(a,h),r.addThis(s),this.constructEllipticArcEndPointsCenter(r,r,this.m_semiMajorAxis,this.m_minorMajorRatio,n,!0,i,s),this}inflate(t){if(this.isDegenerateToLine())return;let e=this.getSemiMinorAxis()+t;if(e=e<=0?0:(this.getSemiMajorAxis()+t)/this.getSemiMajorAxis(),this.isCircular()){const t=new h.T;t.setShiftCoords(-this.m_center.x,-this.m_center.y),t.scale(e,e),t.shiftCoords(this.m_center.x,this.m_center.y),this.applyTransformation(t)}else{const t=new h.T;this.canonicToWorldTransformation(t);const s=t.clone();s.invertPreciseThis(),s.scale(e,e),s.multiply(t),this.applyTransformation(s)}}constructEnclosingCircle(t,e){return function(t,e,s,n){0===s&&(0,i.t)("construct_enclosing_circle");const r=[0,0,0],a=fi(e,s,r);if(1===a)t.constructCircleRadius(0,e[r[0]],n);else if(2===a){const s=o.P.lerp(e[r[0]],e[r[1]],.5),i=o.P.distance(e[r[0]],s),a=o.P.distance(e[r[1]],s);t.constructCircleRadius(Math.max(i,a),s,n)}else if(3===a){const s=o.P.calculateCircleCenterFromThreePoints(e[r[0]],e[r[1]],e[r[2]]),i=o.P.distance(e[r[0]],s),a=o.P.distance(e[r[1]],s),h=o.P.distance(e[r[2]],s);t.constructCircleRadius(Math.max(i,a,h),s,n)}else(0,i.c)("unexpected")}(this,t,e,arguments.length>2&&void 0!==arguments[2]&&arguments[2]),this}constructThreePointCircle(t,e,s){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.equals(e)||e.equals(s)||t.equals(s)){const i=t.clone(),r=e.clone(),o=s.clone();return i.equals(r)&&r.assign(o),this.constructTwoPointCircle(i,r,n)}{const i=o.P.calculateCircleCenterFromThreePoints(t,e,s);if(!i.isFinite()||!Number.isFinite(o.P.distance(t,i))){const n=o.P.distance(t,e),i=o.P.distance(t,s);this.constructLineCircularArc(t,n>=i?e:s)}return this.constructCircleCenterAndPoint(i,t,n)}}constructCircularArcThreePoint(t,e,s){const n=new o.F(t.x),i=new o.F(e.x),r=new o.F(s.x),a=new o.F(t.y),h=new o.F(e.y),m=new o.F(s.y),l=new o.F(.5),u=i.subE(n),c=h.subE(a),g=r.subE(n),d=m.subE(a),_=u.mulE(d).subThisE(c.mulE(g));if(_.scaleError(10),_.isZero()){if(!u.isZero()||!c.isZero())return ji(this,t,e,0),this;{const n=t.clone().addThis(e).mulThis(.5).addThis(s).mulThis(.5),i=s.sub(n).length();this.constructEllipticArcEndPointsCenter(t,e,i,1,0,!0,!1,n),this.m_interior.assign(s)}return this.setProjectionBehavior(0),this}const p=u.sqr().addThisE(c.sqr()).mulThisE(l),f=g.sqr().addThisE(d.sqr()).mulThisE(l),P=p.mulE(d).subThisE(f.mulE(c)),x=u.mulE(f).subThisE(g.mulE(p));P.divThisE(_),x.divThisE(_);const y=P.sqr().addThisE(x.sqr());y.sqrtThis();const E=P.addE(n),C=x.addE(a);let S=t.x-E.value(),v=t.y-C.value();const b=Math.atan2(v,S);S=e.x-E.value(),v=e.y-C.value();const I=Math.atan2(v,S);S=s.x-E.value(),v=s.y-C.value();const w=Math.atan2(v,S);let D=w-2*(0,o.a5)();for(;D<b;)D+=2*(0,o.a5)();let T=I-2*(0,o.a5)();for(;T<D;)T+=2*(0,o.a5)();let N=w+2*(0,o.a5)();for(;N>b;)N-=2*(0,o.a5)();let A,G=I+2*(0,o.a5)();for(;G>N;)G-=2*(0,o.a5)();A=T-b<b-G?T-b:G-b;const M=new o.P(E.value(),C.value());return this.constructEllipticArcEndPointsCenter(t,e,y.value(),1,0,Math.abs(A)>(0,o.a5)(),A>0,M),this.m_interior.assign(s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircularArc(t,e,s,n){return this.constructEllipticArcGeneral(t,1,e,s,n,0),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructEllipticArcEndPoints(t,e,s,n,i,r,o){return Wi(this,t,e,s,n,i,r,o)}constructEllipticArcEndPointsCenter(t,e,s,n,i,r,o,a){return Wi(this,t,e,s,n,i,r,o,a)}constructEllipticArcGeneral(t,e,s,n,i,r){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const a=ci(r),h=Math.cos(a),m=Math.sin(a),l=new o.P(this.m_semiMajorAxis,this.m_minorMajorRatio*this.m_semiMajorAxis),u=o.P.getNAN(),c=ci(n);u.x=l.x*Math.cos(c),u.y=l.y*Math.sin(c),u.rotateDirect(h,m),u.addThis(s);const g=(0,o.ag)(i,(0,o.a8)());let d=g;Math.abs(d)===(0,o.a8)()&&(d=0);const _=o.P.getNAN();return _.x=l.x*Math.cos(c+d),_.y=l.y*Math.sin(c+d),_.rotateDirect(h,m),_.addThis(s),this.constructEllipticArcEndPointsCenter(u,_,this.m_semiMajorAxis,this.m_minorMajorRatio,a,Math.abs(g)>(0,o.a5)(),g>0,s)}constructEllipticArcAsNURB(t,e,s,n){return(n>=1||n<0)&&(0,i.t)("construct_elliptic_arc_as_NURB: weight"),e.isFinite()||(0,i.t)("construct_elliptic_arc_as_NURB: control_point"),lr([t,e,s],n*n,null,!1,this),this}constructCanonic(t){return this.assignCopy(t),t.isDegenerateToLine()||t.m_center.isEqual(0,0)&&0===this.m_rotation||(this.m_XStart=t.getSemiMajorAxis()*Math.cos(t.m_startAngle),this.m_YStart=t.getSemiMinorAxis()*Math.sin(t.m_startAngle),this.m_XEnd=t.getSemiMajorAxis()*Math.cos(t.getEndAngle()),this.m_YEnd=t.getSemiMinorAxis()*Math.sin(t.getEndAngle()),this.m_center.setCoords(0,0),this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,dr(this),this.afterCompletedModification(),t!==this&&L(this,t)),this}isCircular(){return 1===this.m_minorMajorRatio&&0===this.m_rotation&&!this.isDegenerateToLine()}isDegenerateToLineHelper(t){return!!T(this,[t])&&Zi(this)}isDegenerateToLine(){return Zi(this)}getCenter(){return this.m_center.clone()}setCenter(t){if(!this.m_center.isNAN()){const e=t.sub(this.m_center);this.m_XStart+=e.x,this.m_YStart+=e.y,this.m_XEnd+=e.x,this.m_YEnd+=e.y,this.m_interior.addThis(e),this.m_center.assign(t),this.endPointModified(),this.normalizeAfterEndpointChange()}}getAxisXRotation(){return this.m_rotation}getSemiAxes(){return o.P.construct(this.m_semiMajorAxis,this.m_semiMajorAxis*this.m_minorMajorRatio)}getSemiMajorAxis(){return this.m_semiMajorAxis}getSemiMinorAxis(){return this.m_semiMajorAxis*this.m_minorMajorRatio}getMinorMajorRatio(){return this.m_minorMajorRatio}isClockwise(){return!nr(this)}isMajor(){return rr(this)}getSweepAngle(){return this.m_sweepAngle}getStartAngle(){return this.m_startAngle}getEndAngle(){return this.m_startAngle+this.m_sweepAngle}getGeometryType(){return i.G.enumEllipticArc}queryEnvelope(t){if(4===t.m_EnvelopeType){t.setEmpty(),t.assignVertexDescription(this.m_description);const e=a.Envelope2D.constructEmpty();this.queryEnvelope(e),t.setEnvelope(e);for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const e=this.m_description.getSemantics(s);for(let n=0,i=di.getComponentCount(e);s<i;s++){const s=this.queryInterval(e,n);t.setIntervalEnvelope(e,n,s)}}}else 2===t.m_EnvelopeType?Pr(this,o.E.unit(),t):(0,i.b)("3d not impl")}applyTransformation(t){Ji(this,t,!1)}createInstance(){return new _i}calculateLength2D(){return function(t,e,s){if(Zi(t))return(s-e)*o.P.distance(t.getStartXY(),t.getEndXY());if(1===t.m_minorMajorRatio)return Math.abs(t.getSweepAngle()*(e-s))*t.m_semiMajorAxis;const n=Qi(t,e);return Qi(t,s)-n}(this,0,1)}queryCoord2D(t,e){if(Zi(this))et(t,this.getStartXY(),this.getEndXY(),e);else if(0===t)e.assign(o.P.construct(this.m_XStart,this.m_YStart));else if(1===t)e.assign(o.P.construct(this.m_XEnd,this.m_YEnd));else{const s=Li(this,t),n=new o.P(this.m_semiMajorAxis*Math.cos(s),this.getSemiMinorAxis()*Math.sin(s));n.rotateDirect(this.m_cosr,this.m_sinr),n.addThis(this.m_center),e.assign(n)}}queryCoord2DE(t,e){!function(t,e,s){if(Zi(t))it(new $r({start:t.getStartXY(),end:t.getEndXY()}),e,s);else if(0===e.value())s.set(t.getStartXY());else if(1===e.value())s.set(t.getEndXY());else{const n=new o.F;Bi(t,e,n);const i=new o.F,r=new o.F;o.F.st_cosAndSin(n,i,r);const a=v.constructCoordsE(new o.F(t.m_semiMajorAxis).mulThisE(i),new o.F(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio).mulThisE(r)),h=new o.F(t.m_rotation);o.F.st_cosAndSin(h,i,r),a.rotateDirect(i,r),a.addThisE(v.constructPoint2D(t.m_center)),s.setE(a)}}(this,t,e)}getCoordX(t){const e=new o.P;return this.queryCoord2D(t,e),e.x}getCoordY(t){const e=new o.P;return this.queryCoord2D(t,e),e.y}cut(t,e,s){const n=new to;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createEllipticArc();let r=0===t&&1===e;if(r&&!n)return void this.copyTo(i);const a=o.P.getNAN();this.queryCoord2D(t,a);const h=o.P.getNAN();if(this.queryCoord2D(e,h),!r)if(a.equals(h))e-t>.5&&this.isMajor()&&this.isClosed()?(r=!0,t=0,e=1):1===e?t=e:e=t;else if(t>0&&a.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&h.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),r=0===t&&1===e,r&&!n)return void this.copyTo(i);if(i.m_center.assign(this.m_center),i.m_semiMajorAxis=this.m_semiMajorAxis,i.m_minorMajorRatio=this.m_minorMajorRatio,i.m_interior.assign(this.m_interior),i.m_rotation=this.m_rotation,i.m_cosr=this.m_cosr,i.m_sinr=this.m_sinr,i.m_sweepAngle=this.m_sweepAngle,i.m_startAngle=this.m_startAngle,i.m_bits=this.m_bits,M(i,a.x,a.y),q(i,h.x,h.y),r)return void tr(i,Ui(this));i.m_startAngle=Li(this,t),i.m_sweepAngle=Li(this,e)-i.m_startAngle,i.m_startAngle=Yi(i.m_startAngle),ir(i,Math.abs(i.m_sweepAngle)>(0,o.a5)()),i.assignVertexDescription(this.m_description),dr(i),Ri(i);const m=this.m_description.getAttributeCount();if(m>1){for(let e=1;e<m;e++){const s=this.m_description.getSemantics(e),n=di.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<m;t++){const s=this.m_description.getSemantics(t),n=di.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}i.afterCompletedModification()}queryDerivative(t,e){!function(t,e,s){if(Zi(t))s.setE(v.constructPoint2D(t.getEndXY()).subE(v.constructPoint2D(t.getStartXY())));else{const n=new o.F;Bi(t,e,n);const i=new v;if(i.setCoordsE(new o.F(t.m_semiMajorAxis).negate().mulE((new o.F).setSin(n)),new o.F(t.getSemiMinorAxis()).mulE((new o.F).setCos(n))),t.m_rotation){const e=new o.F(t.m_rotation);i.rotateDirect((new o.F).setCos(e),(new o.F).setSin(e))}i.scaleThis(new o.F(t.getSweepAngle())),s.setE(i)}}(this,t,e)}cutArcIgnoreAttributes(t,e,s){let n=0===t&&1===e;const i=new o.P;this.queryCoord2D(t,i);const r=new o.P;this.queryCoord2D(e,r),n||(i.equals(r)?e-t>.5&&this.isMajor()&&this.isClosed()?(n=!0,t=0,e=1):1===e?t=e:e=t:(t>0&&i.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&r.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),n=0===t&&1===e)),s.m_center.assign(this.m_center),s.m_semiMajorAxis=this.m_semiMajorAxis,s.m_minorMajorRatio=this.m_minorMajorRatio,s.m_interior.assign(this.m_interior),s.m_rotation=this.m_rotation,s.m_cosr=this.m_cosr,s.m_sinr=this.m_sinr,s.m_sweepAngle=this.m_sweepAngle,s.m_startAngle=this.m_startAngle,s.m_bits=this.m_bits,M(s,i.x,i.y),q(s,r.x,r.y),n?tr(s,Ui(this)):(s.m_startAngle=Li(this,t),s.m_sweepAngle=Li(this,e)-s.m_startAngle,s.m_startAngle=Yi(s.m_startAngle),ir(s,Math.abs(s.m_sweepAngle)>Math.PI),dr(s),s.afterCompletedModification())}changeEndPoints2D(t,e){Oi(this,t,e,!1)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=di.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),h=this.getEndAttributeAsDbl(e,s);return(0,o.T)(r,a,h,i,di.getDefaultValue(e))}getClosestCoordinate(t,e){return xr(this,t,o.E.unit(),e)}getClosestCoordinateOnInterval(t,e){return xr(this,t,e,!1)}getYMonotonicParts(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t.length<2&&(0,i.t)("");const s=this.getSemiAxes(),n=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),r=n+(0,o.a5)(),a=(0,o.d)(3,Number.NaN);let h=0;if(a[0]=Hi(this,n),a[0]>0&&a[0]<1&&h++,a[1]=Hi(this,r),a[1]>0&&a[1]<1&&(a[h]=a[1],h++),0===h)return 0;a[h]=1,h++,(0,i.g)(t.length>=h);let m=0;for(let i=0;i<h;i++){const s=a[i];this.queryCut(m,s,t[i],e),m=s}return h}getMonotonicParts(t,e){if(t.length<4&&(0,i.t)(""),this.isDegenerateToLine())return t[0].createEllipticArc().assignCopy(this),e&&t[0].get().dropAllAttributes(),1;const s=this.getSemiAxes(),n=(0,o.d)(4,Number.NaN);n[0]=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),n[1]=n[0]+(0,o.a5)(),n[2]=Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr),n[3]=n[2]+(0,o.a5)();const r=(0,o.d)(5,Number.NaN);let a=0;for(let i=0;i<4;i++)r[a]=Hi(this,n[i]),r[a]>0&&r[a]<1&&a++;if(0===a)return 0;(0,o.U)(r,a),r[a-1]<1&&(r[a]=1,a++),(0,i.g)(t.length>=a);let h=0;for(let i=0;i<a;i++){const s=r[i];this.queryCut(h,s,t[i],e),h=s}return a}intersectionWithAxis2D(t,e,s,n){if(Zi(this))return new $r({start:this.getStartXY(),end:this.getEndXY()}).intersectionWithAxis2D(t,e,s,n);let i,r;const a=new o.F(e),h=this.getSemiAxes();if(t){if(e>this.m_center.y+h.x||e<this.m_center.y-h.x)return 0;i=new o.F(h.x).mulThis(this.m_sinr),r=new o.F(h.y).mulThis(this.m_cosr),a.subThis(this.m_center.y)}else{if(e>this.m_center.x+h.x||e<this.m_center.x-h.x)return 0;i=new o.F(h.x).mulThis(this.m_cosr),r=new o.F(h.y).mulThis(-this.m_sinr),a.subThis(this.m_center.x)}const m=i.sqr(),l=r.sqr(),u=m.addE(l),c=r.mulE(a).mulThis(-2),g=a.sqr().subThisE(m),d=c.sqr().subThisE(u.mulE(g).mulThis(4)),_=i.mulE(a).mulThis(-2),p=a.sqr().subThisE(l),f=_.sqr().subThisE(u.mulE(p).mulThis(4));let P=d.eps()*Math.abs(f.value())<=f.eps()*Math.abs(d.value());P?i.isZero()&&(P=!1):r.isZero()&&(P=!0),P||(c.setE(_),g.setE(p));const x=(0,o.m)(o.F,2);let y=At(u,c,g,o.E.construct(-1,1),!1,x);if(0===y)return 0;const E=[0,0];let C=0;for(let S=0;S<y;S++){const t=new o.F,e=new o.F;P?(t.setE(x[S]),e.setE(a.subE(r.mulE(x[S])).divThisE(i))):(e.setE(x[S]),t.setE(a.subE(i.mulE(x[S])).divThisE(r)));const s=Hi(this,Math.atan2(t.value(),e.value()));s>=0&&s<=1&&(E[C]=s,C++)}return y=C,0===y?0:(2===y&&E[0]>E[1]&&(E[1]=(0,o.b)(E[0],E[0]=E[1])),n&&(0,o.a)(n,E,0,0,y),s&&(s[0]=t?this.getCoordX(E[0]):this.getCoordY(E[0]),y>1&&(s[1]=t?this.getCoordX(E[1]):this.getCoordY(E[1]),!n&&s[0]>s[1]&&(s[1]=(0,o.b)(s[0],s[0]=s[1])))),y)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0];return-1===this.intersectionWithAxis2D(!0,t,s,null)?e:s[0]}isCurve(){return!0}isDegenerate(t){return D(this,t)}isDegenerate3D(t,e){return(0,i.g)(0),!1}queryLooseEnvelope(t){3!==t.m_EnvelopeType?this.queryLooseEnvelopeOnInterval(new o.E(0,1),t):(0,i.b)("3d not impl")}clone(t){const e=new _i;return this.copyTo(e),e}queryInterval(t,e){if(0===t){if(Zi(this))return 0===e?o.E.construct(this.getStartX(),this.getEndX()):o.E.construct(this.getStartY(),this.getEndY());let t;const s=this.getSemiAxes();t=0===e?Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr):Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr);const n=t+Math.PI,i=[0,0];i[0]=Hi(this,t),i[1]=Hi(this,n);const r=0===e?o.E.construct(this.getStartX(),this.getEndX()):o.E.construct(this.getStartY(),this.getEndY()),a=new o.P;for(let o=0;o<2;o++){const t=i[o];t>0&&t<1&&(this.queryCoord2D(t,a),r.mergeNeCoordinate(0===e?a.x:a.y))}return r}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=new o.E(0,1);if(s.intersect(t),s.isEmpty())return void e.setEmpty();if(Zi(this))return e.setCoords(this.getCoord2D(s.vmin)),void e.mergeNe(this.getCoord2D(s.vmax));const n=this.getCoord2D(s.vmin),i=this.getCoord2D(s.vmax);if(1===this.m_minorMajorRatio&&Math.abs(this.m_sweepAngle)*s.width()<=o.l){let t=o.P.lerp(n,i,.5);const s=t.sub(this.m_center);return s.normalize(),t=t.add(s.mul(.5*o.P.distance(n,i))),e.setCoords(n),e.mergeNe(i),void e.mergeNe(t)}Pr(this,s,e)}tToLength(t){return Zi(this)?t*o.P.distance(this.getStartXY(),this.getEndXY()):1===this.m_minorMajorRatio?Math.abs(this.getSweepAngle()*t)*this.m_semiMajorAxis:Qi(this,t)}parametricAngleToT(t){return Hi(this,t)}tToParametricAngle(t){return Li(this,t)}lengthToT(t){if(Zi(this)){const e=o.P.distance(this.getStartXY(),this.getEndXY());return 0===e?0:t/e}if(1===this.m_minorMajorRatio){const e=Math.abs(this.getSweepAngle())*this.m_semiMajorAxis;return 0===e?0:t/e}return function(t,e){if(Zi(t)){const s=o.P.distance(t.getStartXY(),t.getEndXY());return 0===s?0:e/s}if(1===t.m_minorMajorRatio){const s=Math.abs(t.getSweepAngle()*t.m_semiMajorAxis);return 0===s?0:e/s}if(0===e)return 0;const s=t.getSweepAngle();if(0===s)return.5;const n=zi(t),i=(0,o.a7)(),r=Ki(t);s<0&&(e=-e);const a=e/t.m_semiMajorAxis+r;let h=(0,o.aa)(a,n.e2,n.completeE);return h-=i,h-=t.getStartAngle(),h/s}(this,t)}calculateWeightedAreaCentroid2D(t){if(Zi(this)){const t=new o.P;return t.setCoords(0,0),t}const e=gr(this),s=this.getStartXY().sub(this.m_center),n=this.getEndXY().sub(this.m_center),i=this.m_semiMajorAxis,r=this.getSemiMinorAxis(),a=this.m_startAngle+this.m_sweepAngle,h=new o.P;h.x=i*r*(i*this.m_cosr*(-Math.sin(a)+Math.sin(this.m_startAngle))+r*(-Math.cos(a)+Math.cos(this.m_startAngle))*this.m_sinr)/3,h.y=i*r*(r*(Math.cos(a)-Math.cos(this.m_startAngle))*this.m_cosr+i*(-Math.sin(a)+Math.sin(this.m_startAngle))*this.m_sinr)/3;const m=n.add(s).mul(n.crossProduct(s)/6);return h.x-=m.x,h.y-=m.y,h.add(this.m_center.sub(t).mul(e))}calculateWeightedCentroid2D(){const t=new o.P;if(this.isDegenerate(0))return t.setCoords(0,0),t;if(Zi(this))return t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t;let e=this.m_startAngle,s=this.m_startAngle+this.m_sweepAngle;if(s<e){const t=e;e=s,s=t}const n=Math.sin(e),i=Math.sin(s),r=Math.cos(e),a=Math.cos(s);if(1===this.m_minorMajorRatio){const e=this.getSemiMajorAxis(),s=e*e,o=s*(i-n),h=s*(r-a);t.setCoords(o,h)}else{const e=this.getSemiMajorAxis(),s=this.getSemiMinorAxis(),o=e*e,h=s*s,m=e*s,l=o-h,u=l/h,c=l/o,g=Math.sqrt(u),d=Math.sqrt(c),_=.5*m*(Math.asinh(g*i)/g+i*Math.sqrt(1+u*i*i))-.5*m*(Math.asinh(g*n)/g+n*Math.sqrt(1+u*n*n)),p=-.5*m*(Math.asin(d*a)/d+a*Math.sqrt(1-c*a*a))- -.5*m*(Math.asin(d*r)/d+r*Math.sqrt(1-c*r*r));t.setCoords(_,p)}return t.rotateDirect(this.m_cosr,this.m_sinr),t.assign(t.add(this.m_center.mul(this.calculateLength2D()))),t}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;if(!Zi(this)){const s=o.P.distance(t,this.m_center),n=this.getSemiAxes();if(s<n.x-e||s>n.y+e)return!1}const n=this.getClosestCoordinate(t,!1),i=new o.P;return this.queryCoord2D(n,i),o.P.distance(i,t)<=e}isIntersectingPoint3D(t,e,s,n){return(0,i.g)(0),!1}getTangent(t){if(Zi(this))return this.getEndXY().sub(this.getStartXY());{const e=Li(this,t),s=new o.P;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}getDerivative(t){if(Zi(this))return this.getEndXY().sub(this.getStartXY());{const e=Li(this,t),s=new o.P;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}normalizeAfterEndpointChange(){return!!or(this)&&(Zi(this)?(ar(this),!1):hr(this,!1))}projectionBehavior(){return(4&this.m_bits)>>2}setProjectionBehavior(t){this.m_bits=-5&this.m_bits|t<<2}convertToCanonic(t){const e=new o.P(t.x,t.y);return e.subThis(this.m_center),e.rotateReverse(this.m_cosr,this.m_sinr),e}convertFromCanonic(t){const e=new o.P(t.x,t.y);return e.rotateDirect(this.m_cosr,this.m_sinr),e.addThis(this.m_center),e}canonicToWorldTransformation(t){t.setRotate(this.m_cosr,this.m_sinr),t.shiftCoords(this.m_center.x,this.m_center.y)}getCurvature(t){const e=Li(this,t),s=new o.P,n=this.getSemiMinorAxis();s.setCoords(-this.m_semiMajorAxis*Math.sin(e),n*Math.cos(e));const i=new o.P;i.setCoords(-this.m_semiMajorAxis*Math.cos(e),-n*Math.sin(e)),this.m_rotation&&(s.rotateDirect(this.m_cosr,this.m_sinr),i.rotateDirect(this.m_cosr,this.m_sinr));const r=s.sqrLength();if(0===r)return Number.NaN;const a=Math.sqrt(r);return s.divThis(a),s.crossProduct(i)/r}getMonotonicPartParams(t,e){const s=(0,o.d)(6,Number.NaN);s[0]=0;let n=1;if(this.isDegenerateToLine())s[1]=1,n=2;else{const t=this.getSemiAxes(),e=(0,o.d)(4,Number.NaN);this.m_rotation?(e[0]=Math.atan2(t.y*this.m_cosr,t.x*this.m_sinr),e[1]=e[0]+Math.PI,e[2]=Math.atan2(-t.y*this.m_sinr,t.x*this.m_cosr),e[3]=e[2]+Math.PI):(e[0]=0,e[1]=Math.PI,e[2]=.5*Math.PI,e[3]=(0,o.a6)());for(let i=0;i<4;i++){const t=Hi(this,e[i]);t>0&&t<1&&(s[n]=t,n++)}n>2&&(0,o.U)(s,n),s[n]=1,n++}if(e){t<n&&(0,i.t)("");for(let t=0;t<n;t++)e[t]=s[t]}return n}calculateLowerLength2D(){const t=o.P.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMinorAxis();return Math.max(e,t)}calculateUpperLength2D(){const t=o.P.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMajorAxis();return Math.max(e,t)}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=(0,o.b)(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=(0,o.b)(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=(0,o.b)(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_startAngle=this.m_startAngle+this.m_sweepAngle,this.m_sweepAngle=-this.m_sweepAngle}}isLine(){return Zi(this)}copyIgnoreAttributes(t){t.m_XStart=this.m_XStart,t.m_YStart=this.m_YStart,t.m_XEnd=this.m_XEnd,t.m_YEnd=this.m_YEnd,t.m_center.assign(this.m_center),t.m_semiMajorAxis=this.m_semiMajorAxis,t.m_minorMajorRatio=this.m_minorMajorRatio,t.m_interior.assign(this.m_interior),t.m_rotation=this.m_rotation,t.m_cosr=this.m_cosr,t.m_sinr=this.m_sinr,t.m_sweepAngle=this.m_sweepAngle,t.m_startAngle=this.m_startAngle,t.m_bits=this.m_bits,er(t)}calculateArea2DHelper(){return gr(this)}absNorm(){let t=this.getStartXY().norm(1)+this.getEndXY().norm(1);return this.isDegenerateToLine()||(t+=this.m_center.norm(1),t+=this.m_semiMajorAxis),t}queryEnvelopeW(t,e){if(e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax)),Zi(this))return;const s=this.getSemiAxes(),n=(0,o.d)(8,Number.NaN);{const t=Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr),e=t+Math.PI,i=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),r=i+Math.PI;n[0]=Hi(this,t),n[1]=Hi(this,e),n[2]=Hi(this,i),n[3]=Hi(this,r)}{const t=this.m_cosr+this.m_sinr,e=this.m_cosr-this.m_sinr,i=Math.atan2(-s.y*t,s.x*e),r=i+Math.PI,o=Math.atan2(s.y*e,s.x*t),a=o+Math.PI;n[4]=Hi(this,i),n[5]=Hi(this,r),n[6]=Hi(this,o),n[7]=Hi(this,a)}const i=o.P.getNAN();for(let r=0;r<8;r++){const s=n[r];t.containsExclusiveCoordinate(s)&&(this.queryCoord2D(s,i),e.mergeNe(i))}}setSegmentFromCoords(t,e){!function(t,e,s){const n=0===t.projectionBehavior();if(s<=2)return void ji(t,e[0],e[s-1],n?0:1);if(n){t.constructCircularArcThreePoint(e[0],e[s-1],e[Math.trunc(s/2)]);const n=new o.P;return t.queryCoord2D(.5,n),void t.m_interior.setCoordsPoint2D(n)}const i=t.getSemiMajorAxis(),r=t.getMinorMajorRatio(),a=t.getAxisXRotation(),h=t.getCenter(),m=new Array(4);m[0]=t.isMajor(),m[1]=!m[0],m[2]=m[0],m[3]=!m[0];const l=new Array(4);l[0]=t.isClockwise(),l[1]=l[0],l[2]=!l[0],l[3]=!l[0];const u=Math.trunc(s<5?1:(s+4)/5),c=(0,o.m)(_i,4),g=(0,o.d)(4,Number.NaN);let d=0;for(let _=0;_<4;_++){c[_].constructEllipticArcEndPointsCenter(e[0],e[s-1],i,r,a,m[_],l[_],h),g[_]=0;let t=0;for(let n=u;n<s-1;n+=u){const s=c[_].getClosestCoordinate(e[n],!1);g[_]+=o.P.sqrDistance(c[_].getCoord2D(s),e[n]),t++}g[_]/=t,g[_]<g[d]&&(d=_)}t.assignCopy(c[d])}(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(10);return s[0]=this.m_bits,s[1]=this.m_semiMajorAxis,s[2]=this.m_minorMajorRatio,s[3]=this.m_rotation,s[4]=this.m_center.x,s[5]=this.m_center.y,s[6]=this.m_sweepAngle,s[7]=this.m_startAngle,s[8]=this.m_interior.x,s[9]=this.m_interior.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(10);t.queryRange(e,s.length,s,!0,1),this.m_bits=s[0],this.m_semiMajorAxis=s[1],this.m_minorMajorRatio=s[2],this.m_rotation=s[3],this.m_center.x=s[4],this.m_center.y=s[5],this.m_sweepAngle=s[6],this.m_startAngle=s[7],this.m_interior.x=s[8],this.m_interior.y=s[9],this.m_cosr=Math.cos(this.m_rotation),this.m_sinr=Math.sin(this.m_rotation),this.m_cachedValues=null}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return(0,i.c)("should not1; be called"),0}ensureXYMonotone(){if(Zi(this))return!1;if(this.getStartXY().equals(this.getEndXY()))return ji(this,this.getStartXY(),this.getEndXY(),this.projectionBehavior()),!0;const t=(0,o.m)(o.P,3);let e=mr(this,t);if(je(t)){let s=!1;if(0===this.projectionBehavior()){const n=new a.Envelope2D;n.setCoords({pt:t[0]}),n.mergeNe(t[2]);const i=new o.P;i.setSub(t[2],t[0]),i.leftPerpendicularThis(),i.normalize(),i.scale(o.P.distance(t[2],t[0]));const r=o.P.lerp(t[2],t[0],.5),h=r.sub(i),m=r.add(i);n.clipLine(h,m);const l=o.P.getClosestCoordinate(h,m,t[1],!1);t[1]=o.P.lerp(h,m,l);const u=t[2].sub(t[1]),c=t[0].sub(t[1]),g=u.crossProduct(c),d=u.dotProduct(c);e=(0,o.a7)()-Math.abs(.5*Math.atan2(g,d)),s=!0}return lr(t,e*e,null,s,this),!0}return!1}setCoordsForIntersector(t,e,s){Oi(this,t,e,s)}getInteriorPoint(){return this.m_interior.clone()}copyToImpl(t){const e=t;e.m_center.assign(this.m_center),e.m_semiMajorAxis=this.m_semiMajorAxis,e.m_minorMajorRatio=this.m_minorMajorRatio,e.m_interior.assign(this.m_interior),e.m_rotation=this.m_rotation,e.m_cosr=this.m_cosr,e.m_sinr=this.m_sinr,e.m_sweepAngle=this.m_sweepAngle,e.m_startAngle=this.m_startAngle,e.m_bits=this.m_bits,tr(e,Ui(this))}reverseImpl(){sr(this,!nr(this)),Ri(this),(0!==this.projectionBehavior()||this.getStartXY().equals(this.getEndXY()))&&dr(this)}equalsImpl(t){const e=t;if(this.m_bits!==e.m_bits)return!1;if(this.m_semiMajorAxis!==e.m_semiMajorAxis)return!1;if(this.m_minorMajorRatio!==e.m_minorMajorRatio)return!1;if(!(this.m_center.isEqualPoint2D(e.m_center)||this.m_center.isNAN()&&e.m_center.isNAN()))return!1;if(this.m_rotation!==e.m_rotation)return!1;if(!this.m_interior.equals(e.m_interior))return!1;const s=e.m_sweepAngle;if(this.m_sweepAngle!==s)return!1;const n=e.m_startAngle;return this.m_startAngle===n}equalsImplTol(t,e){const s=t;if(this.m_bits!==s.m_bits)return!1;if(this.m_center.isNAN()&&s.m_center.isNAN())return!0;if(this.m_center.isNAN()!==s.m_center.isNAN())return!1;if(!this.getSemiAxes().isEqualPoint2D(s.getSemiAxes(),e))return!1;if(!this.m_center.isEqualPoint2D(s.m_center,e))return!1;const n=Math.abs(mi(hi(li(this.m_rotation-s.m_rotation)))),i=Math.abs((0,o.a5)()-n),r=Math.min(n,i);if(this.m_semiMajorAxis*Math.abs(r)>e)return!1;const a=this.getCoord2D(.5),h=s.getCoord2D(.5);return!!a.isEqualPoint2D(h,e)}swapImpl(t){const e=t;this.m_center=(0,o.b)(e.m_center,e.m_center=this.m_center),this.m_semiMajorAxis=(0,o.b)(e.m_semiMajorAxis,e.m_semiMajorAxis=this.m_semiMajorAxis),this.m_minorMajorRatio=(0,o.b)(e.m_minorMajorRatio,e.m_minorMajorRatio=this.m_minorMajorRatio),this.m_interior=(0,o.b)(e.m_interior,e.m_interior=this.m_interior),this.m_rotation=(0,o.b)(e.m_rotation,e.m_rotation=this.m_rotation),this.m_cosr=(0,o.b)(e.m_cosr,e.m_cosr=this.m_cosr),this.m_sinr=(0,o.b)(e.m_sinr,e.m_sinr=this.m_sinr),this.m_sweepAngle=(0,o.b)(e.m_sweepAngle,e.m_sweepAngle=this.m_sweepAngle),this.m_startAngle=(0,o.b)(e.m_startAngle,e.m_startAngle=this.m_startAngle),this.m_bits=(0,o.b)(e.m_bits,e.m_bits=this.m_bits),function(t,e){e.m_cachedValues=(0,o.b)(t.m_cachedValues,t.m_cachedValues=e.m_cachedValues)}(this,e)}afterCompletedModification(){ar(this),er(this)}intersect(t,e,s,n,i){return Wr(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){if(e.length<2&&(0,i.n)(""),Zi(this))return new $r({start:this.getStartXY(),end:this.getEndXY()}).intersectPoint(t,e,s);{const e=o.P.distance(t,this.m_center);if(e>this.m_semiMajorAxis+s||e<this.getSemiMinorAxis()-s)return 0}const n=this.getClosestCoordinate(t,!1),r=o.P.getNAN();return this.queryCoord2D(n,r),o.P.distance(r,t)<=s?(0,o.J)(n,0,1)&&(this.queryCoord2D(0===n?1:0,r),o.P.distance(r,t)<=s)?(e&&(e[0]=0,e[1]=1),2):(e&&(e[0]=n),1):0}isIntersecting(t,e,s){return 0!==Br(!1,this,t,e,s)}endPointModified(){this.m_bits|=8,er(this)}clearEndPointModified(){ar(this)}}function pi(t,e,s){t.isEmpty()&&(0,i.u)(""),(0,i.l)(t);const n=t.getImpl(),r=[];return Pi(n.getPointCount(),r),xi(function(t){return{at:e=>t.getXY(e)}}(n),r,n.getPointCount(),e)}function fi(t,e,s,n){const i=[];return Pi(e,i),xi(t,i,e,s)}function Pi(t,e){e.length=t;for(let s=0;s<e.length;++s)e[s]=s;t>3&&c(t,e)}function xi(t,e,s,n,i){let r=0;const a=[0,0,0];let h=0;let m=0;for(let l=0;l<3;++l){let i=!1;for(;m<s;){const s=t.at(e[m]);let u=1;if(3===r?u=o.P.inCircleRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]),s):2===r?u=o.P.inCircleRobust3Point(t.at(n[0]),t.at(n[1]),s):1===r&&s.equals(t.at(n[0]))&&(u=0),u<=0){if(u<0&&l+1<3){e[h]=(0,o.b)(e[m],e[m]=e[h]);for(let t=0;t<r;t++)if(n[t]===e[m]){a[t]=m;break}h++}m++;continue}i=!0;let c=0;for(let t=0;t<r;t++)a[t]>m&&(n[c]=n[t],a[c]=a[t],c++);r=c,n[r]=e[m],a[r]=m,r++,r<3?m=h:(1===o.P.orientationRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]))&&(n[2]=(0,o.b)(n[0],n[0]=n[2]),a[2]=(0,o.b)(a[0],a[0]=a[2])),m++)}if(!i)break;if(l+1<3){h=0;let s=!1;for(let t=0;t<r;t++)for(let e=t+1;e<r;e++)a[t]>a[e]&&(a[e]=(0,o.b)(a[t],a[t]=a[e]),n[e]=(0,o.b)(n[t],n[t]=n[e]),s=!0);for(let t=0;t<r;t++)e[a[t]]=(0,o.b)(e[t],e[t]=e[a[t]]),a[t]=t;s&&3===r&&1===o.P.orientationRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]))&&(n[2]=(0,o.b)(n[0],n[0]=n[2]),a[2]=(0,o.b)(a[0],a[0]=a[2]))}m=r}return r}_i.type=i.G.enumEllipticArc;class yi extends $n{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!0}),this.m_segmentBufferCTor=to):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!0}),this.m_segmentBufferCTor=to,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=to):t.envelope?(0,i.b)("envelope constructor not impl"):(0,i.c)("bad arg to polygon constructor"):(super({bPolygon:!0}),this.m_segmentBufferCTor=to)}assignMove(t){return t.copyTo(this),this}assignCopy(t){return t.copyTo(this),this}getBoundary(){return ii(this)}getExteriorRingCount(){return this.getOGCPolygonCount()}getGeometryType(){return yi.type}getDimension(){return 2}createInstance(){return new yi({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}function Ei(t,e,s,n,i,r){return new bi(0,0,0,null,!1,(0,o.i)()).densifyEx(t,e,s,n,!1,r)}function Ci(t,e,s,n){return Number.isFinite(e)||(0,i.t)("replace_all_curves_with_beziers: maxDeviation"),function(t,e,s,n){(0,i.g)(t===i.G.enumBezier||t===i.G.enumEllipticArc||t===i.G.enumBezier2);const r=e.createInstance();r.getGeometryType()===i.G.enumPolygon&&r.setFillRule(e.getFillRule());const o=e.querySegmentIterator();for(let a=0,h=e.getPathCount();a<h;++a){if(!e.hasNonLinearSegmentsPath(a)){r.addPath(e,a,!0);continue}const h=e.getPathStart(a);let m=!0,l=0;for(o.resetToPath(a),(0,i.g)(o.nextPath());o.hasNextSegment();){const u=o.nextCurve();if(!u)break;{const c=o.getStartPointIndex()-h,g=c-l;g>0&&(r.addSegmentsFromPath(e,a,l,g,m),m=!1),l=c+1,t===i.G.enumBezier?wi(r,u,s,n,m):t===i.G.enumBezier2?Di(r,u,s,n,m):(0,i.c)(""),m=!1}}const u=e.getSegmentCountPath(a);u-l!=0&&r.addSegmentsFromPath(e,a,l,u-l,m)}return r}(i.G.enumBezier,t,e,s)}function Si(t,e,s,n,r,a,h,m){a&&(a.length=0),h&&(h.length=0);const l=t.getGeometryType();if(l===i.G.enumLine)return a&&(a.push(t.getStartXY()),a.push(o.P.getNAN()),a.push(o.P.getNAN()),a.push(t.getEndXY())),h&&(h.push(0),h.push(1)),1;if(l===i.G.enumBezier){if(!n)return a&&(a.push(t.getStartXY()),a.push(t.getControlPoint1()),a.push(t.getControlPoint2()),a.push(t.getEndXY())),h&&(h.push(0),h.push(1)),1;const e=(0,o.d)(9,Number.NaN);let i=t.getMonotonicPartParams(e.length,e);if(e.length=i,i=Ii(t,s,e),2===i&&r&&(e[1]=.5,e.push(1),i=3),h&&h.splice(0,0,...e.slice(0,i)),a){const s=new to;for(let n=1;n<i;n++){const i=e[n-1],r=e[n];t.queryCut(i,r,s,!0);const o=s.get();yn(o),1===n&&a.push(o.getStartXY()),a.push(o.getControlPoint1()),a.push(o.getControlPoint2()),a.push(o.getEndXY())}}return i-1}if(l===i.G.enumEllipticArc){const m=t;if(m.isDegenerateToLine()||m.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(o.P.getNAN()),a.push(o.P.getNAN()),a.push(t.getEndXY())),h&&(h.push(0),h.push(1)),1;if(n&&(r||!m.isMonotoneQuickAndDirty())){const l=(0,o.d)(6,Number.NaN);let u=m.getMonotonicPartParams(l.length,l);l.length=u,u=Ii(t,s,l),2===u&&r&&(l[1]=.5,l.push(1),u=3);let c=0;if(u>2){const t=new to,r=h||[];let o=0;for(let g=1;g<u;g++){const d=l[o],_=l[g];if(m.queryCut(d,_,t,!0),t.get().isDegenerate(0))continue;const p=r.length,f=Ti(1===g,t.get(),e,s,n,a,h);(0,i.g)(f>0),c+=f;const P=g===u-1,x=l[o],y=t.get().getSweepAngle()/m.getSweepAngle();for(let t=p,e=r.length;t<e;t++)if(r[t]=!P||t+1<e?x+r[t]*y:1,a){const e=3*t,s=m.getCoord2D(r[t]);a[e].setCoordsPoint2D(s),e>0&&En(a.slice(e-3))}o=g}return c}}return Ti(!0,m,e,s,n,a,h)}if(l===i.G.enumRationalBezier2){const i=t;if(n&&(r||!i.isMonotoneQuickAndDirty())){const n=(0,o.d)(6,Number.NaN);let m=i.getMonotonicPartParams(n.length,n);n.length=m,m=Ii(t,s,n),2===m&&r&&(n[1]=.5,n.push(1),m=3);let l=0;if(m>2){const t=new to,r=h||[];for(let o=1;o<m;o++){const u=n[o-1],c=n[o];i.queryCut(u,c,t,!0);const g=r.length;l+=Ai(1===o,t.get(),e,s,!1,a,h);const d=o===m-1,_=n[o-1];for(let t=g,e=r.length;t<e;t++)if(r[t]=!d||t+1<e?_+r[t]:1,a){const e=3*t,s=i.getCoord2D(r[t]);a[e].setCoordsPoint2D(s),e>0&&ks(a.slice(e-3))}}return l}}return Ai(!0,i,e,s,n,a,h)}if(l===i.G.enumBezier2){const i=t,m=(0,o.m)(o.P,3);i.queryControlPoints(m);const l=new $s;return l.constructFromQuadratic(m),Si(l,e,s,n,r,a,h)}(0,i.b)("")}function vi(t,e,s,n,r,a,h,m,l){const u=t.getGeometryType();if(a&&(a.length=0,h.length=0),m&&(m.length=0),u===i.G.enumEllipticArc){const e=t;if(e.isDegenerateToLine()||e.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(o.P.getNAN()),a.push(t.getEndXY()),h.push(Number.NaN),h.push(Number.NaN),h.push(Number.NaN)),m&&(m.push(0),m.push(1)),1}const c=(0,o.d)(9,Number.NaN);let g;if(r)g=t.getMonotonicPartParams(c.length,c),c.length=g,g=Ii(t,s,c);else{if(g=2,c[0]=0,c[1]=1,u===_i.type){const e=t.getSweepAngle();if(e>.9*Math.PI){const t=2*Math.PI/3;Math.min(3,Math.trunc(e/t+.5))>2?(c[0]=0,c[1]=1/3,c[2]=2/3,c[3]=1,g=4):(c[0]=0,c[1]=.5,c[2]=1,g=3)}}else(0,i.g)(u===Bt.type);c.length=g}if(2===g&&n&&(c[1]=.5,c.push(1),g=3),a){const e=new to;let s=1;for(;s<g;){const n=c[s-1],m=c[s];t.queryCut(n,m,e,!0);const l=(0,o.m)(o.P,3),d=[1,1,1];if(u===i.G.enumEllipticArc){const t=e.get();if(Math.abs(t.getSweepAngle())>.9*Math.PI){const t=(m-n)/3;c.splice(s,0,n+t),c.splice(s+1,0,n+2*t),g+=2;continue}d[1]=mr(t,l)}else{const t=e.get();t.queryControlPoints(l),t.queryWeights(d)}r&&je(l),1===s&&(a.push(l[0].clone()),h.push(d[0])),a.push(l[1].clone()),a.push(l[2].clone()),h.push(d[1]),h.push(d[2]),s++}}return m&&(m.length=g,(0,o.a)(m,c,0,0,g)),g-1}yi.type=i.G.enumPolygon;class bi{static constructDefault(t){return new bi(0,0,0,t,!1,(0,o.i)())}constructor(t,e,s,n,a,h){this.m_segmentBuffer=null,this.m_dummyPoint=new r.P,this.m_progressCounter=0,this.m_progressTracker=n,this.m_bSetDensifyFlag=a,this.m_maxLength=t,this.m_maxDeviation=e,this.m_maxAngle=s>(0,o.a7)()?(0,o.a7)():s,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_maxSegmentsPerCurve=h,(0,i.w)(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve}densify(t){return this.densifyGeom(t)}densifySegment(t,e){this.densifySegmentEx(t,null,!0,!1,e)}densifyEx(t,e,s,n,r,a){return this.m_maxLength=e,this.m_maxDeviation=s,this.m_maxAngle=n>(0,o.a7)()?(0,o.a7)():n,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_bSetDensifyFlag=r,this.m_maxSegmentsPerCurve=a,(0,i.w)(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve,this.densifyGeom(t)}densifyGeom(t){if(t.isEmpty()||t.getDimension()<1)return t;const e=t.getGeometryType();return(0,i.o)(e)?t:(0,i.h)(e)?this.densifyMultiPath(t):(0,i.f)(e)?this.densifySegmentImpl(t):e===i.G.enumEnvelope?this.densifyEnvelope(t):void(0,i.c)("")}densifySegmentEx(t,e,s,n,r){const o=t.getGeometryType();if(!(this.m_maxLength>0||this.m_bOnlyCurveDensify&&o!==i.G.enumLine)&&(!n||s))return void(e?o===i.G.enumLine?e.addSegment(t,s):(s&&(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)),t.queryEnd(this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint)):(s&&r.push(0),r.push(1)));if(o===i.G.enumBezier)return void this.densifyCubicBezier(t,e,s,n,r);if(o===i.G.enumRationalBezier2)return void this.densifyRationalBezier2(t,e,s,n,r);if(o===i.G.enumBezier2)return void this.densifyBezier2(t,e,s,n,r);if(o===i.G.enumEllipticArc&&!t.isLine()&&t.getMinorMajorRatio()<.25)return void this.densifyEllipticArc(t,e,s,n,r);let a=1;this.m_maxLength>0&&(a=this.calculateLengthSubdivisionStep(t,this.m_maxLength)),this.m_maxDeviation>0&&(a=Math.min(a,this.calculateDeviationSubdivisionStep(t,this.m_maxDeviation))),this.m_maxAngle>0&&(a=Math.min(a,this.calculateAngularSubdivisionStep(t,this.m_maxAngle))),this.densifySegmentByLength(t,a,e,s,n,r)}densifyMultiPath(t){if(!t.hasNonLinearSegments()){if(1===t.getDescription().getAttributeCount())return this.densifyMultiPathLinear(t);if(!(this.m_maxLength>0))return t}const e=t.createInstance();e.getGeometryType()===i.G.enumPolygon&&e.setFillRule(t.getFillRule()),e.reserve(t.getPointCount());const s=t.getImpl().querySegmentIterator();for(;s.nextPath();){let t=!0;for(;s.hasNextSegment();){const n=s.nextSegment(),i=s.isClosingSegment();this.densifySegmentEx(n,e,t,i,null),i&&e.closePathWithLine(),t=!1}}return e}densifySegmentImpl(t){const e=new ei({vd:t.getDescription()});return this.densifySegmentEx(t,e,!0,!1,[0]),e}densifyEnvelope(t){const e=new yi({vd:t.getDescription()});e.addEnvelope(t,!1);const s=a.Envelope2D.constructEmpty();t.queryEnvelope(s);const n=s.width(),i=s.height();return!(this.m_maxLength>0)||n<=this.m_maxLength&&i<=this.m_maxLength?e:this.densifyMultiPath(e)}densifyMultiPathLinear(t){if(!(this.m_maxLength>0))return t;const e=t.createInstance();e.getGeometryType()===i.G.enumPolygon&&e.setFillRule(t.getFillRule()),e.reserve(t.getPointCount());const s=e.getImpl(),n=t.getImpl(),r=n.getAttributeStreamRef(0),a=new $r;for(let i=0,h=n.getPathCount();i<h;i++){const t=n.isClosedPath(i);if(0===n.getPathSize(i))continue;const h=n.getPathStart(i),m=r.readPoint2D(2*h),l=m.clone();s.startPath(m);for(let u=h+1,c=n.getPathEnd(i);u<c;u++){const t=r.readPoint2D(2*u),n=o.P.distance(l,t);if(n>this.m_maxLength){let e=Math.ceil(n/this.m_maxLength);e>(0,o.i)()&&(e=(0,o.i)());const i=1/e;let r,h,m;l.compare(t)<0?(a.setStartXY(l),a.setEndXY(t),r=0,h=1):(a.setStartXY(t),a.setEndXY(l),r=e-2,h=-1);for(let t=0,n=e-1;t<n;t++,r+=h){this.progress_(),m=i*(r+1);const t=new o.P;a.queryCoord2D(m,t),s.lineTo(t),this.m_bSetDensifyFlag&&s.setAttribute(10,s.getPointCount()-1,0,1)}}else this.progress_();e.lineTo(t),l.assign(t)}if(t){const t=o.P.distance(l,m);if(t>this.m_maxLength){const e=m;let n=Math.ceil(t/this.m_maxLength);n>(0,o.i)()&&(n=(0,o.i)());const i=1/n;let r,h;l.compare(e)<0?(a.setStartXY(l),a.setEndXY(e),r=0,h=1):(a.setStartXY(e),a.setEndXY(l),r=n-2,h=-1);const u=new o.P(0,0);let c;for(let t=0,o=n-1;t<o;t++,r+=h)this.progress_(),c=i*(r+1),a.queryCoord2D(c,u),s.lineTo(u),this.m_bSetDensifyFlag&&s.setAttribute(10,s.getPointCount()-1,0,1)}s.closePathWithLine()}}return e}densifySegmentByLength(t,e,s,n,r,a){(0,i.g)(t.getGeometryType()!==i.G.enumBezier);let h=t.getStartXY().compare(t.getEndXY());0===h&&e<1&&(t.getGeometryType()===i.G.enumEllipticArc?h=t.getSweepAngle()<0?1:-1:(0,i.b)("densify segment by length"));let m=0;if(n&&(s?(t.queryStart(this.m_dummyPoint),s.startPathPoint(this.m_dummyPoint)):a.push(0),++m),e*this.m_maxSegmentsPerCurve<1&&(e=1/this.m_maxSegmentsPerCurve),e<1){this.m_segmentBuffer||(this.m_segmentBuffer=new to);let n=Math.ceil(1/e);n>(0,o.i)()&&(n=(0,o.i)()),e=1/n,this.m_segmentBuffer.create(t.getGeometryType());let i,r,l,u=t;h<0?(i=0,r=1):(t.copyTo(this.m_segmentBuffer.get()),this.m_segmentBuffer.get().reverse(),i=n-2,r=-1,u=this.m_segmentBuffer.get());const c=n-1;for(let t=0;t<c;t++,i+=r)l=e*(i+1),s?(u.queryCoord(l,this.m_dummyPoint),s.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==l&&0!==l&&s.setAttribute(10,s.getPointCount()-1,0,1)):a.push(h>0?1-l:l),this.progress_();l=1,m+=c}(!r||r&&n&&m<2)&&(s?(t.queryEnd(this.m_dummyPoint),s.lineToPoint(this.m_dummyPoint)):a.push(1))}densifyCubicBezier(t,e,s,n,i){const r=new $s;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());if(0===m&&h>0){const e=(0,o.m)(o.P,4);t.queryControlPoints(e),m=e[1].compare(e[2]),0===m&&(m=e[1].compare(e[0]))}m>0&&(t.copyTo(r),r.reverse(),a=r);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++l);const u=[],c=[],g=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));let d=!0,_=0;if(m>0)for(u.push([a.getStartXY(),a.getControlPoint1(),a.getControlPoint2(),a.getEndXY(),new o.P(0,1)]),c.push(0);u.length;){this.progress_();const t=u.at(-1),r=c.at(-1),h=t[4].x,m=t[4].y;if(r<g&&this.bezierNeedsSplit(t)){d&&(_=a.findMinDeriv(),d=!1);let e=.5*(h+m);Math.abs(_-e)<.4*(m-h)&&(e=_);const s=(e-h)/(m-h),n=t[0].mul(1-s).add(t[1].mul(s)),i=t[1].mul(1-s).add(t[2].mul(s)),l=t[2].mul(1-s).add(t[3].mul(s)),g=n.mul(1-s).add(i.mul(s)),p=i.mul(1-s).add(l.mul(s)),f=g.mul(1-s).add(p.mul(s)),P=t[3];t[1]=n,t[2]=g,t[3]=f,t[4].setCoords(h,e);const x=[f,p,l,P,new o.P(e,m)];u.push(x),c[c.length-1]=r+1,c.push(r+1)}else u.pop(),c.pop(),(u.length>0||!n||n&&s&&l<2)&&(e?(a.queryCoord(h,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==h&&0!==h&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(1-h),++l)}else for(u.push([a.getStartXY(),a.getControlPoint1(),a.getControlPoint2(),a.getEndXY(),new o.P(0,1)]),c.push(0);u.length;){this.progress_();const t=u.at(-1),r=c.at(-1),h=t[4].x,m=t[4].y;if(r<g&&this.bezierNeedsSplit(t)){d&&(_=a.findMinDeriv(),d=!1);let e=.5*(h+m);Math.abs(_-e)<.4*(m-h)&&(e=_);const s=(e-h)/(m-h),n=t[0].mul(1-s).add(t[1].mul(s)),i=t[1].mul(1-s).add(t[2].mul(s)),l=t[2].mul(1-s).add(t[3].mul(s)),g=n.mul(1-s).add(i.mul(s)),p=i.mul(1-s).add(l.mul(s)),f=g.mul(1-s).add(p.mul(s)),P=t[0];t[0]=f,t[1]=p,t[2]=l,t[4].setCoords(e,m);const x=[P,n,g,f,new o.P(h,e)];u.push(x),c[c.length-1]=r+1,c.push(r+1)}else u.pop(),c.pop(),(u.length>0||!n||n&&s&&l<2)&&(e?(a.queryCoord(m,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==m&&0!==m&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(m),++l)}}densifyRationalBezier2(t,e,s,n,i){const r=new Bt;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());0===m&&h>0&&(m=0),m>0&&(t.copyTo(r),r.reverse(),a=r);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++l);const u=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),c=new Bt,g=[],d=[];for(g.push(new o.E(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),r=d.at(-1);if(r<u&&this.rationalBezier2NeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();m>0?(g.at(-1).vmax=e,g.push(new o.E(e,t.vmax))):(g.at(-1).vmin=e,g.push(new o.E(t.vmin,e))),d[d.length-1]=r+1,d.push(r+1)}else if(g.pop(),d.pop(),g.length>0||!n||n&&s&&l<2){const s=m>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(m>0?1-s:s),++l}}}densifyBezier2(t,e,s,n,i){const r=new Ht;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());0===m&&h>0&&(m=0),m>0&&(t.copyTo(r),r.reverse(),a=r);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++l);const u=Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)),c=new Ht,g=[],d=[];for(g.push(new o.E(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),r=d.at(-1);if(r<u&&this.bezier2NeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();m>0?(g.at(-1).vmax=e,g.push(new o.E(e,t.vmax))):(g.at(-1).vmin=e,g.push(new o.E(t.vmin,e))),d[d.length-1]=r+1,d.push(r+1)}else if(g.pop(),d.pop(),g.length>0||!n||n&&s&&l<2){const s=m>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(m>0?1-s:s),++l}}}densifyEllipticArc(t,e,s,n,i){const r=new _i;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());0===m&&h>0&&(m=t.isClockwise()?0:1),m>0&&(t.copyTo(r),r.reverse(),a=r);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++l);const u=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),c=new _i,g=[],d=[];for(g.push(new o.E(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),r=d.at(-1);if(r<u&&this.ellipticArcNeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();m>0?(g.at(-1).vmax=e,g.push(new o.E(e,t.vmax))):(g.at(-1).vmin=e,g.push(new o.E(t.vmin,e))),d[d.length-1]=r+1,d.push(r+1)}else if(g.pop(),d.pop(),g.length>0||!n||n&&s&&l<2){const s=m>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(m>0?1-s:s),++l}}}calculateLengthSubdivisionStep(t,e){const s=t.calculateUpperLength2D();if(!t.isCurve())return s?e/s:1;if(t.getGeometryType()===i.G.enumEllipticArc){const n=t;if(n.isCircular()||n.isDegenerate(0)||n.isDegenerateToLine()){let t=e/s;return t<this.m_minStep&&(t=this.m_minStep),t}return e/s*n.getSemiAxes().y/n.getSemiAxes().x}t.getGeometryType()===i.G.enumBezier&&(0,i.b)(""),(0,i.b)("")}calculateDeviationSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===i.G.enumEllipticArc){const s=t;if(s.isDegenerate(0)||s.isDegenerateToLine())return 1;{const n=s.getSemiMajorAxis(),i=1-e/n;let r=Math.PI/2;if(i>0){const t=4*Math.sqrt(e/n*.5);r=Math.min(Math.PI/2,Math.abs(t))}r=Math.max(r,2*Math.PI/this.m_maxSegmentsPerCurve);const o=r*n;return this.calculateLengthSubdivisionStep(t,o)}}(0,i.b)("")}calculateAngularSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===i.G.enumEllipticArc){const s=t;return s.isDegenerate(0)||s.isDegenerateToLine()?1:this.calculateLengthSubdivisionStep(t,e*s.getSemiMinorAxis())}(0,i.b)("")}rationalBezier2NeedsSplit(t,e,s,n){t.cutBezierIgnoreAttributes(s,n,e);let i=!1;if(this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength)return i=!0,!0;const r=(0,o.m)(o.P,3);e.queryControlPoints(r);const a=[0,0,0];return e.queryWeights(a),!i&&this.m_maxDeviation>0&&(i=!bi.checkRationalBezier2MaxDeviation(r,a,this.m_maxDeviation)),!i&&this.m_maxAngle>0&&(i=!bi.checkRationalBezier2MaxAngle(r,a,this.m_cosMaxAngle)),i}bezier2NeedsSplit(t,e,s,n){t.cutBezierIgnoreAttributes(s,n,e);let i=!1;if(this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength)return i=!0,!0;const r=(0,o.m)(o.P,3);return e.queryControlPoints(r),!i&&this.m_maxDeviation>0&&(i=!bi.checkBezier2MaxDeviation(r,this.m_maxDeviation)),!i&&this.m_maxAngle>0&&(i=!bi.checkBezier2MaxAngle(r,this.m_cosMaxAngle)),i}ellipticArcNeedsSplit(t,e,s,n){t.cutArcIgnoreAttributes(s,n,e);let i=!1;return this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength?(i=!0,!0):(!i&&this.m_maxDeviation>0&&(i=!bi.checkEllipticArcMaxDeviation(e,this.m_maxDeviation)),!i&&this.m_maxAngle>0&&(i=!bi.checkEllipticArcMaxAngle(e,this.m_cosMaxAngle)),i)}bezierNeedsSplit(t){let e=!1;return this.m_maxLength>0&&o.P.distance(t[0],t[1])+o.P.distance(t[1],t[2])+o.P.distance(t[2],t[3])>this.m_maxLength?(e=!0,!0):(!e&&this.m_maxDeviation>0&&(e=!bi.checkBezierMaxDeviation(t,this.m_maxDeviation)),!e&&this.m_maxAngle>0&&(e=!bi.checkBezierMaxAngle(t,this.m_cosMaxAngle)),e)}progress_(){}static checkBezierMaxDeviation(t,e){const s=t[3].sub(t[0]);if(s.sqrLength()>0){const n=s.clone();n.leftPerpendicularThis(),n.normalize();const i=n.dotProduct(t[0].sub(t[1])),r=n.dotProduct(t[0].sub(t[2]));if(Math.max(Math.abs(i),Math.abs(r))<=e){const e=new o.P;bn(t,.5,e,!1);const n=e.sub(t[0]).dotProduct(s);return n>=0&&n<=s.sqrLength()}return!1}return Math.max(t[0].sub(t[1]).sqrLength(),t[0].sub(t[2]).sqrLength())<=e*e}static checkBezierMaxAngle(t,e){if(t[0].equals(t[3]))return!(!t[0].equals(t[1])||!t[1].equals(t[2]));const s=t[3].sub(t[0]);s.normalize();{const n=t[1].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}{const n=t[2].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}{const n=t[2].sub(t[1]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}return!0}static checkRationalBezier2MaxDeviation(t,e,s){if(0===e[1])return!1;const n=t[2].sub(t[0]);if(n.sqrLength()>0){const e=n.clone();e.leftPerpendicularThis(),e.normalize();const i=e.dotProduct(t[0].sub(t[1]));if(Math.abs(i)<=s){const e=t[1].sub(t[0]).dotProduct(n);return e>=0&&e<=n.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=s*s}static checkRationalBezier2MaxAngle(t,e,s){if(0===e[1])return!1;if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const n=t[2].sub(t[0]);n.normalize();{const e=t[1].sub(t[0]),i=e.dotProduct(n);if(i<0)return!1;if(e.length()*s>i)return!1}return!0}static checkBezier2MaxDeviation(t,e){const s=t[2].sub(t[0]);if(s.sqrLength()>0){const n=s.clone();n.leftPerpendicularThis(),n.normalize();const i=n.dotProduct(t[0].sub(t[1]));if(Math.abs(i)<=e){const e=t[1].sub(t[0]).dotProduct(s);return e>=0&&e<=s.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=e*e}static checkBezier2MaxAngle(t,e){if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const s=t[2].sub(t[0]);s.normalize();{const n=t[1].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}return!0}static checkEllipticArcMaxDeviation(t,e){if(Math.abs(t.getSweepAngle())<Math.PI){const s=t.getEndXY().sub(t.getStartXY()),n=[0,0];if(1===function(t,e,s){(0,i.g)(!Zi(t));const n=new h.T;n.setRotateAngle(-t.getAxisXRotation());const r=new o.P;n.queryTransform(e,r);const a=Math.atan2(-r.x*t.getMinorMajorRatio(),r.y),m=a+(0,o.a5)();let l=Hi(t,a),u=Hi(t,m);u<l&&(u=(0,o.b)(l,l=u));let c=0;return l>=0&&l<=1&&(s[c++]=l),u>=0&&u<=1&&(s[c++]=u),c}(t,s,n)){const s=t.getCoord2D(n[0]),i=o.P.getClosestCoordinate(t.getStartXY(),t.getEndXY(),s),r=new o.P;return(0,o.Z)(t.getStartXY(),t.getEndXY(),i,r),o.P.distance(s,r)<=e}}const s=t.getCoord2D(.5),n=new o.P;return(0,o.Z)(t.getEndXY(),t.getStartXY(),.5,n),o.P.distance(s,n)<=e}static checkEllipticArcMaxAngle(t,e){const s=t.getTangent(0),n=t.getTangent(1),i=s.dotProduct(n);return!(i<0)&&!(s.length()*n.length()*e>i)}static checkTypeForReplace(t,e){return t.getGeometryType()===e&&(e!==i.G.enumEllipticArc||t.isCircular())}}function Ii(t,e,s){const n=s.length;if(e<=0||n<=2)return n;let i=0;const r=(0,o.d)(n-1,Number.NaN);for(let o=1,a=n;o<a;o++){const e=t.tToLength(s[o]);r[o-1]=e-i,i=e}for(;r.length>1;){const t=r.findIndex((t=>t<=2*e));if(-1===t)break;let n=t+1,i=t+1;if(t>0){const e=t-1;(i===r.length||r[e]>r[i])&&(i=e,n--)}r[i]+=r[t],r.splice(t,1),s.splice(n,1)}return s.length}function wi(t,e,s,n,i){const o=[],a=[],h=Si(e,s,0,n,!1,o,a),m=new $s;let l=i;const u=e.getDescription();m.assignVertexDescription(u);const c=u.getAttributeCount()>1,g=new r.P,d=new $r;for(let r=0,_=0;r<h;r++){if(o[_+1].isNAN()){if(c){let t=a[r];e.queryCoord(t,g),d.setStart(g),t=a[r+1],e.queryCoord(t,g),d.setEnd(g)}d.setStartXY(o[_]),d.setEndXY(o[_+3]),t.addSegment(d,l)}else{if(c){let t=a[r];e.queryCoord(t,g),m.setStart(g),t=a[r+1],e.queryCoord(t,g),m.setEnd(g)}m.setStartXY(o[_]),m.setControlPoint1(o[_+1]),m.setControlPoint2(o[_+2]),m.setEndXY(o[_+3]),t.addSegment(m,l)}_+=3,l=!1}}function Di(t,e,s,n,a){const h=[],m=[],l=function(t,e,s,n,r,a,h){a.length=0,h.length=0;const m=t.getGeometryType();if(m===i.G.enumLine)return a.push(t.getStartXY()),a.push(o.P.getNAN()),a.push(t.getEndXY()),h.push(0),h.push(1),1;if(m===i.G.enumBezier2){const e=(0,o.d)(9,Number.NaN);let n=t.getMonotonicPartParams(e.length,e);e.length=n,n=Ii(t,s,e),h.splice(0,0,...e.slice(0,n));{const s=new to;for(let i=1;i<n;i++){const n=e[i-1],r=e[i];t.queryCut(n,r,s,!0);const o=s.get();Xs(o),1===i&&a.push(o.getStartXY()),a.push(o.getControlPoint1()),a.push(o.getEndXY())}}return n-1}if(m===i.G.enumEllipticArc){const i=t;if(i.isDegenerateToLine()||i.isDegenerate(0))return a.push(t.getStartXY()),a.push(o.P.getNAN()),a.push(t.getEndXY()),h.push(0),h.push(1),1;if(!i.isMonotoneQuickAndDirty()){const n=(0,o.d)(6,Number.NaN);let r=i.getMonotonicPartParams(n.length,n);n.length=r,r=Ii(t,s,n);let m=0;if(r>2){const t=new to,o=h;for(let l=1;l<r;l++){const u=n[l-1],c=n[l];i.queryCut(u,c,t,!0);const g=o.length;m+=Gi(1===l,t.get(),e,s,!1,a,h);const d=l===r-1,_=n[l-1],p=t.get().getSweepAngle()/i.getSweepAngle();for(let t=g,e=o.length;t<e;t++){o[t]=!d||t+1<e?_+o[t]*p:1;{const e=2*t,s=i.getCoord2D(o[t]);a[e].setCoordsPoint2D(s),e>0&&ks(a.slice(e-2))}}}return m}}return Ti(!0,i,e,s,n,a,h)}if(m===i.G.enumBezier){const i=t;if(!i.isMonotoneQuickAndDirty()){const n=(0,o.d)(6,Number.NaN);let r=i.getMonotonicPartParams(n.length,n);n.length=r,r=Ii(t,s,n);let m=0;if(r>2){const t=new to,o=h;for(let l=1;l<r;l++){const u=n[l-1],c=n[l];i.queryCut(u,c,t,!0);const g=o.length;m+=Mi(1===l,t.get(),e,s,!1,a,h);const d=l===r-1,_=n[l-1];for(let t=g,e=o.length;t<e;t++){o[t]=!d||t+1<e?_+o[t]:1;{const e=2*t,s=i.getCoord2D(o[t]);a[e].setCoordsPoint2D(s),e>0&&ks(a.slice(e-2))}}}return m}}return Mi(!0,i,e,s,n,a,h)}if(m===i.G.enumRationalBezier2){const i=t;if(!i.isMonotoneQuickAndDirty()){const n=(0,o.d)(6,Number.NaN);let r=i.getMonotonicPartParams(n.length,n);n.length=r,r=Ii(t,s,n);let m=0;if(r>2){const t=new to,o=h;for(let l=1;l<r;l++){const u=n[l-1],c=n[l];i.queryCut(u,c,t,!0);const g=o.length;m+=Ni(1===l,t.get(),e,s,!1,a,h);const d=l===r-1,_=n[l-1];for(let t=g,e=o.length;t<e;t++){o[t]=!d||t+1<e?_+o[t]:1;{const e=2*t,s=i.getCoord2D(o[t]);a[e].setCoordsPoint2D(s),e>0&&ks(a.slice(e-2))}}}return m}}return Ni(!0,i,e,s,n,a,h)}(0,i.b)("")}(e,s,0,n,0,h,m),u=new Ht;let c=a;const g=e.getDescription();u.assignVertexDescription(g);const d=g.getAttributeCount()>1,_=new r.P,p=new $r;for(let i=0,r=0;i<l;i++){if(h[r+1].isNAN()){if(d){let t=m[i];e.queryCoord(t,_),p.setStart(_),t=m[i+1],e.queryCoord(t,_),p.setEnd(_)}p.setStartXY(h[r]),p.setEndXY(h[r+2]),t.addSegment(p,c)}else{if(d){let t=m[i];e.queryCoord(t,_),u.setStart(_),t=m[i+1],e.queryCoord(t,_),u.setEnd(_)}u.setStartXY(h[r]),u.setControlPoint1(h[r+1]),u.setEndXY(h[r+2]),t.addSegment(u,c)}r+=2,c=!1}}function Ti(t,e,s,n,i,r,m,l){const u=e.clone();u.dropAllAttributes();const c=(t,e,s,n)=>(e&&(t&&e.push(n.getStartXY()),e.push(o.P.getNAN()),e.push(o.P.getNAN()),e.push(n.getEndXY())),s&&(t&&s.push(0),s.push(1)),1);if(u.isDegenerateToLine()||u.isDegenerate(0))return c(t,r,m,e);const g=u.getStartXY(),d=u.getEndXY(),_=u.getSemiAxes(),p=new h.T;if(u.isCircular())p.setIdentity();else{const t=u.getAxisXRotation();p.setScaleCoords(1,u.getMinorMajorRatio()),p.rotateAngle(t)}const f=u.getCenter();p.shift(f);const P=p.clone();P.invertThis(),u.applyTransformation(P);const x=u.getSweepAngle();if(0===x)return c(t,r,m,e);const y=a.Envelope2D.constructEmpty();y.setCoords({center:f,width:2*_.x,height:2*_.x});const E=.05*y.calculateToleranceFromEnvelope(),C=Math.max(s/_.x,E/_.x);let S=4*Math.pow(C/.0741,1/6);S=Math.min(S,Math.PI/2);const v=ui(u.getStartAngle());let b=x>0?Math.floor(v/S):Math.ceil(v/S);b*=S;const I=x>0?S:-S;b+I===v&&(b+=I);let w=4/3*Math.tan(Math.abs(S)/4);x>0&&(w=-w),m&&t&&m.push(0);const D=S/Math.abs(x);let T=(b-v)/x;const N=g.clone(),A=new o.P;u.queryCoord2D(0,A);const G=A.clone(),M=1-.01*D;let F=0,q=0;for(;T<1;){let s;if(T+=D,q>0&&T<M)s=w;else{T>=M&&(T=1);const t=(T-q)*x;s=4/3*Math.tan(Math.abs(t)/4),x>0&&(s=-s)}u.queryCoord2D(T,A);const a=new o.P;p.queryTransform(A,a);const h=e.getClosestCoordinate(a,!1);if(e.queryCoord2D(h,a),1!==T&&(o.P.distance(N,a)<=2*n||o.P.distance(a,d)<=2*n))continue;N.setCoordsPoint2D(a);const l=(0,o.m)(o.P,4);l[0].assign(G),l[3].assign(A),l[1].rightPerpendicularOther(G),l[1].scaleAddThis(s,G),l[2].leftPerpendicularOther(A),l[2].scaleAddThis(s,A),p.transformPoints2D(l,3,l),l[3].assign(a),0===q&&l[0].setCoordsPoint2D(g),1===T&&l[3].setCoordsPoint2D(d),i&&En(l);let c=!0;for(let t=1;t<4;t++)if(!l[t].isEqualPoint2D(l[0])){c=!1;break}c||(m&&m.push(h),r&&(0===q&&t&&r.push(l[0].clone()),r.push(l[1].clone()),r.push(l[2].clone()),r.push(l[3].clone())),F++),q=T,G.setCoordsPoint2D(A)}return F}function Ni(t,e,s,n,i,r,h,m){e.clone().dropAllAttributes();const l=new a.Envelope2D;e.queryLooseEnvelope(l);const u=.05*l.calculateToleranceFromEnvelope(),c=Math.max(s,u);t&&h.push(0);let g=0;const d=(0,o.m)(o.P,3);e.queryControlPoints(d);const _=[0,0,0];e.queryWeights(_);const p=[],f=(0,o.d)(9,Number.NaN);let P=e.getMonotonicPartParams(f.length,f);f.length=P,P=Ii(e,n,f);let x=0,y=t;for(let a=1;a<P;a++){const t=f[a];for(p.push(x),p.push(t);p.length>1;){const t=p.at(-1);p.pop();const e=p.at(-1),s=(0,o.m)(o.P,3);Qe(d,_,t,e,s,[0,0,0]);const n=(0,o.m)(o.P,3),i=Ks(s,_,n),a=16,m=p.length>a;c>=i||m?(h.push(e),y&&(r.push(n[0]),y=!1),r.push(n[1]),r.push(n[2]),g++):(p.push(.5*(t+e)),p.push(t))}x=t}return g}function Ai(t,e,s,n,i,r,h,m){e.clone().dropAllAttributes();const l=new a.Envelope2D;e.queryLooseEnvelope(l);const u=.05*l.calculateToleranceFromEnvelope(),c=Math.max(s,u);h&&t&&h.push(0);let g=0;const d=(0,o.m)(o.P,3);e.queryControlPoints(d);const _=[0,0,0];e.queryWeights(_);const p=[],f=(0,o.d)(9,Number.NaN);let P=0;i?(P=e.getMonotonicPartParams(f.length,f),f.length=P,P=Ii(e,n,f)):(f.length=2,P=2,f[0]=0,f[1]=1);let x=0,y=t;for(let a=1;a<P;a++){const t=f[a];for(p.length=0,p.push(t),p.push(x);p.length>1;){const t=p.at(-1);p.pop();const e=p.at(-1),s=(0,o.m)(o.P,3),n=[0,0,0];Qe(d,_,t,e,s,n);const i=(0,o.m)(o.P,4),a=Ke(s,n,i),m=16,l=p.length>m;c>=a||l?(h.push(e),r&&(y&&(r.push(i[0]),y=!1),r.push(i[1]),r.push(i[2]),r.push(i[3])),g++):(p.push(.5*(t+e)),p.push(t))}x=t}return g}function Gi(t,e,s,n,i,r,m,l){const u=e.clone();if(u.dropAllAttributes(),u.isDegenerateToLine()||0===u.getSweepAngle())return t&&r.push(e.getStartXY()),r.push(o.P.getNAN()),r.push(e.getEndXY()),t&&m.push(0),m.push(1),1;const c=u.getStartXY(),g=u.getEndXY(),d=u.getSemiAxes(),_=new h.T;if(u.isCircular())_.setIdentity();else{const t=u.getAxisXRotation();_.setScaleCoords(1,u.getMinorMajorRatio()),_.rotateAngle(t)}const p=u.getCenter();_.shift(p);const f=_.clone();f.invertThis(),u.applyTransformation(f);const P=a.Envelope2D.constructEmpty();P.setCoords({center:p,width:2*d.x,height:2*d.x});const x=.05*P.calculateToleranceFromEnvelope(),y=Math.max(s/d.x,x/d.x),E=Math.sqrt(2*y+y*y);let C=2*Math.sqrt(2*E*(1+y-E));C=Math.min(C,Math.PI/2);const S=u.getSweepAngle(),v=Math.ceil(Math.abs(S)/C),b=Math.max(v,1);C=S/b;const I=1/b;let w=Math.tan(Math.abs(C)/2);S>0&&(w=-w),t&&m.push(0);const D=new o.P;u.queryCoord2D(0,D);for(let a=0;a<b;a++){const e=D.clone(),s=(a+1)*I;m.push(s),u.queryCoord2D(s,D);const n=(0,o.m)(o.P,3);n[0].assign(e),n[2].assign(D),n[1].rightPerpendicularOther(n[0]),n[1].mulThis(w),n[1].addThis(n[0]),_.transformPoints2D(n,3,n),0===a&&n[0].setCoordsPoint2D(c),a===b-1&&n[2].setCoordsPoint2D(g),0===a&&t&&r.push(n[0]),r.push(n[1]),r.push(n[2])}return b}function Mi(t,e,s,n,i,r,h,m){e.clone().dropAllAttributes();const l=new a.Envelope2D;e.queryLooseEnvelope(l);const u=.05*l.calculateToleranceFromEnvelope(),c=Math.max(s,u);t&&h.push(0);let g=0;const d=(0,o.m)(o.P,4);e.queryControlPoints(d);const _=[],p=(0,o.d)(9,Number.NaN);let f=e.getMonotonicPartParams(p.length,p);p.length=f,f=Ii(e,n,p);let P=0,x=t;for(let a=1;a<f;a++){const t=p[a];for(_.push(P),_.push(t);_.length>1;){const t=_.at(-1);_.pop();const e=_.at(-1),s=(0,o.m)(o.P,4);vn(d,t,e,s);const n=(0,o.m)(o.P,3),i=Qs(s,n),a=16,m=_.length>a;c>=i||m?(h.push(e),x&&(r.push(n[0]),x=!1),r.push(n[1]),r.push(n[2]),g++):(_.push(.5*(t+e)),_.push(t))}P=t}return g}class Fi{constructor(t,e){this.m_arc=t,this.m_sqrChordLength=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?o.P.sqrDistance(this.m_arc.getCoord2D(e),this.m_arc.getCoord2D(1-e))-this.m_sqrChordLength:0}getError(t){return 0}}function qi(t,e){return t.convertToCanonic(e)}function Vi(t,e,s,n){let i=t.m_startAngle,r=t.m_sweepAngle;const a=1e-12;for(;i>(0,o.a5)();)i-=2*(0,o.a5)();for(;i<=-(0,o.a5)();)i+=2*(0,o.a5)();if(!Number.isNaN(e)){for(;e>(0,o.a5)();)e-=2*(0,o.a5)();for(;e<=-(0,o.a5)();)e+=2*(0,o.a5)();!s&&e>i&&(e-=2*(0,o.a5)()),s&&e<i&&(e+=2*(0,o.a5)()),r=e-i,Math.abs(r)<a&&!n&&(r=s?2*(0,o.a5)():-2*(0,o.a5)()),Math.abs(r)>2*(0,o.a5)()-a&&n&&(r=0)}Math.abs(r)>2*(0,o.a5)()-a&&(r=r>=0?2*(0,o.a5)():-2*(0,o.a5)(),t.setEndXY(t.getStartXY())),Math.abs(r)<a&&(r=0,t.setEndXY(t.getStartXY())),n=Math.abs(r)<=(0,o.a5)(),r&&(s=r>0),t.m_startAngle=Yi(i),t.m_sweepAngle=r,ir(t,!n),sr(t,s)}function Yi(t){let e=t,s=!1;return e<=-(0,o.a5)()?(e+=(0,o.a8)(),s=!0):e>(0,o.a5)()&&(e-=(0,o.a8)(),s=!0),e<=-(0,o.a5)()?(e=(0,o.o)(e,(0,o.a8)()),e<=-(0,o.a5)()&&(e+=(0,o.a8)()),s=!0):e>(0,o.a5)()&&(e=(0,o.o)(e,(0,o.a8)()),e>(0,o.a5)()&&(e-=(0,o.a8)()),s=!0),s&&(e>(0,o.a5)()||e<=-(0,o.a5)())&&(e=(0,o.a5)()),e}function Xi(t,e,s){const n=s,i=n.getSemiAxes();let r=new o.P(i.x*Math.cos(t[0]),i.y*Math.sin(t[0]));return r=n.convertFromCanonic(r),o.P.sqrDistance(r,n.getStartXY())}function ki(t,e,s){const n=s,i=n.getSemiAxes(),r=t[0]+n.getStartAngle();let a=new o.P(i.x*Math.cos(r),i.y*Math.sin(r));return a=n.convertFromCanonic(a),o.P.sqrDistance(a,n.getEndXY())}function Ri(t){if(t.m_center.isNAN())return t.m_startAngle=0,void(t.m_sweepAngle=0);const e=t.getStartXY(),s=t.getEndXY(),n=e.equals(s),i=rr(t),r=nr(t),a=t.projectionBehavior();if(n){const s=t.convertToCanonic(e),n=new o.P(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);s.x/=n.x,s.y/=n.y,t.m_startAngle=Yi(Math.atan2(s.y,s.x)),t.m_sweepAngle=i?r?(0,o.a8)():-(0,o.a8)():0}else{const n=t.convertToCanonic(e),h=new o.P(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);n.x/=h.x,n.y/=h.y;const m=t.convertToCanonic(s);m.x/=h.x,m.y/=h.y,t.m_startAngle=Math.atan2(n.y,n.x),t.m_sweepAngle=o.P.calculateAngle(n,m),r?t.m_sweepAngle<0&&(t.m_sweepAngle+=(0,o.a8)()):t.m_sweepAngle>0&&(t.m_sweepAngle-=(0,o.a8)()),t.m_startAngle=Yi(t.m_startAngle);let l=Xi([t.m_startAngle],0,t);if(l=Math.sqrt(l),l>.25*B(t)){const e=t.m_startAngle-1e-4,s=t.m_startAngle+1e-4,n=[0];bt(Xi,t,1,[t.m_startAngle],[e],[s],0,n),t.m_startAngle=Yi(n[0])}if(l=ki([t.m_sweepAngle],0,t),l=Math.sqrt(l),l>.25*B(t)){const e=t.m_sweepAngle-1e-4,s=t.m_sweepAngle+1e-4,n=[0];bt(ki,t,1,[t.m_sweepAngle],[e],[s],0,n),t.m_sweepAngle=n[0]}const u=Math.abs(t.m_sweepAngle)>(0,o.a5)();if(ir(t,u),i!==u&&!i&&Math.abs(t.m_sweepAngle)>1.5*(0,o.a5)())return void ji(t,e,s,a);if(0===t.m_sweepAngle||r!==t.m_sweepAngle>0)return void ji(t,e,s,a)}}function Hi(t,e){return(function(t,e){const s=new o.E(t.getStartAngle(),t.getEndAngle());s.normalize();const n=(0,o.a8)(),i=(0,o.o)(e,n);if(i<s.vmin){let t=i+n;for(;t<s.vmin;)t+=n;return s.containsCoordinate(t)?t:s.vmin-i<t-s.vmax?i:t}if(i>s.vmax){let t=i-n;for(;t>s.vmax;)t-=n;return s.containsCoordinate(t)||s.vmin-t<i-s.vmax?t:i}return i}(t,e)-t.getStartAngle())/t.getSweepAngle()}function Li(t,e){return t.m_startAngle+e*t.m_sweepAngle}function Bi(t,e,s){s.assign(new o.F(t.m_startAngle).addE(e.mulE(new o.F(t.m_sweepAngle))))}function Ui(t){return t.m_cachedValues}function zi(t){if(t.m_cachedValues)return t.m_cachedValues;const e={e2:0,completeE:0};return e.e2=function(t){return 1-(0,o.s)(t.m_minorMajorRatio)}(t),e.completeE=(0,o.ah)(e.e2),t.m_cachedValues=e,e}function Oi(t,e,s,n){if(!e.isEqual(t.m_XStart,t.m_YStart)||!s.isEqual(t.m_XEnd,t.m_YEnd)){if(Zi(t))return t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,dr(t),void t.afterCompletedModification();if(n&&Math.abs(t.getSweepAngle())<=1.01*(0,o.a7)()){const n=(0,o.m)(o.P,3),i=mr(t,n);if(Oe(n)){if(n[0].assign(e),n[2].assign(s),je(n),0===t.projectionBehavior()){let e=0,s=2;o.P.sqrDistance(n[1],n[0])<o.P.sqrDistance(n[1],n[2])&&(s=(0,o.b)(e,e=s));const i=n[s].sub(n[e]),r=i.length();i.divThis(r);const a=n[1].sub(n[e]),h=a.length(),m=a.dotProduct(i)/h,l=a.crossProduct(i)/h,u=new o.P;(0,o.Z)(n[e],n[s],.5,u);const c=.5*r/l*(0,o.c)(1-m,0,1),g=n[1].side(n[e],n[s]),d=i.clone();g?d.leftPerpendicularThis():d.rightPerpendicularThis();const _=u.sub(d.mul(c));t.constructCircularArcThreePoint(n[0],n[2],_)}else lr(n,i*i,null,!1,t);return}}0===t.projectionBehavior()?function(t,e,s){const n=t.getStartXY(),i=t.getEndXY(),r=n.equals(i),a=e.equals(s);if(!r&&!a){const r=new h.T;r.setShiftCoords(-t.m_XStart,-t.m_YStart);const a=o.P.distance(e,s),m=o.P.distance(n,i),l=a/m;r.scale(l,l);const u=i.sub(n);u.divThis(m);const c=s.sub(e);c.divThis(a);const g=u.crossProduct(c),d=c.dotProduct(u);return r.rotate(d,g),r.shiftCoords(e.x,e.y),Ji(t,r,!0),t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,void(t.m_YEnd=s.y)}const m=new o.P;if(t.queryCoord2D(.5,m),a){if(r){const i=t.m_center.add(e.sub(n));t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),1,0,!0,!t.isClockwise(),i),t.setProjectionBehavior(0)}else if(t.isMajor()){const n=m.sub(e).getUnitVector().mul(2*t.getSemiMajorAxis()).add(e);t.constructCircularArcThreePoint(e,s,n)}else t.constructCircularArcThreePoint(e,s,e);return}const l=e.add(s).mul(.5),u=s.sub(e);u.rightPerpendicularThis();const c=l.add(u),g=o.P.getClosestCoordinate(l,c,t.getCenter(),!0),d=new o.P;(0,o.Z)(l,c,g,d);const _=o.P.distance(e,d);t.constructEllipticArcEndPointsCenter(e,s,_,1,0,!0,!t.isClockwise(),d),t.setProjectionBehavior(0)}(t,e,s):Er(t,e,s)}}function Wi(t,e,s,n,i,r,o,a,h){return t.m_bits=0,t.m_rotation=r,G(t,e),F(t,s),t.m_cosr=Math.cos(r),t.m_sinr=Math.sin(r),ir(t,o),sr(t,a),void 0!==h?t.m_center.assign(h):t.m_center.setNAN(),t.setProjectionBehavior(1),t.m_semiMajorAxis=n,t.m_minorMajorRatio=i,hr(t,void 0===h)}function ji(t,e,s,n){t.m_bits=0,t.m_rotation=0,G(t,e),F(t,s),t.m_interior.assign(e.add(s).mul(.5)),t.m_startAngle=0,t.m_sweepAngle=0,t.m_cosr=1,t.m_sinr=0,ir(t,!1),sr(t,!1),t.m_center.setNAN(),t.m_semiMajorAxis=1,t.m_minorMajorRatio=0,t.setProjectionBehavior(n),t.afterCompletedModification()}function Zi(t){return t.m_center.isNAN()}function Qi(t,e){if(0===e)return 0;const s=zi(t),n=Li(t,e),i=(0,o.a7)(),r=Ki(t),a=(0,o.a9)(n+i,s.e2,s.completeE),h=t.m_semiMajorAxis*(a-r);return Math.abs(h)}function Ki(t){const e=zi(t);return(0,o.a9)(t.getStartAngle()+(0,o.a7)(),e.e2,e.completeE)}function Ji(t,e,s){if(2===e.m_TransformationType)return void(0,i.g)(0);if((0,i.g)(!or(t)),e.isIdentity())return;er(t);const n=o.P.getNAN();n.x=t.m_XStart,n.y=t.m_YStart,e.transformInPlace(n);const r=o.P.getNAN();if(r.x=t.m_XEnd,r.y=t.m_YEnd,e.transformInPlace(r),Zi(t))return t.m_XStart=n.x,t.m_YStart=n.y,t.m_XEnd=r.x,void(t.m_YEnd=r.y);const a=t.m_center.clone();if(e.transformInPlace(a),s||e.isUniformNoRotation()){let s=nr(t);if(e.isReflective()&&(s=!s),0===t.projectionBehavior()){if(!n.equals(r)){const s=t.m_interior.clone();return e.transformInPlace(s),void t.constructCircularArcThreePoint(n,r,s)}return void $i(t,n,r,a,s,!1)}const i=new o.P(t.m_cosr,t.m_sinr);e.transformWithoutTranslateInPlace(i);const h=Math.atan2(i.y,i.x),m=t.getSemiAxes();e.transformWithoutTranslateInPlace(m);const l=t.m_center.clone();return e.transformInPlace(l),void t.constructEllipticArcEndPointsCenter(n,r,m.x,m.y/m.x,h,t.isMajor(),s,l)}{{const s=new Array(4);!function(t,e){const s=new o.F(t.m_cosr).sqrThis(),n=new o.F(t.m_sinr).sqrThis(),i=new o.F(t.m_minorMajorRatio),r=new o.F(1/t.m_minorMajorRatio),a=i.mulE(s).addThisE(r.mulE(n)),h=i.subE(r).mulThis(2*t.m_cosr*t.m_sinr),m=i.mulE(n).addThisE(r.mulE(s));e[0]=a,e[1]=h,e[2]=m,e[3]=new o.F(-t.m_semiMajorAxis).mulThis(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio)}(t,s);const i=new b;if(i.a11.setE(s[0]),i.a12.setE(s[1]),i.a12.mulThisByPower2(.5),i.a21.setE(i.a12),i.a22.setE(s[2]),!i.det().isZero()){const h=new b;if(h.a11.set(e.xx),h.a12.set(e.xy),h.a21.set(e.yx),h.a22.set(e.yy),h.invertThis()){const m=h.clone();m.transposeThis();const l=i.clone();if(l.mulThis(h),l.mulLeftThis(m),!l.det().isZero()){const i=(0,o.m)(o.F,4);i[0].setE(l.a11),i[1].setE(l.a12),i[1].mulThisByPower2(2),i[2].setE(l.a22),i[3].setE(s[3]);const h=o.P.getNAN(),m=function(t,e){const s=new b;s.a11.setE(t[0]),s.a12=o.F.st_mulByPower2(t[1],.5),s.a21.setE(s.a12),s.a22.setE(t[2]);const n=[o.P.getNAN(),o.P.getNAN()],i=[new o.F,new o.F];s.eigenSymmetric(i,n);const r=t[3].clone();return r.negateThis(),r.invThis(),i[0].mulThisE(r),i[1].mulThisE(r),i[0].sqrtThis().invThis(),i[1].sqrtThis().invThis(),e.x=i[0].toDouble(),e.y=i[1].toDouble(),Math.atan2(n[0].y,n[0].x)}(i,h);let u=nr(t);return e.isReflective()&&(u=!u),void t.constructEllipticArcEndPointsCenter(n,r,h.x,h.y/h.x,m,t.isMajor(),u,a)}}}}const s=[o.P.getNAN(),o.P.getNAN(),o.P.getNAN()];s[0].setCoords(t.getSemiMajorAxis(),0),s[0].rotateDirect(t.m_cosr,t.m_sinr),s[1].setCoords(t.getSemiMajorAxis(),t.getSemiMinorAxis()),s[1].rotateDirect(t.m_cosr,t.m_sinr),s[2].setCoords(0,t.getSemiMinorAxis()),s[2].rotateDirect(t.m_cosr,t.m_sinr);let i=t.isClockwise();i&&(s[2]=(0,o.b)(s[0],s[0]=s[2]));const h=.5;e.transformWithoutTranslateArray(s,3,s),e.isReflective()&&(i=!i);const m=new o.P(0,0),l=t.createInstance();lr(s,h,m,!1,l),t.constructEllipticArcEndPointsCenter(n,r,l.getSemiMajorAxis(),l.getMinorMajorRatio(),l.getAxisXRotation(),t.isMajor(),!i,a)}}function $i(t,e,s,n,i,r){const o=.5*(n.sub(e).length()+n.sub(s).length());t.m_center.assign(n),t.m_startAngle=Math.atan2(e.y-t.m_center.y,e.x-t.m_center.x),Vi(t,Math.atan2(s.y-t.m_center.y,s.x-t.m_center.x),i,r);const a=t.constructEllipticArcEndPointsCenter(e,s,o,1,0,Math.abs(t.m_sweepAngle)>Math.PI,t.m_sweepAngle>0,n);return t.setProjectionBehavior(0),a}function tr(t,e){t.m_cachedValues=e}function er(t){t.m_cachedValues=null}function sr(t,e){const s=e?1:0;t.m_bits=-2&t.m_bits|s}function nr(t){return!!(1&t.m_bits)}function ir(t,e){const s=e?1:0;t.m_bits=-3&t.m_bits|s<<1}function rr(t){return!!(2&t.m_bits)}function or(t){return!!(8&t.m_bits)}function ar(t){t.m_bits&=-9}function hr(t,e){ar(t);const s=t.getStartXY(),n=t.getEndXY();let r=!1;const a=rr(t),h=nr(t),m=t.projectionBehavior(),l=s.equals(n);let u=0===t.m_minorMajorRatio||0===t.m_semiMajorAxis;if(Number.isNaN(t.m_minorMajorRatio)&&(0===t.m_semiMajorAxis?t.m_minorMajorRatio=1:(0,i.k)("NAN minor major ratio and non-zero major axis")),u||(u=e?l:t.m_center.isNAN()),u)return ji(t,s,n,m),!0;t.m_semiMajorAxis=Math.abs(t.m_semiMajorAxis),t.m_minorMajorRatio=Math.abs(t.m_minorMajorRatio),t.m_minorMajorRatio>1&&(t.m_semiMajorAxis*=t.m_minorMajorRatio,t.m_minorMajorRatio=1/t.m_minorMajorRatio);const c=new o.P(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);if(l){const e=t.convertToCanonic(s);e.x/=c.x,e.y/=c.y;const n=Math.sqrt((0,o.s)(e.x)+(0,o.s)(e.y));if(r=1!==n,t.m_semiMajorAxis*=n,c.mulThis(n),t.m_startAngle=Yi(Math.atan2(e.y,e.x)),!a)return t.m_interior.assign(s),t.m_sweepAngle=0,t.afterCompletedModification(),r;t.m_sweepAngle=h?(0,o.a8)():-(0,o.a8)()}else{let e=t.m_center.isNAN()||function(t){if(t.m_center.isNAN())return!1;const e=new v;e.setWithEps(t.getStartXY(),8),e.subThisE((new v).setWithEps(t.m_center,8));const s=new o.F;s.setWithEps(t.m_rotation,8);const n=new o.F,i=new o.F;o.F.st_cosAndSin(s,n,i),e.rotateReverse(n,i);const r=new v;r.setWithEps(t.getEndXY()),r.subThisE(v.constructPoint2D(t.m_center)),r.rotateReverse(n,i);const a=new o.F;a.setWithEps(t.m_semiMajorAxis,8);const h=a.clone(),m=new o.F;m.setWithEps(t.m_minorMajorRatio),h.mulThisE(m),e.x.divThisE(a),e.y.divThisE(h),r.x.divThisE(a),r.y.divThisE(h);const l=e.x.sqr().addThisE(e.y.sqr()).subThisE(o.G),u=r.x.sqr().addThisE(r.y.sqr()).subThisE(o.G);return!l.isZero()||!u.isZero()}(t);if(!e){const i=t.convertToCanonic(s);i.x/=c.x,i.y/=c.y;const r=new o.P(1,0);t.m_startAngle=o.P.calculateAngle(r,i);const a=t.convertToCanonic(n);a.x/=c.x,a.y/=c.y,t.m_sweepAngle=o.P.calculateAngle(i,a),e=!cr(t)}if(e){r=!0;const e=s.sub(n).mulThis(.5);e.rotateReverse(t.m_cosr,t.m_sinr);let i=(0,o.s)(e.x/c.x)+(0,o.s)(e.y/c.y);i>1&&(i=Math.sqrt(i),t.m_semiMajorAxis*=i,c.mulThis(i));const m=new o.P(0,0);{const t=c.x*c.x,s=c.y*c.y,n=t*e.y*e.y+s*e.x*e.x,i=t*s-n;if(i>0){const t=Math.sqrt(i/n);m.setCoords(c.x*e.y/c.y,-c.y*e.x/c.x),m.mulThis(t),a===h&&m.negateThis()}}{const e=new o.P(m.x,m.y);e.rotateDirect(t.m_cosr,t.m_sinr),e.addThis(s.add(n).mulThis(.5)),t.m_center.assign(e)}}if(Ri(t),!cr(t))return ji(t,s,n,m),!0}return dr(t),t.afterCompletedModification(),r}function mr(t,e){(0,i.g)(Math.abs(t.getSweepAngle())<15*Math.PI/16);const s=t.getSemiMajorAxis(),n=t.getSemiMinorAxis();let r;if(0===s)return e[0].setCoordsPoint2D(t.getStartXY()),e[1].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getStartXY()),r=1,r;if(0===n)return e[0].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getEndXY()),e[1]=o.P.lerp(e[0],e[2],.5),r=1,r;const a=t.getSweepAngle(),h=t.getStartAngle(),m=h+a,l=new o.P(-s*Math.sin(h),n*Math.cos(h)),u=new o.P(-s*Math.sin(m),n*Math.cos(m));l.normalize(),u.normalize(),l.rotateDirect(t.m_cosr,t.m_sinr),u.rotateDirect(t.m_cosr,t.m_sinr),e[0].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getEndXY()),e[1].setSub(e[2],e[0]);const c=l.crossProduct(u);return e[1].assign(l.mul(e[1].crossProduct(u)/c)),e[1].addThis(e[0]),r=Math.cos(.5*a),r}function lr(t,e,s,n,r){if(n){const s=.5,n=Math.sqrt(e),i=(0,o.s)(1-s)+2*n*s*(1-s)+(0,o.s)(s),a=t[0].mul((0,o.s)(1-s)).add(t[1].mul(2*n*s*(1-s))).add(t[2].mul((0,o.s)(s))).divThis(i);return r.constructCircularArcThreePoint(t[0],t[2],a),!0}const a=t[0].sub(t[1]),h=t[2].sub(t[1]),m=a.crossProduct(h),l=a.dotProduct(h),u=e;(0,i.g)(u<=1),(0,i.g)(u>0);const c=.5/(1-u),g=a.sqrLength(),d=l,_=h.sqrLength(),p=(0,o.s)(m),f=a.sub(h).sqrLength();if(0===p)return ji(r,t[0],t[2],1),!1;if(l<=-Math.sqrt(g)*Math.sqrt(_))return ji(r,t[0],t[2],1),!1;const P=[0,0],x=new o.E;x.setInfinite();const y=St(2*p,-(f/u+4*d),2*(1-u)/u,x,!1,P);if(0===y)return ji(r,t[0],t[2],1),!1;1===y&&(P[1]=P[0]);const E=Math.sqrt(c/P[0]),C=Math.sqrt(c/P[1]),S=.5/u;let v=S-_*P[0],b=S-g*P[0];Math.abs(v)>Math.abs(b)?b=d*P[0]-S+1:v=d*P[0]-S+1;const I=a.mul(v).add(h.mul(b)),w=I.norm(1)<1e-15*E?0:Math.atan2(I.y,I.x)+Math.PI,D=a.add(h),T=s?s.clone():t[1].add(D.mul(c)),N=t[0].sub(T),A=t[2].sub(T),G=N.crossProduct(A)<0;return new _i,r.constructEllipticArcEndPointsCenter(t[0],t[2],E,C/E,w,!1,!G,T)}function ur(t,e,s,n,i){return lr(t,e,s,n,i)}function cr(t){let e=!1;{const s=new o.P(t.m_semiMajorAxis*Math.cos(t.m_startAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle));s.rotateDirect(t.m_cosr,t.m_sinr),s.addThis(t.m_center),e=o.P.distance(t.getStartXY(),s)>B(t)}let s=!1;if(!e){const e=new o.P(t.m_semiMajorAxis*Math.cos(t.m_startAngle+t.m_sweepAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle+t.m_sweepAngle));e.rotateDirect(t.m_cosr,t.m_sinr),e.addThis(t.m_center),s=o.P.distance(t.getEndXY(),e)>B(t)}return!e&&!s}function gr(t){if(Zi(t))return 0;if(t.isDegenerate(0))return 0;const e=t.m_semiMajorAxis,s=t.getSemiMinorAxis(),n=e*e+s*s,i=t.getStartAngle(),r=t.getEndAngle(),o=t.m_center.y-t.m_YStart,a=t.m_cosr,h=t.m_sinr;let m=1,l=0;t.m_rotation&&(m=(a-h)*(a+h),l=2*a*h);const u=((-.5*(r-i)+.25*m*(2*Math.cos(r+i)*Math.sin(r-i)))*s+-2*Math.sin(.5*(r+i))*Math.sin(.5*(r-i))*a*o)*e/n;let c=0;return t.m_rotation&&(c=-2*Math.sin(r+i)*Math.sin(r-i)*.125*l-s*o/n*(2*Math.cos(.5*(r+i))*Math.sin(.5*(r-i)))*h),n*(u+c)+-.5*(t.m_XEnd-t.m_XStart)*(t.m_YEnd-t.m_YStart)}function dr(t){t.queryCoord2D(.5,t.m_interior)}function _r(t,e,s,n,i){if(i){if(0!==zr(e,s))return 2}else if(w(e,s))return 1;return 0!==pr(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function pr(t,e,s,n,r,a,h,m,l,u){if(Zi(e))return ht(new $r({start:e.getStartXY(),end:e.getEndXY()}),s,n,r,a,h,m,u);null!==r&&(r.length=0),null!==a&&(a.length=0),null!==n&&(n.length=0);const c=U(e,s);if(z(e,s,h=Math.max(c,h)))return 0;const g=s.getStartXY();g.subThis(e.m_center);const d=s.getEndXY();d.subThis(e.m_center),g.rotateReverse(e.m_cosr,e.m_sinr),d.rotateReverse(e.m_cosr,e.m_sinr);const _=d.clone();_.subThis(g);const p=e.m_semiMajorAxis,f=1/p,P=e.getSemiMinorAxis(),x=1/P,y=_.clone();y.leftPerpendicularThis();const E=Math.atan2(P*y.y,p*y.x),C=(0,o.d)(16,Number.NaN),S=(0,o.d)(16,Number.NaN);let v=0;const b=[E,E+Math.PI];for(let i=0;i<2;++i){const t=Hi(e,b[i]);if(t>=0&&t<=1){C[v]=t;const n=e.getCoord2D(C[v]);S[v]=s.getClosestCoordinate(n,!1),o.P.distance(n,s.getCoord2D(S[v]))<=h&&v++}}const I=g.x*f,w=g.y*x,D=_.x*f,T=_.y*x;let N=St(D*D+T*T,2*(I*D+w*T),I*I+w*w-1,o.E.unit(),!1,S);(0,i.g)(N>=0);for(let i=0;i<N;i++){const t=_.mul(S[i]).add(g);t.x*=f,t.y*=x;const n=Hi(e,Math.atan2(t.y,t.x));if(n>=0&&n<=1){C[v]=n;const t=e.getCoord2D(n);S[v]=s.getClosestCoordinate(t,!1),o.P.distance(t,s.getCoord2D(S[v]))<=h&&v++}}(0,i.g)(v<C.length+4);const A=(0,o.d)(16,Number.NaN);N=e.intersectPoint(s.getStartXY(),A,h);for(let i=0;i<N;i++,v++)C[v]=A[i],S[v]=0;N=e.intersectPoint(s.getEndXY(),A,h);for(let i=0;i<N;i++,v++)C[v]=A[i],S[v]=1;N=s.intersectPoint(e.getStartXY(),A,h);for(let i=0;i<N;i++,v++)C[v]=0,S[v]=A[i];N=s.intersectPoint(e.getEndXY(),A,h);for(let i=0;i<N;i++,v++)C[v]=1,S[v]=A[i];return 0===v?0:Zr(t,e,s,C,S,v,n,r,a,h,m,l,u)}function fr(t,e,s,n,r,a,h,m,l,u){if(Zi(e)){const i=new $r({start:e.getStartXY(),end:e.getEndXY()});return pr(t,s,i,n,a,r,h,m,l,!0)}if(Zi(s)){const i=new $r({start:s.getStartXY(),end:s.getEndXY()});return pr(t,e,i,n,r,a,h,m,l,u)}const c=U(e,s);h=Math.max(h,c);let g=!1;{const t=e.getSemiAxes(),n=e.getCenter(),u=s.getSemiAxes(),c=s.getCenter(),d=o.P.distance(c,n),_=t.x+u.x;if(d>_+h)return 0;if(t.y>u.x){if(d+u.x+h<t.y)return 0}else if(u.y>t.x&&d+t.x+h<u.y)return 0;if(l&&!m){const n=1===e.m_minorMajorRatio&&e.isClosed()&&e.isMajor(),o=1===s.m_minorMajorRatio&&s.isClosed()&&s.isMajor();if(n&&o&&(g=!0,d<=_)&&Math.max(t.x,u.x)<=Math.min(t.x,u.x)+d)return(0,i.g)(!r&&!a),1}}if(!g&&z(e,s,h))return 0;const d=[],_=[],p=!1,f=!1,P=vi(e,0,0,p,f,d,_,null),x=[],y=[],E=vi(s,0,0,p,f,x,y,null);if(1===P&&1===E){const t=new Bt({points:d,weights:_}),i=new Bt({points:x,weights:y}),c=[],g=[],p=ns(!1,t,i,n,null===r?null:c,null===a?null:g,h,m,l,u);if(p>0&&null!==r||null!==a){r&&(r.length=0),a&&(a.length=0);for(let n=0;n<p;++n){if(r)if((0,o.J)(c[n],0,1))r.push(c[n]);else{const s=t.tToLength(c[n]),i=e.lengthToT(s);r.push(i)}if(a)if((0,o.J)(g[n],0,1))a.push(g[n]);else{const t=i.tToLength(g[n]),e=s.lengthToT(t);a.push(e)}}}return p}let C=[];const S=[];let v=0;const b=l&&!m;for(let i=0;i<P;i++){const t=new Bt({points:d.slice(2*i,2*i+3),weights:_.slice(2*i,2*i+3)});let n=0;for(let r=0;r<E;r++){S.length<=r&&S.push(new Bt({points:x.slice(2*r,2*r+3),weights:y.slice(2*r,2*r+3)}));const a=[],m=[],l=b?null:a,u=b?null:m,c=ns(!1,t,S[r],null,l,u,h,!1,b,!1);if(c>0&&b)return 1;for(let h=0;h<c;++h){if(0===a[h]&&0===i)a[h]=0;else if(1===a[h]&&i===P-1)a[h]=1;else{const s=t.tToLength(a[h])+v,n=e.lengthToT(s);a[h]=n}if(0===m[h]&&0===r)m[h]=0;else if(1===m[h]&&r===E-1)m[h]=1;else{const t=S[r].tToLength(m[h])+n,e=s.lengthToT(t);m[h]=e}C.push((0,o.n)(a[h],m[h]))}n+=S[r].calculateLength2D()}v+=t.calculateLength2D()}if(0===C.length)return 0;if(m&&(C=C.filter((t=>!(0,o.J)(t.first,0,1)||!(0,o.J)(t.second,0,1)||!e.getCoord2D(t.first).equals(s.getCoord2D(t.second))))),l)return C.length;const I=[],w=[];for(const i of C)I.push(i.first),w.push(i.second);return Zr(t,e,s,I,w,I.length,n,r,a,h,m,l,u)}function Pr(t,e,s){if(s.setCoords(t.getCoord2D(e.vmin)),s.mergeNe(t.getCoord2D(e.vmax)),Zi(t))return;const n=t.getSemiAxes(),i=[0,0,0,0];{const e=Math.atan2(-n.y*t.m_sinr,n.x*t.m_cosr),s=e+Math.PI,r=Math.atan2(n.y*t.m_cosr,n.x*t.m_sinr),o=r+Math.PI;i[0]=Hi(t,e),i[1]=Hi(t,s),i[2]=Hi(t,r),i[3]=Hi(t,o)}const r=new o.P;for(let o=0;o<4;o++){const n=i[o];e.containsExclusiveCoordinate(n)&&(t.queryCoord2D(n,r),s.mergeNe(r))}}function xr(t,e,s,n,r){if(0===t.m_semiMajorAxis)return s.vmin;let a=o.P.getNAN();t.queryCoord2D(s.vmin,a);let h=o.P.getNAN();if(t.queryCoord2D(s.vmax,h),Zi(t))return new $r({start:a,end:h}).getClosestCoordinate(e,n);const m=qi(t,e);if(a=qi(t,a),h=qi(t,h),1===t.m_minorMajorRatio){if(m.isEqual(0,0))return s.vmin;const e=Hi(t,Math.atan2(m.y,m.x));return n||s.containsCoordinate(e)?e:o.P.distance(m,a)<=o.P.distance(m,h)?s.vmin:s.vmax}const l=t.getSemiMajorAxis(),u=t.getSemiMinorAxis(),c=(l-u)*(l+u),g=(0,o.s)(c),d=m.x,_=m.y,p=(0,o.s)(u*_),f=u*c*_*2,P=[new o.F(p),new o.F(f),new o.F(g-(0,o.s)(l*d)-p),new o.F(-f),new o.F(-g)],x=(0,o.m)(o.F,4),y=Mt(P,4,new o.E(-1,1),!1,x,4);let E=s.vmin,C=o.P.sqrDistance(m,a);{const t=o.P.sqrDistance(m,h);t<C&&(E=s.vmax,C=t)}(0,i.g)(!n);let S=(0,o.d)(8,Number.NaN);for(let i=0;i<y;++i){const e=x[i].value(),s=Math.sqrt(1-e*e),n=Math.atan2(e,s),r=Math.atan2(e,-s);S[2*i]=Hi(t,n),S[2*i+1]=Hi(t,r)}S=S.slice(0,2*y),(0,o.v)(S);for(let i=0,v=2*y;i<v;++i)if(S[i]>s.vmin&&S[i]<s.vmax){const s=o.P.sqrDistance(e,t.getCoord2D(S[i]));C>s&&(C=s,E=S[i])}return E}function yr(t,e,s){return t.m_semiMajorAxis===e.m_semiMajorAxis&&t.isMajor()!==e.isMajor()&&!!t.m_center.equals(e.m_center)&&t.m_sinr===e.m_sinr&&t.m_cosr===e.m_cosr&&t.m_minorMajorRatio===e.m_minorMajorRatio&&(s?t.isClockwise()!==e.isClockwise():t.isClockwise()===e.isClockwise())}function Er(t,e,s,n){const r=t.getStartXY(),a=t.getEndXY(),m=r.equals(a),l=e.equals(s);if(!m&&!l){const n=new h.T;return n.initializeFromTwoPoints(r,a,e,s),Ji(t,n,!0),t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified(),void t.normalizeAfterEndpointChange()}if(!t.isMajor())return void ji(t,e,s,1);if(m&&l){const n=t.m_center.add(e.sub(r));return void t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),n)}if(!m){const n=.5*((0,o.a8)()-Math.abs(t.getSweepAngle())),i=(t.getSweepAngle()+n*(0,o.e)(t.getSweepAngle()))/t.getSweepAngle(),r=new o.P;t.queryCoord2D(i,r),t.constructEllipticArcEndPointsCenter(r,r,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),t.getCenter());const a=t.getCenter().add(e.sub(r));return void t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),a)}const u=o.P.sqrDistance(e,s);let c=.25,g=.75;if(u<o.P.sqrDistance(t.getCoord2D(.25),t.getCoord2D(.75))){const e=[0],s=Ct(new Fi(t,u),o.E.construct(0,.25),1,e);s>0&&((0,i.g)(1===s),c=e[0],g=1-e[0])}const d=t.getCoord2D(c),_=t.getCoord2D(g);(0,i.g)(!d.equals(_)),t.constructEllipticArcEndPointsCenter(d,_,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),t.m_center),Er(t,e,s)}var Cr=r.V;const Sr=-1,vr=1;class br{constructor(t){this.m_shape=t}userSort(t,e,s){this.m_shape.sortVerticesSimpleByYHelper(s,t,e)}getValue(t){return this.m_shape.getY(t)}}class Ir{constructor(t){!function(t){return void 0!==t.parent}(t)?(this.m_parent=t.copy.m_parent,this.m_geometry=t.copy.m_geometry,this.m_path=t.copy.m_path,this.m_vertex=t.copy.m_vertex,this.m_index=t.copy.m_index,this.m_bSkipMultiPoints=t.copy.m_bSkipMultiPoints,this.m_firstVertex=t.copy.m_firstVertex,this.m_bFirst=!0,this.m_selection=t.copy.m_selection,this.m_bOneGeom=t.copy.m_bOneGeom):(this.m_parent=t.parent,this.m_geometry=t.geometry,this.m_path=t.path,this.m_vertex=t.vertex,this.m_firstVertex=t.firstVertex,this.m_index=t.selection?0:t.index,this.m_bSkipMultiPoints=t.bSkipMultiPoints,this.m_selection=t.selection,this.m_bOneGeom=t.bOneGeom,this.m_bFirst=!0)}moveToNextHelper(){for(this.m_path=this.m_parent.getNextPath(this.m_path),this.m_index=0;this.m_geometry!==Sr;){for(;this.m_path!==Sr;this.m_path=this.m_parent.getNextPath(this.m_path))if(this.m_vertex=this.m_parent.getFirstVertex(this.m_path),this.m_firstVertex=this.m_vertex,this.m_vertex!==Sr)return this.m_vertex;if(this.m_bOneGeom)return Sr;if(this.m_geometry=this.m_parent.getNextGeometry(this.m_geometry),this.m_geometry===Sr)break;this.m_bSkipMultiPoints&&!(0,i.h)(this.m_parent.getGeometryType(this.m_geometry))||(this.m_path=this.m_parent.getFirstPath(this.m_geometry))}return Sr}nextSelection(){for(;this.m_index<this.m_parent.m_selectedVertices.length;){const t=this.m_parent.m_selectedVertices[this.m_index++];if(t!==Sr&&(this.m_path=this.m_parent.getPathFromVertex(t),!this.m_bOneGeom||this.m_geometry===this.m_parent.getGeometryFromPath(this.m_path)))return this.m_geometry=this.m_parent.getGeometryFromPath(this.m_path),t}return Sr}next(){return this.m_selection?this.nextSelection():this.m_bFirst?(this.m_bFirst=!1,this.m_vertex):this.m_vertex!==Sr?(this.m_vertex=this.m_parent.getNextVertex(this.m_vertex),this.m_index++,this.m_vertex!==Sr&&this.m_vertex!==this.m_firstVertex?this.m_vertex:this.moveToNextHelper()):Sr}currentGeometry(){return this.m_geometry}currentPath(){return this.m_path}static create_(t,e,s,n,i,r,o,a,h){return new Ir({parent:t,geometry:e,path:s,vertex:n,firstVertex:i,index:r,bSkipMultiPoints:o,selection:a,bOneGeom:h})}}class wr{constructor(t){this.parentage=t}equals(t){return this.parentage===t.parentage}}class Dr{setPrevPath(t,e){this.m_pathIndexList.setField(t,1,e)}setNextPath(t,e){this.m_pathIndexList.setField(t,2,e)}setPathFlags(t,e){this.m_pathIndexList.setField(t,6,e)}getPathFlags(t){return this.m_pathIndexList.getField(t,6)}setPathGeometry(t,e){this.m_pathIndexList.setField(t,7,e)}getPathIndex(t){return this.m_pathIndexList.getField(t,0)}setNextGeometry(t,e){this.m_geometryIndexList.setField(t,1,e)}setPrevGeometry(t,e){this.m_geometryIndexList.setField(t,0,e)}getGeometryIndex(t){return this.m_geometryIndexList.getField(t,7)}setFirstPath(t,e){this.m_geometryIndexList.setField(t,3,e)}setLastPath(t,e){this.m_geometryIndexList.setField(t,4,e)}newGeometry(t){const e=this.m_geometryIndexList.newElement();return this.m_geometryIndexList.setField(e,2,t),this.m_geometryIndexList.setField(e,5,0),this.m_geometryIndexList.setField(e,6,0),this.m_geometryIndexList.setField(e,7,this.m_geometryIndexList.elementToIndex(e)),e}freeGeometry(t){this.m_geometryIndexList.deleteElement(t)}newPath(t){const e=this.m_pathIndexList.newElement(),s=this.m_pathIndexList.elementToIndex(e);if(this.m_pathIndexList.setField(e,0,s),this.m_pathIndexList.setField(e,3,0),this.m_pathIndexList.setField(e,6,0),this.setPathGeometry(e,t),s>=this.m_pathAreas.length){const t=Math.trunc(s<16?16:3*s/2);this.m_pathAreas.length=t,this.m_pathLengths.length=t}return this.m_pathAreas[s]=0,this.m_pathLengths[s]=0,this.m_pathCount++,e}freePath(t){this.m_pathIndexList.deleteElement(t),this.m_pathCount--}newVertex(t){const e=this.m_vertexIndexList.newElement(),s=t>=0?t:this.m_vertexIndexList.elementToIndex(e);if(this.m_vertexIndexList.setField(e,0,s),t<0){if(s>=this.m_vertices.getPointCount()){const t=Math.trunc(s<16?16:3*s/2);this.m_vertices.reserveRounded(t),this.m_vertices.resizeNoInit(t),null!==this.m_segments&&(this.m_segments.length=t),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0)}this.m_segments&&(this.m_segments[s]=null)}return this.m_pointCount++,e}freeVertex(t){this.unselect(t);const e=this.getVertexIndex(t);this.m_vertexIndexList.deleteElement(t),this.m_pointCount--;for(let s=0,n=this.m_indices.length;s<n;s++){if(s===this.m_selectionIndex)continue;const t=this.m_indices[s];null!==t&&t.size()>e&&t.write(e,-1)}this.m_weights&&this.m_weights.size()>e&&this.m_weights.write(e,1),this.m_ranks&&this.m_ranks.size()>e&&this.m_ranks.write(e,vr),this.m_segmentWeights&&this.m_segmentWeights.size()>e&&this.m_segmentWeights.write(e,1),this.m_segmentRanks&&this.m_segmentRanks.size()>e&&this.m_segmentRanks.write(e,vr),this.m_segments&&this.setSegmentToIndex(e,null)}insertVertex_(t,e,s,n){this.m_hasForceSetEnvelope=0;const i=e!==Sr?this.getPrevVertex(e):this.getLastVertex(t),r=i!==Sr?this.getNextVertex(i):Sr,o=this.newVertex(null===s?this.m_pointCount:-1),a=this.getVertexIndex(o);null!==s&&this.m_vertices.setPointByVal(a,s),this.setPathToVertex(o,t),this.setNextVertex(o,r),this.setPrevVertex(o,i),r!==Sr&&this.setPrevVertex(r,o),i!==Sr&&this.setNextVertex(i,o);const h=this.isClosedPath(t),m=this.getFirstVertex(t);e===Sr&&this.setLastVertex(t,o),e===m&&(h&&n&&m!==Sr||this.setFirstVertex(t,o)),h&&r===Sr&&(this.setNextVertex(o,o),this.setPrevVertex(o,o)),this.setPathSize(t,this.getPathSize(t)+1);const l=this.getGeometryFromPath(t);return this.setGeometryVertexCount(l,this.getPointCount(l)+1),o}getHelperPoint(){return this.m_helperPoint||(this.m_helperPoint=new r.P({vd:this.m_vertices.getDescription()}),this.m_helperPoint.setXYCoords(0,0)),this.m_helperPoint}addMultiPoint(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return this.appendMultiPoint(s,t,e),s}addPoint_(t,e){const s=this.createGeometry(i.G.enumMultiPoint,t.getDescription());return this.appendPoint(s,t,e),s}appendMultiPath_(t,e){if(e.isEmpty())return;const s=e.getImpl();this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+s.getPointCount()),this.m_verticesMp.addPoints(e,0,s.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const n=null!==this.m_segments||null!==s.getSegmentFlagsStreamRef();this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+s.getPointCount()),this.m_pathIndexList.setCapacity(this.m_pathIndexList.size()+s.getPathCount());for(let i=0,r=s.getPathCount();i<r;i++){if(0===s.getPathSize(i))continue;const e=this.insertPath(t,Sr);this.setClosedPath(e,s.isClosedPath(i));for(let t=s.getPathStart(i),r=s.getPathEnd(i);t<r;t++){const i=this.insertVertex_(e,Sr,null,!1);if(n){const e=this.getVertexIndex(i);if(1&s.getSegmentFlags(t))this.setSegmentToIndex(e,null);else{const n=new to;s.querySegment(t,n,!0),this.setSegmentToIndex(e,n.releaseSegment())}}}s.isStrongPathStart(i)&&this.setStrongPathStart(e,!0),s.isStrongPathEnd(i)&&this.setStrongPathEnd(e,!0)}}addMultiPath(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return t.getGeometryType()===i.G.enumPolygon&&this.setFillRule(s,t.getFillRule()),this.appendMultiPath(s,t,e),s}appendMultiPathPolyline(t,e,s){const n=e.getImpl(),i=null!==this.m_segments||null!==n.getSegmentFlagsStreamRef(),r=new a.Envelope2D;e.queryEnvelope(r);{const r=s.clone();let a=n.getPointCount();const h=n.getAccelerators();if(h&&h.getQuadTree()&&(a=h.getQuadTree().getIntersectionCount(r,0,n.getPointCount()+1)),a<e.getPointCount()){if(0===a)return;const s=n.queryLimitedSegmentIterator(r);let h=-1,m=-100,l=-1,u=0,c=-1,g=Sr,d=!1,_=s.nextSegment();if(null!==_)for(;;_=s.nextSegment()){let r=null===_;const a=null!==_?s.getPathIndex():h,p=null!==_?s.getStartPointIndex():m;if(r||(h===a&&m+1===p?u++:r=!0),r){if(-1!==c){let t=-1,s=-1;if(u===l){this.setClosedPath(g,d);const i=n.getPathEnd(h);this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+i-c),this.m_verticesMp.addPoints(e,c,i),s=n.getPathSize(h),t=i-1}else if(!d||m+1<n.getPathEnd(h))this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+m+2-c),this.m_verticesMp.addPoints(e,c,m+2),s=m-c+2,t=m;else{var o;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+m+2-c),null!==(o=this.m_verticesMp)&&void 0!==o&&o.addPoints(e,c,m+1),t=m,s=m-c+1;const i=n.getPathStart(h);this.m_verticesMp.addPoints(e,i,i+1),s+=1}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);for(let e=0,r=c;e<s;e++,r++){const e=this.insertVertex_(g,Sr,null,!1);if(i){const s=this.getVertexIndex(e);if(1&n.getSegmentFlags(r)||r>t)this.setSegmentToIndex(s,null);else{const t=new to;n.getSegmentBuffer(r,t,!0),this.setSegmentToIndex(s,t.releaseSegment())}}}}if(null===_)break;u=1,c=p,h!==a?(g=this.insertPath(t,Sr),this.setClosedPath(g,!1),l=n.getSegmentCountPath(a),d=n.isClosedPath(a),h=a):g=this.insertPath(t,Sr)}m=p}return}}this.appendMultiPath_(t,e)}appendMultiPathPolygon(t,e,s){const n=e.getImpl(),r=null!==this.m_segments||null!==n.getSegmentFlagsStreamRef(),h=a.Envelope2D.constructEmpty();e.queryEnvelope(h),(0,i.g)(s.isIntersecting(h)&&!s.containsEnvelope(h));let m=a.Envelope2D.construct(Number.NEGATIVE_INFINITY,s.ymin,Number.POSITIVE_INFINITY,s.ymax),l=a.Envelope2D.construct(s.xmin,Number.NEGATIVE_INFINITY,s.xmax,Number.POSITIVE_INFINITY);const u=n.getAccelerators();if(u&&u.getQuadTree()){const t=u.getQuadTree(),e=t.getIntersectionCount(m,0,0);e>t.getIntersectionCount(l,0,e+1)&&(l=(0,o.b)(m,m=l))}else m.height()>l.width()&&(l=(0,o.b)(m,m=l));const c=[],g=n.queryLimitedSegmentIterator(m);let d=-1,_=-100,p=-1,f=0,P=-1,x=-1,y=Sr,E=!0,C=g.nextSegment();if(null!==C)for(;;C=g.nextSegment()){let s=null===C;const h=null!==C?g.getPathIndex():d,m=null!==C?g.getStartPointIndex():_;if(s||(h===d?_+1===m?f++:s=!0:(s=d>=0,d<0&&(d=h,p=n.getSegmentCountPath(d),P=m,y=Sr,f=1))),s){if(0!==c.length||p!==f){0!==c.length&&c[0].first===P||(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(e,P,P+1),-1===x&&(x=P),y===Sr&&(y=this.insertPath(t,Sr),this.setClosedPath(y,!0)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.insertVertex_(y,Sr,null,!1));for(const{first:s,second:o}of c){-1===x&&(x=s);let a=-1,h=-1;const m=s+o-1;if(o===p){const t=m+1;h=t-s,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h),this.m_verticesMp.addPoints(e,s,t),a=m,(0,i.g)(1===c.length)}else if(m+1<n.getPathEnd(d)){const t=m+2;h=t-s,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h),this.m_verticesMp.addPoints(e,s,t),a=m}else{var S;const t=n.getPathStart(d),i=t!==x?1:0,r=m+1;h=r-s+i,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+(r-s)+i),this.m_verticesMp.addPoints(e,s,r),a=m,i>0&&(null===(S=this.m_verticesMp)||void 0===S||S.addPoints(e,t,t+1))}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),y===Sr&&(y=this.insertPath(t,Sr),this.setClosedPath(y,!0));for(let t=0,e=s;t<h;t++,e++){const t=this.insertVertex_(y,Sr,null,!1);if(r){const s=this.getVertexIndex(t);if(1&n.getSegmentFlags(e)||e>a)this.setSegmentToIndex(s,null);else{const t=new to;n.getSegmentBuffer(e,t,!0),this.setSegmentToIndex(s,t.releaseSegment())}}}}if(0===c.length||c.at(-1).first+c.at(-1).second!==P+f){let t=P+f;t===e.getPathEnd(d)&&(t=e.getPathStart(d)),x!==t&&(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(e,t,t+1),this.insertVertex_(y,Sr,null,!1))}}c.length=0,E=!0,h!==d&&(d=h,p=n.getSegmentCountPath(d),y=Sr,x=-1),P=m,f=1}if(!C)break;{const t=a.Envelope2D.constructEmpty();C.queryLooseEnvelope(t),l.isIntersecting(t)?(E?c.push((0,o.n)(m,1)):c.at(-1).second++,E=!1):E=!0}_=m}}appendMultiPath(t,e,s){if(void 0===s)return void this.appendMultiPath_(t,e);if(e.isEmpty())return;const n=e.getGeometryType()===i.G.enumPolygon,r=a.Envelope2D.constructEmpty();e.queryEnvelope(r),s.isIntersecting(r)&&(!s.containsEnvelope(r)&&e.getPointCount()>10?n?this.appendMultiPathPolygon(t,e,s):this.appendMultiPathPolyline(t,e,s):this.appendMultiPath_(t,e))}appendPoint(t,e,s){if(e.isEmpty())return;if(void 0!==s&&!s.contains(e.getXY()))return;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.add(e),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+1);const n=this.insertPath(t,Sr);this.insertVertex_(n,Sr,null,!1)}appendMultiPoint_(t,e){this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+e.getPointCount()),this.m_verticesMp.addPoints(e,0,e.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+e.getPointCount());const s=this.insertPath(t,Sr);for(let n=0,i=e.getPointCount();n<i;n++)this.insertVertex_(s,Sr,null,!1)}appendMultiPoint(t,e,s){if(void 0===s)return void this.appendMultiPoint_(t,e);const n=e.getAttributeStreamRef(0);let i=0;for(let m=0,l=e.getPointCount();m<l;m++){const t=n.readPoint2D(2*m);s.contains(t)&&i++}this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+i);let r=-1,o=-1,a=0;for(let m=0,l=e.getPointCount();m<l;m++){const t=n.readPoint2D(2*m);s.contains(t)?(-1===r&&(r=m,o=m),o++):r>=0&&(this.m_verticesMp.addPoints(e,r,o-r),r=-1,a++)}if(r>0&&(this.m_verticesMp.addPoints(e,r,o-r),a++),!a)return;this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+i);const h=this.insertPath(t,Sr);for(let m=0,l=e.getPointCount();m<l;m++){const t=n.readPoint2D(2*m);s.contains(t)&&this.insertVertex_(h,Sr,null,!1)}}splitSegmentForward(t,e,s,n,r){const o=this.getNextVertex(t);o===Sr&&(0,i.t)("Edit_shape.split_segment_forward_");const a=this.getHelperPoint(),h=this.getPathFromVertex(t);let m=t;const l=this.hasSegmentParentage();for(let u=0,c=e.getResultSegmentCount(s);u<c;u++){const t=this.getVertexIndex(m),n=this.getNextVertex(m),g=e.getResultSegment(s,u);let d=null;if(g.getGeometryType()!==i.G.enumLine&&(d=g.clone(),d.dropAllAttributes()),0===u&&(g.queryStart(a),this.setSegmentToIndex(t,null),this.setPointEx(m,a,e.getResultSegmentStartPointRank(s,u),e.getResultSegmentStartPointWeight(s,u),r)),this.setSegmentRank(m,e.getResultSegmentInteriorRank(s,u)),this.setSegmentWeight(m,e.getResultSegmentInteriorWeight(s,u)),l){const t=e.getResultSegmentSegmentParentage(s,u),n=e.getResultSegmentStartPointIsBreak(s,u);this.setSegmentParentageAndBreak(m,t,n)}if(g.queryEnd(a),u<c-1){this.setSegmentToIndex(t,d);const i=this.insertVertex(h,n,a);this.setWeight(i,e.getResultSegmentEndPointWeight(s,u)),this.setRank(i,e.getResultSegmentEndPointRank(s,u)),this.select(i),m=i}else{this.setPointEx(o,a,e.getResultSegmentEndPointRank(s,u),e.getResultSegmentEndPointWeight(s,u),r);const n=e.getResultSegmentEndPointIsBreak(s,u);this.setSegmentParentageBreakVertex(o,n),this.setSegmentToIndex(t,d)}}}splitSegmentBackward(t,e,s,n,r){const o=this.getNextVertex(t);o===Sr&&(0,i.t)("Edit_shape.split_segment_backward_");const a=this.getHelperPoint(),h=this.getPathFromVertex(t);let m=t;const l=this.hasSegmentParentage();for(let u=0,c=e.getResultSegmentCount(s);u<c;u++){const t=c-u-1,n=this.getVertexIndex(m),g=this.getNextVertex(m),d=e.getResultSegment(s,t);let _=null;if(d.getGeometryType()!==i.G.enumLine&&(_=d.clone(),_.reverse(),_.dropAllAttributes()),0===u&&(d.queryEnd(a),this.setSegmentToIndex(n,null),this.setPointEx(m,a,e.getResultSegmentEndPointRank(s,t),e.getResultSegmentEndPointWeight(s,t),r),this.setSegmentParentageAndBreak(m,e.getResultSegmentSegmentParentage(s,t),e.getResultSegmentEndPointIsBreak(s,t))),d.getGeometryType()===i.G.enumLine?this.setSegmentToIndex(n,null):this.setSegmentToIndex(n,_),this.setSegmentRank(m,e.getResultSegmentInteriorRank(s,t)),this.setSegmentWeight(m,e.getResultSegmentInteriorWeight(s,t)),d.queryStart(a),u<c-1){const n=this.insertVertex(h,g,a);this.setWeight(n,e.getResultSegmentStartPointWeight(s,t)),this.setRank(n,e.getResultSegmentStartPointRank(s,t)),this.select(n),m=n,l&&this.setSegmentParentageAndBreak(n,e.getResultSegmentSegmentParentage(s,t),e.getResultSegmentEndPointIsBreak(s,t))}else this.setPointEx(o,a,e.getResultSegmentStartPointRank(s,t),e.getResultSegmentStartPointWeight(s,t),r)}}selected_(t){return this.getUserIndex(t,this.m_selectionIndex)>=0}allocateIndex(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];if(this.m_deletedIndices.length){const e=this.m_deletedIndices.pop();return t&&e.setRange(-1,0,e.size()),e}return t?(0,r.z)(0,-1):(0,r.z)(0)}recycleUserIndex(t){this.m_deletedIndices.push(t)}allocatePathIndex(){if(this.m_deletedPathIndices.length){const t=this.m_deletedPathIndices.at(-1);return this.m_deletedPathIndices.pop(),t}return(0,r.z)(0)}recyclePathUserIndex(t){this.m_deletedPathIndices.push(t)}peelALoop_(t,e,s){const n=this.getNextVertex(t),i=this.getNextVertex(e),r=this.getVertexIndex(t),a=this.getVertexIndex(e);if(this.setNextVertex(t,i),this.setPrevVertex(i,t),this.setNextVertex(e,n),this.setPrevVertex(n,e),this.m_segments){const t=this.getSegmentFromIndex(r),e=this.getSegmentFromIndex(a);this.setSegmentToIndex(a,null),this.setSegmentToIndex(r,e),this.setSegmentToIndex(a,t)}if(this.hasSegmentParentage()){let s=this.getSegmentParentage(e),n=this.getSegmentParentage(t);-1===s&&-1===n||(n=(0,o.b)(s,s=n),this.setSegmentParentageAndBreak(t,n),this.setSegmentParentageAndBreak(e,s))}if(s){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e),r=[!1],o=this.insertClosedPath(s,Sr,n,this.getFirstVertex(e),r);r[0]&&this.setFirstVertex(e,i);let a=this.getPathSize(e);return a-=this.getPathSize(o),this.setPathSize(e,a),o}return Sr}sortVerticesSimpleByYHelper(t,e,s){t.sort(e,s,((t,e)=>{let s=this.compareVerticesSimpleY(t,e);if(0===s){const n=this.getPathInternalIndexFromVertex(t),i=this.getPathInternalIndexFromVertex(e);s=n<i?-1:n>i?1:0}return s}))}sortVerticesSimpleByYHelper3D(t,e,s){(0,i.g)(0)}constructor(){this.m_verticesMp=null,this.m_vertices=null,this.m_xyStream=null,this.m_vertexDescription=null,this.m_segments=null,this.m_weights=null,this.m_ranks=null,this.m_segmentWeights=null,this.m_segmentRanks=null,this.m_indices=[],this.m_deletedIndices=[],this.m_pathAreas=[],this.m_pathLengths=[],this.m_pathindices=[],this.m_deletedPathIndices=[],this.m_geometryIndices=[],this.m_selectedVertices=[],this.m_helperPoint=null,this.m_forceSetEnvelope=r.n.constructEmpty(),this.m_hasForceSetEnvelope=0,this.m_workPoint2D=o.P.getNAN(),this.m_workPoint2_2D=o.P.getNAN(),this.m_curveStitcher=null,this.m_pathCount=0,this.m_pointCount=0,this.m_firstGeometry=Sr,this.m_lastGeometry=Sr,this.m_vertexIndexList=new r.S(5),this.m_pathIndexList=new r.S(8),this.m_geometryIndexList=new r.S(8),this.m_bHasAttributes=!1,this.m_selectedCount=0,this.m_selectionIndex=-1,this.m_selection=!1,this.m_bucketSort=new r.B,this.m_segmentParentageIndex=-1}getTotalPointCount(){return this.m_pointCount}getEnvelope2D(t){if(0!==this.m_hasForceSetEnvelope)return new a.Envelope2D(this.m_forceSetEnvelope.xmin,this.m_forceSetEnvelope.ymin,this.m_forceSetEnvelope.xmax,this.m_forceSetEnvelope.ymax);const e=this.hasCurves(),s=a.Envelope2D.constructEmpty(),n=this.queryVertexIterator();let i=!0;for(let r=n.next();r!==Sr;r=n.next()){if(i?s.merge(this.getXY(r)):s.mergeNe(this.getXY(r)),e){const t=this.getSegment(r);if(null!==t){const e=a.Envelope2D.constructEmpty();t.queryLooseEnvelope(e),s.mergeEnvelope2D(e)}}i=!1}return s}getEnvelope3D(t){return(0,i.g)(0),r.n.constructEmpty()}forceSetEnvelope2D(t){this.m_hasForceSetEnvelope=1,this.m_forceSetEnvelope.setCoords(t.xmin,t.ymin,0,t.xmax,t.ymax,0)}forceSetEnvelope3D(t){(0,i.g)(0)}forgetForceSetEnvelope(){this.m_hasForceSetEnvelope=0}getGeometryCount(){return this.m_geometryIndexList.size()}addGeometry(t,e){const s=t.getGeometryType();if((0,i.h)(s))return this.addMultiPath(t,e);if(s===i.G.enumMultiPoint)return this.addMultiPoint(t,e);if(s===i.G.enumPoint)return this.addPoint_(t,e);if(s===i.G.enumEnvelope){const s=new yi;return s.addEnvelope(t,!1),this.addMultiPath(s,e)}(0,i.t)("")}appendGeometry(t,e){this.mergeVertexDescription(e.getDescription());const s=e.getGeometryType();(0,i.h)(s)?this.appendMultiPath(t,e):s!==i.G.enumMultiPoint?(0,i.t)(""):this.appendMultiPoint(t,e)}assignRankToGeometryVertices(t,e){e<vr&&(e=vr);const s=this.queryVertexIterator();for(let n=s.next();n!==Sr;n=s.next())this.setRank(n,e),this.setSegmentRank(n,e)}collapseAllGeometriesToFirst(){this.collapseGeometriesToFirst(i.G.enumUnknown)}collapseGeometriesToFirst(t){this.dbgVerifyVertexCounts();let e=Sr,s=-1,n=-1;for(let r=this.getFirstGeometry();r!==Sr;)if(t!==i.G.enumUnknown&&this.getGeometryType(r)!==t)r=this.getNextGeometry(r);else{if(e===Sr){e=r,s=this.getPathCount(e),n=this.getPointCount(e),r=this.getNextGeometry(r);continue}for(let s=this.getFirstPath(r);s!==Sr;s=this.getNextPath(s))this.setPathGeometry(s,e);s+=this.getPathCount(r),n+=this.getPointCount(r);const t=this.getLastPath(e),i=this.getFirstPath(r);t!==Sr?this.setNextPath(t,i):this.setFirstPath(e,i),i!==Sr&&(this.setPrevPath(i,t),this.setLastPath(e,this.getLastPath(r))),this.setFirstPath(r,Sr),this.setLastPath(r,Sr);const o=r;r=this.getNextGeometry(r),this.setGeometryVertexCount(o,0),this.removeGeometry(o)}return e!==Sr&&(this.setGeometryVertexCount(e,n),this.setGeometryPathCount(e,s),this.dbgVerifyVertexCounts()),e}setFillRule(t,e){let s=this.m_geometryIndexList.getField(t,2);s&=-134217729,s|=1===e?134217728:0,this.m_geometryIndexList.setField(t,2,s)}getFillRule(t){return 134217728&this.m_geometryIndexList.getField(t,2)?1:0}setGeometryModified(t,e){let s=this.m_geometryIndexList.getField(t,2);!!(67108864&s)!==e&&(s&=-67108865,s|=e?67108864:0,this.m_geometryIndexList.setField(t,2,s))}getGeometryModified(t){return!!(67108864&this.m_geometryIndexList.getField(t,2))}setGeometryModifiedWithVertex(t,e){const s=this.getPathFromVertex(t),n=this.getGeometryFromPath(s);this.setGeometryModified(n,e)}getGeometryModifiedWithVertex(t){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e);return this.getGeometryModified(s)}swapGeometry(t,e){const s=this.getFirstPath(t),n=this.getFirstPath(e),i=this.getLastPath(t),r=this.getLastPath(e);for(let c=this.getFirstPath(t);c!==Sr;c=this.getNextPath(c))this.setPathGeometry(c,e);for(let c=this.getFirstPath(e);c!==Sr;c=this.getNextPath(c))this.setPathGeometry(c,t);this.setFirstPath(t,n),this.setFirstPath(e,s),this.setLastPath(t,r),this.setLastPath(e,i);const o=this.getPointCount(t),a=this.getPathCount(t),h=this.getPointCount(e),m=this.getPathCount(e);this.setGeometryVertexCount(t,h),this.setGeometryVertexCount(e,o),this.setGeometryPathCount(t,m),this.setGeometryPathCount(e,a);const l=this.m_geometryIndexList.getField(t,2),u=this.m_geometryIndexList.getField(e,2);this.m_geometryIndexList.setField(t,2,u),this.m_geometryIndexList.setField(e,2,l)}addPathFromMultiPath(t,e,s){const n=this.createGeometry(s?i.G.enumPolygon:i.G.enumPolyline,t.getDescription()),r=t.getImpl();if(t.getPathSize(e)<2)return n;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+t.getPathSize(e)),this.m_verticesMp.addPoints(t,t.getPathStart(e),r.getPathEnd(e)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const o=this.insertPath(n,Sr);this.setClosedPath(o,r.isClosedPath(e)||s);const a=null!==this.m_segments||null!==r.getSegmentFlagsStreamRef();for(let i=r.getPathStart(e),h=r.getPathEnd(e);i<h;i++){const t=this.insertVertex_(o,Sr,null,!1);if(a){const e=this.getVertexIndex(t);if(1&r.getSegmentFlags(i))this.setSegmentToIndex(e,null);else{const t=new to;r.querySegment(i,t,!0),this.setSegmentToIndex(e,t.releaseSegment())}}}return r.isStrongPathStart(e)&&this.setStrongPathStart(o,!0),r.isStrongPathEnd(e)&&this.setStrongPathEnd(o,!0),n}getGeometry(t){const e=this.getGeometryType(t),s=function(t,e){let s,n=e,o=null;switch(n||(o=(0,i.o)(t)?(0,r.w)():(0,r.j)(),n=o),t){case i.G.enumPoint:s=new r.P({vd:n});break;case i.G.enumLine:s=new $r({vd:n});break;case i.G.enumBezier:s=new $s({vd:n});break;case i.G.enumEllipticArc:s=new _i({vd:n});break;case i.G.enumRationalBezier2:s=new Bt({vd:n});break;case i.G.enumBezier2:s=new Ht({vd:n});break;case i.G.enumEnvelope:s=new r.E({vd:n});break;case i.G.enumMultiPoint:s=new y({vd:n});break;case i.G.enumPolyline:s=new ei({vd:n});break;case i.G.enumPolygon:s=new yi({vd:n});break;case i.G.enumMultipatch:(0,i.b)("multipatch not impl");break;case i.G.enumGeometryCollection:s=new Q({vd:n});break;default:(0,i.t)("Geometry.create")}return s}(e,this.m_verticesMp.getDescription()),n=this.getPointCount(t);if(0===n)return s;if((0,i.h)(e)){const e=s.getImpl(),i=this.getPathCount(t),o=(0,r.z)(i+1),a=(0,r.D)(i+1,0),h=s.getDescription(),m=this.hasCurves();for(let s=0,l=h.getAttributeCount();s<l;s++){const m=h.getSemantics(s),l=Cr.getComponentCount(m),u=(0,r.t)(m,n),c=this.m_vertices.getAttributeStreamRef(m);let g=0,d=0,_=0;for(let e=this.getFirstPath(t);e!==Sr;e=this.getNextPath(e)){let t=0;this.isClosedPath(e)&&(t|=1),this.isExterior(e)&&(t|=8),this.isStrongPathStart(e)&&(t|=2),this.isStrongPathEnd(e)&&(t|=4),t&&a.setBits(d,t);const s=this.getPathSize(e);if(o.write(d++,_),_+=s,0===m){const t=c,s=u;let n;for(let i=this.getFirstVertex(e);g<_;i=this.getNextVertex(i),g++){const e=this.getVertexIndex(i);n=t.readPoint2D(2*e),s.writePoint2D(2*g,n)}}else for(let n=this.getFirstVertex(e);g<_;n=this.getNextVertex(n),g++){const t=this.getVertexIndex(n);for(let e=0;e<l;e++){const s=c.readAsDbl(t*l+e);u.writeAsDbl(g*l+e,s)}}}e.setAttributeStreamRef(m,u),o.write(i,n)}if(e.setPathFlagsStreamRef(a),e.setPathStreamRef(o),e.notifyModifiedFlags(65535),m){let s=0,n=0;for(let i=this.getFirstPath(t);i!==Sr;i=this.getNextPath(i)){s+=this.getPathSize(i);for(let t=this.getFirstVertex(i);n<s;t=this.getNextVertex(t)){const s=this.getSegment(t);null!==s&&s.isCurve()&&e.replaceSegment(n,s,!0),n++}}}}else if(e===i.G.enumMultiPoint){const e=s.getImpl(),i=s.getDescription();e.reserve(n),e.resizeNoInit(n);for(let s=0,n=i.getAttributeCount();s<n;s++){const n=i.getSemantics(s),r=Cr.getComponentCount(n),o=e.getAttributeStreamRef(n),a=this.m_vertices.getAttributeStreamRef(n);let h=0;const m=this.getFirstPath(t),l=this.getPathSize(m);for(let t=this.getFirstVertex(m);h<l;t=this.getNextVertex(t),h++){const e=this.getVertexIndex(t);for(let t=0;t<r;t++){const s=a.readAsDbl(e*r+t);o.writeAsDbl(h*r+t,s)}}e.setAttributeStreamRef(n,o)}e.notifyModifiedFlags(65535)}else(0,i.c)("getGeometry");return s}queryPointGeometryOnly(t,e){this.getGeometryType(t)!==i.G.enumMultiPoint&&(0,i.t)("get_point_geometry_only");const s=this.getPointCount(t);if(s>1&&(0,i.t)("get_point_geometry_only"),0===s)return e.assignVertexDescription(this.m_vertexDescription),void e.setEmpty();const n=this.getFirstPath(t),r=this.getFirstVertex(n);this.queryPoint(r,e)}removeGeometry(t){for(let n=this.getFirstPath(t);n!==Sr;n=this.removePath(n));const e=this.getPrevGeometry(t),s=this.getNextGeometry(t);return e!==Sr?this.setNextGeometry(e,s):this.m_firstGeometry=s,s!==Sr?this.setPrevGeometry(s,e):this.m_lastGeometry=e,this.freeGeometry(t),s}createGeometry(t,e){void 0===e&&(e=(0,r.j)());const s=this.newGeometry(t);return this.m_vertices||(this.m_verticesMp=new y({vd:e}),this.m_vertices=this.m_verticesMp.getImpl()),this.mergeVertexDescription(e),this.m_firstGeometry===Sr?(this.m_firstGeometry=s,this.m_lastGeometry=s):(this.setPrevGeometry(s,this.m_lastGeometry),this.setNextGeometry(this.m_lastGeometry,s),this.m_lastGeometry=s),s}getFirstGeometry(){return this.m_firstGeometry}getLastGeometry(){return this.m_lastGeometry}getNextGeometry(t){return this.m_geometryIndexList.getField(t,1)}getPrevGeometry(t){return this.m_geometryIndexList.getField(t,0)}getGeometryType(t){return 16777215&this.m_geometryIndexList.getField(t,2)}setGeometryUserIndex(t,e,s){const n=this.m_geometryIndices[e],i=this.getGeometryIndex(t);i>=n.size()&&n.resize(Math.max(1.25*i,16),-1),n.write(i,s)}getGeometryUserIndex(t,e){const s=this.getGeometryIndex(t),n=this.m_geometryIndices[e];return s<n.size()?n.read(s):-1}createGeometryUserIndex(){for(let e=0;e<this.m_geometryIndices.length;e++)if(null===this.m_geometryIndices[e])return this.m_geometryIndices[e]=(0,r.z)(0),e;this.m_geometryIndices.push((0,r.z)(0));const t=this.m_geometryIndices.length-1;return(0,i.g)(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}removeGeometryUserIndex(t){for(this.m_geometryIndices[t]=null;this.m_geometryIndices.length>0&&null===this.m_geometryIndices.at(-1);)this.m_geometryIndices.pop()}getFirstPath(t){return this.m_geometryIndexList.getField(t,3)}getLastPath(t){return this.m_geometryIndexList.getField(t,4)}hasPointFeatures(){for(let t=this.getFirstGeometry();t!==Sr;t=this.getNextGeometry(t))if(!(0,i.h)(this.getGeometryType(t)))return!0;return!1}getPointCount(t){return this.m_geometryIndexList.getField(t,5)}getPathCount(t){return this.m_geometryIndexList.getField(t,6)}filterClosePoints(t,e,s,n,r){const a=t*t;let h=0;const m=this.hasCurves(),l=this.hasSegmentParentage();for(let u=r===Sr?this.getFirstGeometry():r;u!==Sr;u=r===Sr?this.getNextGeometry(u):Sr){const t=this.getGeometryType(u);if(!(0,i.h)(t))continue;if(s&&t!==i.G.enumPolygon)continue;const r=this.getGeometryType(u)===i.G.enumPolygon;let c=this.getGeometryModified(u);for(let s=this.getFirstPath(u);s!==Sr;){let t=0;for(let e=this.getFirstVertex(s);t<Math.trunc(this.getPathSize(s)/2);){const r=this.getNextVertex(e);if(r===Sr)break;const g=this.getXY(e),d=this.getXY(r);let _=o.P.sqrDistance(g,d),p=!0;do{if(_<=a){if(m){const t=this.getSegment(e);if(null!==t){const e=t.calculateLength2D();if(_=e*e,_>a)break}}if(0===_?0===h&&(h=-1):h=1,r!==this.getLastVertex(s)){const t=l&&(this.getSegmentParentageBreakVertex(e)||this.getSegmentParentageBreakVertex(r));if(this.transferAllDataToTheVertex(r,e),this.removeVertex(r,!1),n&&!c&&(this.setGeometryModified(u,!0),c=!0),l&&e!==r){this.setSegmentParentageBreakVertex(e,t);const s=this.getNextVertex(e);(0,i.g)(s!==Sr),this.isDiscontinuousSegmentParentage(s)&&this.setSegmentParentageBreakVertex(s,!0)}}p=!1}}while(0);p&&(e=this.getNextVertex(e)),t++}let g=this.getFirstVertex(s);for(let e=this.isClosedPath(s)?g:this.getLastVertex(s);this.getPathSize(s)>0;){const t=this.getPrevVertex(e);if(t===Sr)break;{const i=this.getXY(t),r=this.getXY(e);let d=o.P.sqrDistance(i,r),_=!0;do{if(d<=a){if(m){const e=this.getSegment(t);if(null!==e){const t=e.calculateLength2D();if(d=t*t,d>a)break}}0===d?0===h&&(h=-1):h=1;const i=l&&(this.getSegmentParentageBreakVertex(e)||this.getSegmentParentageBreakVertex(t));this.removeVertex(t,!0),n&&!c&&(this.setGeometryModified(u,!0),c=!0),l&&t!==e&&(i||this.isDiscontinuousSegmentParentage(e))&&this.setSegmentParentageBreakVertex(e,!0),g===t&&(g=this.getFirstVertex(s)),_=!1}}while(0);if(_&&(e=this.getPrevVertex(e),e===g))break}}const d=this.getPathSize(s);let _=e&&d<(r?3:2);_&&r&&2===d&&m&&(_=!this.pathHasCurves(s)),_?(s=this.removePath(s),0===h&&(h=-1),n&&!c&&(this.setGeometryModified(u,!0),c=!0)):s=this.getNextPath(s)}}return h}filterClosePoints3D(t,e,s,n,r,o){return(0,i.g)(0),0}hasDegenerateSegments(t){for(let e=this.getFirstGeometry();e!==Sr;e=this.getNextGeometry(e))if((0,i.h)(this.getGeometryType(e)))for(let s=this.getFirstPath(e);s!==Sr;){const e=this.getPathSize(s);if(0===e)return!0;let n=this.getFirstVertex(s);for(let s=0;s<e;s++){const e=this.getNextVertex(n);if(e===Sr)break;const s=this.getVertexIndex(n),i=this.getSegmentFromIndex(s);let r=0;if(null!==i){if(r=i.calculateLowerLength2D(),r<=t){if(r=i.calculateUpperLength2D(),r<=t)return!0;if(r=i.calculateLength2D(),r<=t)return!0}}else{const n=this.getVertexIndex(e);if(r=this.m_vertices.getShortestDistance(s,n),r<=t)return!0}n=e}s=this.getNextPath(s)}return!1}hasDegenerateSegments3D(t,e){return(0,i.g)(0),!1}transferAllDataToTheVertex(t,e){const s=this.getVertexIndex(t),n=this.getVertexIndex(e);if(this.m_weights){const t=this.getWeightWithIndex(s);this.setWeightWithIndex(n,t)}if(this.m_ranks){const t=this.getRankWithIndex(s);this.setRankWithIndex(n,t)}if(this.m_segmentWeights){const t=this.getSegmentWeightWithIndex(s);this.setSegmentWeightWithIndex(n,t)}if(this.m_segmentRanks){const t=this.getSegmentRankWithIndex(s);this.setSegmentRankWithIndex(n,t)}for(let r=0,o=this.m_indices.length;r<o;r++)if(r!==this.m_selectionIndex&&null!==this.m_indices[r]){const s=this.getUserIndex(t,r);-1!==s&&this.setUserIndex(e,r,s)}const i=this.selected(t);i!==this.selected(e)&&(i?this.select(e):this.unselect(e))}splitSegmentAxisAware(t,e,s,n,r){let o=0;const a=this.getNextVertex(t);a===Sr&&(0,i.t)("");const h=this.getVertexIndex(t),m=this.getVertexIndex(a),l=this.getSegmentFromIndex(h);let u=this.m_vertices.getShortestDistance(h,m);const c=this.getPathFromVertex(t),g=this.m_bHasAttributes;g&&l&&(u=l.calculateLength2D());const d=this.getSegmentParentage(t),_=this.getHelperPoint();if(l){let t=0,i=0,r=Sr;for(let p=0;p<s;p++){const s=e[p];if(t<s&&s<1){const e=l.cut(t,s);if(null!==n&&(p>0&&e.setStartXY(n[p-1]),e.setEndXY(n[p]),e.normalizeAfterEndpointChange(),i=p),g){const t=u>0?l.calculateSubLengthFromStart(s)/u:0;this.m_vertices.interpolateTwoVertices(h,m,t,_)}_.setXY(e.getEndXY()),r=this.insertVertex(c,a,_),o++;const f=this.getPrevVertex(r),P=this.getVertexIndex(f);this.setSegmentToIndex(P,e),-1!==d&&this.setSegmentParentageAndBreak(r,d,!1),t=s}}if(r!==Sr){const e=l.cut(t,1);null!==n&&(e.setStartXY(n[i]),e.normalizeAfterEndpointChange());const s=this.getVertexIndex(r);this.setSegmentToIndex(s,e)}}else{let t=0;for(let n=0;n<s;n++){const s=e[n];if(t<s&&s<1){this.m_vertices.interpolateTwoVertices(h,m,s,_);const t=this.insertVertex(c,a,_);o++,-1!==d&&this.setSegmentParentageAndBreak(t,d,!1)}t=s}}return o}splitSegment(t,e,s){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;return this.splitSegmentAxisAware(t,e,s,n,-1)}snapControlPoints(t,e,s){this.getNextVertex(t)===Sr&&(0,i.t)("");let n=t,r=!1;for(let i=0;i<e;++i){const t=this.getVertexIndex(n),e=this.getSegmentFromIndex(t);if(e){const t=e.snapControlPoints(s);r||(r=t)}n=this.getNextVertex(n)}return r}snapControlPointsOnSelection(t){if(!this.hasCurves())return!1;let e=0;const s=this.queryVertexIteratorOnSelection();for(let n=s.next();n!==Sr;n=s.next()){const s=this.getVertexIndex(n),i=this.getSegmentFromIndex(s);i&&(e|=i.snapControlPoints(t)?1:0)}return 0!==e}calculateSubLength2D(t,e,s){return(0,i.g)(0),0}setPoint(t,e,s){if(this.setPointOnly(t,e),null!==this.m_segments){const n=this.getVertexIndex(t),i=this.getSegmentFromIndex(n);null!==i&&(i.setStartXY(e.getXY()),i.normalizeAfterEndpointChange(),s&&i.ensureXYMonotone());const r=this.getPrevVertex(t);if(r!==Sr){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);null!==n&&(n.setEndXY(e.getXY()),n.normalizeAfterEndpointChange(),s&&n.ensureXYMonotone())}}}setPointEx(t,e,s,n,i){this.setPoint(t,e,i);const r=this.getVertexIndex(t);this.setWeightWithIndex(r,n),this.setRankWithIndex(r,s)}setPointOnly(t,e){const s=this.getVertexIndex(t);this.m_vertices.setPointByVal(s,e)}setPointOnlyEx(t,e,s,n){(0,i.g)(0)}queryPoint(t,e){const s=this.getVertexIndex(t);this.m_vertices.getPointByVal(s,e)}setXY(t,e){this.setXYCoords(t,e.x,e.y)}setXYCoords(t,e,s){var n;const i=this.getVertexIndex(t);if(null!==(n=this.m_vertices)&&void 0!==n&&n.setXYCoords(i,e,s),null!==this.m_segments){const n=this.getSegmentFromIndex(i);null!==n&&(n.setStartXYCoords(e,s),n.normalizeAfterEndpointChange());const r=this.getPrevVertex(t);if(r!==Sr){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);null!=n&&(n.setEndXYCoords(e,s),n.normalizeAfterEndpointChange())}}}setXYMonotonic(t,e,s){const n=this.getVertexIndex(t);if(this.m_vertices.setXYCoords(n,e,s),null!==this.m_segments){const i=this.getSegmentFromIndex(n);if(null!==i){const t=i.getEndXY();i.setCoordsForIntersector(new o.P(e,s),t,!1),i.ensureXYMonotone()}const r=this.getPrevVertex(t);if(r!==Sr){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);if(null!==n){const t=n.getStartXY();n.setCoordsForIntersector(t,new o.P(e,s),!1),n.ensureXYMonotone()}}}}setXYMonotonicPoint2D(t,e){this.setXYMonotonic(t,e.x,e.y)}queryXY(t,e){const s=this.getVertexIndex(t);return this.m_vertices.queryXY(s,e)}getXY(t){const e=this.getVertexIndex(t);return this.m_vertices.getXY(e)}getXYWithIndex(t){return this.m_xyStream.readPoint2D(2*t)}static setSegDefault(t,e,s){(0,i.g)(0)}setXYZ(t,e,s){(0,i.g)(0)}setXYZCoords(t,e,s,n){(0,i.g)(0)}queryXYZ(t,e){(0,i.g)(0)}getXYZ(t){return(0,i.g)(0),r.h.getNAN()}getXYZWithIndex(t){return(0,i.g)(0),r.h.getNAN()}mergeVertexDescription(t){this.m_verticesMp.mergeVertexDescription(t),this.m_vertexDescription=this.m_verticesMp.getDescription(),this.m_bHasAttributes=this.m_vertexDescription.getAttributeCount()>1}addAttribute(t){(0,i.g)(0)}getAttributeAsDbl(t,e,s){return this.m_vertices.getAttributeAsDbl(t,this.getVertexIndex(e),s)}queryAttributeAsDbl(t,e,s,n){(0,i.g)(0)}setAttribute(t,e,s,n){(0,i.g)(0)}setAttributeInt(t,e,s,n){(0,i.g)(0)}getVertexDescription(){return this.m_vertexDescription}getMinPathVertexY(t){return(0,i.g)(0),0}getVertexIndex(t){return this.m_vertexIndexList.getField(t,0)}getY(t){const e=this.getVertexIndex(t);return this.m_vertices.queryXY(e,this.m_workPoint2D),this.m_workPoint2D.y}getX(t){return this.getXY(t).x}isEqualXY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D)}isEqualXYPoint2D(t,e){return this.queryXY(t,this.m_workPoint2D),this.m_workPoint2D.isEqualPoint2D(e)}isEqualXYZPoint3D(t,e){return(0,i.g)(0),!1}setWeight(t,e){e<1&&(e=1);const s=1===e;if(null==this.m_weights){if(s)return;this.m_weights=(0,r.F)(this.m_vertices.getPointCount(),1)}const n=this.getVertexIndex(t);if(n>=this.m_weights.size()){if(s)return;this.m_weights.resize(n+1,1)}this.m_weights.write(n,e)}setWeightWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_weights){if(s)return;this.m_weights=(0,r.F)(this.m_vertices.getPointCount(),1)}if(t>=this.m_weights.size()){if(s)return;this.m_weights.resize(t+1,1)}this.m_weights.write(t,e)}getWeight(t){if(null===this.m_weights)return 1;const e=this.getVertexIndex(t);return e>=this.m_weights.size()?1:this.m_weights.read(e)}getWeightWithIndex(t){return null===this.m_weights||t>=this.m_weights.size()?1:this.m_weights.read(t)}getRank(t){if(null===this.m_ranks)return vr;const e=this.getVertexIndex(t);return e>=this.m_ranks.size()?vr:this.m_ranks.read(e)}getRankWithIndex(t){return null===this.m_ranks||t>=this.m_ranks.size()?vr:this.m_ranks.read(t)}setRank(t,e){e<vr&&(e=vr);const s=e===vr;if(null===this.m_ranks){if(s)return;this.m_ranks=(0,r.z)(this.m_vertices.getPointCount(),vr)}const n=this.getVertexIndex(t);if(n>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(n+1,vr)}this.m_ranks.write(n,e)}setRankWithIndex(t,e){e<vr&&(e=vr);const s=e===vr;if(null===this.m_ranks){if(s)return;this.m_ranks=(0,r.z)(this.m_vertices.getPointCount(),vr)}if(t>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(t+1,vr)}this.m_ranks.write(t,e)}setSegmentWeight(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_segmentWeights){if(s)return;this.m_segmentWeights=(0,r.F)(this.m_vertices.getPointCount(),1)}const n=this.getVertexIndex(t);if(n>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(n+1,1)}this.m_segmentWeights.write(n,e)}setSegmentWeightWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null==this.m_segmentWeights){if(s)return;this.m_segmentWeights=(0,r.F)(this.m_vertices.getPointCount(),1)}if(t>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(t+1,1)}this.m_segmentWeights.write(t,e)}getSegmentWeight(t){if(null===this.m_segmentWeights)return 1;const e=this.getVertexIndex(t);return e>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(e)}getSegmentWeightWithIndex(t){return null==this.m_segmentWeights||t>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(t)}getSegmentRank(t){if(null===this.m_segmentRanks)return Dr.st_defaultRank;const e=this.getVertexIndex(t);return e>=this.m_segmentRanks.size()?Dr.st_defaultRank:this.m_segmentRanks.read(e)}getSegmentRankWithIndex(t){return null===this.m_segmentRanks||t>=this.m_segmentRanks.size()?vr:this.m_segmentRanks.read(t)}setSegmentRank(t,e){e<vr&&(e=vr);const s=e===vr;if(null===this.m_segmentRanks){if(s)return;this.m_segmentRanks=(0,r.z)(this.m_vertices.getPointCount(),vr)}const n=this.getVertexIndex(t);if(n>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(n+1,vr)}this.m_segmentRanks.write(n,e)}setSegmentRankWithIndex(t,e){e<vr&&(e=vr);const s=e===vr;if(null===this.m_segmentRanks){if(s)return;this.m_segmentRanks=(0,r.z)(this.m_vertices.getPointCount(),vr)}if(t>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(t+1,vr)}this.m_segmentRanks.write(t,e)}removeWeights(){this.m_weights=null,this.m_segmentWeights=null}removeRanks(){this.m_ranks=null,this.m_segmentRanks=null}setUserIndex(t,e,s){const n=this.m_indices[e],i=this.getVertexIndex(t);if(n.size()<=i){if(-1===s)return;n.resize(this.m_vertices.getPointCount(),-1)}n.write(i,s)}getUserIndex(t,e){const s=this.getVertexIndex(t),n=this.m_indices[e];return s<n.size()?n.read(s):-1}addToUserIndex(t,e,s){const n=this.m_indices[e],i=this.getVertexIndex(t);n.size()<=i&&n.resize(this.m_vertices.getPointCount(),-1);const r=n.read(i);n.write(i,r+s)}createUserIndex(){for(let e=0;e<this.m_indices.length;e++)if(null===this.m_indices[e])return this.m_indices[e]=this.allocateIndex(),e;this.m_indices.push(this.allocateIndex());const t=this.m_indices.length-1;return(0,i.g)(t>=0&&t<=(0,o.i)()),t}createUserIndexUninitialized(){for(let e=0;e<this.m_indices.length;e++)if(null===this.m_indices[e])return this.m_indices[e]=this.allocateIndex(!1),e;this.m_indices.push(this.allocateIndex(!1));const t=this.m_indices.length-1;return(0,i.g)(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillUserIndexForGeometry(t,e,s){const n=this.m_indices[e],i=n.size();for(let r=this.getFirstPath(t);r!==Sr;r=this.getNextPath(r)){let t=this.getFirstVertex(r);for(let e=0,o=this.getPathSize(r);e<o;e++,t=this.getNextVertex(t)){const e=this.getVertexIndex(t);e<i&&n.write(e,s)}}}fillUserIndexForSelection(t,e){(0,i.g)(0)}removeUserIndex(t){for(this.recycleUserIndex(this.m_indices[t]),this.m_indices[t]=null;this.m_indices.length>0&&null===this.m_indices[this.m_indices.length-1];)this.m_indices.pop()}replaceCurveWithLine(t){if(null!==this.m_segments){const e=this.getVertexIndex(t);this.setSegmentToIndex(e,null)}}queryLineConnector(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=this.getNextVertex(t);if(n===Sr)return!1;if(!this.m_bHasAttributes||s){const s=this.getXY(t);e.setStartXY(s);const i=this.getXY(n);e.setEndXY(i)}else{const s=new r.P({vd:this.getVertexDescription()});this.queryPoint(t,s),e.setStart(s),this.queryPoint(n,s),e.setEnd(s)}return!0}queryLineConnector3D(t,e){return(0,i.g)(0),!1}hasCurves(){return null!==this.m_segments}geometryHasCurves(t){return(0,i.g)(0),!1}pathHasCurves(t){if(!this.hasCurves())return!1;const e=this.getFirstVertex(t);if(e===Sr)return!1;const s=this.getPathSize(t);let n=e;for(let r=0;r<s;r++,n=this.getNextVertex(n)){const t=this.getSegment(n);if(null!==t&&t.getGeometryType()!==i.G.enumLine)return!0}return!1}insertPath(t,e){let s=Sr;e!==Sr?(t!==this.getGeometryFromPath(e)&&(0,i.t)(""),s=this.getPrevPath(e)):s=this.getLastPath(t);const n=this.newPath(t);return e!==Sr&&this.setPrevPath(e,n),this.setNextPath(n,e),this.setPrevPath(n,s),s!==Sr?this.setNextPath(s,n):this.setFirstPath(t,n),e===Sr&&this.setLastPath(t,n),this.setGeometryPathCount(t,this.getPathCount(t)+1),n}removePath(t){const e=this.getPrevPath(t),s=this.getNextPath(t),n=this.getGeometryFromPath(t);return e!==Sr?this.setNextPath(e,s):this.setFirstPath(n,s),s!==Sr?this.setPrevPath(s,e):this.setLastPath(n,e),this.clearPath(t),this.setGeometryPathCount(n,this.getPathCount(n)-1),this.freePath(t),s}clearPath(t){const e=this.getFirstVertex(t);if(e!==Sr){let s=e;for(let e=0,i=this.getPathSize(t);e<i;e++){const t=s;s=this.getNextVertex(s),this.freeVertex(t)}const n=this.getGeometryFromPath(t);this.setGeometryVertexCount(n,this.getPointCount(n)-this.getPathSize(t))}this.setPathSize(t,0)}getNextPath(t){return this.m_pathIndexList.getField(t,2)}getPrevPath(t){return this.m_pathIndexList.getField(t,1)}getPathSize(t){return this.m_pathIndexList.getField(t,3)}isClosedPath(t){return!!(1&this.getPathFlags(t))}setClosedPath(t,e){if(this.isClosedPath(t)===e)return;if(this.getPathSize(t)>0){const s=this.getFirstVertex(t),n=this.getLastVertex(t);if(e){this.setNextVertex(n,s),this.setPrevVertex(s,n);const t=this.getVertexIndex(n);this.setSegmentToIndex(t,null)}else{this.setNextVertex(n,Sr),this.setPrevVertex(s,Sr);const t=this.getVertexIndex(n);this.setSegmentToIndex(t,null)}}const s=(1|this.getPathFlags(t))-1;this.setPathFlags(t,s|(e?1:0))}closeAllPaths(t){(0,i.g)(0)}isStrongPathStart(t){return!!(8&this.getPathFlags(t))}isStrongPathEnd(t){return!!(16&this.getPathFlags(t))}setStrongPathStart(t,e){const s=(8|this.getPathFlags(t))-8;this.setPathFlags(t,s|(e?8:0))}setStrongPathEnd(t,e){const s=(16|this.getPathFlags(t))-16;this.setPathFlags(t,s|(e?16:0))}getGeometryFromPath(t){return this.m_pathIndexList.getField(t,7)}isExterior(t){return!!(2&this.getPathFlags(t))}setExterior(t,e){const s=(2|this.getPathFlags(t))-2;this.setPathFlags(t,s|(e?2:0))}getRingArea(t){if(this.isRingAreaValid(t))return this.m_pathAreas[this.getPathIndex(t)];const e=this.getFirstVertex(t);if(e===Sr)return 0;const s=this.getXY(e),n=new o.K(0),r=this.getPathSize(t);if(r>2){const t=s.clone(),i=t.x,a=t.y;let h=this.getNextVertex(e);const m=this.getXY(h);h=this.getNextVertex(h);const l=o.P.getNAN();for(let e=2;e<r;e++,h=this.getNextVertex(h))this.queryXY(h,l),n.pe((l.x-t.x)*(m.y-a)),t.setCoordsPoint2D(m),m.setCoordsPoint2D(l);n.pe((i-t.x)*(m.y-a))}if(this.hasCurves()){let t=e;for(let e=0;e<r;e++,t=this.getNextVertex(t)){const e=this.getSegment(t);if(null===e||e.getGeometryType()===i.G.enumLine)continue;const s=2*e.calculateArea2DHelper();n.pe(s)}}this.setRingAreaValid(t,!0);const a=.5*n.getResult();return this.m_pathAreas[this.getPathIndex(t)]=a,a}getPathIndexInternal(t){return this.getPathIndex(t)}getPathInternalIndexFromVertex(t){return this.getPathIndex(this.getPathFromVertex(t))}setPathUserIndex(t,e,s){const n=this.m_pathindices[e],i=this.getPathIndex(t);n.size()<this.m_pathAreas.length&&n.resize(this.m_pathAreas.length,-1),n.write(i,s)}getPathUserIndex(t,e){const s=this.getPathIndex(t),n=this.m_pathindices[e];return s<n.size()?n.read(s):-1}createPathUserIndex(){for(let e=0;e<this.m_pathindices.length;e++)if(null===this.m_pathindices[e])return this.m_pathindices[e]=this.allocatePathIndex(),e;this.m_pathindices.push(this.allocatePathIndex());const t=this.m_pathindices.length-1;return(0,i.g)(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillPathUserIndexForGeometry(t,e,s){const n=this.m_pathindices[e],i=n.size();for(let r=this.getFirstPath(t);r!==Sr;r=this.getNextPath(r)){const t=this.getPathIndex(r);t<i&&n.write(t,s)}}removePathUserIndex(t){for(this.recyclePathUserIndex(this.m_pathindices[t]),this.m_pathindices[t]=null;this.m_pathindices.length>0&&null===this.m_pathindices.at(-1);)this.m_pathindices.pop()}movePath(t,e,s){if(s===Sr&&(0,i.t)(""),e===s)return;const n=this.getNextPath(s);let r=this.getPrevPath(s);const o=this.getGeometryFromPath(s);r===Sr?this.setFirstPath(o,n):this.setNextPath(r,n),n===Sr?this.setLastPath(o,r):this.setPrevPath(n,r),this.setGeometryVertexCount(o,this.getPointCount(o)-this.getPathSize(s)),this.setGeometryPathCount(o,this.getPathCount(o)-1),r=e===Sr?this.getLastPath(t):this.getPrevPath(e),this.setPrevPath(s,r),this.setNextPath(s,e),e===Sr?this.setLastPath(t,s):this.setPrevPath(e,s),r===Sr?this.setFirstPath(t,s):this.setNextPath(r,s),this.setGeometryVertexCount(t,this.getPointCount(t)+this.getPathSize(s)),this.setGeometryPathCount(t,this.getPathCount(t)+1),this.setPathGeometry(s,t)}addVertex(t,e){return this.m_vertices.getPointByVal(this.getVertexIndex(e),this.getHelperPoint()),this.insertVertex_(t,Sr,this.getHelperPoint(),!1)}insertVertex(t,e,s){return this.insertVertex_(t,e,s,!0)}removeVertex(t,e){const s=this.getPathFromVertex(t),n=this.getPrevVertex(t),i=this.getNextVertex(t);n!==Sr&&this.setNextVertex(n,i);const r=this.getPathSize(s);if(t===this.getFirstVertex(s)&&this.setFirstVertex(s,r>1?i:Sr),i!==Sr&&this.setPrevVertex(i,n),t===this.getLastVertex(s)&&this.setLastVertex(s,r>1?n:Sr),this.hasCurves()&&n!==Sr&&i!==Sr){const s=this.getVertexIndex(t),r=this.getVertexIndex(n),o=this.getVertexIndex(i);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(s,null)}else{const t=this.getSegmentFromIndex(s);if(this.setSegmentToIndex(s,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}this.setPathSize(s,r-1);const o=this.getGeometryFromPath(s);return this.setGeometryVertexCount(o,this.getPointCount(o)-1),this.freeVertex(t),i}removeVertices(t,e){(0,i.g)(t!==e);const s=this.getPathFromVertex(t),n=this.getPrevVertex(t),r=this.getPrevVertex(e);n!==Sr&&this.setNextVertex(n,e);let o=this.getPathSize(s);const a=this.getVertexIndex(t);this.setSegmentToIndex(a,null),this.setPrevVertex(e,n),this.setPrevVertex(t,Sr),this.setNextVertex(r,Sr);let h=0,m=t;const l=this.getFirstVertex(s);let u=!1;for(;;){const t=this.getNextVertex(m);if(u||(u=l===m),this.freeVertex(m),h++,m===r)break;m=t}o-=h,u&&this.setFirstVertex(s,o>0?e:Sr),this.setPathSize(s,o);const c=this.getGeometryFromPath(s);this.setGeometryVertexCount(c,this.getPointCount(c)-h)}getFirstVertex(t){return this.m_pathIndexList.getField(t,4)}getLastVertex(t){return this.m_pathIndexList.getField(t,5)}getNextVertex(t){return this.m_vertexIndexList.getField(t,2)}getPrevVertex(t){return this.m_vertexIndexList.getField(t,1)}getNextVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,2):this.m_vertexIndexList.getField(t,1)}getPrevVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,1):this.m_vertexIndexList.getField(t,2)}getPathFromVertex(t){return this.m_vertexIndexList.getField(t,3)}addPoint(t,e){return this.insertVertex_(t,Sr,e,!1)}getGeometryFromVertex(t){return this.getGeometryFromPath(this.getPathFromVertex(t))}replaceNaNs(t,e){this.m_vertexDescription.hasAttribute(t)||(0,i.c)(""),this.m_vertices.replaceNaNs(t,e)}removeNaNVertices(){for(let t=this.getFirstGeometry();t!==Sr;t=this.getNextGeometry(t))for(let e=this.getFirstPath(t);e!==Sr;e=this.getNextPath(e)){let t=this.getFirstVertex(e);for(let s=0,n=this.getPathSize(e);s<n;s++)t=this.getXY(t).isFinite()?this.getNextVertex(t):this.removeVertex(t,!0)}}queryVertexIterator(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Sr;return this.queryVertexIteratorEx(!1,t)}queryVertexIteratorEx(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Sr,s=Sr,n=Sr,r=Sr,o=Sr,a=0,h=!1;for(s=e!==Sr?e:this.getFirstGeometry();s!==Sr;s=this.getNextGeometry(s))if(!t||(0,i.h)(this.getGeometryType(s))){for(n=this.getFirstPath(s);n!==Sr;n=this.getNextPath(n))if(r=this.getFirstVertex(n),o=r,a=0,r!==Sr){h=!0;break}if(h||e!==Sr)break}return h||(s=Sr),Ir.create_(this,s,n,r,o,a,t,!1,e!==Sr)}queryVertexIteratorOnSelection(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Sr;return this.m_selection?Ir.create_(this,t,Sr,Sr,Sr,-1,!1,!0,t!==Sr):this.queryVertexIteratorEx(!1,t)}hasSelection(){return this.m_selection}createEmptySelection(){(0,i.g)(0)}removeSelection(){this.m_selection&&(this.m_selectedVertices.length=0,this.removeUserIndex(this.m_selectionIndex),this.m_selectionIndex=-1,this.m_selection=!1,this.m_selectedCount=0)}select(t){return!!this.selected(t)||(this.setUserIndex(t,this.m_selectionIndex,this.m_selectedVertices.length),this.m_selectedVertices.push(t),this.m_selectedCount++,!1)}unselect(t){if(!this.m_selection)return;const e=this.getUserIndex(t,this.m_selectionIndex);e>=0&&(this.m_selectedVertices[e]=Sr,this.setUserIndex(t,this.m_selectionIndex,-1),this.m_selectedCount--)}selected(t){return!this.m_selection||this.selected_(t)}getSelectedCount(){return this.m_selection?this.m_selectedCount:this.getTotalPointCount()}createSelectionForCrackingAndClustering(t,e){return(0,i.g)(0),!1}peelALoop(t,e){this.peelALoop_(t,e,!1)}peelALoopIntoAPath(t,e){return this.peelALoop_(t,e,!0)}applyTransformation(t){if(this.m_verticesMp.applyTransformation(t),null!==this.m_segments)for(let e=0,s=this.m_segments.length;e<s;e++)this.m_segments[e]&&this.m_segments[e].applyTransformation(t)}setGeometryType(t,e){this.m_geometryIndexList.setField(t,2,e)}splitSegmentWithIntersector(t,e,s,n,i){n?this.splitSegmentForward(t,e,s,!0,i):this.splitSegmentBackward(t,e,s,!0,i)}setPrevVertex(t,e){this.m_vertexIndexList.setField(t,1,e)}setNextVertex(t,e){this.m_vertexIndexList.setField(t,2,e)}setPathToVertex(t,e){this.m_vertexIndexList.setField(t,3,e)}setPathSize(t,e){this.m_pathIndexList.setField(t,3,e)}setFirstVertex(t,e){this.m_pathIndexList.setField(t,4,e)}setLastVertex(t,e){this.m_pathIndexList.setField(t,5,e)}getSegment(t){if(null!=this.m_segments){const e=this.getVertexIndex(t);return this.getSegmentFromIndex(e)}return null}isCurve(t){return(0,i.g)(0),!1}querySegment(t,e){let s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const i=this.getNextVertex(t);if(i===Sr)return!1;const r=this.getSegment(t);if(!r)return!s&&(this.queryLineConnector(t,e.createLine(),n),!0);if(e.copyFrom(r,!0),n)return!0;if(this.m_vertexDescription.getAttributeCount()>1){const s=this.getHelperPoint();this.queryPoint(t,s),e.get().setStart(s),this.queryPoint(i,s),e.get().setEnd(s)}return!0}getSegmentFromIndex(t){return(null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null)||null}getAndClearSegmentFromIndex(t){return(null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null)||null}setSegmentToIndex(t,e){if(this.m_hasForceSetEnvelope=0,null===this.m_segments){if(!e)return;this.m_segments=[],this.m_segments.length=this.m_vertices.getPointCount()}t>=this.m_segments.length&&(this.m_segments.length=t+1),this.m_segments[t]=e}setGeometryPathCount(t,e){this.m_geometryIndexList.setField(t,6,e)}setGeometryVertexCount(t,e){this.m_geometryIndexList.setField(t,5,e)}ringParentageCheckInternal(t,e){return(0,i.g)(0),!1}reverseRingInternal(t){const e=this.hasCurves(),s=this.hasSegmentParentage();let n=null,i=-1,r=t;if(e){const t=this.getVertexIndex(r);n=this.getAndClearSegmentFromIndex(t)}s&&(i=this.getSegmentParentage(r));do{const t=this.getPrevVertex(r),o=this.getNextVertex(r);if(this.setNextVertex(r,t),this.setPrevVertex(r,o),e){const t=this.getVertexIndex(o),e=this.getSegmentFromIndex(t);n&&n.reverse(),this.setSegmentToIndex(t,n),n=e}if(s){const t=this.getSegmentParentage(o);this.setSegmentParentagePreserveBreak(o,i),i=t}r=o}while(r!==t);this.dbgVerifyIntegrity(t)}setTotalPointCount(t){this.m_pointCount=t}removePathOnly(t){const e=this.getPrevPath(t),s=this.getNextPath(t),n=this.getGeometryFromPath(t);e!==Sr?this.setNextPath(e,s):this.setFirstPath(n,s),s!==Sr?this.setPrevPath(s,e):this.setLastPath(n,e),this.setFirstVertex(t,Sr),this.setLastVertex(t,Sr),this.freePath(t)}insertClosedPath(t,e,s,n,i){const r=this.insertPath(t,Sr);let o=0,a=s;for(i[0]=!1;;){a===n&&(i[0]=!0),this.setPathToVertex(a,r),o++;const t=this.getNextVertex(a);if(t===s)break;a=t}return this.setClosedPath(r,!0),this.setPathSize(r,o),i[0]&&(s=n),this.setFirstVertex(r,s),this.setLastVertex(r,this.getPrevVertex(s)),this.setRingAreaValid(r,!1),r}findVertex2D(t,e){return(0,i.g)(0),0}findVertex3D(t,e,s){return(0,i.g)(0),0}dbgVerifyMonotone(){}dbgCheckSelection(){}dbgVerifySegment(t){}dbgVerifyIntegrity(t){}dbgVerifyVertexCounts(){}dbgVerifyCurves(){}dbgDumpGeometry(t,e){}removeVertexInternal(t,e){const s=this.getPrevVertex(t),n=this.getNextVertex(t);if(s!==Sr&&this.setNextVertex(s,n),n!==Sr&&this.setPrevVertex(n,s),this.hasCurves()&&s!==Sr&&n!==Sr){const i=this.getVertexIndex(t),r=this.getVertexIndex(s),o=this.getVertexIndex(n);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(i,null)}else{const t=this.getSegmentFromIndex(i);if(this.setSegmentToIndex(i,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}return this.freeVertex(t),n}isRingAreaValid(t){return!!(4&this.getPathFlags(t))}setRingAreaValid(t,e){const s=(4|this.getPathFlags(t))-4;this.setPathFlags(t,s|(e?4:0))}compareVerticesSimpleY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.compare(this.m_workPoint2_2D)}compareVerticesSimpleY3D(t,e){return this.getXYZ(t).compare(this.getXYZ(e))}compareVerticesSimpleX(t,e){return this.getXY(t).compareX(this.getXY(e))}sortVerticesSimpleByYHeapMerge(t,e){(0,i.g)(0)}sortVerticesSimpleByY(t,e,s){this.m_bucketSort.sort(t,e,s,new br(this))}sortVerticesSimpleByX(t,e,s){(0,i.g)(0)}sortVerticesSimpleByY3D(t,e,s){(0,i.g)(0)}snapVertexForPoleClipping(t,e){const s=this.getPrevVertex(t);s!==Sr&&this.replaceCurveWithLine(s),this.getNextVertex(t)!==Sr&&this.replaceCurveWithLine(t);const n=new o.P;this.queryXY(t,n),n.y=e,this.setXY(t,n)}setSegmentParentageAndBreak(t,e){let s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(-1===this.m_segmentParentageIndex){if(-1===e)return;this.m_segmentParentageIndex=this.createUserIndex()}e>=0&&((0,i.g)(e<=(0,o.j)()>>1),e<<=1,e|=s?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,e)}setSegmentParentagePreserveBreak(t,e){if((0,i.g)(e>=-1),-1===this.m_segmentParentageIndex){if(-1===e)return;this.m_segmentParentageIndex=this.createUserIndex()}e>=0&&((0,i.g)(e<=(0,o.j)()>>1),e<<=1,e|=this.getSegmentParentageBreakVertex(t)?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,e)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0?e:e>>1}getOriginalSegmentInfo(t){if(-1!==this.m_segmentParentageIndex){const e=this.getSegmentParentage(t);return new wr(e)}return new wr(-1)}setSegmentParentageBreakVertex(t,e){if(-1===this.m_segmentParentageIndex)return;let s=this.getUserIndex(t,this.m_segmentParentageIndex);s<0||!!(1&s)!==e&&(e?s|=1:s&=(0,o.j)()>>1<<1,this.setUserIndex(t,this.m_segmentParentageIndex,s))}getSegmentParentageBreakVertex(t){if(-1===this.m_segmentParentageIndex)return!0;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0||!!(1&e)}isDiscontinuousSegmentParentage(t){const e=this.getPrevVertex(t);return e!==Sr&&this.getSegmentParentage(e)!==this.getSegmentParentage(t)}setCurveStitcherPointer(t){this.m_curveStitcher=t}hasSegmentParentage(){return-1!==this.m_segmentParentageIndex}deleteSegmentParentage(){-1!==this.m_segmentParentageIndex&&(this.removeUserIndex(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),this.m_curveStitcher=null}clearSegments(){this.m_segments=null}}function Tr(t){if(t.isEmpty())return new yi({vd:t.getDescription()});const e=t.getImpl(),s=e.getPointCount();if(s<=2){if(1===s||e.getXY(0).equals(e.getXY(1))){const t=new r.P({vd:e.getDescription()});return e.getPointByVal(0,t),t}{const t=new r.P,s=new ei({vd:e.getDescription()});return e.getPointByVal(0,t),s.startPathPoint(t),e.getPointByVal(1,t),s.lineToPoint(t),s}}const n=e.getAttributeStreamRef(0),i=new Fr({stream:n,n:s});let a=1;const h=n.readPoint2D(0),m=new o.P;for(;a<s&&n.queryPoint2D(a<<1,m).equals(h);)a++;if(i.m_treeHull.addElement(0),a<s){i.m_treeHull.addBiggestElement(a);const t=new o.P;for(let s=a+1;s<e.getPointCount();s++){n.queryPoint2D(s<<1,t);const e=i.treeHull(t);-1!==e&&i.m_treeHull.setElement(e,s)}}const l=e.getDescription(),u=l.getAttributeCount()>1,c=i.m_treeHull.size();let g=null;if(c>=2){g=c>=3?new yi({vd:l}):new ei({vd:l});const t=g.getImpl();t.reserve(i.m_treeHull.size()),t.addPathPoint2D(null,0,!0);const s=new o.P;for(let o=i.m_treeHull.getFirst();-1!==o;o=i.m_treeHull.getNext(o))if(u){const s=new r.P;e.getPointByVal(i.m_treeHull.getElement(o),s),t.insertPoint(0,-1,s)}else n.queryPoint2D(i.m_treeHull.getElement(o)<<1,s),t.insertPoint2D(0,-1,s)}else if(u){const t=new r.P({vd:l});e.getPointByVal(i.m_treeHull.getElement(i.m_treeHull.getFirst()),t),g=t}else{const t=n.readPoint2D(i.m_treeHull.getElement(i.m_treeHull.getFirst())<<1);g=new r.P(t)}return g}function Nr(t,e,s){if(e<=262144)return function(t,e,s){const n=new r.A(0);for(let r=0;r<e;r++)n.add(r);const i={userSort(e,s,n){n.sort(e,s,((e,s)=>t[e].compareX(t[s])))},getValue:e=>t[e].x};r.B.sortEx(n,0,e,i);let o=0;t:for(let r=0;r<e;++r){const e=n.read(r);for(;o>=2;){const i=s[o-2],a=s[o-1];if(t[a].equals(t[e])){n.write(r,-1);continue t}if(!(qr(t[i],t[a],t[e])>=0)){a===n.read(r-1)&&n.write(r-1,-1);break}o--}s[o++]=e,2===o&&t[e].equals(t[s[0]])&&(n.write(1,-1),o--)}const a=o+1;t:for(let r=e-2;r>=0;--r){const e=n.read(r);if(!(e<0)){for(;o>=a;){const n=s[o-2],i=s[o-1];if(t[i].equals(t[e]))continue t;if(!(Vr(t[n],t[i],t[e])>=0))break;o--}if(0!==r){const n=s[o-1];s[o++]=e,t[e].equals(t[n])&&o--}}}return o>1&&t[s[0]].equals(t[s[o-1]])&&o--,o}(t,e,s);(0,i.g)(0);const n=new Fr({points:t,n:e});let o=1;const a=t[0].clone();for(;o<e&&t[o].equals(a);)o++;if(n.m_treeHull.addElement(0),o<e){n.m_treeHull.addBiggestElement(o);for(let s=o+1;s<e;s++){const e=t[s],i=n.treeHull(e);-1!==i&&n.m_treeHull.setElement(i,s)}}let h=0;for(let i=n.m_treeHull.getFirst();-1!==i;i=n.m_treeHull.getNext(i))s[h++]=n.m_treeHull.getElement(i);return h}function Ar(t,e,s){const n=t.getImpl(),i=n.getPathStart(e),r=n.getPathEnd(e),a=!n.isClosedPath(e)&&n.isClosedPathInXYPlane(e),h=n.getAttributeStreamRef(0),m=2*i;let l=2*r;if(a&&(l-=2),l-m<6)return!0;const u=h.readPoint2D(m),c=h.readPoint2D(m+2),g=h.readPoint2D(m+4);if(!Yr(o.P.orientationRobust(c,g,u)))return!1;const d=c.clone(),_=new o.P;for(let p=m+6;p<l;p+=2){if(_.assign(c),c.assign(g),h.queryPoint2D(p,g),!Yr(o.P.orientationRobust(c,g,u)))return!1;if(!Yr(o.P.orientationRobust(d,g,u)))return!1;if(!Yr(o.P.orientationRobust(c,g,_)))return!1}return!0}function Gr(t,e,s,n,r){if(s.setNAN(),n.setCoords(1,0),r.setCoords(0,0),t.isEmpty())return;if(t.getGeometryType()===i.G.enumPoint)return void s.assign(t.getXY());const a=t,h=a.getPointCount();if(2===h){const t=a.getXY(0),e=a.getXY(1);s.assign(t.add(e).mul(.5));const i=e.sub(t);n=Rr(i),r.setCoords(.5*i.length(),0)}else{let t=Number.MAX_VALUE;const i=[0,1,0,0],m=new o.ai(4,2);for(m.set(0,0,0),m.set(0,1,1),m.set(1,0,1),m.set(1,1,2);i[0]<h;++i[0],Hr(m,0,h)){i[1]===i[0]&&(++i[1],Hr(m,1,h));for(let t=1;;++t){for(;;){const e=Lr(a.getXY(m.get(0,0)),a.getXY(m.get(0,1)),a.getXY(m.get(t,0)),a.getXY(m.get(t,1)),2^t);if(e>0)break;if(++i[t],Hr(m,t,h),0===e)break}if(3===t)break;i[t+1]<i[t]&&(i[t+1]=i[t],m.set(t+1,0,m.get(t,0)),m.set(t+1,1,m.get(t,1)))}const l=a.getXY(m.get(0,0)).add(a.getXY(m.get(2,0))).mul(.5),u=Rr(a.getXY(m.get(0,1)).sub(a.getXY(m.get(0,0)))),c=new o.P;let g,d;if(c.x=Math.max(0,u.dotProduct(a.getXY(m.get(1,0)).sub(a.getXY(m.get(3,0))))),c.y=Math.max(0,u.crossProduct(a.getXY(m.get(0,0)).sub(a.getXY(m.get(2,0))))),e?(g=c.x*c.y,d=g<t):(g=c.y,d=g<t),d){t=g;const e=a.getXY(m.get(1,0)),i=a.getXY(m.get(3,0)),o=e.add(i).mul(.5).sub(l);s.assign(l.add(u.mul(u.dotProduct(o)))),n.assign(u),r.assign(c)}}r.mulThis(.5),r.x<r.y&&(r.y=(0,o.b)(r.x,r.x=r.y),n.leftPerpendicularThis())}n.y<0?n.negateThis():0===n.y&&(n.x=1)}Dr.st_defaultRank=1;class Mr{constructor(t){this.m_handleP=-1,this.m_handleQ=-1,this.m_currentSupport=-1,this.m_area=0,this.m_bDone=!0,(0,i.g)(0),this.m_convexHull=t,this.m_function=this.done_}next(){return(0,i.g)(0),!1}get_vertex_handle_p(){return(0,i.g)(0),0}get_vertex_handle_q(){return(0,i.g)(0),0}get_current_support(){return(0,i.g)(0),0}getNext(t){return(0,i.g)(0),0}getPrev(t){return(0,i.g)(0),0}intialize_(){return(0,i.g)(0),!1}increment_(){return(0,i.g)(0),!1}increment_q_(){return(0,i.g)(0),!1}increment_p_(){return(0,i.g)(0),!1}parallel_edge_with_q_support_(){return(0,i.g)(0),!1}parallel_edge_with_p_support_(){return(0,i.g)(0),!1}done_(){return(0,i.g)(0),!1}}class Fr{nullGetXY(t){return(0,i.c)("m_getXY is null"),{}}nullDeleteNode(t){(0,i.c)("m_deleteNode is null")}constructor(t){return this.m_treeHull=new r.T,this.m_shape=null,this.m_stream=null,this.m_points=null,this.m_geometryHandle=-1,this.m_pathHandle=-1,this.m_getXY=this.nullGetXY,this.m_deleteNode=this.nullDeleteNode,t?t.stream?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_stream=t.stream,this.m_getXY=this.getXYStream,this.m_deleteNode=this.deleteNodeStream,this.m_points=null,this.m_geometryHandle=Sr,void(this.m_pathHandle=Sr)):t.points?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_points=t.points,this.m_getXY=this.getXYPoints,this.m_deleteNode=this.deleteNodePoints,this.m_stream=null,this.m_geometryHandle=Sr,void(this.m_pathHandle=Sr)):void(0,i.m)("unrecognized constructor parameter"):(this.m_treeHull.setCapacity(20),this.m_shape=new Dr,this.m_geometryHandle=this.m_shape.createGeometry(i.G.enumMultiPoint),this.m_pathHandle=this.m_shape.insertPath(this.m_geometryHandle,Sr),this.m_getXY=this.getXYShape,this.m_deleteNode=this.deleteNodeShape,this.m_stream=null,void(this.m_points=null))}getXYShape(t){return this.m_shape.getXY(t)}getXYStream(t){return this.m_stream.readPoint2D(t<<1)}getXYPoints(t){return(0,i.g)(0),new o.P}deleteNodeShape(t){const e=this.m_treeHull.getElement(t);this.m_treeHull.deleteNode(t),this.m_shape.removeVertex(e,!1)}deleteNodeStream(t){this.m_treeHull.deleteNode(t)}deleteNodePoints(t){(0,i.g)(0)}addGeometry(t){if(t.isEmpty())return;const e=t.getGeometryType();if(e===i.G.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else(0,i.i)(e)?this.addMultiVertexGeometry(t):(0,i.f)(e)?this.addSegment(t):e===i.G.enumEnvelope?this.addEnvelope(t):e===i.G.enumPoint?this.addPoint(t):(0,i.t)("Convex_hull: geometry not supported")}getBoundingGeometry(){const t=new r.P,e=this.m_treeHull.getFirst(),s=new yi({vd:this.m_shape.getVertexDescription()});if(0===this.m_treeHull.size())return s;s.reserve(this.m_treeHull.size()),this.m_shape.queryPoint(this.m_treeHull.getElement(e),t),s.startPathPoint(t);for(let n=this.m_treeHull.getNext(e);-1!==n;n=this.m_treeHull.getNext(n))this.m_shape.queryPoint(this.m_treeHull.getElement(n),t),s.lineToPoint(t);return s}getAntipodalPairsIterator(){return(0,i.g)(0),new Mr(this)}getXY(t){return(0,i.g)(0),new o.P}getXYWithIndex(t){return(0,i.g)(0),new o.P}getFirst(){return(0,i.g)(0),0}getLast(){return(0,i.g)(0),0}getNext(t){return(0,i.g)(0),0}getPrev(t){return(0,i.g)(0),0}getVertexIndex(t){return(0,i.g)(0),0}getPointCount(){return(0,i.g)(0),0}addMultiVertexGeometry(t){const e=new r.P,s=t.getImpl(),n=new o.P;for(let i=0;i<t.getPointCount();i++){s.queryXY(i,n);const r=this.addPoint2D(n);if(-1!==r){t.getPointByVal(i,e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(r,s)}}}addEnvelope(t){const e=new r.P;for(let s=0;s<4;s++){const n=new o.P;t.queryCorner(s,n);const i=this.addPoint2D(n);if(-1!==i){t.queryCornerByVal(s,e);const n=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(i,n)}}}addSegment(t){const e=new r.P,s=t.getStartXY(),n=this.addPoint2D(s);if(-1!==n){t.queryStart(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(n,s)}const i=t.getEndXY(),o=this.addPoint2D(i);if(-1!==o){t.queryEnd(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(o,s)}}addPoint(t){const e=t.getXY(),s=this.addPoint2D(e);if(-1!==s){const e=this.m_shape.addPoint(this.m_pathHandle,t);this.m_treeHull.setElement(s,e)}}addPoint2D(t){let e=-1;if(0===this.m_treeHull.size())return e=this.m_treeHull.addElement(-4),e;if(1===this.m_treeHull.size()){const s=this.m_treeHull.getElement(this.m_treeHull.getFirst()),n=this.m_shape.getXY(s);return t.equals(n)||(e=this.m_treeHull.addBiggestElement(-5)),e}return e=this.treeHull(t),e}treeHull(t){let e=-1;do{const s=this.m_treeHull.getFirst(),n=this.m_treeHull.getLast(),i=this.m_treeHull.getElement(s),r=this.m_treeHull.getElement(n),a=this.m_getXY(i),h=this.m_getXY(r),m=o.P.orientationRobust(h,t,a);if(Yr(m)){e=this.m_treeHull.addBiggestElement(-1);const i=this.treeHullWalkBackward(t,n,s);i!==s&&this.treeHullWalkForward(t,s,this.m_treeHull.getPrev(i));break}if(Xr(m)){let i=this.m_treeHull.getRoot(),r=this.m_treeHull.getFirst(),h=this.m_treeHull.getLast(),m=-1,l=-1,u=-1;for(;r!==this.m_treeHull.getPrev(h);){l=this.m_treeHull.getElement(i);const e=this.m_getXY(l);Xr(o.P.orientationRobust(e,t,a))?(h=i,i=this.m_treeHull.getLeft(i)):(r=i,i=this.m_treeHull.getRight(i))}i=h,m=r,l=this.m_treeHull.getElement(i),u=this.m_treeHull.getElement(m);const c=this.m_getXY(l),g=this.m_getXY(u);if(m!==s&&!Yr(o.P.orientationRobust(g,t,c)))break;e=this.m_treeHull.addElementAtPosition(m,i,-2,!0,!1),this.treeHullWalkForward(t,i,n),this.treeHullWalkBackward(t,m,s);break}{const i=kr(t,h,a);if(-1===i){const i=this.m_treeHull.getPrev(n);this.m_treeHull.deleteNode(n),e=this.m_treeHull.addBiggestElement(-3),this.treeHullWalkBackward(t,i,s)}else if(1===i){const i=this.m_treeHull.getNext(s);this.m_treeHull.deleteNode(s),e=this.m_treeHull.addElementAtPosition(-1,i,-3,!0,!1),this.treeHullWalkForward(t,i,n)}break}}while(0);return e}treeHullWalkForward(t,e,s){if(e===s)return s;let n=e,i=this.m_treeHull.getElement(n),r=this.m_treeHull.getNext(n);const a=this.m_getXY(i);for(;n!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(r),s=this.m_getXY(e);if(Yr(o.P.orientationRobust(s,t,a)))break;const h=n;n=r,i=e,a.assign(s),r=this.m_treeHull.getNext(n),this.m_deleteNode(h)}return n}treeHullWalkBackward(t,e,s){if(e===s)return s;let n=e,i=this.m_treeHull.getElement(n),r=this.m_treeHull.getPrev(n);const a=this.m_getXY(i);for(;n!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(r),s=this.m_getXY(e);if(Yr(o.P.orientationRobust(a,t,s)))break;const h=n;n=r,i=e,a.assign(s),r=this.m_treeHull.getPrev(n),this.m_deleteNode(h)}return n}}function qr(t,e,s){const n=e.sub(t),i=s.sub(e);if(0===n.x)return i.x>0?-1:0;if(0===n.y)return i.y>0?1:i.y<0?-1:0;const r=n.crossProduct(i),a=4*Number.EPSILON*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>a?1:r<-a?-1:o.P.orientationRobust(t,e,s)}function Vr(t,e,s){const n=e.sub(t),i=s.sub(e);if(0===n.x)return i.x<0?-1:0;if(0===n.y)return i.y>0?-1:i.y<0?1:0;const r=n.crossProduct(i),a=4*Number.EPSILON*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>a?1:r<-a?-1:o.P.orientationRobust(t,e,s)}function Yr(t){return t<0}function Xr(t){return t>0}function kr(t,e,s){let n=-1;n=e.y===s.y?0:e.x===s.x?1:Math.abs(e.x-s.x)>=Math.abs(e.y-s.y)?0:1;let i=-1;return i=e[n]<s[n]?t[n]<e[n]?-1:s[n]<t[n]?1:0:e[n]<t[n]?-1:t[n]<s[n]?1:0,i}function Rr(t){return(t=t.clone()).divThis(Math.max(Math.abs(t.x),Math.abs(t.y))),t.normalize(),t}function Hr(t,e,s){t.inc(e,0)===s&&t.set(e,0,0),t.inc(e,1)===s&&t.set(e,1,0)}function Lr(t,e,s,n,r){switch(r){case 0:break;case 1:e.rightPerpendicularThis(),t.rightPerpendicularThis();break;case 2:e.negateThis(),t.negateThis();break;case 3:e.leftPerpendicularThis(),t.leftPerpendicularThis();break;default:(0,i.t)("")}return o.P.orientationRobustEx(t,e,s,n)}function Br(t,e,s,n,i){return Ur(t,!1,e,s,n,i)}function Ur(t,e,s,n,r,o){const a=s.getGeometryType(),h=n.getGeometryType(),m=Math.max(r,U(s,n));if(a===i.G.enumLine&&h===i.G.enumLine)return at(s,n,m,o);let l=s,u=n,c=s.getStartXY(),g=s.getEndXY();if(c.compare(g)>0&&(l=s.clone().reverse()),c=n.getStartXY(),g=n.getEndXY(),c.compare(g)>0&&(u=n.clone().reverse()),e){if(s.equals(n))return 2;if(function(t,e,s){return(0,i.g)(t.isCurve()||e.isCurve()),!(!t.getStartXY().equals(e.getStartXY())||!A(t,e,0,0,s,2,[0,0],[0,0]))||!(!t.getEndXY().equals(e.getEndXY())||!A(t,e,1,1,s,2,[0,0],[0,0]))||!(!t.getStartXY().equals(e.getEndXY())||!A(t,e,0,1,s,2,[0,0],[0,0]))||!(!t.getEndXY().equals(e.getStartXY())||!A(t,e,1,0,s,2,[0,0],[0,0]))}(s,n,m))return 4}switch(a){case i.G.enumLine:switch(h){case i.G.enumEllipticArc:return _r(t,u,l,m,o);case i.G.enumBezier:return Dn(t,u,l,m,o);case i.G.enumRationalBezier2:return Je(t,u,l,m,o);case i.G.enumBezier2:return Ls(t,u,l,m,o);default:(0,i.c)("")}break;case i.G.enumEllipticArc:switch(h){case i.G.enumLine:return _r(t,l,u,m,o);case i.G.enumEllipticArc:return function(t,e,s,n,i){if(i){if(0!==zr(e,s))return 2}else if(w(e,s))return 1;return 0!==fr(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,l,u,m,o);case i.G.enumBezier:return Tn(t,u,l,m,o);case i.G.enumRationalBezier2:return $e(t,u,l,m,o);case i.G.enumBezier2:return Bs(t,u,l,m,o);default:(0,i.c)("")}break;case i.G.enumBezier:switch(h){case i.G.enumLine:return Dn(t,l,u,m,o);case i.G.enumEllipticArc:return Tn(t,l,u,m,o);case i.G.enumBezier:return function(t,e,s,n,i){if(i){if(0!==zr(e,s))return 2}else if(w(e,s))return 1;return 0!==Fn(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,l,u,m,o);case i.G.enumRationalBezier2:return Nn(t,l,u,m,o);case i.G.enumBezier2:return An(t,l,u,m,o);default:(0,i.c)("")}break;case i.G.enumRationalBezier2:switch(h){case i.G.enumLine:return Je(t,l,u,m,o);case i.G.enumEllipticArc:return $e(t,l,u,m,o);case i.G.enumBezier:return Nn(t,u,l,m,o);case i.G.enumRationalBezier2:return function(t,e,s,n,i){if(i){const n=zr(e,s);if(0!==n){if(t){if(1===n){if(e.m_weights[0]===s.m_weights[0]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[2])return 2}else if(e.m_weights[0]===s.m_weights[2]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[0])return 2;return 4}return 2}}else if(w(e,s))return 1;return 0!==ns(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,l,u,m,o);case i.G.enumBezier2:return ts(t,l,u,m,o);default:(0,i.c)("")}break;case i.G.enumBezier2:switch(h){case i.G.enumLine:return Ls(t,l,u,m,o);case i.G.enumEllipticArc:return Bs(t,l,u,m,o);case i.G.enumBezier:return An(t,u,l,m,o);case i.G.enumRationalBezier2:return ts(t,u,l,m,o);case i.G.enumBezier2:return function(t,e,s,n,i){if(i){if(0!==zr(e,s))return 2}else if(w(e,s))return 1;return 0!==Os(t,e,s,null,null,null,n,null!==i&&void 0!==i&&i,!0,!1)?4:0}(t,l,u,m,o);default:(0,i.c)("")}break;default:(0,i.c)("")}}function zr(t,e){if(!(!(arguments.length>2&&void 0!==arguments[2])||arguments[2])&&!Or(t,e))return 0;const s=t.isLine()&&e.isLine();if(t.getStartXY().equals(e.getStartXY())&&t.getEndXY().equals(e.getEndXY())){const n=1;if(s)return n;const r=t.getGeometryType();if(r!==e.getGeometryType())return 0;if(r===i.G.enumBezier){const s=t,i=e;return s.getControlPoint1().equals(i.getControlPoint1())&&s.getControlPoint2().equals(i.getControlPoint2())?n:0}if(r===i.G.enumEllipticArc)return yr(t,e,!1)?n:0;if(r===i.G.enumRationalBezier2){const s=t,i=e;if(s.getControlPoint1().equals(i.getControlPoint1())&&s.getStandardFormWeight()===i.getStandardFormWeight())return n}else if(r===i.G.enumBezier2){const s=e;if(t.getControlPoint1().equals(s.getControlPoint1()))return n}return 0}if(t.getStartXY().equals(e.getEndXY())&&t.getEndXY().equals(e.getStartXY())){const n=-1;if(s)return n;const r=t.getGeometryType();if(r!==e.getGeometryType())return 0;if(r===i.G.enumBezier){const s=t,i=e;return s.getControlPoint1().equals(i.getControlPoint2())&&s.getControlPoint2().equals(i.getControlPoint1())?n:0}if(r===i.G.enumEllipticArc)return yr(t,e,!0)?n:-1;if(r===i.G.enumRationalBezier2){const s=t,i=e;if(s.getControlPoint1().equals(i.getControlPoint1())&&s.getStandardFormWeight()===i.getStandardFormWeight())return n}else if(r===i.G.enumBezier2){const s=e;if(t.getControlPoint1().equals(s.getControlPoint1()))return n}return 0}return 0}function Or(t,e){const s=t.getGeometryType();return s===e.getGeometryType()&&(s!==i.G.enumEllipticArc||t.projectionBehavior()===e.projectionBehavior())}function Wr(t,e,s,n,r,o,a){!r&&o&&(0,i.t)("");const h=e.getGeometryType(),m=s.getGeometryType(),l=Math.max(a,U(e,s));if(n&&(n.length=0),r&&(r.length=0),o&&(o.length=0),h===i.G.enumLine&&m===i.G.enumLine)return ht(e,s,n,r,o,l,!1,!1);let u=e,c=s,g=e.getStartXY(),d=e.getEndXY(),_=!1,p=!1;g.compare(d)>0&&(u=e.clone(!0).reverse(),_=!0),g=s.getStartXY(),d=s.getEndXY(),g.compare(d)>0&&(c=s.clone(!0).reverse(),p=!0);let f=0;switch(h){case i.G.enumLine:switch(m){case i.G.enumEllipticArc:f=pr(t,c,u,n,o,r,l,!1,!1,!0);break;case i.G.enumBezier:f=Gn(t,c,u,n,o,r,l,!1,!1,!0);break;case i.G.enumRationalBezier2:f=es(t,c,u,n,o,r,l,!1,!1,!0);break;case i.G.enumBezier2:f=Us(t,c,u,n,o,r,l,!1,!1,!0);break;default:(0,i.c)("")}break;case i.G.enumEllipticArc:switch(m){case i.G.enumLine:f=pr(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumEllipticArc:f=fr(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumBezier:f=Mn(t,c,u,n,o,r,l,!1,!1,!0);break;case i.G.enumRationalBezier2:f=ss(t,c,u,n,o,r,l,!1,!1,!0);break;case i.G.enumBezier2:f=zs(t,c,u,n,o,r,l,!1,!1,!0);break;default:(0,i.c)("")}break;case i.G.enumRationalBezier2:switch(m){case i.G.enumLine:f=es(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumEllipticArc:f=ss(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumBezier:f=qn(t,c,u,n,o,r,l,!1,!1,!0);break;case i.G.enumRationalBezier2:f=ns(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumBezier2:f=is(t,u,c,n,r,o,l,!1,!1,!1);break;default:(0,i.c)("")}break;case i.G.enumBezier2:switch(m){case i.G.enumLine:f=Us(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumEllipticArc:f=zs(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumBezier:f=Vn(t,c,u,n,o,r,l,!1,!1,!0);break;case i.G.enumRationalBezier2:f=is(t,c,u,n,o,r,l,!1,!1,!0);break;case i.G.enumBezier2:f=Os(t,u,c,n,r,o,l,!1,!1,!1);break;default:(0,i.c)("")}break;case i.G.enumBezier:switch(m){case i.G.enumLine:f=Gn(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumEllipticArc:f=Mn(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumBezier:f=Fn(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumRationalBezier2:f=qn(t,u,c,n,r,o,l,!1,!1,!1);break;case i.G.enumBezier2:f=Vn(t,u,c,n,r,o,l,!1,!1,!1);break;default:(0,i.c)("")}break;default:(0,i.c)("")}if(_){if(r){for(let t=0;t<f;t++)r[t]=1-r[t];r.reverse()}n&&n.reverse(),o&&o.reverse()}if(p&&o)for(let i=0;i<f;i++)o[i]=1-o[i];return f}function jr(t,e,s){return e===s?0:(e>s&&(s=(0,o.b)(e,e=s)),t.cut(e,s,!0).calculateUpperLength2D())}function Zr(t,e,s,n,i,r,a,h,m,l,u,c,g){if(!r)return 0;const d=(t,e)=>{for(let s=0;s<r;++s){let n=e[s];if((0,o.J)(n,0,1)){n=(0,o.al)(n);continue}const i=t.getCoord2D(n);n<.5?i.equals(t.getStartXY())&&jr(t,0,n)<=B(t)&&(e[s]=0):i.equals(t.getEndXY())&&jr(t,n,1)<=B(t)&&(e[s]=1)}};d(e,n),d(s,i),function(t,e,s,n,i){const r=[],a=[],h=[];for(let l=0,u=i;l<u;l++)r.push(t.calculateSubLengthFromStart(s[l])),a.push(e.calculateSubLengthFromStart(n[l])),(0,o.J)(s[l],0,1)&&(0,o.J)(n[l],0,1)&&t.getCoord2D(s[l]).equals(e.getCoord2D(n[l]))&&h.push(l);if(0===h.length||h.length===i)return;h.sort(((t,e)=>s[t]<s[e]?-1:s[t]>s[e]?1:n[t]<n[e]?-1:n[t]>n[e]?1:0));let m=-1;for(const l of h){if(m>=0&&s[l]===s[m]&&s[l]===s[m]){m=l;continue}m=l;const h=[];h.length=i;for(let t=0;t<h.length;++t)h[t]=t;h.sort(((t,e)=>{const s=r[l],n=a[l],i=r[t]-s,o=a[t]-n,h=i*i+o*o,m=r[e]-s,u=a[e]-n,c=m*m+u*u;return h<c?-1:h>c?1:0}));for(let r=0;r<i;r++){const i=h[r];if(i===l||s[i]===s[l]&&n[i]===n[l]||(0,o.J)(s[i],0,1)&&(0,o.J)(n[i],0,1))continue;const a=(s,n,i,r)=>{const a=new v,h=new o.F;h.setWithEps(1);const m=new o.F;m.set(n,h.eps()),t.queryCoord2DE(m,a);const l=new v;t.queryCoord2DE(new o.F(s),l);let u=!1;return a.eq(l)&&(m.set(r,h.eps()),e.queryCoord2DE(m,a),e.queryCoord2DE(new o.F(i),l),u=a.eq(l)),!u},m=o.P.getNAN();t.queryCoord2D(s[i],m);const u=o.P.getNAN();if(e.queryCoord2D(n[i],u),0===o.P.distance(m,u)&&a(s[l],s[i],n[l],n[i]))break;const c=new o.E(n[i],n[l]);c.normalizeNoNAN();const g=new o.E(s[i],s[l]);g.normalizeNoNAN();let d=-1,_=Number.POSITIVE_INFINITY,p=Number.POSITIVE_INFINITY,f=s[i];m.assign(t.getCoord2D(f));for(let r=0;r<5;r++){const r=e.getClosestCoordinateOnInterval(m,c,-1);u.assign(e.getCoord2D(r));const h=o.P.distance(m,u);if(f=t.getClosestCoordinateOnInterval(u,g,-1),f===s[l]&&r===n[l]){d=1;break}m.assign(t.getCoord2D(f));const P=o.P.distance(u,m);if(!(P<p&&h<_)){d=0;break}if(0===P&&0===h){a(s[l],s[i],n[l],n[i])?(s[i]=f,n[i]=r,d=0):d=1;break}p=P,_=h}if(-1===d&&(d=(0,o.J)(s[i],0,1)||(0,o.J)(n[i],0,1)?0:1),1!==d)break;s[i]=s[l],n[i]=n[l]}}}(e,s,n,i,r);const _=[];for(let o=0,P=r;o<P;o++)_.push(o);const p=(t,e)=>g?(0,o.am)(i[t],n[t],i[e],n[e]):(0,o.am)(n[t],i[t],n[e],i[e]);if(_.length>1){_.sort(p);const t=Math.max(B(e),B(s));let r=0;for(let a=1,h=_.length;a<h;a++){const h=n[_[r]],m=n[_[a]],l=i[_[r]],u=i[_[a]];if(h!==m||l!==u)if(!(jr(e,h,m)<=t&&jr(s,l,u)<=t)||(0,o.J)(h,0,1)&&(0,o.J)(l,0,1)||(0,o.J)(m,0,1)&&(0,o.J)(u,0,1))r++,_[r]=_[a];else{const t=o.P.distance(e.getCoord2D(h),s.getCoord2D(l)),n=o.P.distance(e.getCoord2D(m),s.getCoord2D(u));if(t<=n)continue;if(n<t){_[r]=_[a];continue}}}if(_.length=r+1,1===_.length&&0!==_[0]&&(n[0]=n[_[0]],i[0]=i[_[0]],_[0]=0),_.length>2){const t=o.E.constructEmpty(),r=o.E.constructEmpty();t.setCoords(n[_[0]],n[_.at(-1)]),r.setCoords(i[_[0]],i[_.at(-1)]);let a=!0;for(let e=1,s=_.length-1;e<s;e++)if(!t.containsCoordinate(n[_[e]])||!r.containsCoordinate(i[_[e]])){a=!1;break}if(a){const n=[.5,.2,.7,.1,.3,.4,.6,.8,.9];for(let i=0;i<n.length;i++){let h=(0,o.q)(t.vmin,t.vmax,n[i]);const m=e.getCoord2D(h);if(!s.isCloserThanDistance(m,r,l)){a=!1;break}h=(0,o.q)(r.vmin,r.vmax,n[i]);const u=s.getCoord2D(h);if(!e.isCloserThanDistance(u,t,l)){a=!1;break}}}a&&(_[1]=_.at(-1),_.length=2)}}if(1===_.length&&t){const t=0,r=0;A(e,s,n[0],i[0],l,1,[t],[r])&&(_.push(1),n[1]=t,i[1]=r,_.sort(p))}if(u&&1===_.length){let t=!0;for(let r=0,a=_.length;r<a;r++)if(!(0,o.J)(n[_[r]],0,1)||!(0,o.J)(i[_[r]],0,1)||0!==o.P.distance(e.getCoord2D(n[_[r]]),s.getCoord2D(i[_[r]]))){t=!1;break}if(t)return 0}let f=0;for(let P=0,x=_.length;P<x;P++){if(h&&h.push(n[_[P]]),m&&m.push(i[_[P]]),a){const t=o.P.getNAN();e.queryCoord2D(n[_[P]],t),a.push(t)}f++}return f}function Qr(t,e,s,n,i,r,a,h,m){if((0,o.J)(s,0,1)&&(0,o.J)(n,0,1)&&0===o.P.distance(t.getCoord2D(s),e.getCoord2D(n))){const l=1e-12,u=new v,c=Number.EPSILON;if(t.queryDerivative(new o.F(s,c),u),u.isTrueZero()){const e=1===s?-1e-12:l;t.queryDerivative(new o.F(s,c).add(e),u)}1===s&&u.negateThis();const g=new v;if(e.queryDerivative(new o.F(n,c),g),g.isTrueZero()){const t=1===s?-1e-12:l;e.queryDerivative(new o.F(n,c).add(t),g)}1===n&&g.negateThis(),u.isZero()||u.normalize(),g.isZero()||g.normalize();const d=u.dotProduct(g),_=u.crossProduct(g);_.scaleError(3);const p=()=>{if(m)return.001;{const s=t.calculateUpperLength2D(),n=e.calculateUpperLength2D();return Math.min(.01*i/Math.min(s,n),1e-10)}};if(d.ge(o.H)&&(_.isZero()||Math.abs(_.value())<p()))return N(t,e,s,n,i,r,a,h)}return 0}function Kr(t,e,s,n,r){let a=-1,h=-1,m=-1,l=-1;{const i=[0,e],r=[e,0],o=[0,n],u=[n,0];for(let e=0;e<2&&-1===a;++e)for(let n=0;n<2;++n)if(t[i[e]].equals(s[o[n]])){a=i[e],h=r[e],m=o[n],l=u[n];break}}if(-1===a){const i=new E;i.setFromPoints(t,e+1);const o=new E;return o.setFromPoints(s,n+1),o.inflate(r),i.isIntersectingW(o)?-1:0}{const u=(0,o.d)(e+1,Number.NaN),c=Nr(t,e+1,u);(0,i.g)(c>1);let g=0,d=0;for(let t=0;t<c;++t)a===u[t]&&(d=t,g++),h===u[t]&&g++;if(2!==g)return-1;const _=(0,o.d)(n+1,Number.NaN),p=Nr(s,n+1,_);(0,i.g)(p>1),g=0;let f=0;for(let t=0;t<p;++t)m===_[t]&&(f=t,g++),l===_[t]&&g++;if(2!==g)return-1;const P=t[u[(d+c-1)%c]],x=t[u[(d+1)%c]],y=s[_[(f+p-1)%p]],E=s[_[(f+1)%p]],C=t[a],S=[P,x,y,E],v=[0,1,2,3];v.sort(((t,e)=>o.P.compareVectorsOrigin(C,S[t],S[e])));let b=v[0];for(let t=1;t<4;t++){if(v[t]!==(b+1)%4)return-1;b=v[t]}{const t=P.sub(C),e=E.sub(C),s=e.dotProduct(t);if(s>0){const n=e.crossProduct(t),i=Math.abs(Math.atan2(n,s)),o=i*t.length(),a=i*e.length();if(o<=r||a<=r)return-1}}{const t=x.sub(C),e=y.sub(C),s=e.dotProduct(t);if(s>0){const n=e.crossProduct(t),i=Math.abs(Math.atan2(n,s)),o=i*t.length(),a=i*e.length();if(o<=r||a<=r)return-1}}return 1}}var Jr=r.V;class $r extends ${constructor(t){super(t||{XStart:0,YStart:0,XEnd:0,YEnd:0})}assignMove(t){return this!==t&&(this.m_description=t.m_description,t.m_description=null,this.m_attributes=t.m_attributes,t.m_attributes=null,this.m_XStart=t.m_XStart,t.m_XStart=Number.NaN,this.m_YStart=t.m_YStart,this.m_XEnd=t.m_XEnd,t.m_XEnd=Number.NaN,this.m_YEnd=t.m_YEnd),this}assignCopy(t){return this!==t&&t.copyTo(this),this}calculateLowerLength3D(){return(0,i.g)(0),0}calculateUpperLength3D(){return(0,i.g)(0),0}changeEndPoints3D(t,e){(0,i.g)(0)}getClosestCoordinate3D(t,e,s){return(0,i.g)(0),0}getBoundary(){return ii(this)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?st(this,t):nt(this,t);const n=Jr.getInterpolation(e),i=this.getStartAttributeAsDbl(e,s),r=this.getEndAttributeAsDbl(e,s);return(0,o.T)(n,i,r,t,Jr.getDefaultValue(e))}constructFromCoords(t,e,s,n){this.dropAllAttributes(),this.setStartXYCoords(t,e),this.setEndXYCoords(s,n)}construct(t,e){this.dropAllAttributes(),this.setStartXY(t),this.setEndXY(e)}construct3D(t,e){(0,i.g)(0)}constructPoint(t,e){this.assignVertexDescription(t.getDescription()),this.mergeVertexDescription(e.getDescription()),this.setStart(t),this.setEnd(e)}getGeometryType(){return $r.type}queryEnvelope(t){if(4===t.m_EnvelopeType){t.setEmpty(),t.assignVertexDescription(this.m_description);const e=a.Envelope2D.constructEmpty();this.queryEnvelope(e),t.setEnvelope(e);for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const e=this.m_description.getSemantics(s);for(let n=0,i=Jr.getComponentCount(e);s<i;s++){const s=this.queryInterval(e,n);t.setIntervalEnvelope(e,n,s)}}}else 2===t.m_EnvelopeType?t.setCoords({xmin:this.m_XStart,ymin:this.m_YStart,xmax:this.m_XEnd,ymax:this.m_YEnd}):3===t.m_EnvelopeType?(t.setEmpty(),t.mergeCoords(this.m_XStart,this.m_YStart,R(this,0,1,0)),t.mergeCoords(this.m_XEnd,this.m_YEnd,R(this,1,1,0))):(0,i.b)("env type not impl")}applyTransformation(t){(0,i.g)(t instanceof h.T);const e=new o.P;e.x=this.m_XStart,e.y=this.m_YStart,t.transformInPlace(e),this.m_XStart=e.x,this.m_YStart=e.y,e.x=this.m_XEnd,e.y=this.m_YEnd,t.transformInPlace(e),this.m_XEnd=e.x,this.m_YEnd=e.y}createInstance(){return new $r({vd:this.m_description})}calculateLength2D(){return Math.sqrt(dt(this))}calculateLength3D(t){return(0,i.g)(0),0}changeEndPoints2D(t,e){this.setStartXY(t),this.setEndXY(e),this.normalizeAfterEndpointChange()}queryCoord2D(t,e){return tt(this,t,e)}queryCoord3D(t,e){(0,i.g)(0)}getCoordZ(t){return function(t,e){const s=t.getStartZ(),n=t.getEndZ();return(0,o.q)(s,n,e)}(this,t)}queryCoord2DE(t,e){it(this,t,e)}getCoordX(t){return st(this,t)}getCoordY(t){return nt(this,t)}cut(t,e,s){const n=new to;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createLine();n&&i.assignVertexDescription(this.m_description);const r=o.P.getNAN();if(tt(this,t,r),i.setStartXYCoords(r.x,r.y),tt(this,e,r),i.setEndXYCoords(r.x,r.y),!n)for(let o=1,a=this.m_description.getAttributeCount();o<a;o++){const s=this.m_description.getSemantics(o),n=Jr.getComponentCount(s);for(let r=0;r<n;r++){const n=this.getAttributeAsDbl(t,s,r);i.setStartAttribute(s,r,n);const o=this.getAttributeAsDbl(e,s,r);i.setEndAttribute(s,r,o)}}}queryDerivative(t,e){!function(t,e,s){const n=v.constructPoint2D(t.getStartXY()),i=v.constructPoint2D(t.getEndXY());s.setCoordsE(i.x.subE(n.x),i.y.subE(n.y))}(this,0,e)}getClosestCoordinate(t,e){return o.P.getClosestCoordinate(this.getStartXY(),this.getEndXY(),t,e)}getClosestCoordinateOnInterval(t,e){const s=new o.P;this.queryCoord2D(e.vmin,s);const n=new o.P;this.queryCoord2D(e.vmax,n);const i=o.P.getClosestCoordinate(s,n,t,!1);return j.recalculateParentT(e.vmin,e.vmax,i)}intersectionOfYMonotonicWithAxisX(t,e){const s=this.m_YEnd-this.m_YStart;if(!s)return t===this.m_YEnd?e:Number.NaN;const n=(t-this.m_YStart)/s;let i=st(this,n);return 1===n&&(i=this.m_XEnd),i}isCurve(){return!1}isMonotoneQuickAndDirty(){return!0}isDegenerate(t){const e=this.m_XStart-this.m_XEnd,s=this.m_YStart-this.m_YEnd;return Math.sqrt(e*e+s*s)<=t}isDegenerate3D(t,e){return(0,i.g)(0),!1}queryLooseEnvelope(t){this.queryEnvelope(t)}clone(t){const e=new $r;return this.copyTo(e),e}tToLength(t){return t*this.calculateLength2D()}lengthToT(t){const e=this.calculateLength2D();return 0!==e?t/e:0}calculateWeightedAreaCentroid2D(t){const e=new o.P;return e.setCoords(0,0),e}calculateWeightedCentroid2D(){return this.getCoord2D(.5).mul(this.calculateLength2D())}getTangent(t){const e=o.P.getNAN();return e.setSub(this.getEndXY(),this.getStartXY()),e}getDerivative(t){const e=new o.P;return e.setSub(this.getEndXY(),this.getStartXY()),e}getCurvature(t){return 0}isIntersectingPoint(t,e,s){return lt(this,t,e,s)>=0}isIntersectingPoint3D(t,e,s,n){return(0,i.g)(0),!1}getYMonotonicParts(t,e){return 0}getMonotonicParts(t,e){return 0}getMonotonicPartParams(t,e){return e&&(t<2&&(0,i.t)(""),e[0]=0,e[1]=1),2}intersectionWithAxis2D(t,e,s,n){if(t){const t=this.m_YEnd-this.m_YStart;if(!t)return e===this.m_YEnd?-1:0;const i=(e-this.m_YStart)/t;return i<0||i>1?0:(s&&(s[0]=st(this,i)),n&&(n[0]=i),1)}{const t=this.m_XEnd-this.m_XStart;if(!t)return e===this.m_XEnd?-1:0;const i=(e-this.m_XStart)/t;return i<0||i>1?0:(s&&(s[0]=nt(this,i)),n&&(n[0]=i),1)}}calculateUpperLength2D(){return this.calculateLength2D()}calculateLowerLength2D(){return this.calculateLength2D()}normalizeAfterEndpointChange(){return!1}queryLooseEnvelopeOnInterval(t,e){if(2===e.m_EnvelopeType){let s=(0,o.c)(t.vmin,0,1);const n=new o.P;return this.queryCoord2D(s,n),e.setCoords({pt:n}),s=(0,o.c)(t.vmax,0,1),this.queryCoord2D(s,n),void e.mergeNe(n)}(0,i.b)("3d dst not impl")}orientBottomUp(){ot(this)}isLine(){return!0}isDegenerateToLineHelper(t){return!0}copyIgnoreAttributes(t){t.setStartXY(this.getStartXY()),t.setEndXY(this.getEndXY()),t.normalizeAfterEndpointChange()}calculateArea2DHelper(){return 0}absNormXYZ(t){return function(t,e){const s=t.getStartXYZ();s.z*=e;const n=t.getEndXYZ();return n.z*=e,s.norm(1)+n.norm(1)}(this,t)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)}queryEnvelopeW(t,e){e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax))}setSegmentFromCoords(t,e){rt(this,t[0],t[e-1])}writeInBufferStream(t,e){return(0,i.g)(0),0}readFromBufferStream(t,e){(0,i.g)(0)}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return!1}setCoordsForIntersector(t,e,s){rt(this,t,e)}static isIntersectingLineLine(t,e,s,n){return at(t,e,s,n)}static isIntersectingLineLine_(t,e,s,n){return at(t,e,s,n)}copyToImpl(t){}reverseImpl(){}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}swapImpl(t){}afterCompletedModification(){}endPointModified(){}clearEndPointModified(){}intersect(t,e,s,n,i){return Wr(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){e.length<1&&(0,i.n)("");const n=lt(this,t,s,!1);return n>=0?(e&&(e[0]=n),1):0}isIntersecting(t,e,s){return 0!==Br(!1,this,t,e,s)}}$r.type=i.G.enumLine;class to{constructor(t){this.m_seg=null,this.m_curves=null,this.m_lineBuffer=new $r,this.m_mask=0,this.m_active=0,void 0!==t&&(t.copy?t.copy.copyTo(this,!1):t.move?this.assignMove(t.move):t.segment?this.copyFrom(t.segment,!!t.bIgnoreAttributes):(0,i.c)("bad constructor params"))}assignCopy(t){return t instanceof to?this!==t&&t.copyTo(this,!1):this.copyFrom(t,!1),this}assignMove(t){if(t instanceof to){if(this===t)return this;this.reset(),1&t.m_mask&&(this.m_lineBuffer=t.m_lineBuffer,t.m_lineBuffer=null,this.m_mask=1),this.m_curves=t.m_curves,this.m_mask=t.m_mask,this.m_active=t.m_active,t.reset(),this.m_seg=this.activeSegment(),t.m_seg=null}else{if(this.m_seg===t)return this;this.create(t.getGeometryType()),this.m_seg.swap(t)}return this}activeSegment(){switch(this.m_active){case 0:return null;case 1:return this.line();case 2:return this.arc();case 4:return this.bezier3();case 8:return this.bezier2();case 16:return this.rbezier2();default:(0,i.c)("")}}get(){return this.m_seg}reset(){1&this.m_mask&&(this.m_lineBuffer=null),this.m_mask>1&&(this.m_curves=null),this.m_mask=0,this.m_active=0}empty(){return null===this.m_seg}copyTo(t,e){this!==t&&(this.empty()?t.m_seg=null:t.copyFrom(this.m_seg,e))}copyToWithZ(t,e){(0,i.g)(0)}createImpl(t){switch(t){case i.G.enumLine:1&this.m_mask||(this.m_lineBuffer=new $r,this.m_mask|=1,this.m_active=1);break;case i.G.enumEllipticArc:2&this.m_mask||(this.m_curves=new _i,this.m_mask=1&this.m_mask|2,this.m_active=2);break;case i.G.enumBezier:4&this.m_mask||(this.m_curves=new $s,this.m_mask=1&this.m_mask|4,this.m_active=4);break;case i.G.enumBezier2:8&this.m_mask||(this.m_curves=new Ht,this.m_mask=1&this.m_mask|8,this.m_active=8);break;case i.G.enumRationalBezier2:16&this.m_mask||(this.m_curves=new Bt,this.m_mask=1&this.m_mask|16,this.m_active=16);break;default:(0,i.t)("")}}create(t){t===i.G.enumLine?this.createLine():t===i.G.enumEllipticArc?this.createEllipticArc():t===i.G.enumBezier?this.createCubicBezier():t===i.G.enumRationalBezier2?this.createQuadraticRationalBezier():t===i.G.enumBezier2?this.createQuadraticBezier():(0,i.t)("Segment_buffer.create")}copyFrom(t,e){this.m_seg!==t&&(this.create(t.getGeometryType()),e?t.copyIgnoreAttributes(this.m_seg):t.copyTo(this.m_seg))}copyFromWithZ(t,e){(0,i.g)(0)}line(){return this.m_lineBuffer}arc(){return this.m_curves}bezier3(){return this.m_curves}bezier2(){return this.m_curves}rbezier2(){return this.m_curves}createLine(){return this.createImpl(i.G.enumLine),this.m_seg=this.line(),this.line()}createEllipticArc(){return this.createImpl(i.G.enumEllipticArc),this.m_seg=this.arc(),this.arc()}createCubicBezier(){return this.createImpl(i.G.enumBezier),this.m_seg=this.bezier3(),this.bezier3()}createQuadraticRationalBezier(){return this.createImpl(i.G.enumRationalBezier2),this.m_seg=this.rbezier2(),this.rbezier2()}createQuadraticBezier(){return this.createImpl(i.G.enumBezier2),this.m_seg=this.bezier2(),this.bezier2()}releaseSegment(){if(this.m_seg=null,0===this.m_active&&(0,i.c)("releaseSegment"),1&this.m_active){const t=this.line();return this.m_mask-=1,this.m_active=0,this.m_lineBuffer=null,t}let t;return 2&this.m_active?t=this.arc():4&this.m_active?t=this.bezier3():8&this.m_active?t=this.bezier2():16&this.m_active?t=this.rbezier2():(0,i.c)("releaseSegment"),this.m_mask-=this.m_active,this.m_active=0,this.m_curves=null,t}equals(t){return t instanceof to?this===t||(this.empty()?t.empty():!t.empty()&&this.get().equals(t.get())):((0,i.b)("seg comparison not yet impl"),!1)}}},82103:(t,e,s)=>{s.r(e),s.d(e,{$:()=>Zi,A:()=>x,B:()=>Qn,C:()=>ys,D:()=>Xi,E:()=>Yo,F:()=>zo,G:()=>$r,H:()=>Kn,I:()=>Zn,J:()=>Tn,K:()=>Nn,L:()=>Pr,M:()=>wn,N:()=>Dn,O:()=>fi,P:()=>Vo,Q:()=>I,R:()=>Wi,S:()=>nr,T:()=>Bs,U:()=>v,V:()=>zi,W:()=>Hi,X:()=>hs,Y:()=>T,Z:()=>Ro,_:()=>Fi,a:()=>vi,a0:()=>H,a1:()=>M,a2:()=>q,a3:()=>ji,a4:()=>ko,a5:()=>pn,a6:()=>R,a7:()=>G,a8:()=>Sr,a9:()=>bi,aA:()=>go,aB:()=>co,aC:()=>ri,aD:()=>ao,aE:()=>vo,aF:()=>d,aG:()=>aa,aH:()=>ha,aI:()=>ma,aJ:()=>la,aK:()=>ua,aa:()=>wr,ab:()=>br,ac:()=>ur,ad:()=>Bt,ae:()=>Ut,af:()=>_i,ag:()=>pi,ah:()=>_s,ai:()=>Xs,aj:()=>Zs,ak:()=>Js,al:()=>Fs,am:()=>eo,an:()=>Ht,ao:()=>lo,ap:()=>vs,aq:()=>Cs,ar:()=>xs,as:()=>js,at:()=>st,au:()=>nt,av:()=>B,aw:()=>Po,ax:()=>Xo,ay:()=>Oi,az:()=>X,b:()=>ro,c:()=>io,d:()=>di,e:()=>xi,f:()=>dn,g:()=>ln,h:()=>Ei,i:()=>as,j:()=>to,k:()=>fs,l:()=>ds,m:()=>Ms,n:()=>ps,o:()=>Vt,p:()=>Cr,q:()=>ls,r:()=>oe,s:()=>Ps,t:()=>Oo,u:()=>bn,v:()=>Sn,w:()=>ki,x:()=>In,y:()=>Vs,z:()=>mo});var n=s(89379),i=s(21557),r=s(97799),o=s(79186),a=s(91523),h=s(26871),m=s(35143),l=s(16364),u=s(88689),c=s(20265),g=s(68707);class d{constructor(t){if(this.m_geom=this.m_sr=null,t){if(t.move)return this.m_geom=t.move.m_geom,t.move.m_geom=null,this.m_sr=t.move.m_sr,void(t.move.m_sr=null);if(t.copy)return this.m_geom=t.copy.m_geom?t.copy.m_geom.clone():null,void(this.m_sr=t.copy.m_sr);t.geom&&(this.m_geom=t.geom),t.sr&&(this.m_sr=t.sr)}}getGeometry(){return this.m_geom}getSpatialReference(){return this.m_sr}setGeometry(t){this.m_geom=t}setSpatialReference(t){this.m_sr=t}equals(t,e){const s=t;return!(!this.m_sr&&s.m_sr)&&!(this.m_sr&&!s.m_sr)&&!(!this.m_geom&&s.m_geom)&&!(this.m_geom&&!s.m_geom)&&!(this.m_sr&&s.m_sr&&!this.m_sr.equals(s.m_sr))&&!(this.m_geom&&s.m_geom&&!this.m_geom.equals(s.m_geom,e))}clone(){let t=null;return this.m_geom&&(t=this.m_geom.clone()),new d({geom:t,sr:this.m_sr})}hasGeom(){return!!this.m_geom}}class _{constructor(t){this.m_factor=1,this.m_wkid=0,this.m_peUnit=null,t&&(this.m_peUnit=t,this.m_factor=t.getUnitFactor(),this.m_wkid=t.getCode(),this.m_wkid<0&&(this.m_wkid=0))}getName(){return this.m_peUnit.getName()}getID(){return this.m_wkid}getConversionFactor(t){return this.getUnitType()!==t.getUnitType()&&(0,r.t)("unit type mismatch"),this.getUnitToBaseFactor()/t.getUnitToBaseFactor()}getUnitToBaseFactor(){return this.m_factor}getHashCode(){return(0,h.aq)((0,h.ar)(this.getUnitType()),(0,h.ar)(this.getUnitToBaseFactor()))}equals(t){return!!t&&this.getUnitType()===t.getUnitType()&&this.getUnitToBaseFactor()===t.getUnitToBaseFactor()&&this.getID()===t.getID()&&this.getName()===t.getName()}static isValidWkid(t){return!1}}class p{assign(t){this.m_reason=t.m_reason,this.m_vertexIndex1=t.m_vertexIndex1,this.m_vertexIndex2=t.m_vertexIndex2}constructor(t,e,s){void 0!==t?(this.m_reason=t,this.m_vertexIndex1=e,this.m_vertexIndex2=s):(this.m_reason=0,this.m_vertexIndex1=-1,this.m_vertexIndex2=-2)}clear(){this.m_reason=0,this.m_vertexIndex1=-1,this.m_vertexIndex2=-1}}const f={330:104878,500:104879,1300:104899,1450:104986,2230:104988,3800:104978,5e3:104919,6200:104906,8200:104909,9500:104927,9600:104977,1e4:[104911,104936],11e3:104941,11080:104872,11100:104907,12e3:104920,12400:104995,13e3:104948,14e3:[104923,104989],15e3:[104913,104954],15100:104976,16e3:[104926,104931],18e3:[104922,104982],21e3:104947,21500:104877,27e3:[104950,104957],29e3:104964,3e4:104921,31e3:104949,33e3:104946,4e4:[104914,104967],40600:104897,41900:104937,42e3:104951,43100:104993,49300:104924,50100:104939,54e3:104955,58200:104981,59500:104930,74e3:104961,77e3:104956,79e3:104962,83500:104910,85e3:104917,88800:104934,89200:104985,96e3:104997,104e3:104963,106500:104898,11e4:104938,133e3:104932,135e3:104983,17e4:104965,198200:104987,198630:104935,208e3:104966,235800:104952,249400:104929,252100:104980,255e3:104973,47e4:104972,529800:104942,531e3:104996,56e4:104928,561400:104979,578900:104945,584700:104959,593e3:104970,606e3:104999,718e3:104933,745700:104984,761400:104953,763500:104994,764e3:104940,788900:104958,1188300:104998,1195e3:104969,1352600:104968,1560800:104874,1562090:104915,1737400:104903,1821460:104918,1821490:104876,2409300:104912,2410300:104873,2439400:104974,2439700:104900,2575e3:104943,2631200:104875,2632345:104916,3393400:104904,3396190:[104905,104971],6051e3:104901,6051800:104902,637e4:104128,6370997:[4052,37008],6371e3:4035,6371007:4047,6371228:[4053,10346],6376045:[8042,8043],6376523:[4027,4901,4902],6376896:37007,6378135:[4122,4322,4324,4720,4985,4987],6378136:[4740,4923,7678,7680,9474,9475,104017,104018],6378137:[3823,3824,3888,3889,4017,4019,4023,4031,4040,4046,4055,4074,4075,4080,4081,4121,4126,4130,4133,4140,4141,4148,4151,4152,4163,4166,4167,4170,4171,4172,4173,4176,4180,4189,4190,4258,4269,4283,4318,4319,4326,4463,4466,4469,4470,4480,4482,4483,4490,4557,4558,4612,4617,4619,4624,4627,4659,4661,4667,4669,4670,4674,4686,4687,4693,4694,4702,4737,4742,4747,4749,4750,4755,4756,4757,4758,4759,4761,4762,4763,4764,4765,4883,4885,4887,4889,4893,4895,4898,4907,4909,4921,4925,4927,4929,4931,4933,4935,4937,4939,4941,4943,4945,4947,4949,4951,4953,4955,4957,4959,4961,4963,4965,4967,4971,4975,4977,4979,4981,4983,4989,4997,4999,5012,5013,5245,5246,5251,5252,5263,5264,5323,5324,5340,5342,5353,5354,5359,5360,5364,5365,5370,5371,5372,5373,5380,5381,5392,5393,5488,5489,5545,5546,5592,5593,5885,5886,6134,6135,6310,6311,6318,6319,6321,6322,6324,6325,6364,6365,6667,6668,6705,6706,6782,6783,6980,6982,6983,6987,6989,6990,7034,7035,7036,7037,7038,7039,7040,7041,7042,7072,7073,7084,7085,7086,7087,7133,7135,7136,7138,7139,7372,7373,7657,7659,7661,7663,7665,7685,7686,7797,7798,7816,7843,7844,7880,7881,7885,7886,7900,7901,7902,7903,7904,7905,7906,7907,7908,7909,7910,7911,7912,7915,7917,7919,7921,7923,7925,7927,7929,7931,8085,8086,8231,8232,8235,8237,8239,8240,8244,8246,8248,8249,8251,8252,8254,8255,8399,8403,8426,8427,8449,8542,8544,8545,8684,8685,8698,8699,8817,8818,8860,8888,8899,8900,8901,8902,8906,8907,8916,8918,8920,8922,8924,8926,8928,8930,8932,8934,8936,8938,8940,8942,8944,8946,8948,8949,8972,8973,8974,8975,8976,8977,8978,8979,8980,8981,8982,8983,8984,8985,8986,8987,8988,8989,8990,8991,8992,8993,8994,8995,8996,8997,8998,8999,9e3,9002,9003,9005,9006,9008,9009,9011,9012,9013,9014,9016,9017,9018,9019,9053,9054,9055,9056,9057,9059,9060,9061,9062,9063,9064,9065,9066,9067,9068,9069,9071,9072,9074,9075,9139,9140,9147,9148,9152,9153,9183,9184,9293,9294,9299,9308,9309,9332,9333,9364,9372,9379,9380,9384,9453,9469,9470,9546,9547,9695,9696,9701,9702,9739,9754,9755,9758,9763,9776,9777,9778,9779,9781,9782,9783,9784,9866,9871,9939,9964,9969,9974,9989,9990,10175,10177,10178,10185,10191,10196,10204,10209,10214,10219,10224,10229,10237,10272,10277,10283,10284,10298,10299,10300,10304,10305,10307,10309,10310,10311,10312,10327,10328,10413,10414,10468,10474,10475,10570,10571,10605,10606,10623,10628,20033,20040,20041,20045,20046,104009,104010,104011,104012,104013,104014,104015,104016,104019,104020,104021,104022,104024,104027,104028,104050,104100,104107,104108,104110,104111,104114,104115,104116,104117,104118,104119,104120,104121,104122,104123,104124,104129,104133,104134,104137,104141,104142,104143,104144,104145,104179,104180,104181,104182,104183,104184,104185,104186,104199,104223,104257,104258,104259,104260,104286,104287,104602,104613,104644,104645,104646,104647,104653,104804,104896,104991],6378140:4610,6378145:[4025,4276,4760,4891,37001],6378150:37003,6378155:[37004,37207],6378160:[3821,4003,4021,4036,4202,4203,4237,4238,4291,4618,4708,5527,37231,104023,104136],6378166:37002,6378200:[4020,4229,4286,4303,4706],6378245:[4024,4147,4164,4178,4179,4191,4200,4205,4214,4284,4317,4555,4676,4677,4678,4991,4993,5560,5561,37257,104135],6378270:[4732,37005,37229],6378273:[4054,10345],6378300:[4029,4168,4174],6378388:[4022,4123,4153,4154,4158,4159,4160,4161,4165,4181,4182,4183,4184,4185,4192,4194,4195,4196,4199,4204,4207,4208,4215,4218,4221,4224,4225,4230,4231,4233,4235,4236,4247,4248,4249,4254,4255,4259,4264,4265,4271,4272,4274,4285,4287,4288,4292,4297,4309,4311,4313,4316,4472,4475,4611,4614,4615,4616,4621,4622,4623,4625,4626,4628,4629,4630,4631,4632,4633,4636,4637,4639,4641,4642,4643,4644,4645,4646,4658,4660,4662,4663,4664,4665,4668,4672,4673,4684,4688,4689,4690,4691,4692,4698,4704,4705,4707,4709,4710,4711,4712,4714,4715,4716,4718,4719,4721,4722,4724,4725,4727,4728,4729,4730,4733,4734,4735,4739,4741,4753,4754,4802,4803,4806,4809,4810,4823,4824,4900,5524,6883,8428,8430,8431,9248,9251,9253,9403,9893,10158,10249,10252,37201,37204,37205,37212,37213,37214,37215,37216,37217,37218,37219,37221,37222,37224,37226,37227,37230,37232,37233,37234,37235,37237,37238,37241,37242,37245,37246,37247,37249,37250,37251,37253,37259,104104,104106,104125,104126,104127,104130,104138,104248],6378523:104786,24764e3:104960,25559e3:104944,60268e3:104925,71492e3:104908,6957e5:104975,6377397.155:[3819,3906,4004,4120,4124,4125,4149,4150,4156,4162,4211,4219,4257,4262,4280,4289,4294,4295,4301,4306,4308,4312,4314,4613,4666,4745,4746,4801,4804,4805,4808,4813,4814,4815,4818,4820,4904,5132,5228,5229,5681,5830,8351,9267,10268,37255,104101,104102,104105,104131,104648,104696,104697,104990,104992],6377563.396:[4001,4188,4277,4278,4279],6377340.189:[4002,4299,4300],6377492.018:[4005,4273,4817],6377483.865280418:[4006,4293],6378293.645208759:[4007,4157,4302,4738,5464],6378206.4:[4008,4127,4128,4129,4135,4136,4137,4138,4139,4169,4216,4242,4253,4267,4608,4609,4638,4675,4683,4695,4717,4723,4726,4995,5451,5467,37220,37239,37243,37252,37260,104e3,104109,104112,104113,104132],6378450.047:[4009,4268],6378300.789:[4010,4281],6378249.2:[4011,4014,4155,4193,4206,4213,4223,4226,4227,4228,4252,4261,4266,4275,4282,4296,4304,4310,4315,4671,4807,4811,4816,4821,37223,37225,104139,104140,104261,104304],6378249.145:[4012,4013,4132,4134,4142,4143,4175,4197,4198,4201,4209,4210,4212,4220,4222,4232,4234,4246,4250,4251,4256,4260,4263,4270,4305,4307,4600,4601,4602,4603,4604,4605,4606,4607,4620,4679,4680,4696,4697,4699,4700,4701,4703,4713,4731,4736,4743,4744,4812,4819,6881,6882,6892,6894,8694,37206,37208,37211,37228,37240,37254,104025,104026,104103,104305],6377276.345:[4015,4131,4144,4239,4240,4244,4682,5233,6207,37202,104256,104664,104693],6377298.556:[4016,4298],6377304.063:[4018,4245],6378298.3:[4028,4903],6378136.2:4032,6378136.3:4033,6378249.144808011:[4034,4241],20922931.8:[4042,4243],6377301.243:[4044,4145,37203],6377299.151:[4045,4146],6377019.27:[4657,10256,10260,10265],6378306.3696:[4748,4752],6377295.664:[4751,37006],6378136.5:[7682,7683],6371008.7714:104047,6378418.941:[104700,104726,104760],6378586.581:[104701,104743],6378505.809:104702,6378544.823:104703,6378490.569:104704,6378470.757:[104705,104776],6378403.701:[104706,104750],6378434.181:[104707,104724,104739,104764],6378454.907:104708,6378400.653:104709,6378567.378:104710,6378546.957:[104711,104717,104780],6378476.853:[104712,104736],6378411.321:[104713,104728],6378647.541:[104714,104715],6378514.953:[104716,104782],6378421.989:[104718,104770],6378481.425:[104719,104753,104774,104781],6378518.001:[104720,104725],6378521.049:[104721,104723,104731,104745,104748],6378464.661:104722,6378436.619:104727,6378574.389:[104729,104730],6378472.281:[104732,104756],6378498.189:[104733,104746],6378449.421:[104734,104766],6378525.621:[104735,104754],6378466.185:104737,6378496.665:104738,6378643.579:104740,6378559.758:104741,6378414.369:[104742,104763,104772],6378441.801:104744,6378502.761:[104747,104759,104773,104775],6378617.061:104749,6378624.681:[104751,104765],6378468.623:104752,6378445.763:[104755,104758,104761],6378670.401:104757,6378438.753:104762,6378543.909:104767,6378605.783:104768,6378540.861:104769,6378443.325:[104771,104784],6378548.481:104777,6378463.746:104778,6378426.561:104779,6378453.688:104783,6378530.193:104785,6378376.271:[104800,104828],6378471.92:104801,6378472.931:104802,6378411.351:104803,6378380.991:104805,6378414.96:104806,6378345.09:[104807,104819,104844,104870],6378412.542:104808,6378470.401:104809,6378376.331:104810,6378379.031:104811,6378407.621:104812,6378376.811:[104813,104827],6378313.92:104814,6378414.93:104815,6378413.021:104816,6378380.381:104817,6378530.851:104818,6378591.521:104820,6378378.881:104821,6378408.481:[104822,104832],6378375.601:[104823,104838],6378408.041:104824,6378655.071:104825,6378409.151:104826,6378315.7:[104829,104840,104845,104851],6378285.86:[104830,104835,104859],6378379.301:104831,6378560.121:104833,6378531.821:104834,6378500.6:104836,6378376.041:104837,6378406.601:104839,6378438.991:104841,6378345.42:104842,6378593.86:104843,6378381.271:[104846,104847],6378413.671:104848,6378344.377:104849,6378563.891:104850,6378408.091:104852,6378377.671:104853,6378472.751:104854,6378412.511:104855,6378407.281:104856,6378534.451:104857,6378406.051:104858,6378532.921:104860,6378380.091:104861,6378408.941:104862,6378624.171:104863,6378377.411:104864,6378474.591:104865,6378407.141:104866,6378376.871:104867,6378375.251:104868,6378405.971:104869,6378437.651:104871};class P extends _{constructor(t){if("number"==typeof t)return super(),this.m_factor=t,void(this.m_wkid=0);super(t)}getUnitType(){return 1}convertFromRadians(t){return t/this.getUnitToBaseFactor()}convertToRadians(t){return t*this.getUnitToBaseFactor()}}function x(t){return new zr}function y(t){const e=jo(null);return t.getType()===ko.PE_TYPE_PROJCS||t.getType()===ko.PE_TYPE_GEOGCS?e.reset(t.getUnit()):(0,r.t)("PE_coord_sys"),e.get()||(0,r.c)("cannot create units from coord sys"),function(t){return t.getType()===ko.PE_TYPE_LINUNIT?new zr(t):t.getType()===ko.PE_TYPE_ANGUNIT?new P(t):void(0,r.t)("peUnit")}(e.get())}class E{constructor(t,e,s){void 0===t?(this.x=new h.F,this.y=new h.F,this.z=new h.F):t instanceof a.h?(this.x=new h.F(t.x),this.y=new h.F(t.y),this.z=new h.F(t.z)):t instanceof h.F?(this.x=t.clone(),this.y=e.clone(),this.z=s.clone()):(0,r.t)("EPoint3D constructor")}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y)).addE(this.z.mulE(t.z))}crossProduct(t){return new E(this.y.mulE(t.z).subE(this.z.mulE(t.y)),this.z.mulE(t.x).subE(this.x.mulE(t.z)),this.x.mulE(t.y).subE(this.y.mulE(t.x)))}crossProductVector(t){const e=this.y.mulE(t.z).subE(t.y.mulE(this.z)),s=t.x.mulE(this.z).subE(this.x.mulE(t.z)),n=this.x.mulE(t.y).subE(t.x.mulE(this.y));return new E(e,s,n)}sqrLength(){return this.x.mulE(this.x).addE(this.y.mulE(this.y)).addE(this.z.mulE(this.z))}length(){return this.sqrLength().sqrt()}static distance(t,e){return t.sub(e).length()}negate(){return new E(this.x.negate(),this.y.negate(),this.z.negate())}add(t){return new E(this.x.addE(t.x),this.y.addE(t.y),this.z.addE(t.z))}sub(t){return new E(this.x.subE(t.x),this.y.subE(t.y),this.z.subE(t.z))}subThis(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this.z.subThisE(t.z),this}addThis(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this.z.addThisE(t.z),this}mul(t){return new E(this.x.mulE(t),this.y.mulE(t),this.z.mulE(t))}div(t){return new E(this.x.divE(t),this.y.divE(t),this.z.divE(t))}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)&&this.z.eq(t.z)}isZero(){return this.x.isZero()&&this.y.isZero()&&this.z.isZero()}value(){return a.h.construct(this.x.value(),this.y.value(),this.z.value())}}class C{constructor(t){if(this.m_origin=new a.h,this.m_normal=new a.h,this.m_axisX=new a.h,this.m_axisY=new a.h,!t)return this.m_origin=new a.h,this.m_normal=new a.h(0,0,1),this.m_axisX=new a.h(1,0,0),void(this.m_axisY=new a.h(0,1,0));t.pt0&&t.pt1&&t.pt2?this.setFromPoints(t.pt0,t.pt1,t.pt2):(0,r.g)(0,"unimplemented constructor options ".concat(JSON.stringify(t)))}assign(t){return(0,r.g)(0),this}set(t,e,s,n){(0,r.g)(0)}setFromPoints(t,e,s){let n=e.sub(t);const i=s.sub(t);this.m_normal=n.crossProductVector(i);let r=!0;if(this.m_normal.isZero()){if(r=!1,n.isZero()&&(n=i),n.isZero()){const e=0,s=1;return this.m_normal.setCoords(e,e,s),this.m_axisX.setCoords(s,e,e),this.m_axisY.setCoords(e,s,e),this.m_origin=t,!1}this.m_axisX=n.getUnitVector(),this.m_normal=this.m_axisX.createAPerpendicular()}else this.m_normal.normalizeThis(),this.m_axisX=n.getUnitVector();return this.m_axisY=this.m_normal.crossProductVector(this.m_axisX),this.m_origin=t,r}getCoord(t,e){return(0,r.g)(0),{}}getCoord2D(t){return(0,r.g)(0),{}}getCoordX(t,e){return(0,r.g)(0),0}getCoordY(t,e){return(0,r.g)(0),0}getCoordZ(t,e){return(0,r.g)(0),0}setPreferredAxisX(t){(0,r.g)(0)}getOrigin(){return(0,r.g)(0),{}}getNormal(){return(0,r.g)(0),{}}getAxisX(){return this.m_axisX.clone()}getAxisY(){return this.m_axisY.clone()}setAxisX(t){(0,r.g)(0)}setAxisY(t){(0,r.g)(0)}recalculateAxisY(){(0,r.g)(0)}setOrigin(t){(0,r.g)(0)}setNormal(t,e){(0,r.g)(0)}intersect(t,e){return(0,r.g)(0),!1}intersectLine(t){return(0,r.g)(0),0}intersectLineEx(t,e){return(0,r.g)(0),0}closestCoordinate(t){const e=t.sub(this.m_origin),s=new h.P;return s.x=e.dotProduct(this.m_axisX),s.y=e.dotProduct(this.m_axisY),s}projectVector(t){return(0,r.g)(0),{}}signedDistance(t){return(0,r.g)(0),0}distance(t){return(0,r.g)(0),0}}function S(t,e){return!1}function v(t,e,s,n){let i,o,a,m,l,u,c,g,d,_=arguments.length>4&&void 0!==arguments[4]?arguments[4]:100,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:S;(0,r.g)(n>0);let f,P,x,y=0,E=0;const C=(0,h.an)();e>s&&(s=(0,h.b)(e,e=s));const v=t(e),b=t(s);v<b?(i=o=a=e,m=l=u=v):(i=o=a=s,m=l=u=b);let I=0;for(;I<_&&(x=.5*(s-e),d=e+x,f=n*(Math.abs(i)+.25),P=2*f,!(p(i,m)||Math.abs(i-d)<=P-x));++I){if(Math.abs(E)>f){const t=(i-o)*(m-u);let n=(i-a)*(m-l),r=(i-a)*n-(i-o)*t;n=2*(n-t),n>0&&(r=-r),n=Math.abs(n);const c=E;E=y,Math.abs(r)>=Math.abs(n*c*.5)||r<=n*(e-i)||r>=n*(s-i)?(E=i>=d?e-i:s-i,y=(0,h.an)()*E):(y=r/n,g=i+y,(g-e<P||s-g<P)&&(y=d-i<0?-Math.abs(f):Math.abs(f)))}else E=i>=d?e-i:s-i,y=E*C;g=i+y,c=t(g),c<m?(g>=i?e=i:s=i,a=o,o=i,i=g,u=l,l=m,m=c):(g<i?e=g:s=g,c<=l||o===i?(a=o,o=g,u=l,l=c):(c<=u||a===i||a===o)&&(a=g,u=c))}return(0,h.n)(i,m)}function b(t,e,s){return t>s?t-=Math.ceil((t-s)/h.k)*h.k:t<e&&(t+=Math.ceil((e-t)/h.k)*h.k),t}function I(t,e,s){return function(t,e,s,n){const i=s.x,r=s.y;return w(t,e,Math.cos(i),Math.sin(i),Math.cos(r),Math.sin(r),n)}(t,e,s,0)}function w(t,e,s,n,i,r,o){const h=t/Math.sqrt(1-e*r*r),m=h+o,l=m*i*s,u=m*i*n,c=(h*(1-e)+o)*r;return a.h.construct(l,u,c)}function D(t,e,s){const n=new h.F,i=new h.F,r=new h.F,o=new h.F;n.setCos(s.x),i.setSin(s.x),r.setCos(s.y),o.setSin(s.y);const a=o.negate().mulE(o.mul(e)).add(1).sqrt(),m=new h.F(t).divE(a),l=m.mulE(r).mulE(n),u=m.mulE(r).mulE(i),c=m.mul(1-e).mulE(o);return new E(l,u,c)}function T(t,e,s){const n=s.x,i=s.y,r=s.z,o=Math.atan2(i,n),a=Math.sqrt(n*n+i*i),m=Math.atan2(r,(1-e)*a);return h.P.construct(o,m)}function N(t,e,s){const n=1-e,i=t/Math.sqrt((0,h.s)(s.x)+(0,h.s)(s.y)+(0,h.s)(s.z)/n);return s.mul(i)}function A(t,e,s,n,i){const r=I(t,e,s),o=I(t,e,n);return T(0,e,a.h.lerp(r,o,i))}function G(t,e,s){const n=new a.h;return n.setCrossProductVector(e,s),Math.abs(Math.atan2(n.length(),e.dotProduct(s)))*t}function M(t,e,s,n,i){const r=s.getUnitVector(),o=n.getUnitVector(),h=e.getUnitVector(),m=new a.h;if(m.setCrossProductVector(r,o),!m.isZero()){m.normalizeThis();const e=h.sub(m.mul(m.dotProduct(h)));if(!e.isZero()){e.normalizeThis();const s=r.add(o).mul(.5);if(s.dotProduct(e)>s.dotProduct(r)){const s=Math.abs(m.dotProduct(h)),n=Math.asin(s);return i.assign(e.getUnitVector().mul(t)),n*t}}}const l=G(1,r,h),u=G(1,o,h);return l<=u?(i.assign(s),l*t):(i.assign(n),u*t)}function F(t,e,s,n,i){switch((0,r.g)(s.isFinite()&&n.isFinite()),i){case 0:return function(t,e,s,n){const r={stack:[],error:void 0,hasError:!1};try{const i=(0,m.b)(r,new Yo,!1);return zo.geodeticDistance(t,e,s.x,s.y,n.x,n.y,i,null,null,ko.PE_LINETYPE_GEODESIC),i.val}catch(i){r.error=i,r.hasError=!0}finally{(0,m.c)(r)}}(t,e,s,n);case 1:return function(t,e,s){const n={stack:[],error:void 0,hasError:!1};try{const i=(0,m.b)(n,new Yo,!1);return zo.greatEllipticDistance(t,e,s.x,s.y,s.x,s.y,i,null,null),i.val}catch(i){n.error=i,n.hasError=!0}finally{(0,m.c)(n)}}(t,e,s);case 2:case 3:{const i=I(t,e,s),r=I(t,e,n);return a.h.distance(i,r)}default:(0,r.b)("")}}function q(t,e,s,n,i){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6?arguments[6]:void 0;if(2===r||3===r)return function(t,e,s,n,i){let r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6?arguments[6]:void 0;const m=N(t,e,s);if(r){const r=new C({pt0:new a.h(0,0,0),pt1:n,pt2:i}),l=r.closestCoordinate(s),u=r.closestCoordinate(n),c=r.closestCoordinate(i),g=h.P.getClosestCoordinate(u,c,l),d=N(t,e,a.h.lerp(n,i,g)),_=a.h.distance(d,m);return o&&o.assign(d),(0,h.n)(g,_)}const l=s=>{const r=N(t,e,a.h.lerp(n,i,s));return a.h.distance(r,m)},u=a.h.distance(n,i);if(u>0){const s=L(t,u),{first:r,second:m}=v(l,0,1,s);return o&&o.assign(N(t,e,a.h.lerp(n,i,r))),(0,h.n)(r,m)}{const t=a.h.distance(s,n);return o&&o.assign(s),(0,h.n)(.5,t)}}(t,e,s,n,i,3===r,o);const m=T(0,e,s),l=s=>{const o=T(0,e,a.h.lerp(n,i,s));return F(t,e,m,o,r)},u=a.h.distance(n,i);if(u>0){const s=L(t,u),{first:r,second:m}=v(l,0,1,s);return o&&o.assign(N(t,e,a.h.lerp(n,i,r))),(0,h.n)(r,m)}{const t=l(0);return o&&o.assign(n),(0,h.n)(.5,t)}}function V(t,e,s,n,i,r){if(r[0]=Number.NaN,r[1]=Number.NaN,Math.abs(s.x-n.x)>Math.PI)return 0;if(Math.abs(s.y)>h.l||Math.abs(n.y)>h.l)return 0;if((Math.abs(s.y)===h.l||Math.abs(n.y)===h.l)&&s.x!==n.x)return 0;if(Math.abs(i)>=h.l)return 0;if(s.y>0&&n.y>0&&s.y>i&&n.y>i||s.y<0&&n.y<0&&s.y<i&&n.y<i)return 0;const a=o.W.constructPoint2D(s),m=o.W.constructPoint2D(n),l=D(1,e,a),u=D(1,e,m),c=l.crossProductVector(u);if(c.z.isZero())return h.E.construct(s.y,n.y).containsCoordinate(i)?(r[0]=s.x,1):0;const g=c.x.divE(c.z.negate()),d=c.y.divE(c.z.negate()),_=g.mulE(g).addE(d.mulE(d)).sqrt();if(_.isZero()||g.isZero()&&d.isZero())return 0===i?(r[0]=s.x,r[1]=n.x,2):0;const p=(1-e)*Math.tan(i)/_.value();if(Math.abs(p)>1)return 0;const f=Math.acos(p),P=Math.atan2(d.value(),g.value()),x=P-f;let y=P+f;const E=Math.min(s.x,n.x),C=Math.max(s.x,n.x);b(x,E,C),0!==i?b(y,E,C):y=x;let S=0;return E<=x&&x<=C&&(r[S]=x,S++),y!==x&&E<=y&&y<=C&&(r[S]=y,S++),S}function Y(t,e){e[0]>.5*Math.PI?(t[0]+=Math.PI,e[0]=Math.PI-e[0]):e[0]<.5*-Math.PI&&(t[0]-=Math.PI,e[0]=-Math.PI-e[0]),(0,r.g)(e[0]>=.5*-Math.PI&&e[0]<=.5*Math.PI)}function X(t,e,s,n,i){n=(0,h.c)(n,-h.l,h.l),i=(0,h.c)(i,-h.l,h.l);const r=h.l-.03;let o;return o=n>r&&i>r||n<-r&&i<-r?function(t,e,s){let n=1;if(e<0&&(n=-1,e=-e,s=-s),0!==t){const i=t*t,r=i*t,o=[1,(1+11*t)/12,(1+118*t+241*i)/360,(1+1089*t+10419*i+8651*r)/20160,(1+9836*t+318246*i+1027436*r+r*t*458881)/1814400],a=e=>{let s=0;const n=(0,h.s)(e)/(t-1);for(let t=o.length-1;t>=0;--t)s=o[t]+s*n;return s*=-(0,h.s)(e/(1-t)),s},m=a(h.l-e);return(a(h.l-s)-m)*n}{const t=h.l-e,i=h.l-s,r=-4*(0,h.s)(Math.sin(t/2));return(-4*(0,h.s)(Math.sin(i/2))-r)*n}}(t,n,i):k(t,i)-k(t,n),.5*(s-e)*o*function(t){return 1-t}(t)}function k(t,e){if(0===e)return 0;const s=Math.sin(e);let n=s,i=s;if(0!==t){n/=1-t*s*s;const e=Math.sqrt(t);i=s*(0,h.y)(e*s)}return n+i}function R(t,e){return t/Math.sqrt(1-e)}function H(t,e){return(1-e)*t}function L(t,e){if(0!==e){const s=t*(0,h.aF)()/e;return Math.min(s,1e-10)}return 0}class B{constructor(t){this.m_currentShift=63n,this.m_currentElt=0n,this.m_iCurrentElt=-1,this.m_parent=t,this.m_aiSetElts=t.m_bits.flatMap(((t,e)=>e))}next(){if(this.m_currentShift++,64n===this.m_currentShift){if(this.m_iCurrentElt++,this.m_iCurrentElt===this.m_aiSetElts.length)return B.npos();this.m_currentShift=0n,this.m_currentElt=this.m_parent.m_bits[this.m_aiSetElts[this.m_iCurrentElt]]}for(;this.m_currentShift<63n&&!(this.m_currentElt&1n<<this.m_currentShift);)this.m_currentShift++;return this.m_currentElt&1n<<this.m_currentShift?64*this.m_aiSetElts[this.m_iCurrentElt]+Number(this.m_currentShift):this.next()}static npos(){return Number.MAX_SAFE_INTEGER}}function U(t){return 1n<<(0x3fn&BigInt(t))}function z(t){return t>>6}class O{constructor(t){this.m_bits=[],void 0!==t&&t.copy&&(this.m_bits=t.copy.m_bits.slice())}assignMove(){return this}assignCopy(){return this}hasBit(t){const e=U(t),s=z(t);return void 0!==this.m_bits[s]&&!!(this.m_bits[s]&e)}setBit(t){const e=U(t),s=z(t);void 0===this.m_bits[s]&&(this.m_bits[s]=0n),this.m_bits[s]|=e}clearBit(t){}flipBit(t){const e=U(t),s=z(t);return void 0===this.m_bits[s]&&(this.m_bits[s]=0n),this.m_bits[s]^=e,0n!==(this.m_bits[s]&e)}clear(){this.m_bits.length=0}isZero(){let t=0;return this.m_bits.forEach((e=>{t|=e?2:1})),!(2&t)}equals(t){if(this===t)return!0;if(this.m_bits.length!==t.m_bits.length)return!1;let e=0;return this.m_bits.forEach(((s,n)=>{e|=s===t.m_bits[n]?2:1})),!(1&e)&&(t.m_bits.forEach(((t,s)=>{e|=t===this.m_bits[s]?2:1})),!(1&e))}notEquals(t){return!this.equals(t)}assignOr(t){return t.m_bits.forEach(((t,e)=>{void 0===this.m_bits[e]?this.m_bits[e]=t:this.m_bits[e]|=t})),this}assignSubtract(t){return t.m_bits.forEach(((t,e)=>{void 0!==this.m_bits[e]&&(this.m_bits[e]&=~t)})),this}assignAnd(t){return t.m_bits.forEach(((t,e)=>{void 0!==this.m_bits[e]&&(this.m_bits[e]&=t)})),this}assignXor(t){return t.m_bits.forEach(((t,e)=>{void 0===this.m_bits[e]?this.m_bits[e]=t:this.m_bits[e]^=t})),this}getHashCode(){return this.m_bits.reduce(((t,e)=>(0,h.aD)(t,e)),(0,h.ar)(0))}getUnorderedBitIterator(){return new B(this)}}class W{constructor(t,e){this.m_map=new Map,this.m_hf=t,this.m_ef=e}add(t){const e=this.m_hf(t);if(!this.m_map.has(e))return this.m_map.set(e,t),this;const s=this.m_map.get(e);return s instanceof Array?s.find((e=>this.m_ef(e,t)))||s.push(t):this.m_ef(s,t)||this.m_map.set(e,[s,t]),this}clear(){this.m_map.clear()}delete(t){return!1}has(t){const e=this.m_hf(t);if(!this.m_map.has(e))return!1;const s=this.m_map.get(e);return s instanceof Array?void 0!==s.find((e=>this.m_ef(e,t))):this.m_ef(s,t)}get(t){const e=this.m_hf(t),s=this.m_map.get(e);if(void 0!==s)return s instanceof Array?s.find((e=>this.m_ef(e,t))):s}get size(){let t=0;for(const e of this.m_map.values())t+=e instanceof Array?e.length:1;return t}forEach(t,e){}[Symbol.iterator](){return(new Set)[Symbol.iterator]()}entries(){return(new Set).entries()}keys(){return(new Set).keys()}values(){return(new Set).values()}get[Symbol.toStringTag](){return"ValueSet"}}class j extends a.a6{constructor(t){super(),this.m_bufferLeft=new o.S,this.m_bufferRight=new o.S,this.m_intervalLeft=h.E.constructEmpty(),this.m_intervalRight=h.E.constructEmpty(),this.m_yScanline=Number.NaN,this.m_helper=t}compare(t,e,s){const n=e,i=t.getElement(s);this.m_helper.querySegmentXY(n,this.m_bufferLeft),this.m_helper.querySegmentXY(i,this.m_bufferRight);const r=this.m_bufferLeft.get(),o=this.m_bufferRight.get();if(this.m_intervalLeft.setCoords(r.getStartX(),r.getEndX()),this.m_intervalRight.setCoords(o.getStartX(),o.getEndX()),this.m_intervalLeft.vmax<this.m_intervalRight.vmin)return-1;if(this.m_intervalLeft.vmin>this.m_intervalRight.vmax)return 1;const a=r.getStartY()===r.getEndY(),h=o.getStartY()===o.getEndY();if(a||h){if(a&&h)return 0;if(r.getStartY()===o.getStartY()&&r.getStartX()===o.getStartX())return a?1:-1;if(r.getEndY()===o.getEndY()&&r.getEndX()===o.getEndX())return a?-1:1}let m=r.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalLeft.vmin),l=o.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalRight.vmin);if(m===l){const t=r.getEndY(),e=o.getEndY(),s=Math.min(t,e);let n=.5*(s+this.m_yScanline);n===this.m_yScanline&&(n=s),m=r.intersectionOfYMonotonicWithAxisX(n,this.m_intervalLeft.vmin),l=o.intersectionOfYMonotonicWithAxisX(n,this.m_intervalRight.vmin)}return m<l?-1:m>l?1:0}setY(t){this.m_yScanline=t}}class Z{constructor(t){this.m_segmentBuffer=new o.S,this.m_point=h.P.getNAN(),this.m_parent=t}setPointXY(t){this.m_point.assign(t)}compare(t,e){const s=t.getElement(e);this.m_parent.querySegmentXY(s,this.m_segmentBuffer);const n=this.m_segmentBuffer.get(),i=new h.E;if(i.setCoords(n.getStartX(),n.getEndX()),this.m_point.x<i.vmin)return-1;if(this.m_point.x>i.vmax)return 1;const r=n.intersectionOfYMonotonicWithAxisX(this.m_point.y,this.m_point.x);return this.m_point.x<r?-1:this.m_point.x>r?1:0}}var Q,K,J;function $(t,e){return{parentage:t,rank:e}}function tt(t,e){const s=t.length;if(s!==e.length)return!1;const n=t[0].parentage;if(n!==e[0].parentage)return!1;if(-1===n)return!0;for(let i=1;i<s;++i)if(t[i].parentage!==e[i].parentage)return!1;return!0}function et(t,e,s){s.length=0;let n=!1;{let i=t.getHalfEdgeVertexIterator(e);for(;i!==o.n;){const e=t.getVertexFromVertexIterator(i),r=t.getShape().getSegmentRank(e),o=t.getShape().getSegmentParentage(e);n||(n=o>=0),s.push($(o,r)),i=t.incrementVertexIterator(i)}}{let i=t.getHalfEdgeVertexIterator(t.getHalfEdgeTwin(e));for(;i!==o.n;){const e=t.getVertexFromVertexIterator(i),r=t.getShape().getSegmentRank(e),o=t.getShape().getSegmentParentage(e);n||(n=o>=0),s.push($(o,r)),i=t.incrementVertexIterator(i)}}n&&s.sort(((t,e)=>t.rank>e.rank?-1:t.rank<e.rank?1:t.parentage<e.parentage?-1:t.parentage>e.parentage?1:0)),-1===s[0].parentage&&(s.length=1)}(J=Q||(Q={}))[J.enumInputModeBuildGraph=0]="enumInputModeBuildGraph",J[J.enumInputModeSimplifyAlternate=1]="enumInputModeSimplifyAlternate",J[J.enumInputModeSimplifyWinding=2]="enumInputModeSimplifyWinding",function(t){t[t.enumSegmentParentageBreakNode=1]="enumSegmentParentageBreakNode",t[t.enumPathBreakNode=2]="enumPathBreakNode"}(K||(K={}));class st{constructor(){this.m_shape=null,this.m_clusterData=new a.S(8),this.m_clusterVertices=new a.S(2),this.m_firstCluster=o.n,this.m_lastCluster=o.n,this.m_halfEdgeData=new a.S(8),this.m_chainData=new a.S(8),this.m_chainAreas=null,this.m_chainPerimeters=null,this.m_universeChain=-1,this.m_simplifiedGeometry=-1,this.m_edgeIndices=[],this.m_clusterIndices=[],this.m_chainIndices=[],this.m_bBuildGeometryParentageSets=!1,this.m_chainBitSetIndex=-1,this.m_edgeBitSetIndex=-1,this.m_edgeBitSetIndexLeft=-1,this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_uniqueBitSets=null,this.m_chainBitSets=[],this.m_edgeBitSets=[],this.m_checkDirtyPlanesweepTolerance=Number.NaN,this.m_geometryIDIndex=-1,this.m_clusterIndex=-1,this.m_halfEdgeIndex=-1,this.m_tmpHalfEdgeParentageIndex=-1,this.m_tmpHalfEdgeParentageIndexLeft=-1,this.m_tmpHalfEdgeWindingNumberIndex=-1,this.m_tmpHalfEdgeOddEvenNumberIndex=-1,this.m_segmentParentageIndex=-1,this.m_segmentIndexHe=-1,this.m_clusterBreakNodeIndex=-1,this.m_universeGeomID=-1,this.m_pointCount=0,this.m_progressCounter=0,this.m_bBuildChains=!0,this.m_bDirtyCheckFailed=!1}setCheckDirtyPlanesweepTolerance(t){this.m_checkDirtyPlanesweepTolerance=t}dirtyCheckFailed(){return this.m_bDirtyCheckFailed}getShape(){return this.m_shape}setEditShape(t,e){let s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];arguments.length>3&&void 0!==arguments[3]&&arguments[3]?this.setEditShapeImpl3D_(t,Q.enumInputModeBuildGraph,null,e,!1):this.setEditShapeImpl_(t,Q.enumInputModeBuildGraph,null,e,s)}setAndSimplifyEditShapeAlternate(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const i=[];i.push(e),this.m_simplifiedGeometry=e,n?this.setEditShapeImpl3D_(t,Q.enumInputModeSimplifyAlternate,i,s,!1):this.setEditShapeImpl_(t,Q.enumInputModeSimplifyAlternate,i,s,t.getGeometryType(e)===r.G.enumPolygon)}setAndSimplifyEditShapeWinding(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const n=[];n.push(e),this.m_simplifiedGeometry=e,this.setEditShapeImpl_(t,Q.enumInputModeSimplifyWinding,n,s,!0)}removeShape(){null!==this.m_shape&&(-1!==this.m_geometryIDIndex&&(this.m_shape.removeGeometryUserIndex(this.m_geometryIDIndex),this.m_geometryIDIndex=-1),-1!==this.m_clusterIndex&&(this.m_shape.removeUserIndex(this.m_clusterIndex),this.m_clusterIndex=-1),-1!==this.m_halfEdgeIndex&&(this.m_shape.removeUserIndex(this.m_halfEdgeIndex),this.m_halfEdgeIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),-1!==this.m_tmpHalfEdgeWindingNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),-1!==this.m_tmpHalfEdgeOddEvenNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1),-1!==this.m_segmentParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),-1!==this.m_segmentIndexHe&&(this.deleteUserIndexForHalfEdges(this.m_segmentIndexHe),this.m_segmentIndexHe=-1),-1!==this.m_clusterBreakNodeIndex&&(this.deleteUserIndexForClusters(this.m_clusterBreakNodeIndex),this.m_clusterBreakNodeIndex=-1),this.deleteEdgeBitSets_(),this.deleteChainBitSets_(),this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_shape=null,this.m_clusterData.deleteAll(!0),this.m_clusterVertices.deleteAll(!0),this.m_firstCluster=o.n,this.m_lastCluster=o.n,this.m_halfEdgeData.deleteAll(!0),this.m_edgeIndices.length=0,this.m_clusterIndices.length=0,this.m_chainIndices.length=0,this.m_chainData.deleteAll(!0),this.m_universeChain=o.n,this.m_chainAreas=null)}getClusterHalfEdge(t){return this.m_clusterData.getField(t,2)}queryXY(t,e){const s=this.getClusterVertexIndex_(t);e.assign(this.m_shape.getXYWithIndex(s))}queryXYZ(t,e){(0,r.g)(0)}getClusterParentage(t){return this.m_clusterData.getField(t,1)}getFirstCluster(){return this.m_firstCluster}getPrevCluster(t){return this.m_clusterData.getField(t,3)}getNextCluster(t){return this.m_clusterData.getField(t,4)}getClusterChain(t){return this.m_clusterData.getField(t,6)}getClusterVertexIterator(t){return this.m_clusterData.getField(t,7)}incrementVertexIterator(t){return this.m_clusterVertices.getField(t,1)}getVertexFromVertexIterator(t){return this.m_clusterVertices.getField(t,0)}getClusterUserIndex(t,e){const s=this.getClusterIndex_(t),n=this.m_clusterIndices[e];return n.size()<=s?-1:n.read(s)}setClusterUserIndex(t,e,s){const n=this.getClusterIndex_(t),i=this.m_clusterIndices[e];i.size()<=n&&i.resize(this.m_clusterData.size(),-1),i.write(n,s)}hasClusterUserIndexFlags(t,e,s){if(-1===e)return!1;const n=this.getClusterUserIndex(t,e);return-1!==n&&!!(s&n)}setClusterUserIndexFlags(t,e,s){const n=this.getClusterIndex_(t),i=this.m_clusterIndices[e];i.size()<=n&&i.resize(this.m_clusterData.size(),-1);let r=i.read(n);-1===r&&(r=0),i.write(n,s|r)}clearClusterUserIndexFlags(t,e,s){const n=this.getClusterIndex_(t),i=this.m_clusterIndices[e];i.size()<=n&&i.resize(this.m_clusterData.size(),-1);let r=i.read(n);-1===r&&(r=0),i.write(n,~s&r)}createUserIndexForClusters(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;const e=new a.A(this.m_clusterData.capacity(),t);for(let s=0,n=this.m_clusterIndices.length;s<n;s++)if(null===this.m_clusterIndices[s])return this.m_clusterIndices[s]=e,s;return this.m_clusterIndices.push(e),this.m_clusterIndices.length-1}deleteUserIndexForClusters(t){this.m_clusterIndices[t]=null}getHalfEdgeOrigin(t){return this.m_halfEdgeData.getField(t,1)}getHalfEdgeTo(t){return this.getHalfEdgeOrigin(this.getHalfEdgeTwin(t))}getHalfEdgeTwin(t){return this.m_halfEdgeData.getField(t,4)}getHalfEdgePrev(t){return this.m_halfEdgeData.getField(t,5)}getHalfEdgeNext(t){return this.m_halfEdgeData.getField(t,6)}getHalfEdgeChain(t){return this.m_halfEdgeData.getField(t,2)}getHalfEdgeFaceParentage(t){return this.getChainParentage(this.getHalfEdgeChain(t))}getHalfEdgeVertexIterator(t){return this.m_halfEdgeData.getField(t,7)}getHalfEdgeFromXY(t,e){this.queryXY(this.getHalfEdgeOrigin(t),e)}getHalfEdgeToXY(t,e){this.queryXY(this.getHalfEdgeTo(t),e)}isHalfEdgeCurve(t){return-1!==this.m_segmentIndexHe&&-1!==this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)}getHalfEdgeFromXYZ(t,e){(0,r.g)(0)}getHalfEdgeToXYZ(t,e){(0,r.g)(0)}getHalfEdgeParentage(t){return this.m_halfEdgeData.getField(t,3)&st.c_EdgeParentageMask}getHalfEdgeUserIndex(t,e){const s=this.getHalfEdgeIndex_(t),n=this.m_edgeIndices[e];return n.size()<=s?-1:n.read(s)}setHalfEdgeUserIndex(t,e,s){const n=this.getHalfEdgeIndex_(t),i=this.m_edgeIndices[e];i.size()<=n&&i.resize(this.m_halfEdgeData.size(),-1),i.write(n,s)}createUserIndexForHalfEdges(t){void 0===t&&(t=-1);const e=new a.A(this.m_halfEdgeData.capacity(),t);for(let n=0,i=this.m_edgeIndices.length;n<i;n++)if(null===this.m_edgeIndices[n])return this.m_edgeIndices[n]=e,n;this.m_edgeIndices.push(e);const s=this.m_edgeIndices.length-1;return(0,r.g)(s>=0&&s<=Number.MAX_SAFE_INTEGER),s}deleteUserIndexForHalfEdges(t){this.m_edgeIndices[t]=null}deleteEdgesBreakFaces_(t){for(let e=0,s=t.length;e<s;e++){const s=t[e],n=this.getHalfEdgeChain(s),i=this.getHalfEdgeTwin(s),r=this.getHalfEdgeChain(i);this.setChainHalfEdge_(n,o.n),this.setChainHalfEdge_(r,o.n),this.updateVertexToHalfEdgeConnection_(s,!0),this.deleteEdgeImpl_(s)}}doesHalfEdgeBelongToAPolygonInterior(t,e){return(0,r.g)(0),!1}doesHalfEdgeBelongToAPolygonExterior(t,e){return(0,r.g)(0),!1}doesHalfEdgeBelongToAPolygonBoundary(t,e){return(0,r.g)(0),!1}doesHalfEdgeBelongToAPolylineInterior(t,e){return(0,r.g)(0),!1}doesHalfEdgeBelongToAPolylineExterior(t,e){return(0,r.g)(0),!1}doesClusterBelongToAPolygonInterior(t,e){return(0,r.g)(0),!1}doesClusterBelongToAPolygonExterior(t,e){return(0,r.g)(0),!1}doesClusterBelongToAPolygonBoundary(t,e){return(0,r.g)(0),!1}getFirstChain(){return this.m_universeChain}getChainHalfEdge(t){return this.m_chainData.getField(t,1)}getChainParentage(t){return this.m_chainData.getField(t,2)}getChainParent(t){return this.m_chainData.getField(t,3)}getChainFirstIsland(t){return this.m_chainData.getField(t,4)}getChainNextInParent(t){return this.m_chainData.getField(t,5)}getChainNext(t){return this.m_chainData.getField(t,7)}getChainArea(t){const e=this.getChainIndex_(t);let s=this.m_chainAreas.read(e);return Number.isNaN(s)&&(this.updateChainAreaAndPerimeter_(t),s=this.m_chainAreas.read(e)),s}getChainPerimeter(t){return(0,r.g)(0),0}getChainUserIndex(t,e){const s=this.getChainIndex_(t),n=this.m_chainIndices[e];return n.size()<=s?-1:n.read(s)}setChainUserIndex(t,e,s){const n=this.getChainIndex_(t),i=this.m_chainIndices[e];i.size()<=n&&i.resize(this.m_chainData.size(),-1),i.write(n,s)}createUserIndexForChains(){const t=new a.A(this.m_chainData.capacity(),-1);for(let e=0,s=this.m_chainIndices.length;e<s;e++)if(null===this.m_chainIndices[e])return this.m_chainIndices[e]=t,e;return this.m_chainIndices.push(t),this.m_chainIndices.length-1}deleteUserIndexForChains(t){this.m_chainIndices[t]=null}extractPolygonFromChainAndIslands(t,e,s,n){const i=e===o.n?t.createGeometry(r.G.enumPolygon):e,a=new o.S;this.extractPolygonPathFromChain_(t,i,s,n,a);for(let r=this.getChainFirstIsland(s);r!==o.n;r=this.getChainNextInParent(r))this.extractPolygonPathFromChain_(t,i,r,n,a);return i}getGeometryID(t){const e=this.m_shape.getGeometryUserIndex(t,this.m_geometryIDIndex);return(0,r.g)(e>=0),1<<Math.min(e,31)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_clusterIndex)}getHalfEdgeFromVertex(t){return this.m_shape.getUserIndex(t,this.m_halfEdgeIndex)}buildGeometryParentageSets(){this.m_bBuildGeometryParentageSets=!0}getChainBitSet(t){if((0,r.g)(this.m_bBuildGeometryParentageSets),-1===this.m_chainBitSetIndex)return this.getEmptySet();const e=this.getChainUserIndex(t,this.m_chainBitSetIndex);(0,r.g)(e>=0);let s=this.m_chainBitSets.at(e);return s||(s=this.getEmptySet()),s}getChainBoundaryBitSet(t){(0,r.g)(this.m_bBuildGeometryParentageSets);const e=new O,s=t=>{const s=this.getChainHalfEdge(t);let n=s;do{const t=this.getEdgeBitSet_(n);null!==t&&e.assignOr(t);const s=this.getEdgeBitSet_(this.getHalfEdgeTwin(n));null!==s&&e.assignOr(s),n=this.getHalfEdgeNext(n)}while(n!==s)};s(t);for(let n=this.getChainFirstIsland(t);n!==o.n;n=this.getChainNextInParent(n))s(t);return e}getChainPolygons(t){return(0,r.g)(0),[]}getGeometriesFromBits(t){if(!this.m_bBuildGeometryParentageSets||null===t)return[];if(null===this.m_geometryMapID){this.m_geometryMapID=new Map;for(let t=this.m_shape.getFirstGeometry();t!==o.n;t=this.m_shape.getNextGeometry(t))this.m_geometryMapID.set(this.m_shape.getGeometryUserIndex(t,this.m_geometryIDIndex),t)}const e=[],s=t.getUnorderedBitIterator();for(let n=s.next();n!==B.npos();n=s.next())(0,r.g)(this.m_geometryMapID.has(n)),e.push(this.m_geometryMapID.get(n));return e}getVertexDominant(t,e){if(e===o.n)return t;const s=this.getClusterFromVertex(t);return this.getVertexDominantFromCluster(s,e)}getVertexDominantFromCluster(t,e){if(e!==o.n){let s=o.n;for(let n=this.getClusterVertexIterator(t);n!==o.n;n=this.incrementVertexIterator(n)){const t=this.getVertexFromVertexIterator(n);s===o.n&&(s=t);const i=this.m_shape.getPathFromVertex(t);if(this.m_shape.getGeometryFromPath(i)===e){s=t;break}}return s}{const e=this.getClusterVertexIterator(t);return e!==o.n?this.getVertexFromVertexIterator(e):o.n}}isBreakNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,K.enumSegmentParentageBreakNode)}setBreakNode(t,e){(0,r.g)(-1!==this.m_clusterBreakNodeIndex),e?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,K.enumSegmentParentageBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,K.enumSegmentParentageBreakNode)}isStrongPathNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,K.enumPathBreakNode)}setStrongPathNode(t,e){if(-1===this.m_clusterBreakNodeIndex){if(!e)return;this.m_clusterBreakNodeIndex=this.createUserIndexForClusters()}e?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,K.enumPathBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,K.enumPathBreakNode)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const e=this.getHalfEdgeUserIndex(t,this.m_segmentParentageIndex);return e>=0?e:-1}isCrossroadAhead(t){const e=this.getHalfEdgeNext(t);if(this.isStrongPathNode(this.getHalfEdgeOrigin(e)))return!0;const s=this.getHalfEdgeTwin(e),n=this.getHalfEdgeNext(s);return t!==this.getHalfEdgeTwin(n)}isCrossroadBehind(t){return(0,r.g)(0),!1}getHalfEdgeConnector(t,e){const s=this.getClusterHalfEdge(t);if(s===o.n)return o.n;let n=s,i=o.n,r=o.n;do{if(this.getHalfEdgeTo(n)===e)return n;if(i===o.n){if(i=this.getClusterHalfEdge(e),i===o.n)return o.n;r=i}if(this.getHalfEdgeTo(r)===t)return n=this.getHalfEdgeTwin(r),n;n=this.getHalfEdgeNext(this.getHalfEdgeTwin(n)),r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(n!==s&&r!==i);return o.n}querySegmentXY(t,e){if(-1!==this.m_segmentIndexHe){let s=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(-1!==s){if(-2!==s){const t=this.m_shape.getSegmentFromIndex(s);e.copyFrom(t,!0)}else{s=this.getHalfEdgeUserIndex(this.getHalfEdgeTwin(t),this.m_segmentIndexHe);const n=this.m_shape.getSegmentFromIndex(s);e.copyFrom(n,!0),e.get().reverse()}return}}e.createLine();const s=e.get(),n=h.P.getNAN();this.getHalfEdgeFromXY(t,n),s.setStartXY(n),this.getHalfEdgeToXY(t,n),s.setEndXY(n)}isCurveEdge(t){return-1!==this.m_segmentIndexHe&&-1!==this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)}compareEdgeAnglesCurveHelper_(t,e,s){const n=new o.S,i=new o.S;this.querySegmentXY(t,n),this.querySegmentXY(e,i);const a=n.get(),m=i.get();if(a.equals(m))return 0;const l=new h.P;this.getHalfEdgeFromXY(t,l);const u=new h.P;this.getHalfEdgeToXY(t,u);const c=new h.P;this.getHalfEdgeToXY(e,c),(0,r.g)(!u.isEqualPoint2D(c));const g=a.getTangent(0),d=m.getTangent(0);return h.P.compareVectors(g,d)}compareEdgeAnglesHelper_(t,e,s){if(t===e)return 0;if(this.isHalfEdgeCurve(t)||this.isHalfEdgeCurve(e))return this.compareEdgeAnglesCurveHelper_(t,e,s);const n=h.P.getNAN();this.getHalfEdgeToXY(t,n);const i=h.P.getNAN();if(this.getHalfEdgeToXY(e,i),n.isEqualPoint2D(i))return 0;const r=h.P.getNAN();this.getHalfEdgeFromXY(t,r);const o=h.P.getNAN();o.setSub(n,r);const a=h.P.getNAN();return a.setSub(i,r),!s||a.y>=0&&o.y>0?h.P.compareVectors(o,a):0}compareEdgeAngles_(t,e){return this.compareEdgeAnglesHelper_(t,e,!1)}compareEdgeAnglesForPair_(t,e){return this.compareEdgeAnglesHelper_(t,e,!0)}compareEdgeAngles3D_(t,e){return(0,r.g)(0),0}compareEdgeAnglesForPair3D_(t,e){return(0,r.g)(0),0}dbgDumpChains_(){}dbgDumpChainToPolygon_(t,e){}deleteEdgeInternal_(t){const e=this.getHalfEdgeChain(t),s=this.getHalfEdgeTwin(t),n=this.getHalfEdgeChain(s);(0,r.g)(n===e),(0,r.g)(t===this.getHalfEdgeNext(s)||s===this.getHalfEdgeNext(t));let i=this.getHalfEdgeNext(t);i===s&&(i=this.getHalfEdgeNext(i),i===t&&(i=o.n));const a=this.getChainIndex_(e),h=this.m_chainAreas.read(a);Number.isNaN(h)||(this.setChainArea_(e,Number.NaN),this.setChainPerimeter_(e,Number.NaN));const m=this.getChainHalfEdge(e);m!==t&&m!==s||this.setChainHalfEdge_(e,i),this.updateVertexToHalfEdgeConnection_(t,!0),this.deleteEdgeImpl_(t)}getFirstUnvisitedHalfEdgeOnCluster_(t,e,s){let n=e!==o.n?e:this.getClusterHalfEdge(t);if(n===o.n)return o.n;const i=n;for(;;){if(1!==this.getHalfEdgeUserIndex(n,s))return n;const t=this.getHalfEdgeNext(this.getHalfEdgeTwin(n));if(t===i)return o.n;n=t}}removeSpikes_(){let t=!1;const e=this.createUserIndexForHalfEdges();for(let s=this.getFirstCluster();s!==o.n;s=this.getNextCluster(s)){let n=o.n;for(;;){let i=this.getFirstUnvisitedHalfEdgeOnCluster_(s,n,e);if(i===o.n)break;n=this.getHalfEdgeNext(this.getHalfEdgeTwin(i));let r=i;for(;;){const s=this.getHalfEdgeNext(r),a=this.getHalfEdgePrev(r),h=this.getHalfEdgeTwin(r);if(a===h){if(this.deleteEdgeInternal_(r),t=!0,n!==r&&n!==h||(n=o.n),r===i||a===i){if(i=s,r===i||a===i)break;r=s;continue}}else this.setHalfEdgeUserIndex(r,e,1);if(r=s,r===i)break}}}return this.deleteUserIndexForHalfEdges(e),t}progress_(t){}newCluster_(){const t=this.m_clusterData.newElement();return this.m_clusterData.setField(t,1,0),t}newHalfEdgePair_(){const t=this.m_halfEdgeData.newElement();this.m_halfEdgeData.setField(t,2,0),this.m_halfEdgeData.setField(t,3,0);const e=this.m_halfEdgeData.newElement();return this.m_halfEdgeData.setField(e,2,0),this.m_halfEdgeData.setField(e,3,0),this.setHalfEdgeTwin_(t,e),this.setHalfEdgeTwin_(e,t),t}newChain_(){const t=this.m_chainData.newElement();return this.m_chainData.setField(t,2,0),t}deleteChain_(t){return(0,r.g)(0),0}getClusterIndex_(t){return this.m_clusterData.elementToIndex(t)}setClusterVertexIterator_(t,e){this.m_clusterData.setField(t,7,e)}setClusterHalfEdge_(t,e){this.m_clusterData.setField(t,2,e)}setClusterParentage_(t,e){this.m_clusterData.setField(t,1,e)}setPrevCluster_(t,e){this.m_clusterData.setField(t,3,e)}setNextCluster_(t,e){this.m_clusterData.setField(t,4,e)}setClusterVertexIndex_(t,e){this.m_clusterData.setField(t,5,e)}getClusterVertexIndex_(t){return this.m_clusterData.getField(t,5)}setClusterChain_(t,e){this.m_clusterData.setField(t,6,e)}addClusterToExteriorChain_(t,e){this.setClusterChain_(e,t)}getHalfEdgeIndex_(t){return this.m_halfEdgeData.elementToIndex(t)}setHalfEdgeOrigin_(t,e){this.m_halfEdgeData.setField(t,1,e)}setHalfEdgeTwin_(t,e){this.m_halfEdgeData.setField(t,4,e)}setHalfEdgePrev_(t,e){this.m_halfEdgeData.setField(t,5,e)}setHalfEdgeNext_(t,e){this.m_halfEdgeData.setField(t,6,e)}setHalfEdgeChain_(t,e){this.m_halfEdgeData.setField(t,2,e)}setHalfEdgeParentage_(t,e){this.m_halfEdgeData.setField(t,3,e)}getHalfEdgeParentageMask_(t){return this.m_halfEdgeData.getField(t,3)}setHalfEdgeVertexIterator_(t,e){this.m_halfEdgeData.setField(t,7,e)}updateVertexToHalfEdgeConnectionHelper_(t,e){const s=e?o.n:t;for(let n=this.getHalfEdgeVertexIterator(t);n!==o.n;n=this.incrementVertexIterator(n)){const t=this.getVertexFromVertexIterator(n);this.m_shape.setUserIndex(t,this.m_halfEdgeIndex,s)}}updateVertexToHalfEdgeConnection_(t,e){t!==o.n&&(this.updateVertexToHalfEdgeConnectionHelper_(t,e),this.updateVertexToHalfEdgeConnectionHelper_(this.getHalfEdgeTwin(t),e))}getChainIndex_(t){return this.m_chainData.elementToIndex(t)}setChainHalfEdge_(t,e){this.m_chainData.setField(t,1,e)}setChainParentage_(t,e){this.m_chainData.setField(t,2,e)}setChainParent_(t,e){this.m_chainData.setField(t,3,e);const s=this.getChainFirstIsland(e);this.setChainNextInParent_(t,s),this.setChainFirstIsland_(e,t)}setChainFirstIsland_(t,e){this.m_chainData.setField(t,4,e)}setChainNextInParent_(t,e){this.m_chainData.setField(t,5,e)}setChainPrev_(t,e){this.m_chainData.setField(t,6,e)}setChainNext_(t,e){this.m_chainData.setField(t,7,e)}setChainArea_(t,e){const s=this.getChainIndex_(t);this.m_chainAreas.write(s,e)}setChainPerimeter_(t,e){const s=this.getChainIndex_(t);this.m_chainPerimeters.write(s,e)}updateChainAreaAndPerimeter_(t){const e=this.m_shape.hasCurves(),s=new h.K(0),n=new h.K(0),i=this.getChainHalfEdge(t),r=h.P.getNAN(),a=h.P.getNAN(),m=h.P.getNAN();this.getHalfEdgeFromXY(i,r),a.setCoordsPoint2D(r);let l=i;do{this.getHalfEdgeToXY(l,m),e&&this.isCurveEdge(l)||n.pe(h.P.distance(a,m)),this.getHalfEdgeChain(this.getHalfEdgeTwin(l))!==t&&s.pe((m.x-r.x-(a.x-r.x))*(m.y-r.y+(a.y-r.y))*.5),a.setCoordsPoint2D(m),l=this.getHalfEdgeNext(l)}while(l!==i);if(e){const e=new o.S;l=i;do{this.getHalfEdgeToXY(l,m);const i=this.isCurveEdge(l);if(i&&(this.querySegmentXY(l,e),n.pe(e.get().calculateLength2D())),this.getHalfEdgeChain(this.getHalfEdgeTwin(l))!==t&&i){const t=e.get().calculateArea2DHelper();s.pe(t)}l=this.getHalfEdgeNext(l)}while(l!==i)}const u=this.getChainIndex_(t);this.m_chainAreas.write(u,s.getResult()),this.m_chainPerimeters.write(u,n.getResult())}getChainTopmostEdge_(t){return(0,r.g)(0),0}planeSweepParentage_(t,e){const s=new j(this),n=new a.T;n.setCapacity(Math.trunc(this.m_pointCount/2)),n.setComparator(s);const i=[],r=this.createUserIndexForHalfEdges();let m=null;const l=h.P.getNAN();for(let h=this.getFirstCluster();h!==o.n;h=this.getNextCluster(h)){this.progress_(e);const u=this.getClusterHalfEdge(h);if(u!==o.n){if(i.length=0,!this.tryOptimizedInsertion_(n,r,i,h,u)){this.queryXY(h,l),s.setY(l.y);let t=u;do{const e=this.getHalfEdgeUserIndex(t,r);-1!==e&&(n.deleteNode(e),this.setHalfEdgeUserIndex(t,r,a.S.impossibleIndex2())),t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(u!==t);t=u;do{if(-1===this.getHalfEdgeUserIndex(t,r)){const e=n.addElement(t);i.push(e)}t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(u!==t)}for(let e=i.length-1;e>=0;e--){const s=i[e],o=n.getElement(s),a=this.getHalfEdgeTwin(o);this.setHalfEdgeUserIndex(a,r,s),this.planeSweepParentagePropagateParentage_(n,s,t)}}else if(this.getClusterChain(h)===o.n){null===m&&(m=new Z(this)),this.queryXY(h,l),m.setPointXY(l);const t=n.searchLowerBound(m);let e=this.m_universeChain;if(-1!==t){let s=n.getElement(t);this.getHalfEdgeChain(s)===this.getHalfEdgeChain(this.getHalfEdgeTwin(s))&&(s=this.getLeftSkipPolylines_(n,t)),s!==o.n&&(e=this.getHalfEdgeChain(s))}this.addClusterToExteriorChain_(e,h)}}this.deleteUserIndexForHalfEdges(r)}planeSweepParentagePropagateParentage_(t,e,s){const n=t.getElement(e),i=this.getHalfEdgeChain(n);if(this.getChainParent(i)!==o.n)return;const a=this.getLeftSkipPolylines_(t,e),h=this.getHalfEdgeTwin(n),m=this.getHalfEdgeChain(h);let l=this.getChainParent(i),u=this.getChainParent(m);if(a===o.n)l===o.n&&(m===i?(this.setChainParent_(m,this.m_universeChain),u=this.m_universeChain,l=u):(u===o.n&&(this.setChainParent_(m,this.m_universeChain),u=this.m_universeChain),this.setChainParent_(i,m),l=m));else{const t=this.getHalfEdgeChain(a);if(u===o.n){if(this.getChainArea(t)<=0){const e=this.getChainParent(t);this.setChainParent_(m,e),u=e}else this.setChainParent_(m,t),u=t;m===i&&(l=u)}}l===o.n&&(this.trySetChainParentFromTwin_(i,m),l=this.getChainParent(i)),(0,r.g)(l!==o.n),s===Q.enumInputModeBuildGraph?this.propagateParentageBuildGraph_(t,e,n,a):s===Q.enumInputModeSimplifyWinding?this.propagateParentageWinding_(t,e,n,a,h,i,m):s===Q.enumInputModeSimplifyAlternate&&this.propagateParentageAlternate_(t,e,n,a,h,i,m)}propagateParentageBuildGraph_(t,e,s,n){let i,r=e;n===o.n?(r=t.getNext(r),i=this.getHalfEdgeChain(s)):i=this.getHalfEdgeChain(n);let a=null,h=this.getChainParentage(i);for(this.m_bBuildGeometryParentageSets&&(a=this.getChainBitSet(i));-1!==r;r=t.getNext(r)){const e=t.getElement(r),s=this.getHalfEdgeTwin(e);i=this.getHalfEdgeChain(e);const n=this.getHalfEdgeChain(s);if(this.m_bBuildGeometryParentageSets){let t=this.getChainBitSet(n);t=new O({copy:t}),t.assignOr(a),this.setChainBitSet_(n,t);let s=this.getChainBitSet(i);const r=this.getLeftEdgeBitSet_(e),o=new O({copy:a});if(o.assignSubtract(r),o.isZero())break;s=new O({copy:s}),s.assignOr(o),this.setChainBitSet_(i,s),a=s}const o=this.getChainParentage(n),m=o|h;m!==o&&this.setChainParentage_(n,m);let l=this.getChainParentage(i);const u=h&~this.getHalfEdgeUserIndex(e,this.m_tmpHalfEdgeParentageIndexLeft);if(u&&(l|=u,this.setChainParentage_(i,l)),0===u)break;h=l}}propagateParentageWinding_(t,e,s,n,i,a,h){if(a===h)return;let m=this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeWindingNumberIndex);m+=this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeWindingNumberIndex);let l=0;const u=[],c=[];c.push(0);for(let g=t.getFirst();g!==e;g=t.getNext(g)){const e=t.getElement(g),s=this.getHalfEdgeTwin(e),n=this.getHalfEdgeChain(e),i=this.getHalfEdgeChain(s);if(n!==i){let t=this.getHalfEdgeUserIndex(e,this.m_tmpHalfEdgeWindingNumberIndex);t+=this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeWindingNumberIndex),l+=t;let a=!1;0!==u.length&&u.at(-1)===i&&(c.pop(),u.pop(),a=!0),(0,r.g)(this.getChainParent(i)!==o.n),a&&this.getChainParent(i)===n||(c.push(l),u.push(n))}}if(l+=m,0!==u.length&&u.at(-1)===h&&(c.pop(),u.pop()),0!==l){if(0===c.at(-1)){const t=this.m_simplifiedGeometry,e=this.getGeometryID(t);this.setChainParentage_(a,e)}}else if(0!==c.at(-1)){const t=this.m_simplifiedGeometry,e=this.getGeometryID(t);this.setChainParentage_(a,e)}}propagateParentageAlternate_(t,e,s,n,i,r,a){const h=this.m_simplifiedGeometry,m=this.getGeometryID(h);if(n===o.n)this.setChainParentage_(a,this.m_universeGeomID),1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,m):this.setChainParentage_(r,this.m_universeGeomID);else{const t=this.getChainParentage(a);if(0===t){const t=this.getHalfEdgeChain(n),e=this.getChainParentage(t);this.setChainParentage_(a,e),1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,e===m?this.m_universeGeomID:m):this.setChainParentage_(r,e)}else 1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,t===m?this.m_universeGeomID:m):this.setChainParentage_(r,t)}}tryOptimizedInsertion_(t,e,s,n,i){let r=i,h=-1,m=o.n,l=0;do{if(2===l)return!1;const t=this.getHalfEdgeUserIndex(r,e);if(-1!==t){if(-1!==h)return!1;h=t}else{if(m!==o.n)return!1;m=r}l++,r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(i!==r);return m!==o.n&&-1!==h&&(this.setHalfEdgeUserIndex(t.getElement(h),e,a.S.impossibleIndex2()),t.setElement(h,m),s.push(h),!0)}trySetChainParentFromTwin_(t,e){const s=this.getChainArea(t);if(0===s)return!1;const n=this.getChainArea(e);if(s>0&&n<0||s<0&&n>0)return this.setChainParent_(t,e),!0;{const s=this.getChainParent(e);if(s!==o.n)return this.setChainParent_(t,s),!0}return!1}createHalfEdges_(t,e){this.m_halfEdgeIndex=this.m_shape.createUserIndex();for(let s=0,n=e.size();s<n;s++){const n=e.read(s),i=this.m_shape.getUserIndex(n,this.m_clusterIndex),a=this.m_shape.getPathFromVertex(n),h=this.m_shape.getGeometryFromPath(a),m=this.m_shape.getGeometryType(h);if((0,r.h)(m)){const e=this.m_shape.getNextVertex(n);if(e===o.n)continue;const s=this.m_shape.getUserIndex(e,this.m_clusterIndex);if(i===s)continue;const a=this.newHalfEdgePair_(),l=this.getHalfEdgeTwin(a),u=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(u,0,n),this.m_clusterVertices.setField(u,1,-1),this.setHalfEdgeVertexIterator_(a,u),this.m_shape.setUserIndex(n,this.m_halfEdgeIndex,a),this.setHalfEdgeOrigin_(a,i);const c=this.getClusterHalfEdge(i);if(c===o.n)this.setClusterHalfEdge_(i,a),this.setHalfEdgePrev_(a,l),this.setHalfEdgeNext_(l,a);else{const t=this.getHalfEdgePrev(c);this.setHalfEdgePrev_(c,l),this.setHalfEdgeNext_(l,c),this.setHalfEdgeNext_(t,a),this.setHalfEdgePrev_(a,t)}this.setHalfEdgeOrigin_(l,s);const g=this.getClusterHalfEdge(s);if(g===o.n)this.setClusterHalfEdge_(s,l),this.setHalfEdgeNext_(a,l),this.setHalfEdgePrev_(l,a);else{const t=this.getHalfEdgePrev(g);this.setHalfEdgePrev_(g,a),this.setHalfEdgeNext_(a,g),this.setHalfEdgeNext_(t,l),this.setHalfEdgePrev_(l,t)}const d=this.getGeometryID(h);if(t===Q.enumInputModeBuildGraph){const t=m===r.G.enumPolygon?d:0;if(this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndex,0),this.setHalfEdgeUserIndex(a,this.m_tmpHalfEdgeParentageIndex,t),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndexLeft,t),this.setHalfEdgeUserIndex(a,this.m_tmpHalfEdgeParentageIndexLeft,0),this.m_bBuildGeometryParentageSets){const t=new O,e=this.m_shape.getGeometryUserIndex(h,this.m_geometryIDIndex);t.setBit(e),this.setEdgeBitSet_(a,t),this.setEdgeBitSet_(l,null),this.setLeftEdgeBitSet_(l,t),this.setLeftEdgeBitSet_(a,null)}}else if(t===Q.enumInputModeSimplifyWinding){const t=this.m_shape.getXY(n),s=this.m_shape.getXY(e);let i=0,r=0;t.compare(s)<0?i=1:r=-1,this.setHalfEdgeUserIndex(a,this.m_tmpHalfEdgeWindingNumberIndex,i),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeWindingNumberIndex,r)}else t===Q.enumInputModeSimplifyAlternate&&(this.setHalfEdgeUserIndex(a,this.m_tmpHalfEdgeOddEvenNumberIndex,1),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeOddEvenNumberIndex,1));const _=m===r.G.enumPolygon?st.c_EdgeBitMask:0;this.setHalfEdgeParentage_(a,d|_),this.setHalfEdgeParentage_(l,d|_)}}if(this.m_shape.hasCurves()){this.m_segmentIndexHe=this.createUserIndexForHalfEdges();for(let t=0,s=e.size();t<s;t++){const s=e.read(t);if(this.m_shape.getSegment(s)){const t=this.m_shape.getUserIndex(s,this.m_halfEdgeIndex);t!==o.n&&(this.setHalfEdgeUserIndex(t,this.m_segmentIndexHe,this.m_shape.getVertexIndex(s)),this.setHalfEdgeUserIndex(this.getHalfEdgeTwin(t),this.m_segmentIndexHe,-2))}}}}mergeVertexListsOfEdges_(t,e){{const s=this.getHalfEdgeVertexIterator(e);if(s!==o.n){const n=this.getHalfEdgeVertexIterator(t);this.m_clusterVertices.setField(s,1,n),this.setHalfEdgeVertexIterator_(t,s),this.setHalfEdgeVertexIterator_(e,o.n)}}const s=this.getHalfEdgeTwin(t),n=this.getHalfEdgeTwin(e);{const t=this.getHalfEdgeVertexIterator(n);if(t!==o.n){const e=this.getHalfEdgeVertexIterator(s);this.m_clusterVertices.setField(t,1,e),this.setHalfEdgeVertexIterator_(s,t),this.setHalfEdgeVertexIterator_(n,o.n)}}if(-1!==this.m_segmentIndexHe){let i=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(-1!==i){if(-2===i){const s=this.getHalfEdgeUserIndex(e,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(t,this.m_segmentIndexHe,s)}if(i=this.getHalfEdgeUserIndex(s,this.m_segmentIndexHe),-2===i){const t=this.getHalfEdgeUserIndex(n,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(s,this.m_segmentIndexHe,t)}}}}sortHalfEdgesByAngle_(t){const e=[];for(let s=this.getFirstCluster();s!==o.n;s=this.getNextCluster(s)){e.length=0;const n=this.getClusterHalfEdge(s);if(n!==o.n){let i=n;do{e.push(i),i=this.getHalfEdgeNext(this.getHalfEdgeTwin(i))}while(i!==n);if(e.length>1){let i=!0;e.length>2?(e.sort(((t,e)=>this.compareEdgeAngles_(t,e))),e.push(e[0])):this.compareEdgeAnglesForPair_(e[0],e[1])>0?e[1]=(0,h.b)(e[0],e[0]=e[1]):i=!1;let r=e[0],a=r,m=this.getHalfEdgeTo(a),l=this.getHalfEdgeTwin(a),u=o.n;for(let s=1,n=e.length;s<n;s++){const n=e[s],i=this.getHalfEdgeTwin(n),h=this.getHalfEdgeOrigin(i);if(h!==m||n===a)this.updateVertexToHalfEdgeConnection_(u,!1),u=o.n,a=n,m=h,l=i;else{if(t===Q.enumInputModeBuildGraph){const t=this.getHalfEdgeParentageMask_(a)|this.getHalfEdgeParentageMask_(n);if(this.setHalfEdgeParentage_(a,t),this.setHalfEdgeParentage_(l,t),this.setHalfEdgeUserIndex(a,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(a,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(a,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(a,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeParentageIndexLeft)),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeParentageIndexLeft)),this.m_bBuildGeometryParentageSets){let t,e,s;t=this.getEdgeBitSet_(a),e=this.getEdgeBitSet_(n),s=new O({copy:t}),s.assignOr(e),this.setEdgeBitSet_(a,s),t=this.getEdgeBitSet_(l),e=this.getEdgeBitSet_(i),s=new O({copy:t}),s.assignOr(e),this.setEdgeBitSet_(l,s),t=this.getLeftEdgeBitSet_(a),e=this.getLeftEdgeBitSet_(n),s=new O({copy:t}),s.assignOr(e),this.setLeftEdgeBitSet_(a,s),t=this.getLeftEdgeBitSet_(l),e=this.getLeftEdgeBitSet_(i),s=new O({copy:t}),s.assignOr(e),this.setLeftEdgeBitSet_(l,s)}}else if(-1!==this.m_tmpHalfEdgeWindingNumberIndex){const t=this.getHalfEdgeUserIndex(a,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeWindingNumberIndex),e=this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeWindingNumberIndex);this.setHalfEdgeUserIndex(a,this.m_tmpHalfEdgeWindingNumberIndex,t),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeWindingNumberIndex,e)}else if(-1!==this.m_tmpHalfEdgeOddEvenNumberIndex){const t=this.getHalfEdgeUserIndex(a,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeOddEvenNumberIndex),e=this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeOddEvenNumberIndex);this.setHalfEdgeUserIndex(a,this.m_tmpHalfEdgeOddEvenNumberIndex,t),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeOddEvenNumberIndex,e)}this.mergeVertexListsOfEdges_(a,n),this.deleteEdgeImpl_(n),u=a,e[s]=o.n,n===r&&(e[0]=o.n,r=o.n)}}if(this.updateVertexToHalfEdgeConnection_(u,!1),u=o.n,!i){r=o.n;for(let t=0,s=e.length;t<s;t++){const s=e[t];if(s!==o.n){r=s;break}}n!==r&&this.setClusterHalfEdge_(s,r);continue}r=o.n;for(let t=0,s=e.length;t<s;t++){const s=e[t];if(s===o.n)continue;if(r===o.n){r=s,a=r,m=this.getHalfEdgeTo(a),l=this.getHalfEdgeTwin(a);continue}if(s===a)continue;const n=this.getHalfEdgeTwin(s),i=this.getHalfEdgeOrigin(n);this.setHalfEdgeNext_(l,s),this.setHalfEdgePrev_(s,l),a=s,m=i,l=n}this.setClusterHalfEdge_(s,r)}}}}sortHalfEdgesByAngle3D_(t){(0,r.g)(0)}buildChains_(t){this.m_universeChain=this.newChain_(),this.setChainHalfEdge_(this.m_universeChain,o.n);let e=this.m_universeChain;const s=this.createUserIndexForHalfEdges();for(let n=this.getFirstCluster();n!==o.n;n=this.getNextCluster(n)){const t=this.getClusterHalfEdge(n);if(t!==o.n){let n=t;do{if(1!==this.getHalfEdgeUserIndex(n,s)){const t=this.newChain_();this.setChainHalfEdge_(t,n),this.setChainPrev_(t,e),this.setChainNext_(e,t);let i=null;this.m_bBuildGeometryParentageSets&&(i=new O),e=t;let r=0,o=n;do{-1!==this.m_tmpHalfEdgeParentageIndex&&(r|=this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndex)),this.m_bBuildGeometryParentageSets&&i.assignOr(this.getEdgeBitSet_(o)),this.setHalfEdgeChain_(o,t),this.setHalfEdgeUserIndex(o,s,1),o=this.getHalfEdgeNext(o)}while(o!==n);this.m_bBuildGeometryParentageSets&&this.setChainBitSet_(t,i),this.setChainParentage_(t,r)}n=this.getHalfEdgeNext(this.getHalfEdgeTwin(n))}while(n!==t)}}this.m_chainAreas=new a.y(this.m_chainData.size(),Number.NaN),this.m_chainPerimeters=new a.y(this.m_chainData.size(),Number.NaN),this.setChainArea_(this.m_universeChain,Number.POSITIVE_INFINITY),this.setChainPerimeter_(this.m_universeChain,Number.POSITIVE_INFINITY),this.deleteUserIndexForHalfEdges(s)}simplify_(t){(0,r.g)(0)}simplifyAlternate_(){(0,r.g)(0)}simplifyWinding_(){(0,r.g)(0)}setEditShapeImpl_(t,e,s,n,i){this.removeShape(),this.m_bBuildChains=i,this.m_shape=t,this.m_geometryIDIndex=this.m_shape.createGeometryUserIndex();let m=this.m_shape.getTotalPointCount();if(s){m=0;for(let t=0,e=s.length;t<e;t++)m+=this.m_shape.getPointCount(s[t])}const l=new a.A(0);let u=0,c=0;{let t=null!=s?s[0]:this.m_shape.getFirstGeometry(),e=1;for(;t!==o.n;){this.m_shape.setGeometryUserIndex(t,this.m_geometryIDIndex,c++);for(let e=this.m_shape.getFirstPath(t);e!==o.n;e=this.m_shape.getNextPath(e)){let t=this.m_shape.getFirstVertex(e);for(let s=0,n=this.m_shape.getPathSize(e);s<n;s++)l.add(t),t=this.m_shape.getNextVertex(t)}(0,r.e)(this.m_shape.getGeometryType(t))||(u+=this.m_shape.getPathCount(t)),null!=s?(t=e<s.length?s[e]:o.n,e++):t=this.m_shape.getNextGeometry(t)}}this.m_universeGeomID=1<<Math.min(c,31),this.m_pointCount=l.size(),this.m_shape.sortVerticesSimpleByY(l,0,this.m_pointCount),this.m_clusterVertices.setCapacity(this.m_pointCount),this.progress_(n,!0),this.m_clusterData.setCapacity(this.m_pointCount+10),this.m_halfEdgeData.setCapacity(2*this.m_pointCount+32),this.m_chainData.setCapacity(Math.max(32,u)),this.m_clusterIndex=this.m_shape.createUserIndex();const g=h.P.getNAN();let d=0;const _=h.P.getNAN();for(let r=0;r<=this.m_pointCount;r++){if(r<this.m_pointCount){const t=l.read(r);this.m_shape.queryXY(t,_)}else _.setNAN();if(!g.isEqualPoint2D(_)){if(d<r){const t=this.newCluster_();let e=o.n,s=-1;for(let n=d;n<r;n++){s=l.read(n),this.m_shape.setUserIndex(s,this.m_clusterIndex,t);const i=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(i,0,s),this.m_clusterVertices.setField(i,1,e),e=i;const r=this.m_shape.getPathFromVertex(s),o=this.m_shape.getGeometryFromPath(r),a=this.getGeometryID(o);this.setClusterParentage_(t,this.getClusterParentage(t)|a)}this.setClusterVertexIterator_(t,e),this.setClusterVertexIndex_(t,this.m_shape.getVertexIndex(s)),this.m_lastCluster!==o.n&&this.setNextCluster_(this.m_lastCluster,t),this.setPrevCluster_(t,this.m_lastCluster),this.m_lastCluster=t,this.m_firstCluster===o.n&&(this.m_firstCluster=t)}d=r,g.setCoordsPoint2D(_)}}if(this.m_shape.hasSegmentParentage()){-1===this.m_clusterBreakNodeIndex&&(this.m_clusterBreakNodeIndex=this.createUserIndexForClusters());for(let t=0;t<this.m_pointCount;t++){const e=l.read(t);if(this.m_shape.getSegmentParentageBreakVertex(e)){const t=this.getClusterFromVertex(e);this.setBreakNode(t,!0)}}}this.progress_(n,!0);{let t=null!=s?s[0]:this.m_shape.getFirstGeometry(),e=1;for(;t!==o.n;){for(let e=this.m_shape.getFirstPath(t);e!==o.n;e=this.m_shape.getNextPath(e)){if(this.m_shape.isStrongPathStart(e)){const t=this.m_shape.getFirstVertex(e),s=this.getClusterFromVertex(t);this.setStrongPathNode(s,!0)}if(this.m_shape.isStrongPathEnd(e)){const t=this.m_shape.isClosedPath(e)?this.m_shape.getFirstVertex(e):this.m_shape.getLastVertex(e),s=this.getClusterFromVertex(t);this.setStrongPathNode(s,!0)}}null!=s?(t=e<s.length?s[e]:o.n,e++):t=this.m_shape.getNextGeometry(t)}}if(e===Q.enumInputModeBuildGraph&&(this.m_tmpHalfEdgeParentageIndex=this.createUserIndexForHalfEdges(),this.m_tmpHalfEdgeParentageIndexLeft=this.createUserIndexForHalfEdges()),e===Q.enumInputModeSimplifyWinding&&(this.m_tmpHalfEdgeWindingNumberIndex=this.createUserIndexForHalfEdges()),e===Q.enumInputModeSimplifyAlternate&&(this.m_tmpHalfEdgeOddEvenNumberIndex=this.createUserIndexForHalfEdges()),this.createHalfEdges_(e,l),this.dbgNavigate_(),this.sortHalfEdgesByAngle_(e),!Number.isNaN(this.m_checkDirtyPlanesweepTolerance)&&!this.checkStructureAfterDirtySweep_())return this.m_bDirtyCheckFailed=!0,void this.cleanSetEditShapeImpl_();this.buildChains_(e),-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),this.m_bBuildChains&&this.planeSweepParentage_(e,n),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),this.dbgChkChainParents_(),this.dbgDumpChains_(),this.mergeSegmentParentage_(),this.dbgNavigate_(),this.dbgDumpChains_(),this.cleanSetEditShapeImpl_()}setEditShapeImpl3D_(t,e,s,n,i){(0,r.g)(0)}cleanSetEditShapeImpl_(){-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),-1!==this.m_tmpHalfEdgeWindingNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),-1!==this.m_tmpHalfEdgeOddEvenNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1)}cleanSetEditShapeImpl3D_(){(0,r.g)(0)}dbgNavigate_(){}dbgChkChainParents_(){}deleteEdgeImpl_(t){const e=this.getHalfEdgeNext(t),s=this.getHalfEdgePrev(t),n=this.getHalfEdgeTwin(t),i=this.getHalfEdgeNext(n),r=this.getHalfEdgePrev(n);e!==n&&(this.setHalfEdgeNext_(r,e),this.setHalfEdgePrev_(e,r)),s!==n&&(this.setHalfEdgeNext_(s,i),this.setHalfEdgePrev_(i,s));const a=this.getHalfEdgeOrigin(t);this.getClusterHalfEdge(a)===t&&(i!==t?this.setClusterHalfEdge_(a,i):this.setClusterHalfEdge_(a,o.n));const h=this.getHalfEdgeOrigin(n);this.getClusterHalfEdge(h)===n&&(e!==n?this.setClusterHalfEdge_(h,e):this.setClusterHalfEdge_(h,o.n)),this.m_halfEdgeData.deleteElement(t),this.m_halfEdgeData.deleteElement(n)}getLeftSkipPolylines_(t,e){let s=e;for(;;){if(s=t.getPrev(s),-1===s)return o.n;{const e=t.getElement(s);if(this.getHalfEdgeChain(e)!==this.getHalfEdgeChain(this.getHalfEdgeTwin(e)))return e}}}checkStructureAfterDirtySweep_(){const t=(0,h.s)(this.m_checkDirtyPlanesweepTolerance),e=new h.P,s=new h.P,n=new h.P,i=new h.P,r=new h.P;for(let a=this.getFirstCluster();a!==o.n;a=this.getNextCluster(a)){const h=this.getClusterHalfEdge(a);if(h!==o.n){let o=h;this.getHalfEdgeFromXY(o,e),this.getHalfEdgeToXY(o,s),n.setSub(s,e);let a=n.sqrLength();do{const h=o;if(o=this.getHalfEdgeNext(this.getHalfEdgeTwin(o)),o!==h){this.getHalfEdgeToXY(o,i),r.setSub(i,e);const h=r.sqrLength(),m=r.crossProduct(n),l=m*m/(h*a);if(Math.min(h,a)*l<=t&&r.dotProduct(n)>=0)return!1;n.assign(r),a=h,s.assign(i)}}while(o!==h)}}return!0}extractPolygonPathFromChain_(t,e,s,n,i){const r=this.m_shape.hasSegmentParentage(),h=this.getChainHalfEdge(s);let m=h,l=o.n;const u=new a.P;do{const a=this.getHalfEdgeTwin(m);if(this.getHalfEdgeChain(a)!==s){let s=o.n;const a=this.getHalfEdgeOrigin(m);if(n===o.n){const t=this.getClusterVertexIterator(a);s=this.getVertexFromVertexIterator(t)}else for(let t=this.getClusterVertexIterator(a);t!==o.n;t=this.incrementVertexIterator(t)){const e=this.getVertexFromVertexIterator(t);s===o.n&&(s=e);const i=this.m_shape.getPathFromVertex(e);if(this.m_shape.getGeometryFromPath(i)===n){s=e;break}}let h;if(l===o.n&&(l=t.insertPath(e,o.n),t.setClosedPath(l,!0)),this.m_shape===t?h=t.addVertex(l,s):(this.m_shape.queryPoint(s,u),h=t.addPoint(l,u)),this.isHalfEdgeCurve(m)&&(this.querySegmentXY(m,i),t.setSegmentToIndex(t.getVertexIndex(h),i.get().clone())),r){const e=this.getSegmentParentage(m);t.setSegmentParentageAndBreak(h,e,this.isBreakNode(a))}}m=this.getHalfEdgeNext(m)}while(m!==h)}mergeSegmentParentage_(){if(!this.m_shape.hasSegmentParentage())return;(0,r.g)(-1!==this.m_clusterBreakNodeIndex),(0,r.g)(-1===this.m_segmentParentageIndex);for(let n=this.getFirstCluster();n!==o.n;n=this.getNextCluster(n)){let t=0;const e=this.getClusterHalfEdge(n);if(e!==o.n){let s=e;do{t++,s=this.getHalfEdgeNext(this.getHalfEdgeTwin(s))}while(s!==e&&t<3)}2!==t&&this.setBreakNode(n,!0)}let t=[],e=[];this.m_segmentParentageIndex=this.createUserIndexForHalfEdges();const s=this.createUserIndexForHalfEdges();for(let n=this.getFirstCluster();n!==o.n;n=this.getNextCluster(n)){const i=this.getClusterHalfEdge(n);if(i!==o.n){let n=!1,r=i;do{let i=r;for(;-1===this.getHalfEdgeUserIndex(i,s);){const r=this.getHalfEdgeNext(i),o=this.getHalfEdgeTwin(i);et(this,i,e);const a=e.at(-1).parentage;if(!n){const e=this.getHalfEdgeOrigin(i);if(!this.isBreakNode(e)){const e=this.getHalfEdgePrev(i);i!==e&&(et(this,e,t),n=!0)}}if(n&&!tt(e,t)){const t=this.getHalfEdgeOrigin(i);this.setBreakNode(t,!0)}t=(0,h.b)(e,e=t),n=!0;const m=this.getHalfEdgeOrigin(r);this.isBreakNode(m)&&(n=!1),this.setHalfEdgeUserIndex(i,this.m_segmentParentageIndex,a),this.setHalfEdgeUserIndex(o,this.m_segmentParentageIndex,a),this.setHalfEdgeUserIndex(i,s,1),this.setHalfEdgeUserIndex(o,s,1),i=r}r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(r!==i)}}this.deleteUserIndexForHalfEdges(s)}registerNewBitSet(t){return null===this.m_uniqueBitSets&&(this.m_uniqueBitSets=new W((t=>t.getHashCode()),((t,e)=>t.equals(e))),this.m_uniqueBitSets.add(this.getEmptySet())),null===t?this.getEmptySet():this.m_uniqueBitSets.has(t)?this.m_uniqueBitSets.get(t):(this.m_uniqueBitSets.add(t),t)}getLeftEdgeBitSet_(t){const e=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft);return(0,r.g)(e>=0),(0,r.g)(this.m_edgeBitSets.at(e)),this.m_edgeBitSets.at(e)}getEdgeBitSet_(t){const e=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndex);return(0,r.g)(e>=0),this.m_edgeBitSets.at(e)}setEdgeBitSet_(t,e){(0,r.g)(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),-1===this.m_edgeBitSetIndex&&(this.m_edgeBitSetIndex=this.createUserIndexForHalfEdges());const s=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndex);-1!==s?this.m_edgeBitSets[s]=e:(this.setHalfEdgeUserIndex(t,this.m_edgeBitSetIndex,this.m_edgeBitSets.length),this.m_edgeBitSets.push(e))}setLeftEdgeBitSet_(t,e){(0,r.g)(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),-1===this.m_edgeBitSetIndexLeft&&(this.m_edgeBitSetIndexLeft=this.createUserIndexForHalfEdges());const s=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft);-1!==s?this.m_edgeBitSets[s]=e:(this.setHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft,this.m_edgeBitSets.length),this.m_edgeBitSets.push(e))}setChainBitSet_(t,e){(0,r.g)(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),-1===this.m_chainBitSetIndex&&(this.m_chainBitSetIndex=this.createUserIndexForChains());const s=this.getChainUserIndex(t,this.m_chainBitSetIndex);-1!==s?this.m_chainBitSets[s]=e:(this.setChainUserIndex(t,this.m_chainBitSetIndex,this.m_chainBitSets.length),this.m_chainBitSets.push(e))}getEmptySet(){return this.m_emptyBitSet||(this.m_emptyBitSet=new O),this.m_emptyBitSet}deleteEdgeBitSets_(){-1!==this.m_edgeBitSetIndex&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndex),this.m_edgeBitSetIndex=-1),-1!==this.m_edgeBitSetIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndexLeft),this.m_edgeBitSetIndexLeft=-1),this.m_edgeBitSets.length=0,this.m_uniqueBitSets=null}deleteChainBitSets_(){-1!==this.m_chainBitSetIndex&&(this.deleteUserIndexForChains(this.m_chainBitSetIndex),this.m_chainBitSetIndex=-1,this.m_chainBitSets.length=0)}dbgPrintEdge_(t){}dbgVerifyEdgeSegment(t){}}st.c_EdgeParentageMask=~(1<<31),st.c_EdgeBitMask=1<<31;class nt{freeNode_(t){this.m_listNodes.deleteElement(t)}newNode_(){return this.m_listNodes.newElement()}freeList_(t){this.m_lists.deleteElement(t)}newList_(){return this.m_lists.newElement()}Init_(t){(0,r.g)(0)}constructor(t){this.m_listNodes=new a.S(2),this.m_listOfLists=nt.st_nullNode(),this.m_bAllowNavigationBetweenLists=!0,void 0===t&&(t=!0),this.m_bAllowNavigationBetweenLists=t,this.m_lists=new a.S(this.m_bAllowNavigationBetweenLists?4:2)}createList(){const t=this.newList_();return this.m_bAllowNavigationBetweenLists&&(this.m_lists.setField(t,3,this.m_listOfLists),this.m_listOfLists!==nt.st_nullNode()&&this.m_lists.setField(this.m_listOfLists,2,t),this.m_listOfLists=t),t}deleteList(t){let e=this.getFirst(t);for(;e!==nt.st_nullNode();){const t=e;e=this.getNext(e),this.freeNode_(t)}if(this.m_bAllowNavigationBetweenLists){const e=this.m_lists.getField(t,2),s=this.m_lists.getField(t,3);e!==nt.st_nullNode()?this.m_lists.setField(e,3,s):this.m_listOfLists=s,s!==nt.st_nullNode()&&this.m_lists.setField(s,2,e)}this.freeList_(t)}reserveLists(t){this.m_lists.setCapacity(t)}addElement(t,e){this.m_lists.getField(t,0);const s=this.m_lists.getField(t,1),n=this.newNode_();return s!==nt.st_nullNode()?(this.m_listNodes.setField(s,1,n),this.m_lists.setField(t,1,n)):(this.m_lists.setField(t,0,n),this.m_lists.setField(t,1,n)),this.m_listNodes.setField(n,0,e),n}reserveNodes(t){this.m_listNodes.setCapacity(t)}deleteElementDirect(t,e,s){e!==nt.st_nullNode()?(this.m_listNodes.setField(e,1,this.m_listNodes.getField(s,1)),this.m_lists.getField(t,1)===s&&this.m_lists.setField(t,1,e)):(this.m_lists.setField(t,0,this.m_listNodes.getField(s,1)),this.m_lists.getField(t,1)===s&&this.m_lists.setField(t,1,nt.st_nullNode())),this.freeNode_(s)}deleteElementSearch(t,e){let s=-1,n=this.getFirst(t);for(;n!==e;)s=n,n=this.getNext(n);this.deleteElementDirect(t,s,e)}concatenateLists(t,e){const s=this.m_lists.getField(t,1),n=this.m_lists.getField(e,0);if(n!==nt.st_nullNode()&&(s!==nt.st_nullNode()?(this.m_listNodes.setField(s,1,n),this.m_lists.setField(t,1,this.m_lists.getField(e,1))):(this.m_lists.setField(t,0,n),this.m_lists.setField(t,1,this.m_lists.getField(e,1)))),this.m_bAllowNavigationBetweenLists){const t=this.m_lists.getField(e,2),s=this.m_lists.getField(e,3);t!==nt.st_nullNode()?this.m_lists.setField(t,3,s):this.m_listOfLists=s,s!==nt.st_nullNode()&&this.m_lists.setField(s,2,t)}return this.freeList_(e),t}getElement(t){return this.m_listNodes.getField(t,0)}getData(t){return this.getElement(t)}setElement(t,e){(0,r.g)(0)}getNext(t){return this.m_listNodes.getField(t,1)}getFirst(t){return this.m_lists.getField(t,0)}getFirstElement(t){const e=this.getFirst(t);return this.getElement(e)}static st_nullNode(){return-1}clear(){this.m_listNodes.deleteAll(!0),this.m_lists.deleteAll(!0),this.m_listOfLists=nt.st_nullNode()}isEmpty(t){return(0,r.g)(0),!1}getNodeCount(){return this.m_listNodes.size()}getListCount(){return this.m_lists.size()}getFirstList(){return this.m_listOfLists}getNextList(t){return this.m_lists.getField(t,3)}}function it(){return{m_value:arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,m_line:new o.L,m_segment:null,m_segmentInfo:new o.a8(-1),m_env:new h.E(0,0),m_dxdy:55555555,m_bHorizontal:!1,m_bCurve:!1}}class rt extends a.a6{constructor(t,e,s){super(!0),this.m_bIntersectionDetected=!1,this.m_nonSimpleResult=new p,this.m_tempSimpleEdge1=it(),this.m_tempSimpleEdge2=it(),this.m_prev1=o.n,this.m_prev2=o.n,this.m_vertex1=o.n,this.m_vertex2=o.n,this.m_currentNode=-1,this.m_prevX1=Number.NaN,this.m_prevX2=Number.NaN,this.m_prevY=Number.NaN,this.m_prevX=0,this.m_sweepY=Number.NaN,this.m_sweepX=0,this.m_ptSweep=new h.P,this.m_simpleEdgesCache=[],this.m_simpleEdgesRecycle=[],this.m_cOutstandingConstructedEdges=0,this.m_shape=t,this.m_bShapeHasSegments=this.m_shape.hasCurves(),this.m_tolerance=e,this.m_tolerance10=10*e,this.m_bIsSimple=s;const n=Math.trunc(Math.min(3*t.getTotalPointCount()/2,67)),i=Math.min(7,n);this.m_simpleEdgesCache.length=i}tryGetCachedEdge_(t){const e=this.m_simpleEdgesCache[(t&(0,h.j)())%this.m_simpleEdgesCache.length];return e&&e.m_value===t?e:null}tryDeleteCachedEdge_(t){const e=(t&(0,h.j)())%this.m_simpleEdgesCache.length,s=this.m_simpleEdgesCache[e];s&&s.m_value===t&&(this.m_simpleEdgesRecycle.push(s),this.m_simpleEdgesCache[e]=null)}tryCreateCachedEdge_(t){const e=(t&(0,h.j)())%this.m_simpleEdgesCache.length;let s=this.m_simpleEdgesCache[e];return s?null:(0===this.m_simpleEdgesRecycle.length?(s=it(),this.m_cOutstandingConstructedEdges++):s=this.m_simpleEdgesRecycle.pop(),s.m_value=t,this.m_simpleEdgesCache[e]=s,s)}initSimpleEdge_(t,e){this.m_bShapeHasSegments&&this.initSimpleEdgeHelper_(t,e)||t.m_bCurve||(this.m_shape.queryLineConnector(e,t.m_line,!0),t.m_segment=t.m_line,t.m_env.setCoordsNoNAN(t.m_line.getStartX(),t.m_line.getEndX()),t.m_env.vmax+=this.m_tolerance,t.m_line.orientBottomUp(),t.m_bHorizontal=t.m_line.getEndY()===t.m_line.getStartY(),t.m_bHorizontal||(t.m_dxdy=(t.m_line.getEndX()-t.m_line.getStartX())/(t.m_line.getEndY()-t.m_line.getStartY())))}initSimpleEdgeHelper_(t,e){if(t.m_segment=this.m_shape.getSegment(e),t.m_segmentInfo=this.m_shape.getOriginalSegmentInfo(e),t.m_bCurve=null!==t.m_segment,t.m_bCurve){const e=t.m_segment.clone();return e.orientBottomUp(),t.m_segment=e,t.m_env=t.m_segment.queryInterval(0,0),t.m_env.vmax+=this.m_tolerance,!0}return!1}compareTwoSegments_(t,e){const s=t.getStartXY(),n=t.getEndXY(),i=e.getStartXY(),r=e.getEndXY();if(this.m_ptSweep.setCoords(this.m_sweepX,this.m_sweepY),s.isEqualPoint2D(i)&&this.m_sweepY===s.y){this.m_ptSweep.assign(n.compare(r)<0?n:r);const s=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),i=e.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x);if(Math.abs(s-i)>this.m_tolerance)return s<i?-1:1}const o=s.compare(i)<0?i:s,a=n.compare(r)<0?n:r;let m=0,l=0;for(let u=1;u<5;u++){(0,h.Z)(o,a,u/5,this.m_ptSweep);const s=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),n=e.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),i=Math.abs(s-n);i>m&&(m=i,l=s<n?-1:1)}return 0===l?this.errorCracking():l}compareNonHorizontal_(t,e){if(t.m_line.getStartY()===e.m_line.getStartY()&&t.m_line.getStartX()===e.m_line.getStartX())return t.m_line.getEndY()===e.m_line.getEndY()&&t.m_line.getEndX()===e.m_line.getEndX()?this.m_bIsSimple?this.errorCoincident():0:this.compareNonHorizontalUpperEnd_(t,e);if(t.m_line.getEndY()===e.m_line.getEndY()&&t.m_line.getEndX()===e.m_line.getEndX())return this.compareNonHorizontalLowerEnd_(t,e);const s=this.compareNonHorizontalLowerEnd_(t,e),n=this.compareNonHorizontalUpperEnd_(t,e);return s<0&&n<0?-1:s>0&&n>0?1:this.errorCracking()}compareHorizontal1Case1_(t,e){if(t.getEndX()>e.getEndX()){if(e.getEndX()>e.getStartX()&&e.getEndY()-e.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(e.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else if((e.getEndY()-e.getStartY())/(e.getEndX()-e.getStartX())*(t.getEndX()-t.getStartX())<this.m_tolerance10&&e.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return 1}compareHorizontal1Case2_(t,e){if(t.getStartX()<e.getStartX()){if(e.getEndX()>e.getStartX()&&e.getEndY()-e.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(e.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else if((e.getEndY()-e.getStartY())/(e.getEndX()-e.getStartX())*(t.getStartX()-t.getEndX())<this.m_tolerance10&&e.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking();return-1}compareHorizontal1Case3_(t,e){const s=h.P.getNAN();s.setSub(e.getEndXY(),e.getStartXY()),s.rightPerpendicularThis(),s.normalize();const n=h.P.getNAN();n.setSub(t.getStartXY(),e.getStartXY());const i=h.P.getNAN();i.setSub(t.getEndXY(),e.getStartXY());const r=n.dotProduct(s),o=i.dotProduct(s),a=Math.abs(r),m=Math.abs(o);if(a<m){if(a<this.m_tolerance10&&e.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking()}else if(m<this.m_tolerance10&&e.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return r<0&&o<0?-1:r>0&&o>0?1:this.errorCracking()}compareHorizontal1_(t,e){return t.getStartY()===e.getStartY()&&t.getStartX()===e.getStartX()?this.compareHorizontal1Case1_(t,e):t.getEndY()===e.getEndY()&&t.getEndX()===e.getEndX()?this.compareHorizontal1Case2_(t,e):this.compareHorizontal1Case3_(t,e)}compareHorizontal2_(t,e){return t.getEndY()===e.getEndY()&&t.getEndX()===e.getEndX()&&t.getStartY()===e.getStartY()&&t.getStartX()===e.getStartX()?this.m_bIsSimple?this.errorCoincident():0:this.errorCracking()}compareNonHorizontalLowerEnd_(t,e){let s=1;if(t.m_line.getStartY()<e.m_line.getStartY()){s=-1;const n=t;t=e,e=n}const n=t.m_line,i=e.m_line,r=n.getStartX()-i.getStartX(),o=e.m_dxdy*(n.getStartY()-i.getStartY()),a=this.m_tolerance10;return r<o-a?-s:r>o+a?s:i.isIntersectingPoint(n.getStartXY(),this.m_tolerance,!0)?this.errorCracking():r<o?-s:s}compareNonHorizontalUpperEnd_(t,e){let s=1;if(e.m_line.getEndY()<t.m_line.getEndY()){s=-1;const n=t;t=e,e=n}const n=t.m_line,i=e.m_line,r=n.getEndX()-i.getStartX(),o=e.m_dxdy*(n.getEndY()-i.getStartY()),a=this.m_tolerance10;return r<o-a?-s:r>o+a?s:i.isIntersectingPoint(n.getEndXY(),this.m_tolerance,!0)?this.errorCracking():r<o?-s:s}errorCoincident(){this.m_bIntersectionDetected=!0;return this.m_nonSimpleResult=new p(7,this.m_vertex1,this.m_vertex2),-1}errorCracking(){if(this.m_bIntersectionDetected=!0,this.m_bIsSimple){const t=6;this.m_nonSimpleResult=new p(t,this.m_vertex1,this.m_vertex2)}else this.m_prev1=o.n,this.m_prev2=o.n,this.m_vertex1=o.n,this.m_vertex2=o.n;return-1}compareSegments_(t,e,s,n){if(s.m_env.vmax<n.m_env.vmin)return-1;if(n.m_env.vmax<s.m_env.vmin)return 1;if(!s.m_bCurve&&!n.m_bCurve){let t=s.m_bHorizontal?1:0;return t|=n.m_bHorizontal?2:0,0===t?this.compareNonHorizontal_(s,n):1===t?this.compareHorizontal1_(s.m_line,n.m_line):2===t?-1*this.compareHorizontal1_(n.m_line,s.m_line):this.compareHorizontal2_(s.m_line,n.m_line)}if(this.m_bIntersectionDetected)return-1;const i=this.m_prevY===this.m_sweepY&&this.m_prevX===this.m_sweepX;let r,a;if(i&&t===this.m_prev1?r=this.m_prevX1:(r=Number.NaN,this.m_prev1=o.n),i&&e===this.m_prev2?a=this.m_prevX2:(a=Number.NaN,this.m_prev2=o.n),this.m_prevY=this.m_sweepY,this.m_prevX=this.m_sweepX,Number.isNaN(r)){this.m_prev1=t;const e=s.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);r=e,this.m_prevX1=e}if(Number.isNaN(a)){this.m_prev2=e;const t=n.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);a=t,this.m_prevX2=t}const h=(0,o.a2)(!0,!0,s.m_segment,n.m_segment,this.m_tolerance,!0);return 0!==h?2===h?this.m_bIsSimple?this.errorCoincident():s.m_segmentInfo.equals(n.m_segmentInfo)?0:this.errorCracking():this.errorCracking():Math.abs(r-a)<=this.m_tolerance?this.compareTwoSegments_(s.m_segment,n.m_segment):r<a?-1:r>a?1:0}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1}intersectionDetected(){return this.m_bIntersectionDetected}getLastComparedNode(){return this.m_currentNode}getResult(){return this.m_nonSimpleResult}setSweepY(t,e){this.m_sweepY=t,this.m_sweepX=e,this.m_prev1=o.n,this.m_prev2=o.n,this.m_vertex1=o.n,this.m_vertex2=o.n}compare(t,e,s){if(this.m_bIntersectionDetected)return-1;const n=t.getElement(s),i=e;return this.m_currentNode=s,this.compareSegments(i,i,n,n)}compareSegments(t,e,s,n){let i=this.tryGetCachedEdge_(t);null===i?this.m_vertex1===e?i=this.m_tempSimpleEdge1:(this.m_vertex1=e,i=this.tryCreateCachedEdge_(t),null===i&&(i=this.m_tempSimpleEdge1,this.m_tempSimpleEdge1.m_value=t),this.initSimpleEdge_(i,e)):this.m_vertex1=e;let r=this.tryGetCachedEdge_(s);return null===r?this.m_vertex2===n?r=this.m_tempSimpleEdge2:(this.m_vertex2=n,r=this.tryCreateCachedEdge_(s),null===r&&(r=this.m_tempSimpleEdge2,this.m_tempSimpleEdge2.m_value=s),this.initSimpleEdge_(r,n)):this.m_vertex2=n,this.compareSegments_(e,n,i,r)}onDelete(t){this.tryDeleteCachedEdge_(t)}onSet(t){this.tryDeleteCachedEdge_(t)}onEndSearch(t){this.tryDeleteCachedEdge_(t)}onAddUniqueElementFailed(t){this.tryDeleteCachedEdge_(t)}}class ot{constructor(t,e){this.m_bIntersectionDetected=!1,this.m_pointOfInterest=h.P.getNAN(),this.m_line1=new o.L,this.m_seg1=null,this.m_env=h.E.constructEmpty(),this.m_vertex1=-1,this.m_currentNode=-1,this.m_minDist=Number.MAX_VALUE,this.m_shape=t,this.m_tolerance=e}getCurrentNode(){return this.m_currentNode}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1,this.m_minDist=Number.MAX_VALUE}intersectionDetected(){return this.m_bIntersectionDetected}setPoint(t){this.m_pointOfInterest.assign(t)}compare(t,e){const s=t.getElement(e);return this.compareVertex(t,e,s)}compareVertex(t,e,s){let n,r=this.m_shape.getSegment(s),a=!0;if(null==r)this.m_shape.queryLineConnector(s,this.m_line1,!0),this.m_env.setCoordsNoNAN(this.m_line1.getStartX(),this.m_line1.getEndX()),r=this.m_line1,n=this.m_line1.getStartY()===this.m_line1.getEndY();else{const t=i.Envelope2D.constructEmpty();r.queryLooseEnvelope(t),t.queryIntervalX(this.m_env),n=0===t.height(),a=!1}if(this.m_pointOfInterest.x+this.m_tolerance<this.m_env.vmin)return-1;if(this.m_pointOfInterest.x-this.m_tolerance>this.m_env.vmax)return 1;if(n)return this.m_currentNode=e,this.m_bIntersectionDetected=!0,0;let m=0;if(a){(0,o.a4)(this.m_line1);const t=this.m_line1.getStartXY(),e=new h.P;e.setSub(this.m_line1.getEndXY(),t),e.rightPerpendicularThis();const s=new h.P;s.setSub(this.m_pointOfInterest,t),m=e.dotProduct(s),m/=e.length()}else m=r.intersectionOfYMonotonicWithAxisX(this.m_pointOfInterest.y,this.m_pointOfInterest.x)-this.m_pointOfInterest.x;return m<10*-this.m_tolerance?-1:m>10*this.m_tolerance?1:(r.isIntersectingPoint(this.m_pointOfInterest,this.m_tolerance)&&(Math.abs(m)<this.m_minDist&&(this.m_currentNode=e,this.m_minDist=m),this.m_bIntersectionDetected=!0),m<0?-1:m>0?1:0)}}class at{constructor(t,e){this.m_lists=new nt(!1),this.m_hash=e,this.m_hashBuckets=new Int32Array(t),this.m_hashBuckets.fill(at.st_nullNode()),this.m_bitFilter=new Int32Array(10*t+31>>5)}reserveElements(t){this.m_lists.reserveLists(Math.min(this.m_hashBuckets.length,t)),this.m_lists.reserveNodes(t)}addElement(t,e){void 0===e&&(e=this.m_hash.getHash(t));const s=e%(this.m_bitFilter.length<<5);this.m_bitFilter[s>>5]|=1<<(31&s);const n=e%this.m_hashBuckets.length;let i=this.m_hashBuckets[n];return i===nt.st_nullNode()&&(i=this.m_lists.createList(),this.m_hashBuckets[n]=i),this.m_lists.addElement(i,t)}deleteElement(t,e){void 0===e&&(e=this.m_hash.getHash(t));const s=e%this.m_hashBuckets.length,n=this.m_hashBuckets[s];n===nt.st_nullNode()&&(0,r.t)("");let i=this.m_lists.getFirst(n),o=nt.st_nullNode();for(;i!==nt.st_nullNode();){const e=this.m_lists.getData(i),r=this.m_lists.getNext(i);e===t?(this.m_lists.deleteElementDirect(n,o,i),this.m_lists.getFirst(n)===nt.st_nullNode()&&(this.m_lists.deleteList(n),this.m_hashBuckets[s]=nt.st_nullNode())):o=i,i=r}}getFirstInBucket(t){const e=t%(this.m_bitFilter.length<<5);if(!(this.m_bitFilter[e>>5]&1<<(31&e)))return nt.st_nullNode();const s=t%this.m_hashBuckets.length,n=this.m_hashBuckets[s];return n===nt.st_nullNode()?nt.st_nullNode():this.m_lists.getFirst(n)}getNextInBucket(t){return this.m_lists.getNext(t)}findNode(t){const e=this.m_hash.getHash(t);let s=this.getFirstInBucket(e);for(;s!==nt.st_nullNode();){const e=this.m_lists.getData(s);if(this.m_hash.equal(e,t))return s;s=this.m_lists.getNext(s)}return nt.st_nullNode()}deleteNode(t){const e=this.getElement(t),s=this.m_hash.getHash(e)%this.m_hashBuckets.length,n=this.m_hashBuckets[s];n===nt.st_nullNode()&&(0,r.t)(""),this.m_lists.deleteElementSearch(n,t),this.m_lists.getFirst(n)===nt.st_nullNode()&&(this.m_lists.deleteList(n),this.m_hashBuckets[s]=nt.st_nullNode())}getElement(t){return this.m_lists.getData(t)}static st_nullNode(){return nt.st_nullNode()}clear(){(0,r.g)(0)}size(){return this.m_lists.getNodeCount()}dbgPrintBucketHistogram(){}}function ht(t,e,s,n,i){const r=new gt(i);return r.m_shape=t,r.m_sqrTolerance=e*e,r.m_cellSize=2*e,r.m_invCellSize=1/r.m_cellSize,r.m_geometry=s,r.m_bTrackChanges=n,r.m_bHasSegmentParentage=t.hasSegmentParentage(),r.clusterNonReciprocal()}function mt(t,e,s,n,i){const r=t-s,o=e-n;return r*r+o*o<=i}function lt(t,e,s,n,i,r){const o={pt:new h.P,weight:0,rank:0,bMerged:!1},a=s+i;let m=!1,l=t.x;t.x!==e.x&&(n===r&&(l=(t.x*s+e.x*i)/a),m=!0);let u=t.y;return t.y!==e.y&&(n===r&&(u=(t.y*s+e.y*i)/a),m=!0),n!==r?n>r?(o.rank=n,o.weight=s,o.pt=t):(o.rank=r,o.weight=i,o.pt=e):(o.pt.setCoords(l,u),o.weight=a,o.rank=n),o.bMerged=m,o}function ut(t,e){const s=(0,h.aH)(t);return(0,h.aG)(s,e)}class ct{constructor(t,e,s,n,i){this.m_workPt=new h.P,this.m_shape=t,this.m_sqrTolerance=s,this.m_invCellSize=n,this.m_origin=e.clone(),this.m_hashValues=i}getHash(t){return this.m_shape.getUserIndex(t,this.m_hashValues)}calculateHashFromVertex(t){this.m_shape.queryXY(t,this.m_workPt);const e=this.m_workPt.x-this.m_origin.x,s=Math.trunc(e*this.m_invCellSize+.5),n=this.m_workPt.y-this.m_origin.y;return ut(s,Math.trunc(n*this.m_invCellSize+.5))}equal(t,e){return(0,r.g)(0),!1}}class gt{constructor(t){this.m_origin=h.P.getNAN(),this.m_sqrTolerance=0,this.m_cellSize=0,this.m_invCellSize=0,this.m_geometry=o.n,this.m_bucketArray=(0,h.d)(4,Number.NaN),this.m_bucketHash=(0,h.d)(4,Number.NaN),this.m_dbgCandidateCheckCount=0,this.m_nsr=new p,this.m_hashValues=-1,this.m_newClusters=-1,this.m_bTrackChanges=!1,this.m_bHasSegmentParentage=!1,this.m_shape=null,this.m_clusters=new nt,this.m_hashFunction=null,this.m_hashTable=null,this.m_progressCounter=0,this.m_progressTracker=t}progress_(){}collectClusterCandidates(t,e){const s=h.P.getNAN();this.m_shape.queryXY(t,s);const n=(s.x-this.m_origin.x)*this.m_invCellSize,i=(s.y-this.m_origin.y)*this.m_invCellSize,r=Math.trunc(n),o=Math.trunc(i);let a=0;for(let h=0;h<=1;h+=1)for(let t=0;t<=1;t+=1){const e=ut(r+h,o+t),s=this.m_hashTable.getFirstInBucket(e);s!==at.st_nullNode()&&(this.m_bucketArray[a]=s,this.m_bucketHash[a]=e,a++)}for(let h=a-1;h>=1;h--){const t=this.m_bucketArray[h];for(let e=h-1;e>=0;e--)if(t===this.m_bucketArray[e]){this.m_bucketHash[e]=-1,a--,h!==a&&(this.m_bucketHash[h]=this.m_bucketHash[a],this.m_bucketArray[h]=this.m_bucketArray[a]);break}}for(let h=0;h<a;h++)this.collectNearestNeighbourCandidates(t,this.m_bucketHash[h],s,this.m_bucketArray[h],e)}collectNearestNeighbourCandidates(t,e,s,n,i){const r=h.P.getNAN();for(let o=n;o!==at.st_nullNode();o=this.m_hashTable.getNextInBucket(o)){const n=this.m_hashTable.getElement(o);t===n||-1!==e&&this.m_shape.getUserIndex(n,this.m_hashValues)!==e||(this.m_shape.queryXY(n,r),mt(s.x,s.y,r.x,r.y,this.m_sqrTolerance)&&i.push(o))}}mergeClusters(t,e,s){let n=this.m_shape.getUserIndex(t,this.m_newClusters);const i=this.m_shape.getUserIndex(e,this.m_newClusters);-1===n&&(n=this.m_clusters.createList(),this.m_clusters.addElement(n,t),this.m_shape.setUserIndex(t,this.m_newClusters,n)),-1===i?this.m_clusters.addElement(n,e):this.m_clusters.concatenateLists(n,i),this.m_shape.setUserIndex(e,this.m_newClusters,a.S.impossibleIndex2());const r=this.mergeVertices(t,e);if(s){const e=this.m_hashFunction.calculateHashFromVertex(t);this.m_shape.setUserIndex(t,this.m_hashValues,e)}return r}mergeVertices(t,e){const s=h.P.getNAN();this.m_shape.queryXY(t,s);const n=h.P.getNAN();this.m_shape.queryXY(e,n);const i=this.m_shape.getRank(t),r=this.m_shape.getRank(e),o=this.m_shape.getWeight(t),a=this.m_shape.getWeight(e);let m,l,u,c,g=!1;if(i===r?(m=i,l=o+a,u=s.x,s.x!==n.x&&(u=(s.x*o+n.x*a)/l,g=!0),c=s.y,s.y!==n.y&&(c=(s.y*o+n.y*a)/l,g=!0)):(i>r?(u=s.x,c=s.y,l=o,m=i):(u=n.x,c=n.y,l=a,m=r),g=!s.equals(n)),g&&(this.m_shape.setXYMonotonic(t,u,c),this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(t,!0),this.m_bHasSegmentParentage)){const s=this.m_shape.getSegmentParentageBreakVertex(t)||this.m_shape.getSegmentParentageBreakVertex(e);this.m_shape.setSegmentParentageBreakVertex(t,s),this.m_shape.setSegmentParentageBreakVertex(e,s)}return this.m_shape.setWeight(t,l),this.m_shape.setRank(t,m),g}needsClustering(){const t={stack:[],error:void 0,hasError:!1};try{(0,m.b)(t,(0,h.h)((()=>{this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters)})),!1);const e=this.m_shape.getSelectedCount(),s=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin.assign(s.getLowerLeft());const n=Math.max(s.height(),s.width())/((0,h.i)()-1);this.m_cellSize<n&&(this.m_cellSize=n,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(this.m_shape.getSelectedCount()/3+1),this.m_clusters.reserveNodes(this.m_shape.getSelectedCount()/3+1),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new ct(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new at(4*e/3,this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let i=!1;for(let t=0;t<2;t++){const e=[],s=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let n=s.next();n!==o.n;n=s.next()){if(this.progress_(),t>0&&this.m_shape.getUserIndex(n,this.m_newClusters)===a.S.impossibleIndex2())continue;let s;if(0===t?(s=this.m_hashFunction.calculateHashFromVertex(n),this.m_shape.setUserIndex(n,this.m_hashValues,s)):s=this.m_shape.getUserIndex(n,this.m_hashValues),this.collectClusterCandidates(n,e),0!==e.length){for(let t=0,s=e.length;t<s;t++){this.progress_();const s=e[t],r=this.m_hashTable.getElement(s);if(this.m_hashTable.deleteNode(s),!this.m_shape.isEqualXY(n,r))return this.m_nsr=new p(5,this.m_shape.getVertexIndex(n),this.m_shape.getVertexIndex(r)),i=!0,i;this.mergeClusters(n,r,!1)}e.length=0}0===t&&this.m_hashTable.addElement(n,s)}}return i}catch(e){t.error=e,t.hasError=!0}finally{(0,m.c)(t)}}clusterNonReciprocal(){const t=this.m_shape.getSelectedCount(),e=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin=e.getLowerLeft();const s=Math.max(e.height(),e.width())/((0,h.i)()-1);this.m_cellSize<s&&(this.m_cellSize=s,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_clusters.reserveNodes(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new ct(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new at(Math.trunc(4*t/3),this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let n=!1;{const t=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let e=t.next();e!==o.n;e=t.next()){this.progress_();const t=this.m_hashFunction.calculateHashFromVertex(e);this.m_shape.setUserIndex(e,this.m_hashValues,t),this.m_hashTable.addElement(e,t)}}{const t=[],e=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let s=e.next();s!==o.n;s=e.next()){if(this.m_shape.getUserIndex(s,this.m_newClusters)===a.S.impossibleIndex2())continue;let e=this.m_shape.getUserIndex(s,this.m_hashValues);this.m_hashTable.deleteElement(s,e);let i=!1;for(;this.collectClusterCandidates(s,t),0!==t.length;){let e=0;for(let n=0,i=t.length;n<i;n++){this.progress_();const r=t[n],o=this.m_hashTable.getElement(r);this.m_hashTable.deleteNode(r);const a=n+1===i;e|=this.mergeClusters(s,o,a)?1:0}if(i||(i=0!==e),n||(n=0!==e),t.length=0,!e)break}i&&(e=this.m_shape.getUserIndex(s,this.m_hashValues)),this.m_hashTable.addElement(s,e)}t.length=0}return n&&this.applyClusterPositions_(),this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters),n}applyClusterPositions_(){const t=h.P.getNAN();for(let e=this.m_clusters.getFirstList();e!==nt.st_nullNode();e=this.m_clusters.getNextList(e)){let s=this.m_clusters.getFirst(e);const n=this.m_clusters.getElement(s);this.m_shape.queryXY(n,t);const i=this.m_shape.getRank(n),r=this.m_shape.getWeight(n);for(s=this.m_clusters.getNext(s);s!==nt.st_nullNode();s=this.m_clusters.getNext(s)){const e=this.m_clusters.getElement(s);if(this.m_bTrackChanges?this.m_shape.isEqualXYPoint2D(e,t)||(this.m_shape.setXYMonotonicPoint2D(e,t),this.m_shape.setGeometryModifiedWithVertex(e,!0)):this.m_shape.setXYMonotonicPoint2D(e,t),this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentageBreakVertex(n)||this.m_shape.getSegmentParentageBreakVertex(e);this.m_shape.setSegmentParentageBreakVertex(n,t),this.m_shape.setSegmentParentageBreakVertex(e,t)}this.m_shape.setWeight(e,r),this.m_shape.setRank(e,i)}}}}class dt{constructor(){this.m_inputParts=[],this.m_resultParts1=[],this.m_resultParts2=[],this.m_resultSegments=[],this.m_freeSegments=[],this.m_inputSegments=[],this.m_param1=[],this.m_param2=[],this.m_tolerance=0,this.m_toleranceZ=0,this.m_point=new a.P,this.m_pointWeight=1,this.m_maxDensifyLimit=0,this.m_pointRank=0,this.m_changed1=!1,this.m_changed2=!1,this.m_adaptiveDensify=!1}clear(){this.freeAllResultSegments(),this.m_inputSegments.length=0,this.m_inputParts.length=0,this.m_resultParts1.length=0,this.m_resultParts2.length=0,this.m_param1.length=0,this.m_param2.length=0,this.m_adaptiveDensify=!1,this.m_changed1=!1,this.m_changed2=!1}newIntersectionPart_(t,e,s,n,i,r,o,a,h,m){return function(t,e,s,n,i,r,o,a,h,m){return{segmentIndex:t,weightStart:e,rankStart:s,weightEnd:n,rankEnd:i,weightInterior:r,rankInterior:o,segmentParentage:m,u:_t(a,h)}}(t,e,s,n,i,r,o,a,h,m)}pushSegment(t,e,s,n,i,r,o,a,h,m){return this.m_inputParts.push(this.newIntersectionPart_(this.m_inputSegments.length,e,s,n,i,r,o,a,h,m)),this.m_inputSegments.push(t),this.m_inputParts.length-1}getResultSegmentCount(t){return this.m_adaptiveDensify?0===t?this.m_param1.length-1:this.m_param2.length-1:0===t?this.m_resultParts1.length:this.m_resultParts2.length}getResultPart_(t,e){return 0===t?this.m_resultParts1[e]:this.m_resultParts2[e]}getResultSegment(t,e){return this.m_resultSegments[this.getResultPart_(t,e).segmentIndex].get()}getSegmentChanged(t){return 0===t?this.m_changed1:this.m_changed2}getResultSegmentStartPointWeight(t,e){return this.getResultPart_(t,e).weightStart}getResultSegmentStartPointRank(t,e){return this.getResultPart_(t,e).rankStart}getResultSegmentSegmentParentage(t,e){return this.getResultPart_(t,e).segmentParentage}getResultSegmentStartPointIsBreak(t,e){return this.getResultPart_(t,e).u.bBreakStart}getResultSegmentEndPointWeight(t,e){return this.getResultPart_(t,e).weightEnd}getResultSegmentEndPointRank(t,e){return this.getResultPart_(t,e).rankEnd}getResultSegmentEndPointIsBreak(t,e){return this.getResultPart_(t,e).u.bBreakEnd}getResultSegmentInteriorRank(t,e){return this.getResultPart_(t,e).rankInterior}getResultSegmentInteriorWeight(t,e){return this.getResultPart_(t,e).weightInterior}getResultPoint(){return this.m_point}getResultPointWeight(){return this.m_pointWeight}getResultPointRank(){return this.m_pointRank}getResultPointChanged(){return this.m_changed2}intersectLines(t,e){2!==this.m_inputSegments.length&&(0,r.c)(""),this.m_changed1=!1,this.m_changed2=!1,this.m_tolerance=t;const s=(0,h.s)(t*dt.c_smallToleranceFactor);let n=!1;const i=this.m_inputParts[0],a=this.m_inputParts[1],m=this.m_inputSegments[i.segmentIndex],l=this.m_inputSegments[a.segmentIndex];if(e||5&(0,o._)(!0,m,l,t,!0)){const e=(0,o.a0)(!0,m,l,null,this.m_param1,this.m_param2,t);0===e&&(0,r.c)("");const u=new Array(e);for(let t=0;t<e;++t)u[t]=h.P.getNAN();const c=new Float64Array(e),g=new Int32Array(e),d=new Array(e),_=new Array(e);for(let t=0;t<e;++t)d[t]={bBigMove:!1,bIsBreak:!1},_[t]={bBigMove:!1,bIsBreak:!1};for(let t=0;t<e;t++){const e=this.m_param1[t],r=this.m_param2[t];let o,p=i.rankInterior,f=i.weightInterior;0===e?(p=i.rankStart,f=i.weightStart,o=i.u.bBreakStart):1===e?(p=i.rankEnd,f=i.weightEnd,o=i.u.bBreakEnd):(this.m_changed1=!0,o=!1);let P,x=a.rankInterior,y=a.weightInterior;0===r?(x=a.rankStart,y=a.weightStart,P=a.u.bBreakStart):1===r?(x=a.rankEnd,y=a.weightEnd,P=a.u.bBreakEnd):(this.m_changed2=!0,P=!1);const E=p,C=x;let S=1,v=0,b=h.P.getNAN();if(E===C){const n=m.getCoord2D(e),i=l.getCoord2D(r);S=f+y,v=p,(0,h.Z)(n,i,y/S,b);const o=h.P.sqrDistance(b,n),a=h.P.sqrDistance(b,i);d[t].bBigMove=o>s,_[t].bBigMove=a>s,this.m_changed1||n.equals(b)||(this.m_changed1=!0),this.m_changed2||i.equals(b)||(this.m_changed2=!0)}else if(E>C){b=m.getCoord2D(e);const n=l.getCoord2D(r);S=f,v=p;const i=h.P.sqrDistance(b,n);d[t].bBigMove=!1,_[t].bBigMove=i>s,this.m_changed2||n.equals(b)||(this.m_changed2=!0)}else{b=l.getCoord2D(r),S=y,v=x;const n=m.getCoord2D(e),i=h.P.sqrDistance(b,n);d[t].bBigMove=i>s,_[t].bBigMove=!1,this.m_changed1||n.equals(b)||(this.m_changed1=!0)}u[t].assign(b),c[t]=S,g[t]=v,d[t].bIsBreak=o||P,_[t].bIsBreak=o||P,n||(n=d[t].bBigMove||_[t].bBigMove)}const p=i.rankInterior,f=i.weightInterior;let P=0,x=-1;for(let s=0;s<=e;s++){const n=s<e?this.m_param1[s]:1;if(n!==P){const r=this.allocResultSegment(),o=this.m_resultSegments[r];let a,l,_,y;m.queryCut(P,n,o,!1),o.get().snapControlPoints(t*t);let E=!1,C=!1,S=!1,v=!1,b=!1,I=h.P.getNAN(),w=h.P.getNAN();-1!==x?(l=g[x],a=c[x],E=d[x].bBigMove,I.assign(u[x]),S=d[x].bIsBreak,b=!0):(a=i.weightStart,l=i.rankStart,I=o.get().getStartXY(),S=i.u.bBreakStart),s<e?(y=g[s],_=c[s],C=d[s].bBigMove,w.assign(u[s]),v=d[s].bIsBreak,b=!0):(_=i.weightEnd,y=i.rankEnd,w=o.get().getEndXY(),v=i.u.bBreakEnd),b&&o.get().setCoordsForIntersector(I,w,!0),this.m_resultParts1.push(this.newIntersectionPart_(r,a,l,_,y,f,p,S,v,i.segmentParentage));const D=this.m_resultParts1.at(-1);D.u.bBigMoveStart=E,D.u.bBigMoveEnd=C,P=n,x=s}else-1===x&&(x=s)}const y=(0,h.d)(e,0);for(let t=0;t<e;t++)y[t]=t;e>2?(y.sort(((t,e)=>this.m_param2[t]<this.m_param2[e]?-1:this.m_param2[t]>this.m_param2[e]?1:0)),(0,h.v)(this.m_param2)):2===e&&this.m_param2[0]>this.m_param2[1]&&(this.m_param2[1]=(0,h.b)(this.m_param2[0],this.m_param2[0]=this.m_param2[1]),y[1]=(0,h.b)(y[0],y[0]=y[1]));const E=a.rankInterior,C=a.weightInterior;P=0,x=-1;for(let s=0;s<=e;s++){const n=s<e?this.m_param2[s]:1;if(n!==P){const i=this.allocResultSegment(),r=this.m_resultSegments[i];let o,m,d,p;l.queryCut(P,n,r,!1),r.get().snapControlPoints(t*t);let f=h.P.getNAN(),S=h.P.getNAN(),v=!1,b=!1,I=!1,w=!1,D=!1;if(-1!==x){const t=y[x];o=c[t],m=g[t],f.assign(u[t]),I=_[t].bBigMove,v=_[t].bIsBreak,D=!0}else o=a.weightStart,m=a.rankStart,f=r.get().getStartXY(),v=a.u.bBreakStart;if(s!==e){const t=y[s];d=c[t],p=g[t],S.assign(u[t]),w=_[t].bBigMove,b=_[t].bIsBreak,D=!0}else d=a.weightEnd,p=a.rankEnd,S=r.get().getEndXY(),b=a.u.bBreakEnd;D&&r.get().setCoordsForIntersector(f,S,!0),this.m_resultParts2.push(this.newIntersectionPart_(i,o,m,d,p,C,E,v,b,a.segmentParentage));const T=this.m_resultParts2.at(-1);T.u.bBigMoveStart=I,T.u.bBigMoveEnd=w,P=n,x=s}else-1===x&&(x=s)}return n?3:2}return 0}intersectLines3D(t,e,s,n){return(0,r.g)(0),1}intersect2D(t,e){const s=this.m_inputParts[0],n=this.m_inputParts[1],i=this.m_inputSegments[s.segmentIndex].getGeometryType(),o=this.m_inputSegments[n.segmentIndex].getGeometryType();return i!==r.G.enumLine||o!==r.G.enumLine?new yt(this).intersectCurves(t,e):this.intersectLines(t,e)}intersect2DEx(t,e,s,n,i){this.m_point.assignCopy(e),1!==this.m_inputSegments.length&&(0,r.c)(""),this.m_tolerance=t,this.m_changed1=!1,this.m_changed2=!1;const o=(0,h.s)(t*dt.c_smallToleranceFactor);let a=!1;const m=this.m_inputParts[0],l=this.m_inputSegments[m.segmentIndex];if(i||l.isIntersectingPoint(e.getXY(),t,!0)){this.m_param1=(0,h.d)(16,Number.NaN);const i=l.getClosestCoordinate(e.getXY(),!1);this.m_param1[0]=i;let r=m.rankInterior,u=m.weightInterior;0===i?(r=m.rankStart,u=m.weightStart):1===i?(r=m.rankEnd,u=m.weightEnd):this.m_changed1=!0;let c=r;const g=s,d=n;c===g&&l.isCurve()&&(c=g+1);let _=1,p=0;const f=new h.P;if(c===g){const t=l.getCoord2D(i),s=e.getXY();_=u+d,p=r,(0,h.Z)(t,s,d/_,f),this.m_changed1||t.equals(f)||(this.m_changed1=!0),this.m_changed2||s.equals(f)||(this.m_changed2=!0),a=h.P.sqrDistance(f,t)>o}else c>g?(f.assign(l.getCoord2D(i)),_=u,p=r,this.m_changed2||f.equals(e.getXY())||(this.m_changed2=!0)):(f.assign(l.getCoord2D(i)),_=d,p=g,this.m_changed1||f.equals(e.getXY())||(this.m_changed1=!0),a=h.P.sqrDistance(f,e.getXY())>o);let P=0,x=-1;const y=1;for(let e=0;e<=y;e++){const s=e<y?this.m_param1[0]:1;if(s!==P){const n=this.allocResultSegment(),i=this.m_resultSegments[n];l.queryCut(P,s,i),i.get().snapControlPoints(t*t);let r=m.weightStart,o=m.weightEnd,a=m.rankStart,h=m.rankEnd;const u=m.rankInterior,c=m.weightInterior;let g=m.u.bBreakStart,d=m.u.bBreakEnd;-1!==x&&(r=_,a=p,g=!0,i.get().setCoordsForIntersector(f,i.get().getEndXY(),!0)),e!==y&&(o=_,h=p,d=!0,i.get().setCoordsForIntersector(i.get().getStartXY(),f,!0)),P=s,this.m_resultParts1.push(this.newIntersectionPart_(n,r,a,o,h,c,u,g,d,m.segmentParentage))}x=e}return this.m_point.setXY(f),this.m_pointWeight=_,this.m_pointRank=p,a?3:2}return 0}intersect3D(t,e,s,n){return(0,r.g)(0),1}intersect3DEx(t,e,s,n,i,o,a){return(0,r.g)(0),1}getTolerance(){return this.m_tolerance}freeAllResultSegments(){this.m_resultSegments.length=0,this.m_freeSegments.length=0}freeResultSegment(t){this.m_freeSegments.push(t)}allocResultSegment(){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const t=new o.S,e=this.m_resultSegments.length;return this.m_resultSegments.push(t),e}allocResultSegmentFromBuffer(t){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const e=new o.S({copy:t}),s=this.m_resultSegments.length;return this.m_resultSegments.push(e),s}allocResultSegmentFromSegment(t){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const e=new o.S({segment:t}),s=this.m_resultSegments.length;return this.m_resultSegments.push(e),s}}function _t(t,e){return{bBigMoveStart:!1,bBigMoveEnd:!1,bBreakStart:t,bBreakEnd:e}}function pt(){return{bBigMove:!1,bIsBreak:!1}}dt.maxWeight=.1*Number.MAX_VALUE,dt.c_smallToleranceFactor=.01,dt.c_maxGeometryTypeToRankDelta=8;let ft=class{constructor(){this.start=null,this.end=null,this.equalEdge=null,this.segmentIndex=-1,this.segmentParentage=-1,this.weight=0,this.rank=0}hasSegment(){return this.segmentIndex>=0}transferAttributes(t,e,s){if(1===e.getDescription().getAttributeCount())return;const n=t.parent.m_resultSegments[this.segmentIndex].get().getStartXY(),i=t.parent.m_resultSegments[this.segmentIndex].get().getEndXY(),r=new a.P;e.queryStart(r),s?(r.setXY(n),t.parent.m_resultSegments[this.segmentIndex].get().setStart(r)):(r.setXY(i),t.parent.m_resultSegments[this.segmentIndex].get().setEnd(r)),e.queryEnd(r),s?(r.setXY(i),t.parent.m_resultSegments[this.segmentIndex].get().setEnd(r)):(r.setXY(n),t.parent.m_resultSegments[this.segmentIndex].get().setStart(r))}copyFromWhenOverlap(t,e,s){this.equalEdge=e,e.equalEdge=this,this.segmentIndex=t.parent.allocResultSegmentFromBuffer(t.parent.m_resultSegments[e.segmentIndex]),this.segmentParentage=e.segmentParentage,this.weight=e.weight,this.rank=e.rank,s?(this.start.copyFrom(e.start),this.end.copyFrom(e.end)):(this.start.copyFrom(e.end),this.end.copyFrom(e.start),t.parent.m_resultSegments[this.segmentIndex].get().reverse())}getEnd(){return this.end}getNextInChain(){return this.end.nextInChain}getPrevInChain(){return this.start.prevInChain}};class Pt{constructor(){this.hash=0,this.pt=new h.P,this.prevInChain=null,this.nextInChain=null,this.prevInHash=null,this.nextInHash=null,this.prevEqual=null,this.nextEqual=null,this.weight=0,this.rank=0,this.bBigMove=!1,this.bIsBreak=!1}copyFrom(t){this.pt.assign(t.pt),this.weight=t.weight,this.rank=t.rank,this.bBigMove=t.bBigMove,this.bIsBreak=t.bIsBreak}nextNode(){return this.nextInChain?this.nextInChain.end:null}prevNode(){return this.prevInChain?this.prevInChain.start:null}equalListHead(){let t=this;for(;null!==t.prevEqual;t=t.prevEqual);return t}}function xt(t,e,s,n){return{edge1:t,edge2:e,recursion:s,bIsIntersecting:n}}class yt{constructor(t){this.m_pairs=[],this.m_chainOrigin1=null,this.m_chainOrigin2=null,this.m_newNodes=[],this.m_hashTableOfEquals=[],this.m_hashTableOfEqualsSize=0,this.m_origin=new h.P,this.m_cell=new h.P,this.parent=t}addSegment(t,e,s,n,i,o,a,h,m,l,u){const c=this.newNode(this.parent.m_resultSegments[t].get().getStartXY(),s,n,m),g=this.newNode(this.parent.m_resultSegments[t].get().getEndXY(),i,o,l);this.newEdge(c,g,t,a,h,u),null===this.m_chainOrigin1?this.m_chainOrigin1=c:null===this.m_chainOrigin2?this.m_chainOrigin2=c:(0,r.g)(0)}intersectCurvesHelper(t,e,s,n,i){var a,m;const l=this.getSegment(t).get(),u=this.getSegment(e).get();if(l.isDegenerate(0)||u.isDegenerate(0))return 0;const c=this.tryOverlapIntersectCurves(t,e,s,n);if(0!==c)return c;const g=(0,h.s)(.01*s);let d=!1,_=this.processSharpCorners(l,u,s,i>4);const p=_>0;if(!p){if(!(n||5&(0,o.a2)(!0,!1,l,u,s,!0)))return 0;_=(0,o.a0)(!0,l,u,null,this.parent.m_param1,this.parent.m_param2,s)}0===_&&(0,r.c)("");const f=l.getGeometryType(),P=u.getGeometryType(),x=(0,h.m)(h.P,_),y=(0,h.m)(h.P,_),E=(0,h.d)(_,Number.NaN),C=(0,h.d)(_,Number.NaN),S=(0,h.d)(_,Number.NaN),v=(0,h.d)(_,Number.NaN),b=(0,h.p)(pt,_),I=(0,h.p)(pt,_);let w=!1,D=!1;for(let r=0;r<_;r++){var T,N,A,G,M,F,q,V;const n=this.parent.m_param1[r],i=this.parent.m_param2[r];let o=t.rank,a=t.weight,m=!0,c=!1;0===n?(o=t.start.rank,a=t.start.weight,c=t.start.bIsBreak):1===n?(o=t.end.rank,a=t.end.weight,c=t.end.bIsBreak):(w=!0,m=!1);let _=e.rank,Y=e.weight,X=!1,k=!0;0===i?(_=e.start.rank,Y=e.start.weight,X=e.start.bIsBreak):1===i?(_=e.end.rank,Y=e.end.weight,X=e.end.bIsBreak):(D=!0,k=!1);let R=o,H=_;if(R===H&&(R*=dt.c_maxGeometryTypeToRankDelta,H*=dt.c_maxGeometryTypeToRankDelta,R+=Et(f,l,!1),H+=Et(P,u,!1)),m&&k&&H===R){const t=l.getCoord2D(n),e=u.getCoord2D(i);t.equals(e)&&(H=R-1)}let L=1,B=0,U=1,z=0;const O=new h.P,W=new h.P,j=l.getCoord2D(n),Z=u.getCoord2D(i);if(p&&h.P.distance(j,Z)>s)O.setCoordsPoint2D(j),W.setCoordsPoint2D(Z),L=a,U=Y,B=o,z=_,b[r].bBigMove=!1,I[r].bBigMove=!1,c=!0,X=!0;else if(R===H){U=L=a+Y,z=B=o,(0,h.Z)(j,Z,Y/L,O),W.setCoordsPoint2D(O);const t=h.P.sqrDistance(O,j),e=h.P.sqrDistance(O,Z);b[r].bBigMove=t>g,I[r].bBigMove=e>g,w||j.equals(O)||(w=!0),D||Z.equals(W)||(D=!0)}else if(R>H){O.setCoordsPoint2D(j),W.setCoordsPoint2D(O),U=L=a,z=B=o;const t=h.P.sqrDistance(O,Z);b[r].bBigMove=!1,I[r].bBigMove=t>g,D||Z.equals(W)||(D=!0)}else{W.setCoordsPoint2D(Z),O.setCoordsPoint2D(W),U=L=Y,z=B=_;const t=h.P.sqrDistance(O,j);b[r].bBigMove=t>g,I[r].bBigMove=!1,w||j.equals(O)||(w=!0)}x[r].assign(O),y[r].assign(W),E[r]=L,C[r]=U,S[r]=B,v[r]=z,b[r].bIsBreak=c||X,I[r].bIsBreak=c||X,d||(d=b[r].bBigMove||I[r].bBigMove),r>0&&(n!==this.parent.m_param1[r-1]&&i!==this.parent.m_param2[r-1]||(S[r]<=S[r-1]?(x[r].assign(y[r-1]),E[r]=C[r-1],S[r]=v[r-1],y[r].assign(y[r-1]),C[r]=C[r-1],v[r]=v[r-1],(T=b[r]).bBigMove||(T.bBigMove=b[r-1].bBigMove),(N=I[r]).bBigMove||(N.bBigMove=I[r-1].bBigMove),(A=b[r]).bIsBreak||(A.bIsBreak=b[r-1].bIsBreak),(G=I[r]).bIsBreak||(G.bIsBreak=I[r-1].bIsBreak)):(x[r-1].assign(x[r]),E[r-1]=E[r],S[r-1]=S[r],y[r-1].assign(y[r]),C[r-1]=C[r],v[r-1]=v[r],(M=b[r-1]).bBigMove||(M.bBigMove=b[r].bBigMove),(F=I[r-1]).bBigMove||(F.bBigMove=I[r].bBigMove),(q=b[r-1]).bIsBreak||(q.bIsBreak=b[r].bIsBreak),(V=I[r-1]).bIsBreak||(V.bIsBreak=I[r].bIsBreak))))}if(!(w||D||2!==_||f===r.G.enumLine&&P===r.G.enumLine)){if(this.processDoublyConnectedEdges(t,e,i+1,s))return this.parent.m_changed1=!0,this.parent.m_changed2=!0,2;(0,r.g)(0)}(a=this.parent).m_changed1||(a.m_changed1=w),(m=this.parent).m_changed2||(m.m_changed2=D);let Y=t,X=t.end.weight,k=t.end.rank,R=t.end.bBigMove,H=t.end.bIsBreak,L=0,B=-1;for(let r=0;r<=_;r++){const e=r<_?this.parent.m_param1[r]:1;if(e!==L){var U,z,O,W;const n=this.parent.allocResultSegment(),i=this.parent.m_resultSegments[n];let o,a,m,u;l.queryCut(L,e,i,!1),i.get().snapControlPoints(s*s);let c=!1,g=!1,d=!1,p=!1;const f=new h.P,P=new h.P;-1!==B?(a=S[B],o=E[B],d=b[B].bBigMove,c=b[B].bIsBreak,f.assign(x[B])):(o=t.start.weight,a=t.start.rank,d=t.start.bBigMove,c=t.start.bIsBreak,f.assign(i.get().getStartXY())),r<_?(u=S[r],m=E[r],p=b[r].bBigMove,g=b[r].bIsBreak,P.assign(x[r])):(m=X,u=k,p=R,g=H,P.assign(i.get().getEndXY()));let y=Y;e<1&&(this.splitEdgeInPlace(Y),y=Y.getNextInChain()),this.updateSegmentOnly(Y,n),0===Y.start.hash||Y.start.pt.equals(f)||(this.m_newNodes.push(Y.start),this.removeNodeFromHash(Y.start),Y.start.hash=0),0===Y.end.hash||Y.end.pt.equals(P)||(this.m_newNodes.push(Y.end),this.removeNodeFromHash(Y.end),Y.end.hash=0),Y.start.pt.assign(f),Y.end.pt.assign(P),(U=Y.start).bBigMove||(U.bBigMove=d),(z=Y.end).bBigMove||(z.bBigMove=p),(O=Y.start).bIsBreak||(O.bIsBreak=c),(W=Y.end).bIsBreak||(W.bIsBreak=g),Y.start.weight=o,Y.start.rank=a,Y.end.weight=m,Y.end.rank=u,Y=y,L=e,B=r}else-1===B&&(B=r)}const j=Y.getNextInChain(),Z=[];Z.length=_;for(let r=0;r<_;r++)Z[r]=r;_>2?(Z.sort(((t,e)=>(0,h.X)(this.parent.m_param2[t],this.parent.m_param2[e]))),this.parent.m_param2.sort(h.X)):2===_&&this.parent.m_param2[0]>this.parent.m_param2[1]&&(this.parent.m_param2[1]=(0,h.b)(this.parent.m_param2[0],this.parent.m_param2[0]=this.parent.m_param2[1]),Z[1]=(0,h.b)(Z[0],Z[0]=Z[1])),Y=e,X=e.end.weight,k=e.end.rank,R=e.end.bBigMove,H=e.end.bIsBreak,L=0,B=-1;for(let r=0;r<=_;r++){const t=r<_?this.parent.m_param2[r]:1;if(t!==L){var Q,K,J,$;const n=this.parent.allocResultSegment(),i=this.parent.m_resultSegments[n];let o,a,m,l;u.queryCut(L,t,i,!1),i.get().snapControlPoints(s*s);const c=new h.P,g=new h.P;let d=!1,p=!1,f=!1,P=!1;if(-1!==B){const t=Z[B];o=C[t],a=v[t],c.assign(y[t]),f=I[t].bBigMove,d=I[t].bIsBreak}else o=e.start.weight,a=e.start.rank,f=e.start.bBigMove,d=e.start.bIsBreak,c.assign(i.get().getStartXY());if(r!==_){const t=Z[r];m=C[t],l=v[t],g.assign(y[t]),P=I[t].bBigMove,p=I[t].bIsBreak}else m=X,l=k,P=R,p=H,g.assign(i.get().getEndXY());let x=Y;t<1&&(this.splitEdgeInPlace(Y),x=Y.getNextInChain()),this.updateSegmentOnly(Y,n),0===Y.start.hash||Y.start.pt.equals(c)||(this.m_newNodes.push(Y.start),this.removeNodeFromHash(Y.start),Y.start.hash=0),0===Y.end.hash||Y.end.pt.equals(g)||(this.m_newNodes.push(Y.end),this.removeNodeFromHash(Y.end),Y.end.hash=0),Y.start.pt.assign(c),Y.end.pt.assign(g),(Q=Y.start).bBigMove||(Q.bBigMove=f),(K=Y.end).bBigMove||(K.bBigMove=P),(J=Y.start).bIsBreak||(J.bIsBreak=d),($=Y.end).bIsBreak||($.bIsBreak=p),Y.start.weight=o,Y.start.rank=a,Y.end.weight=m,Y.end.rank=l,Y=x,L=t,B=r}else-1===B&&(B=r)}const tt=Y.getNextInChain();return this.postProcessResultPartsForCurves(t,j,e,tt,i+1),d?3:2}intersectCurves(t,e){2!==this.parent.m_inputSegments.length&&(0,r.c)(""),this.parent.m_changed1=!1,this.parent.m_changed2=!1,this.parent.m_tolerance=t,this.m_hashTableOfEqualsSize=0,this.m_hashTableOfEquals=(0,h.as)(16);const s=i.Envelope2D.constructEmpty();for(let r=0;r<2;r++){const t=this.parent.allocResultSegmentFromSegment(this.parent.m_inputSegments[this.parent.m_inputParts[r].segmentIndex]),e=i.Envelope2D.constructEmpty();this.parent.m_inputSegments[this.parent.m_inputParts[r].segmentIndex].queryLooseEnvelope(e),s.mergeEnvelope2D(e);const n=this.parent.m_inputParts[r];this.addSegment(t,0,n.weightStart,n.rankStart,n.weightEnd,n.rankEnd,n.weightInterior,n.rankInterior,n.u.bBreakStart,n.u.bBreakEnd,n.segmentParentage)}s.inflateCoords(100*t,100*t),this.m_origin.assign(s.getLowerLeft()),this.m_cell.setCoords(2*t,2*t),this.m_pairs.push(xt(this.m_chainOrigin1.nextInChain,this.m_chainOrigin2.nextInChain,0,e));let n=0,o=!0;for(;this.m_pairs.length;){const e=this.m_pairs.at(-1);this.m_pairs.pop(),(0,r.g)(e.recursion>=0),(0,r.g)(e.recursion<=256),this.clusterNodes(t);const s=this.intersectCurvesHelper(e.edge1,e.edge2,t,e.bIsIntersecting,e.recursion);o&&(o=!1,n=s)}for(let i=0;i<2;i++){const t=0===i?this.parent.m_resultParts1:this.parent.m_resultParts2;for(let e=(0===i?this.m_chainOrigin1:this.m_chainOrigin2).nextInChain;null!=e;e=e.getNextInChain())t.push(this.parent.newIntersectionPart_(e.segmentIndex,e.start.weight,e.start.rank,e.end.weight,e.end.rank,e.weight,e.rank,e.start.bIsBreak,e.end.bIsBreak,e.segmentParentage)),t.at(-1).u.bBigMoveStart=e.start.bBigMove,t.at(-1).u.bBigMoveEnd=e.end.bBigMove}return n}tryOverlapIntersectCurves(t,e,s,n){const i=this.parent.m_resultSegments[t.segmentIndex].get(),a=this.parent.m_resultSegments[e.segmentIndex].get(),m=i.getStartXY().equals(a.getStartXY())&&i.getEndXY().equals(a.getEndXY()),l=i.getStartXY().equals(a.getEndXY())&&i.getEndXY().equals(a.getStartXY());if(!m&&!l)return 0;const u=(0,o.a5)(i,a,!0);if(0!==u&&(0,o.a6)(i,a)&&t.segmentParentage===e.segmentParentage){let t=!1;if(u>0)t=i.equals(a);else{(0,r.g)(-1===u);const e=new o.S({segment:a});e.get().reverse(),t=i.equals(e.get())}if(t)return 1}const c=s*dt.c_smallToleranceFactor;let g=!1;if(0===u){const t=[.5,.25,.75,.125,.375,.625,.875,.5625,.3125];for(let e=0,n=t.length;e<n;++e){const n=t[e],r=new h.P;i.queryCoord2D(n,r);const o=a.getClosestCoordinate(r,!1),m=new h.P;a.queryCoord2D(o,m);const l=h.P.distance(r,m);if(l>s)return 0;g||(g=l>c)}for(let e=0,n=t.length;e<n;++e){const n=t[e],r=new h.P;a.queryCoord2D(n,r);const o=i.getClosestCoordinate(r,!1),m=new h.P;i.queryCoord2D(o,m);const l=h.P.distance(r,m);if(l>s)return 0;g||(g=l>c)}}let d=t.rank,_=e.rank;return d===_&&(d*=dt.c_maxGeometryTypeToRankDelta,_*=dt.c_maxGeometryTypeToRankDelta,d+=Et(i.getGeometryType(),i,!0),_+=Et(a.getGeometryType(),a,!0)),d>_?(e.copyFromWhenOverlap(this,t,m),e.transferAttributes(this,i,m)):_>d?(t.copyFromWhenOverlap(this,e,m),t.transferAttributes(this,a,m)):t.segmentParentage<=e.segmentParentage?(t.weight=t.weight+e.weight,e.copyFromWhenOverlap(this,t,m),e.transferAttributes(this,i,m)):(e.weight=t.weight+e.weight,t.copyFromWhenOverlap(this,e,m),t.transferAttributes(this,a,m)),g?3:2}postProcessResultPartsForCurves(t,e,s,n,i){i===(0,h.aE)()&&(0,r.c)("curve_helper");for(let r=t;r!==e;r=r.getNextInChain())this.updateSegmentToNodes(r);for(let r=s;r!==n;r=r.getNextInChain())this.updateSegmentToNodes(r);for(let o=t;o!==e;o=o.getNextInChain()){const t=o.end.pt.sub(o.start.pt);for(let e=s;e!==n;e=e.getNextInChain()){let s=0;if(o.start.pt.equals(e.start.pt)&&o.end.pt.equals(e.end.pt)?s=1:o.start.pt.equals(e.end.pt)&&o.end.pt.equals(e.start.pt)&&(s=-1),!s){let s=o.start.pt.equals(e.start.pt)?1:0;if(s||(s=o.end.pt.equals(e.end.pt)?2:0,s||(s=o.end.pt.equals(e.start.pt)?3:0,s||(s=o.start.pt.equals(e.end.pt)?4:0))),s){const n=e.end.pt.sub(e.start.pt),a=t.dotProduct(n);let h;switch(s){case 1:case 2:h=a>0;break;case 3:case 4:h=a<0;break;default:(0,r.c)("post_process_result_parts_for_curves_")}h&&this.m_pairs.push(xt(o,e,i,!1))}continue}const n=this.parent.m_resultSegments[o.segmentIndex],a=this.parent.m_resultSegments[e.segmentIndex],m=[.5,.25,.75];for(let t=0,e=m.length;t<e;++t){const e=m[t],i=new h.P;n.get().queryCoord2D(e,i);const r=a.get().getClosestCoordinate(i,!1),o=new h.P;if(a.get().queryCoord2D(r,o),h.P.distance(i,o)>this.parent.m_tolerance){s=0;break}}if(!s){this.m_pairs.push(xt(o,e,i,!1));continue}for(let t=0,e=m.length;t<e;++t){const e=m[t],i=new h.P;a.get().queryCoord2D(e,i);const r=n.get().getClosestCoordinate(i,!1),o=new h.P;if(n.get().queryCoord2D(r,o),h.P.distance(i,o)>this.parent.m_tolerance){s=0;break}}if(!s){this.m_pairs.push(xt(o,e,i,!1));continue}o.equalEdge=e,e.equalEdge=o;let l=o.rank,u=e.rank;l===u&&(l*=dt.c_maxGeometryTypeToRankDelta,u*=dt.c_maxGeometryTypeToRankDelta,l+=Et(n.get().getGeometryType(),n.get(),!0),u+=Et(a.get().getGeometryType(),a.get(),!0)),l>u||l===u&&o.segmentParentage<=e.segmentParentage?(n.copyTo(a,!1),e.segmentParentage=o.segmentParentage,-1===s&&a.get().reverse()):(a.copyTo(n,!1),o.segmentParentage=e.segmentParentage,-1===s&&n.get().reverse());break}}this.updateAttachedEdgesAfterNodeChange(t.start),e&&this.updateAttachedEdgesAfterNodeChange(e.start),this.updateAttachedEdgesAfterNodeChange(s.start),n&&this.updateAttachedEdgesAfterNodeChange(n.start)}processDoublyConnectedEdges(t,e,s,n){s===(0,h.aE)()&&(0,r.c)("curve_helper");const i=this.getSegment(t).get(),a=this.getSegment(e).get(),m=i.getStartXY().equals(a.getStartXY())&&i.getEndXY().equals(a.getEndXY())?1:i.getEndXY().equals(a.getStartXY())&&i.getStartXY().equals(a.getEndXY())?-1:0;if(0!==m){const r=new o.S;i.queryCut(0,.5,r),r.get().snapControlPoints(n*n);const h=new o.S;i.queryCut(.5,1,h),h.get().snapControlPoints(n*n),this.splitEdgeInPlace(t),t.end.pt=r.get().getEndXY(),t.segmentIndex=this.parent.allocResultSegmentFromBuffer(r),t.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(h);let l=a.getClosestCoordinate(t.end.pt,!1);return Math.abs(l-.5)>.2&&(l=.5),a.queryCut(0,l,r),r.get().snapControlPoints(n*n),a.queryCut(l,1,h),h.get().snapControlPoints(n*n),this.splitEdgeInPlace(e),e.end.pt=r.get().getEndXY(),e.segmentIndex=this.parent.allocResultSegmentFromBuffer(r),e.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(h),m>0?(this.m_pairs.push(xt(t,e,s,!1)),this.m_pairs.push(xt(t.getNextInChain(),e.getNextInChain(),s,!1))):(this.m_pairs.push(xt(t,e.getNextInChain(),s,!1)),this.m_pairs.push(xt(t.getNextInChain(),e,s,!1))),!0}return!1}newNode(t,e,s,n){const i=new Pt;return this.m_newNodes.push(i),i.pt=t,i.rank=s,i.weight=e,i.bIsBreak=n,i}newEdge(t,e,s,n,i,r){const o=new ft;return o.start=t,o.end=e,t.nextInChain=o,e.prevInChain=o,o.segmentIndex=s,o.segmentParentage=r,o.rank=i,o.weight=n,o}splitEdgeInPlace(t){t.segmentIndex=-1;const e=new ft,s=new Pt;this.m_newNodes.push(s),s.pt.setNAN(),s.nextInChain=e,s.prevInChain=t,s.prevInHash=null,s.nextInHash=null,s.prevEqual=null,s.nextEqual=null,s.weight=t.weight,s.rank=t.rank,s.bIsBreak=!1,s.bBigMove=!1,e.start=s,e.segmentIndex=-1,e.end=t.end,e.end.prevInChain=e,e.rank=t.rank,e.weight=t.weight,e.segmentParentage=t.segmentParentage,t.end=s,t.equalEdge&&(t.equalEdge.equalEdge=null),t.equalEdge=null}updateSegmentOnly(t,e){t.segmentIndex=e}updateAttachedEdgesAfterNodeChange(t){for(let e=t.equalListHead();null!==e;e=e.nextEqual)this.updateAttachedEdgesAfterNodeChangeImpl(e)}updateAttachedEdgesAfterNodeChangeImpl(t){const e=t.prevInChain;if(e&&e.hasSegment()){const s=this.getSegment(e).get();t.pt.equals(s.getEndXY())||(s.setCoordsForIntersector(e.start.pt,e.end.pt,!1),s.ensureXYMonotone())}const s=t.nextInChain;if(s&&s.hasSegment()){const e=this.getSegment(s).get();t.pt.equals(e.getStartXY())||(e.setCoordsForIntersector(s.start.pt,s.end.pt,!1),e.ensureXYMonotone())}}updateSegmentToNodes(t){const e=this.getSegment(t).get();t.start.pt.equals(e.getStartXY())&&t.end.pt.equals(e.getEndXY())||(e.setCoordsForIntersector(t.start.pt,t.end.pt,!1),e.ensureXYMonotone()),this.updateAttachedEdgesAfterNodeChange(t.start),this.updateAttachedEdgesAfterNodeChange(t.end)}getSegment(t){return this.parent.m_resultSegments[t.segmentIndex]}clusterNodes(t){let e=!1;const s=[],n=[],i=[];for(let r=0,o=this.m_newNodes.length;r<o;r++){const t=this.m_newNodes[r];if(null===t)continue;let e=t;for(let s=r+1;s<o;s++){const n=this.m_newNodes[s];null!==n&&t.pt.equals(n.pt)&&(e.nextInHash=n,n.prevInHash=e,e=n,this.m_newNodes[s]=null)}}for(let r=0,o=this.m_newNodes.length;r<o;r++){const o=this.m_newNodes[r];if(null==o)continue;for(o.hash=this.calculateHash(o.pt);;){const r=(0,h.as)(4),a=this.hashTableBinsToCheck(o,r);for(let e=0;e<a;e++)if(null!==r[e])for(let a=r[e];null!==a;){const e=a.nextInHash;h.P.distance(o.pt,a.pt)<=t&&(s.push(a),this.removeNodeFromHash(a),a.hash=0,i.push(a),n.push(a)),a=e}let m=!1;for(const t of s)if(!o.pt.equals(t.pt)){const s=lt(o.pt,t.pt,o.weight,o.rank,t.weight,t.rank);o.pt.assign(s.pt),o.weight=s.weight,o.rank=s.rank,m=!0,e=!0}if(s.length=0,!m)break;o.hash=this.calculateHash(o.pt)}i.push(o),n.push(o);for(let t=o.nextInHash;null!==t;){t.prevInHash=null;const e=t.nextInHash;t.nextInHash=null,i.push(t),n.push(t),t=e}const a=o.hash;let m=null,l=null;for(const t of n)o!==t&&(t.hash=a,t.pt.assign(o.pt),t.rank=o.rank,t.weight=o.weight),t.prevInHash=m,m&&(m.nextInHash=t),t.prevEqual=l,t.nextEqual=null,l&&(l.nextEqual=t),l=t,m=t;const u=a%this.m_hashTableOfEquals.length;m.nextInHash=this.m_hashTableOfEquals[u],null!==this.m_hashTableOfEquals[u]&&(this.m_hashTableOfEquals[u].prevInHash=m),this.m_hashTableOfEquals[u]=n[0],this.m_hashTableOfEqualsSize+=n.length,n.length=0,this.rehashIfNeeded()}if(this.m_newNodes.length=0,e)for(const r of i)this.updateAttachedEdgesAfterNodeChange(r)}rehashIfNeeded(){if(2*this.m_hashTableOfEqualsSize>this.m_hashTableOfEquals.length){const t=this.m_hashTableOfEquals;this.m_hashTableOfEquals=(0,h.as)(2*t.length),this.m_hashTableOfEqualsSize=0;for(const e of t){let t=e;for(;t;){const e=t.nextInHash;t.nextInHash=null,t.prevInHash=null,this.addNodeToHashImpl(t),t=e}}}}addNodeToHashImpl(t){const e=t.hash%this.m_hashTableOfEquals.length,s=this.m_hashTableOfEquals[e];t.nextInHash=s,null!==s&&(s.prevInHash=t),this.m_hashTableOfEquals[e]=t,this.m_hashTableOfEqualsSize++}removeNodeFromHash(t){const e=t.hash%this.m_hashTableOfEquals.length,s=t.prevInHash,n=t.nextInHash;s?s.nextInHash=n:this.m_hashTableOfEquals[e]=n,n&&(n.prevInHash=s),this.m_hashTableOfEqualsSize--,t.prevInHash=null,t.nextInHash=null}hashTableBinsToCheck(t,e){const s=(t.pt.x-this.m_origin.x)/this.m_cell.x,n=(t.pt.y-this.m_origin.y)/this.m_cell.y,i=(0,h.i)()-1,r=Math.round((0,h.c)(s,-2147483646,i)),o=Math.round((0,h.c)(n,-2147483646,i));let a=r|o<<32;a=(0,h.ar)(a),e[0]=this.m_hashTableOfEquals[a%this.m_hashTableOfEquals.length];let m=r+1|o<<32;m=(0,h.ar)(m);let l=1;e[1]=this.m_hashTableOfEquals[m%this.m_hashTableOfEquals.length],e[1]!==e[0]&&(l=2);let u=r+1|o+1<<32;u=(0,h.ar)(u),e[l]=this.m_hashTableOfEquals[u%this.m_hashTableOfEquals.length];for(let h=0;h<l;h++)if(e[l]===e[h]){l--;break}l++;let c=r|o+1<<32;c=(0,h.ar)(c),e[l]=this.m_hashTableOfEquals[c%this.m_hashTableOfEquals.length];for(let h=0;h<l;h++)if(e[l]===e[h]){l--;break}return l++,l}calculateHash(t){const e=(t.x-this.m_origin.x)/this.m_cell.x,s=(t.y-this.m_origin.y)/this.m_cell.y,n=(0,h.i)()-1;let i=Math.round((0,h.c)(e,-2147483646,n))|Math.round((0,h.c)(s,-2147483646,n))<<32;return i=(0,h.ar)(i),0===i&&(i=1),i}processSharpCorners(t,e,s,n){if(this.parent.m_param1.length=0,this.parent.m_param2.length=0,t.getStartXY().equals(e.getStartXY())){const i=[0,0],r=[0,0],a=(0,o.a7)(t,e,0,0,s,2,i,r,n);if(a){this.parent.m_param1.push(0),this.parent.m_param2.push(0);for(let t=0;t<a;t++)this.parent.m_param1.push(i[t]),this.parent.m_param2.push(r[t]);return a+1}}if(t.getEndXY().equals(e.getEndXY())){const i=[0,0],r=[0,0],a=(0,o.a7)(t,e,1,1,s,2,i,r,n);if(a){for(let t=0;t<a;t++)this.parent.m_param1.push(i[t]),this.parent.m_param2.push(r[t]);return this.parent.m_param1.push(1),this.parent.m_param2.push(1),a+1}}if(t.getStartXY().equals(e.getEndXY())){const i=[0,0],r=[0,0],a=(0,o.a7)(t,e,0,1,s,2,i,r,n);if(a){this.parent.m_param1.push(0),this.parent.m_param2.push(1);for(let t=0;t<a;t++)this.parent.m_param1.push(i[t]),this.parent.m_param2.push(r[t]);return a+1}}if(t.getEndXY().equals(e.getStartXY())){const i=[0,0],r=[0,0],a=(0,o.a7)(t,e,1,0,s,2,i,r,n);if(a){for(let t=0;t<a;t++)this.parent.m_param1.push(i[t]),this.parent.m_param2.push(r[t]);return this.parent.m_param1.push(1),this.parent.m_param2.push(0),a+1}}return 0}}function Et(t,e,s){let n=0;switch(t){case r.G.enumLine:n=0;break;case r.G.enumBezier:n=2;break;case r.G.enumRationalBezier2:n=3;break;case r.G.enumBezier2:n=1;break;case r.G.enumEllipticArc:n=0===e.projectionBehavior()?5:4;break;default:(0,r.c)("")}return s?5-n:n}class Ct extends rt{constructor(t){super(t.m_shape,t.m_tolerance,!1),this.m_parent=t}compare(t,e,s){if(this.m_bIntersectionDetected)return-1;const n=t.getElement(s),i=this.m_parent.getEdgeOriginVertices(e),r=this.m_parent.m_edgeVertices.getFirstElement(i),o=this.m_parent.getEdgeOriginVertices(n),a=this.m_parent.m_edgeVertices.getFirstElement(o);return this.m_currentNode=s,this.compareSegments(e,r,n,a)}}class St extends ot{constructor(t){super(t.m_shape,t.m_tolerance),this.m_parent=t}compare(t,e){if(this.m_bIntersectionDetected)return-1;const s=t.getElement(e),n=this.m_parent.getEdgeOriginVertices(s),i=this.m_parent.m_edgeVertices.getFirstElement(n);return this.m_currentNode=e,this.compareVertex(t,e,i)}}class vt extends a.a6{constructor(t){super(),this.pt1=h.P.getNAN(),this.pt2=h.P.getNAN(),this.m_shape=t}compare(t,e,s){this.m_shape.queryXY(e,this.pt1);const n=t.getElement(s);return this.m_shape.queryXY(n,this.pt2),this.pt1.compare(this.pt2)}}class bt{constructor(t){this.m_point=h.P.getNAN(),this.m_pt=h.P.getNAN(),this.m_shape=t}setPoint(t){this.m_point.setCoordsPoint2D(t)}compare(t,e){const s=t.getElement(e);return this.m_shape.queryXY(s,this.m_pt),this.m_point.compare(this.m_pt)}}class It{constructor(t,e){this.m_shape=null,this.m_progressTracker=null,this.m_edges=new a.S(8),this.m_clusters=new a.S(5),this.m_clusterVertices=new nt(!1),this.m_edgeVertices=new nt(!1),this.m_helperPoint=new a.P,this.m_eventQ=new a.T,this.m_sweepStructure=new a.T,this.m_bComplications=!1,this.m_sweepComparator=null,this.m_tempEdgeBuffer=[],this.m_modifiedClusters=[],this.m_edgesToInsertInSweepStructure=[],this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1,this.m_progressCounter=0,this.m_segmentIntersector=new dt,this.m_segBuf1=new o.S,this.m_segBuf2=new o.S,this.m_sweepPoint=new h.P(0,0),this.m_tolerance=0,this.m_toleranceSqr=0,this.m_sweepPointCluster=-1,this.m_vertexClusterIndex=-1,this.m_bCracked=!1,this.m_bSweepPointClusterWasModified=!1,this.m_progressTracker=t,this.m_bTrackChanges=e}hadComplications(){return this.m_bComplications}sweep(t,e){const s=new l.T;s.setSwapCoordinates(),t.applyTransformation(s),this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=e,this.m_toleranceSqr=e*e;let n=this.sweepImpl_();return t.applyTransformation(s),n||(this.fillEventQueuePass2(),n=this.sweepImpl_()||n),this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_shape=null,this.m_bCracked}sweepVertical(t,e){this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=e,this.m_toleranceSqr=e*e,this.m_bComplications=!1;let s=this.sweepImpl_();if(!this.m_bComplications){const n=t.filterClosePoints(e,!0,!1,this.m_bTrackChanges,o.n);this.m_bComplications=1===n,s||(s=1===n)}return-1!==this.m_vertexClusterIndex&&(this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_vertexClusterIndex=-1),this.m_shape=null,s}getEdgeCluster(t,e){return this.m_edges.getField(t,0+e)}setEdgeCluster_(t,e,s){this.m_edges.setField(t,0+e,s)}getEdgeOriginVertices(t){return this.m_edges.getField(t,2)}setEdgeOriginVertices_(t,e){this.m_edges.setField(t,2,e)}getNextEdgeEx(t,e){return this.m_edges.getField(t,3+e)}setNextEdgeEx_(t,e,s){this.m_edges.setField(t,3+e,s)}getEdgeSweepNode(t){return this.m_edges.getField(t,7)}setEdgeSweepNode_(t,e){this.m_edges.setField(t,7,e)}getNextEdge(t,e){const s=this.getEdgeEnd(t,e);return this.m_edges.getField(t,3+s)}setNextEdge_(t,e,s){const n=this.getEdgeEnd(t,e);this.m_edges.setField(t,3+n,s)}getPrevEdge(t,e){const s=this.getEdgeEnd(t,e);return this.m_edges.getField(t,5+s)}setPrevEdge_(t,e,s){const n=this.getEdgeEnd(t,e);this.m_edges.setField(t,5+n,s)}getClusterVertices(t){return this.m_clusters.getField(t,0)}setClusterVertices_(t,e){this.m_clusters.setField(t,0,e)}getClusterSweepEdgeList(t){return this.m_clusters.getField(t,2)}setClusterSweepEdgeList_(t,e){this.m_clusters.setField(t,2,e)}getClusterFirstEdge(t){return this.m_clusters.getField(t,1)}setClusterFirstEdge_(t,e){this.m_clusters.setField(t,1,e)}getClusterEventQNode(t){return this.m_clusters.getField(t,3)}setClusterEventQNode_(t,e){this.m_clusters.setField(t,3,e)}newCluster_(t){const e=this.m_clusters.newElement(),s=this.m_clusterVertices.createList();return this.setClusterVertices_(e,s),t!==o.n&&(this.m_clusterVertices.addElement(s,t),this.m_shape.setUserIndex(t,this.m_vertexClusterIndex,e)),e}deleteCluster_(t){this.m_clusters.deleteElement(t)}addVertexToCluster_(t,e){const s=this.getClusterVertices(t);this.m_clusterVertices.addElement(s,e),this.m_shape.setUserIndex(e,this.m_vertexClusterIndex,t)}newEdge_(t){const e=this.m_edges.newElement(),s=this.m_edgeVertices.createList();return this.setEdgeOriginVertices_(e,s),-1!==t&&this.m_edgeVertices.addElement(s,t),e}addVertexToEdge_(t,e){const s=this.getEdgeOriginVertices(t);this.m_edgeVertices.addElement(s,e)}deleteEdge_(t){this.m_edges.deleteElement(t);const e=this.m_edgesToInsertInSweepStructure.findIndex((e=>e===t));e>=0&&(0,h.aA)(this.m_edgesToInsertInSweepStructure,e)}addEdgeToCluster(t,e){-1===this.getEdgeCluster(t,0)?this.setEdgeCluster_(t,0,e):-1===this.getEdgeCluster(t,1)?this.setEdgeCluster_(t,1,e):(0,r.c)(""),this.addEdgeToClusterImpl_(t,e)}addEdgeToClusterImpl_(t,e){const s=this.getClusterFirstEdge(e);if(-1!==s){const n=this.getNextEdge(s,e);this.setPrevEdge_(n,e,t),this.setNextEdge_(t,e,n),this.setNextEdge_(s,e,t),this.setPrevEdge_(t,e,s)}else this.setPrevEdge_(t,e,t),this.setNextEdge_(t,e,t),this.setClusterFirstEdge_(e,t)}getEdgeEnd(t,e){return this.getEdgeCluster(t,0)===e?0:1}mergeClusters_(t,e){this.dbgCheckCluster_(t),this.dbgCheckCluster_(e);const s=this.getClusterEventQNode(e);-1!==s&&(this.m_eventQ.deleteNode(s),this.setClusterEventQNode_(e,-1));let n=this.getClusterFirstEdge(t),i=this.getClusterFirstEdge(e);if(-1!==i){let s=i,r=i,o=!1;do{this.dbgCheckEdge_(s),o=!1;const n=this.getEdgeEnd(s,e),a=this.getNextEdgeEx(s,n);if(this.getEdgeCluster(s,n+1&1)===t){this.disconnectEdge_(s);const t=this.getEdgeOriginVertices(s);if(this.m_edgeVertices.deleteList(t),this.deleteEdge_(s),s===a){i=-1;break}i===s&&(i=this.getClusterFirstEdge(e),r=a,o=!0)}s=a}while(s!==r||o);if(-1!==i){do{const n=this.getEdgeEnd(s,e),i=this.getNextEdgeEx(s,n);this.setEdgeCluster_(s,n,t),s=i}while(s!==r);if(n=this.getClusterFirstEdge(t),-1!==n){const e=this.getNextEdge(n,t),s=this.getNextEdge(i,t);e===n?(this.setClusterFirstEdge_(t,i),this.addEdgeToClusterImpl_(n,t),this.setClusterFirstEdge_(t,n)):s===i&&this.addEdgeToClusterImpl_(i,t),this.setNextEdge_(i,t,e),this.setPrevEdge_(e,t,i),this.setNextEdge_(n,t,s),this.setPrevEdge_(s,t,n)}else this.setClusterFirstEdge_(t,i)}}const r=this.getClusterVertices(t),o=this.getClusterVertices(e);for(let a=this.m_clusterVertices.getFirst(o);-1!==a;a=this.m_clusterVertices.getNext(a)){const e=this.m_clusterVertices.getElement(a);this.m_shape.setUserIndex(e,this.m_vertexClusterIndex,t)}this.m_clusterVertices.concatenateLists(r,o),this.deleteCluster_(e),this.dbgCheckCluster_(t)}mergeEdges_(t,e){this.dbgCheckEdge_(t),this.dbgCheckEdge_(e);const s=this.getEdgeCluster(t,0),n=this.getEdgeCluster(t,1),i=this.getEdgeCluster(e,0),r=this.getEdgeCluster(e,1),o=this.getEdgeOriginVertices(t),a=this.getEdgeOriginVertices(e);if(this.m_edgeVertices.concatenateLists(o,a),e===this.getClusterFirstEdge(s)&&this.setClusterFirstEdge_(s,t),e===this.getClusterFirstEdge(n)&&this.setClusterFirstEdge_(n,t),this.disconnectEdge_(e),this.deleteEdge_(e),!(s===i&&n===r||n===i&&s===r)){const t=this.getClusterXY(s),e=this.getClusterXY(i);t.isEqualPoint2D(e)?(s!==i&&this.mergeClusters_(s,i),n!==r&&this.mergeClusters_(n,r)):(n!==i&&this.mergeClusters_(n,i),s!==r&&this.mergeClusters_(s,r))}this.dbgCheckEdge_(t)}disconnectEdge_(t){const e=this.getEdgeCluster(t,0),s=this.getEdgeCluster(t,1);this.disconnectEdgeFromCluster_(t,e),this.disconnectEdgeFromCluster_(t,s)}disconnectEdgeFromCluster_(t,e){const s=this.getNextEdge(t,e),n=this.getPrevEdge(t,e),i=this.getClusterFirstEdge(e);s!==t?(this.setNextEdge_(n,e,s),this.setPrevEdge_(s,e,n),i===t&&this.setClusterFirstEdge_(e,s)):this.setClusterFirstEdge_(e,-1)}applyIntersectorToEditShape_(t,e,s){let n=this.m_edgeVertices.getFirst(t);const i=this.m_edgeVertices.getElement(n),r=this.getClusterFromVertex(i),o=this.m_shape.getNextVertex(i),a=this.getClusterFromVertex(o),h=this.m_shape.getXY(i),m=this.m_shape.getXY(o);let l=!1,u=!1;const c=e.getResultSegment(s,0).getStartXY(),g=e.getResultSegment(s,e.getResultSegmentCount(s)-1).getEndXY();h.equals(c)||(l=!0),m.equals(g)||(u=!0),this.m_shape.splitSegmentWithIntersector(i,e,s,!0,!0);const d=this.m_bTrackChanges&&e.getSegmentChanged(s);for(d&&this.m_shape.setGeometryModifiedWithVertex(i,!0),n=this.m_edgeVertices.getNext(n);-1!==n;n=this.m_edgeVertices.getNext(n)){const t=this.m_edgeVertices.getElement(n),i=this.getClusterFromVertex(t)===r;this.m_shape.splitSegmentWithIntersector(t,e,s,i,!0),d&&this.m_shape.setGeometryModifiedWithVertex(t,!0)}if(l&&this.updateClusterXY(!0,r,c,e.getResultSegmentStartPointWeight(s,0),e.getResultSegmentStartPointRank(s,0)),u){const t=e.getResultSegmentCount(s)-1;this.updateClusterXY(!0,a,g,e.getResultSegmentEndPointWeight(s,t),e.getResultSegmentEndPointRank(s,t))}}createEdgesAndClustersFromSplitEdge_(t,e,s){this.dbgCheckNewEdgesArray_();const n=this.getEdgeOriginVertices(t),i=this.getEdgeCluster(t,0),r=this.getEdgeCluster(t,1);let o=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(o);const h=a.S.impossibleIndex3();this.setEdgeSweepNode_(o,h),this.m_tempEdgeBuffer.push(o),this.addEdgeToCluster(o,i);const m=e.getResultSegmentCount(s);for(let a=1;a<m;a++){const t=this.newCluster_(-1);this.m_modifiedClusters.push(t),this.m_tempEdgeBuffer.push(t),this.addEdgeToCluster(o,t);const e=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(e),this.setEdgeSweepNode_(e,h),this.m_tempEdgeBuffer.push(e),this.addEdgeToCluster(e,t),o=e}this.addEdgeToCluster(o,r);for(let a=this.m_edgeVertices.getFirst(n);-1!==a;a=this.m_edgeVertices.getNext(a)){let t=this.m_edgeVertices.getElement(a);if(this.getClusterFromVertex(t)===i){let e=0;const s=this.m_tempEdgeBuffer.length;do{if(e>0){const s=this.m_tempEdgeBuffer[e-1];this.addVertexToCluster_(s,t)}const s=this.m_tempEdgeBuffer[e];e+=2,this.addVertexToEdge_(s,t),t=this.m_shape.getNextVertex(t)}while(e<s)}else{let e=this.m_tempEdgeBuffer.length-1;do{if(e<this.m_tempEdgeBuffer.length-2){const s=this.m_tempEdgeBuffer[e+1];this.addVertexToCluster_(s,t)}const s=this.m_tempEdgeBuffer[e];e-=2,this.addVertexToEdge_(s,t),t=this.m_shape.getNextVertex(t)}while(e>=0)}}this.m_tempEdgeBuffer.length=0,this.dbgCheckNewEdgesArray_()}getVertexFromClusterIndex(t){const e=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(e)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_vertexClusterIndex)}processSplitHelper1_(t,e,s){const n=this.getEdgeCluster(e,0),i=this.getClusterXY(n),r=this.getEdgeCluster(e,1),o=this.getClusterXY(r),h=s.getResultSegmentCount(t);let m=s.getResultSegment(t,0);const l=m.getStartXY();if(i.isEqualPoint2D(l)||(this.m_bComplications||i.compare(this.m_sweepPoint)*l.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0),this.getAffectedEdges(n,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(n)),!this.m_bComplications&&h>1){const t=i.compare(o),e=m.getEndXY();(i.compare(e)!==t||e.compare(o)!==t||e.compare(this.m_sweepPoint)<0)&&(this.m_bComplications=!0)}m=s.getResultSegment(t,h-1);const u=m.getEndXY();o.isEqualPoint2D(u)||(this.m_bComplications||o.compare(this.m_sweepPoint)*u.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0),this.getAffectedEdges(r,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(r)),this.m_tempEdgeBuffer.push(e);for(let c=0,g=this.m_tempEdgeBuffer.length;c<g;c++){const t=this.m_tempEdgeBuffer[c],s=this.getEdgeSweepNode(t);a.S.isValidElement(s)&&(this.m_sweepStructure.deleteNode(s),this.setEdgeSweepNode_(t,-1));const n=a.S.impossibleIndex3();t!==e&&this.getEdgeSweepNode(t)!==n&&(this.m_edgesToInsertInSweepStructure.push(t),this.setEdgeSweepNode_(t,n))}this.m_tempEdgeBuffer.length=0}checkAndFixIntersection_(t,e){const s=this.m_sweepStructure.getElement(t);return this.m_sweepComparator.compare(this.m_sweepStructure,s,e),!!this.m_sweepComparator.intersectionDetected()&&(this.m_sweepComparator.clearIntersectionDetectedFlag(),this.fixIntersection_(t,e),!0)}fixIntersection_(t,e){this.m_bCracked=!0;const s=this.m_sweepStructure.getElement(t),n=this.m_sweepStructure.getElement(e);let i=null,o=null;const a=this.getEdgeOriginVertices(s),h=this.m_edgeVertices.getFirstElement(a),m=this.getEdgeOriginVertices(n),l=this.m_edgeVertices.getFirstElement(m),u=this.m_shape.querySegment(h,this.m_segBuf1,!1,!1);(0,r.g)(u),i=this.m_segBuf1.get();const c=this.m_shape.getNextVertex(h),g=this.m_shape.getWeight(h),d=this.m_shape.getSegmentParentageBreakVertex(h),_=this.m_shape.getWeight(c),p=this.m_shape.getSegmentParentageBreakVertex(c),f=this.m_shape.getSegmentWeight(h),P=this.m_shape.getRank(h),x=this.m_shape.getRank(c),y=this.m_shape.getSegmentRank(h),E=this.m_shape.getSegmentParentage(h),C=this.m_shape.querySegment(l,this.m_segBuf2,!1,!1);(0,r.g)(C),o=this.m_segBuf2.get();const S=this.m_shape.getNextVertex(l),v=this.m_shape.getWeight(l),b=this.m_shape.getSegmentParentageBreakVertex(l),I=this.m_shape.getWeight(S),w=this.m_shape.getSegmentParentageBreakVertex(S),D=this.m_shape.getSegmentWeight(l),T=this.m_shape.getRank(l),N=this.m_shape.getRank(S),A=this.m_shape.getSegmentRank(l),G=this.m_shape.getSegmentParentage(l);this.m_segmentIntersector.pushSegment(i,g,P,_,x,f,y,d,p,E),this.m_segmentIntersector.pushSegment(o,v,T,I,N,D,A,b,w,G),3===this.m_segmentIntersector.intersect2D(this.m_tolerance,!0)&&(this.m_bComplications=!0),this.splitEdge_(s,n,-1,this.m_segmentIntersector),this.m_segmentIntersector.clear()}fixIntersectionPointSegment_(t,e){this.m_bCracked=!0;const s=this.m_sweepStructure.getElement(e);let n=null;const i=this.getEdgeOriginVertices(s),o=this.m_edgeVertices.getFirstElement(i),a=this.m_shape.querySegment(o,this.m_segBuf1,!1,!1);(0,r.g)(a),n=this.m_segBuf1.get();const h=this.m_shape.getNextVertex(o),m=this.m_shape.getWeight(o),l=this.m_shape.getSegmentParentageBreakVertex(o),u=this.m_shape.getWeight(h),c=this.m_shape.getSegmentParentageBreakVertex(h),g=this.m_shape.getSegmentWeight(o),d=this.m_shape.getRank(o),_=this.m_shape.getRank(h),p=this.m_shape.getSegmentRank(o),f=this.m_shape.getSegmentParentage(o),P=this.getClusterFirstVertex(t);this.m_segmentIntersector.pushSegment(n,m,d,u,_,g,p,l,c,f),this.m_shape.queryPoint(P,this.m_helperPoint);const x=this.m_shape.getWeight(P),y=this.m_shape.getRank(P);this.m_segmentIntersector.intersect2DEx(this.m_tolerance,this.m_helperPoint,y,x,!0),this.splitEdge_(s,-1,t,this.m_segmentIntersector),this.m_segmentIntersector.clear()}insertNewEdges_(){if(0===this.m_edgesToInsertInSweepStructure.length)return!0;this.dbgCheckNewEdgesArray_();let t=!0,e=0;const s=this.m_edgesToInsertInSweepStructure.length,n=Math.max(2*s+200,this.m_sweepStructure.size()+200);for(;this.m_edgesToInsertInSweepStructure.length;){if(this.m_edgesToInsertInSweepStructure.length>Math.max(100,this.m_shape.getTotalPointCount())||e>n){this.m_edgesToInsertInSweepStructure.length=0,this.m_bComplications=!0,t=!1;break}const s=this.m_edgesToInsertInSweepStructure.at(-1);this.m_edgesToInsertInSweepStructure.pop(),this.setEdgeSweepNode_(s,-1);const i=this.isEdgeOnSweepLine_(s);a.S.isValidElement(i)?(this.insertNewEdgeToSweepStructure_(s,i),e++):i!==a.S.impossibleIndex2()&&(t=!1),this.m_bContinuingSegmentChainOptimization=!1}return t}insertNewEdgeToSweepStructure_(t,e){let s;if(this.m_bContinuingSegmentChainOptimization?(s=this.m_sweepStructure.addElementAtPosition(this.m_prevNeighbour,this.m_nextNeighbour,t,!0,!0),this.m_bContinuingSegmentChainOptimization=!1):s=this.m_sweepStructure.addUniqueElement(t),-1===s){const e=this.m_sweepStructure.getDuplicateElement(),s=this.m_sweepStructure.getElement(e);return this.mergeEdges_(s,t),!1}if(this.setEdgeSweepNode_(t,s),this.m_sweepComparator.intersectionDetected()){this.m_sweepComparator.clearIntersectionDetectedFlag();const t=this.m_sweepComparator.getLastComparedNode();return this.m_prevNeighbour===t&&(this.m_prevNeighbour=-1),this.m_nextNeighbour===t&&(this.m_nextNeighbour=-1),this.fixIntersection_(t,s),!0}return!1}isEdgeOnSweepLine_(t){const e=this.getEdgeCluster(t,0),s=this.getEdgeCluster(t,1),n=this.getClusterXY(e),i=this.getClusterXY(s);if(h.P.sqrDistance(n,i)<=this.m_toleranceSqr)return this.m_bComplications=!0,-1;const r=n.compare(this.m_sweepPoint),o=i.compare(this.m_sweepPoint);return r<=0&&o>0?s:o<=0&&r>0?e:r>0&&o>0?a.S.impossibleIndex2():-1}fillEventQueue(){const t=new a.A(0),e=this.m_shape.queryVertexIteratorOnSelection();for(let i=e.next();i!==o.n;i=e.next())-1!==this.m_shape.getUserIndex(i,this.m_vertexClusterIndex)&&t.add(i);this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0),this.m_eventQ.clear(),this.m_eventQ.setCapacity(t.size()),this.m_eventQ.setComparator(new vt(this.m_shape));const s=h.P.getNAN();s.setNAN();let n=-1;for(let i=0,r=t.size();i<r;i++){const e=t.read(i);if(this.m_shape.getXY(e).isEqualPoint2D(s)){const t=this.m_shape.getUserIndex(e,this.m_vertexClusterIndex);this.mergeClusters_(n,t);continue}n=this.getClusterFromVertex(e),this.m_shape.queryXY(e,s);const r=this.m_eventQ.addBiggestElement(e);this.setClusterEventQNode_(n,r)}}fillEventQueuePass2(){const t=new a.A(0);for(let e=this.m_eventQ.getFirst();-1!==e;e=this.m_eventQ.getNext(e)){const s=this.m_eventQ.getElement(e);t.add(s)}this.m_eventQ.clear(),this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0);for(let e=0,s=t.size();e<s;e++){const s=t.read(e),n=this.getClusterFromVertex(s),i=this.m_eventQ.addBiggestElement(s);this.setClusterEventQNode_(n,i)}}getAffectedEdges(t,e){const s=this.getClusterFirstEdge(t);if(-1===s)return;let n=s;do{const s=this.getEdgeSweepNode(n);a.S.isValidElement(s)&&e.push(n),n=this.getNextEdge(n,t)}while(n!==s)}updateClusterXY(t,e,s,n,i){const r=this.getClusterVertices(e);for(let o=this.m_clusterVertices.getFirst(r);-1!==o;o=this.m_clusterVertices.getNext(o)){const e=this.m_clusterVertices.getElement(o);this.m_shape.setXYMonotonicPoint2D(e,s),this.m_shape.setWeight(e,n),this.m_shape.setRank(e,i),t&&this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(e,!0),this.m_shape.setSegmentParentageBreakVertex(e,!0)}}splitEdge_(t,e,s,n){this.dbgCheckEdge_(t),-1!==e&&this.dbgCheckEdge_(e),this.disconnectEdge_(t),-1!==e&&this.disconnectEdge_(e),this.processSplitHelper1_(0,t,n),-1!==e&&this.processSplitHelper1_(1,e,n),-1!==s&&n.getResultPointChanged()&&this.m_modifiedClusters.push(s);for(let o=0,a=this.m_modifiedClusters.length;o<a;o++){const t=this.m_modifiedClusters[o],e=this.getClusterEventQNode(t);-1!==e&&(this.m_eventQ.deleteNode(e),this.setClusterEventQNode_(t,-1))}const i=this.getEdgeOriginVertices(t),r=-1!==e?this.getEdgeOriginVertices(e):-1;if(this.applyIntersectorToEditShape_(i,n,0),-1!==r)this.applyIntersectorToEditShape_(r,n,1);else{const t=n.getResultPoint().getXY();this.updateClusterXY(n.getResultPointChanged(),s,t,n.getResultPointWeight(),n.getResultPointRank())}this.createEdgesAndClustersFromSplitEdge_(t,n,0),-1!==e&&this.createEdgesAndClustersFromSplitEdge_(e,n,1),this.m_edgeVertices.deleteList(i),this.deleteEdge_(t),-1!==e&&(this.m_edgeVertices.deleteList(r),this.deleteEdge_(e));for(let o=0,a=this.m_modifiedClusters.length;o<a;o++){const t=this.m_modifiedClusters[o];t===this.m_sweepPointCluster&&(this.m_bSweepPointClusterWasModified=!0);let e=this.getClusterEventQNode(t);if(-1===e){const s=this.getClusterFirstVertex(t);if(e=this.m_eventQ.addUniqueElement(s),-1===e){const e=this.m_eventQ.getDuplicateElement(),s=this.m_eventQ.getElement(e),n=this.getClusterFromVertex(s);this.mergeClusters_(n,t)}else this.setClusterEventQNode_(t,e)}}this.m_modifiedClusters.length=0}getClusterXY(t){const e=this.getClusterFirstVertex(t);return this.m_shape.getXY(e)}getClusterFirstVertex(t){const e=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(e)}dbgCheckEdge_(t){}dbgCheckCluster_(t){}dbgCheckNewEdgesArray_(){}dbgSaveSweepStructure_(t){}sweepImpl_(){this.progress_(!0),this.m_bSweepPointClusterWasModified=!1,this.m_sweepPointCluster=-1,null===this.m_sweepComparator&&(this.m_sweepStructure.disableBalancing(),this.m_sweepComparator=new Ct(this),this.m_sweepStructure.setComparator(this.m_sweepComparator));const t=[];let e=null,s=null;this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1;const n=a.S.impossibleIndex2(),i=a.S.impossibleIndex3();for(let r=this.m_eventQ.getFirst();-1!==r;){this.progress_(),this.dbgCheckSweepStructure_(),this.m_bContinuingSegmentChainOptimization=!1,this.m_prevNeighbour=-1,this.m_nextNeighbour=-1;const o=this.m_eventQ.getElement(r);this.m_sweepPointCluster=this.getClusterFromVertex(o),this.m_shape.queryXY(o,this.m_sweepPoint),this.m_sweepComparator.setSweepY(this.m_sweepPoint.y,this.m_sweepPoint.x);let a=!1;{const e=this.getClusterFirstEdge(this.m_sweepPointCluster);if(a=-1===e,!a){let s=e;do{const e=this.getEdgeSweepNode(s);-1===e?(this.m_edgesToInsertInSweepStructure.push(s),this.setEdgeSweepNode_(s,i)):e!==i&&t.push(e),s=this.getNextEdge(s,this.m_sweepPointCluster)}while(s!==e)}}if(!this.m_sweepStructure.isAutoBalancing()&&(this.m_sweepStructure.getMaxDepthEver()>4||this.m_edgesToInsertInSweepStructure.length>10)&&this.m_sweepStructure.enableBalancing(),t.length>0){this.m_bContinuingSegmentChainOptimization=1===t.length&&1===this.m_edgesToInsertInSweepStructure.length;for(let i=0,r=t.length;i<r;i++){const e=this.m_sweepStructure.getElement(t[i]);this.setEdgeSweepNode_(e,n)}let e=n,s=n;for(let i=0,r=t.length;i<r;i++){const r=t[i];if(e===n){const t=this.m_sweepStructure.getPrev(r);if(-1!==t){const s=this.m_sweepStructure.getElement(t);this.getEdgeSweepNode(s)!==n&&(e=t)}else e=-1}if(s===n){const t=this.m_sweepStructure.getNext(r);if(-1!==t){const e=this.m_sweepStructure.getElement(t);this.getEdgeSweepNode(e)!==n&&(s=t)}else s=-1}if(e!==n&&s!==n)break}for(let n=0,i=t.length;n<i;n++){const e=t[n],s=this.m_sweepStructure.getElement(e);this.m_sweepStructure.deleteNode(e),this.setEdgeSweepNode_(s,-1)}t.length=0,this.m_prevNeighbour=e,this.m_nextNeighbour=s,-1!==e&&-1!==s?this.m_bContinuingSegmentChainOptimization||this.checkAndFixIntersection_(e,s):-1===e&&-1===s&&(this.m_bContinuingSegmentChainOptimization=!1)}else a&&(null===e&&(e=new St(this)),e.setPoint(this.m_sweepPoint),this.m_sweepStructure.searchUpperBound(e),e.intersectionDetected()&&(e.clearIntersectionDetectedFlag(),this.fixIntersectionPointSegment_(this.m_sweepPointCluster,e.getCurrentNode())));const h=this.m_bContinuingSegmentChainOptimization;!this.insertNewEdges_()&&h&&-1!==this.m_prevNeighbour&&-1!==this.m_nextNeighbour&&this.checkAndFixIntersection_(this.m_prevNeighbour,this.m_nextNeighbour),this.m_bSweepPointClusterWasModified?(this.m_bSweepPointClusterWasModified=!1,null===s&&(s=new bt(this.m_shape)),s.setPoint(this.m_sweepPoint),r=this.m_eventQ.searchUpperBound(s)):r=this.m_eventQ.getNext(r)}return this.m_bCracked}setEditShape_(t){this.m_shape=t,this.m_vertexClusterIndex=this.m_shape.createUserIndex(),this.m_edges.setCapacity(t.getSelectedCount()+32),this.m_clusters.setCapacity(t.getSelectedCount()),this.m_clusterVertices.reserveLists(t.getSelectedCount()),this.m_clusterVertices.reserveNodes(t.getSelectedCount()),this.m_edgeVertices.reserveLists(t.getSelectedCount()+32),this.m_edgeVertices.reserveNodes(t.getSelectedCount()+32);for(let e=this.m_shape.getFirstGeometry();e!==o.n;e=this.m_shape.getNextGeometry(e))if((0,r.h)(this.m_shape.getGeometryType(e)))for(let s=this.m_shape.getFirstPath(e);s!==o.n;s=this.m_shape.getNextPath(s)){const e=this.m_shape.getPathSize(s),n=this.m_shape.getFirstVertex(s);if(n===o.n)continue;let i=this.m_shape.getNextVertex(n);if(i===o.n||i===n)continue;let r=-1;t.selected(n)&&(r=this.newCluster_(n));let a=-1;-1!==r&&t.selected(i)&&(a=this.newEdge_(n),this.addEdgeToCluster(a,r));let h=a;for(let t=0,s=e-2;t<s;t++){const t=this.m_shape.getNextVertex(i);let e=-1;if(this.m_shape.selected(i)){const s=this.newCluster_(i);-1!==h&&this.addEdgeToCluster(h,s),this.m_shape.selected(t)&&(e=this.newEdge_(i),this.addEdgeToCluster(e,s))}h=e,i=t}if(this.m_shape.isClosedPath(s)){const t=this.m_shape.getNextVertex(i);if(this.m_shape.selected(i)){const e=this.newCluster_(i);if(-1!==h&&this.addEdgeToCluster(h,e),this.m_shape.selected(t)){const t=this.newEdge_(i);this.addEdgeToCluster(t,e),this.addEdgeToCluster(t,r)}}}else{let t=-1;this.m_shape.selected(i)&&(t=this.newCluster_(i),-1!==h&&this.addEdgeToCluster(h,t))}}else for(let t=this.m_shape.getFirstPath(e);t!==o.n;t=this.m_shape.getNextPath(t)){let e=this.m_shape.getFirstVertex(t);for(let s=0,n=this.m_shape.getPathSize(t);s<n;s++)this.m_shape.selected(e)&&this.newCluster_(e),e=this.m_shape.getNextVertex(e)}this.fillEventQueue()}progress_(){}dbgCheckSweepStructure_(){}}function wt(t,e,s){return{vertex0:t,vertex1:e,dir:s}}class Dt{constructor(t){this.m_shape=null,this.m_spikes=[],this.m_points=new a.A(0),this.m_pointsIndex=-1,this.m_dissolvedEdges=0,this.m_progressTracker=t}executeImpl_(t,e){if(this.m_shape=t,t.getPathCount(e)<2&&t.getPointCount(e)<6)return;this.m_points.resize(0);for(let r=t.getFirstPath(e);r!==o.n;r=t.getNextPath(r)){let e=t.getFirstVertex(r);for(let s=0,n=t.getPathSize(r);s<n;s++,e=t.getNextVertex(e))this.m_points.add(e)}this.m_pointsIndex=t.createUserIndex();for(let r=0,o=this.m_points.size();r<o;++r)t.setUserIndex(this.m_points.read(r),this.m_pointsIndex,r);t.sortVerticesSimpleByY(this.m_points,0,this.m_points.size());let s=this.m_points.read(0);const n=t.getXY(s);let i=1,a=0;const h=[];for(let r=1;r<this.m_points.size();r++){const e=this.m_points.read(r);if(e===o.n)continue;if(-1===t.getUserIndex(e,this.m_pointsIndex))continue;const m=t.getXY(e);if(m.isEqualPoint2D(n))i++;else{if(i>1){for(let e=a;e<r;e++){const s=this.m_points.read(e);if(-1===t.getUserIndex(s,this.m_pointsIndex))continue;const i=t.getNextVertex(s),r=t.getPrevVertex(s);if(s!==i&&!t.isEqualXYPoint2D(i,n)){const t=wt(s,i,1);h.push(t)}if(s!==r&&r!==i&&!t.isEqualXYPoint2D(r,n)){const t=wt(s,r,-1);h.push(t)}}h.length>0&&this.processBunch_(h,n)}s=e,n.assign(m),i=1,a=r}}if(0===this.m_dissolvedEdges)return t.removeUserIndex(this.m_pointsIndex),void(this.m_pointsIndex=-1);let m=t.getPointCount(e);for(let r=0;r<this.m_points.size();r++){const e=this.m_points.read(r);if(e===o.n)continue;if(-1!==t.getUserIndex(e,this.m_pointsIndex)){t.setUserIndex(e,this.m_pointsIndex,-1);continue}const s=t.getPathFromVertex(e);t.getFirstVertex(s)===e&&t.setFirstVertex(s,o.n),t.freeVertex(e),this.m_points.write(r,o.n),m--}const l=t.createPathUserIndex();let u=t.getPathCount(e);for(let c=0,g=this.m_points.size();c<g;++c){if(this.m_points.read(c)===o.n)continue;let s=this.m_points.read(c);if(-1!==t.getUserIndex(s,this.m_pointsIndex))continue;let n=t.getPathFromVertex(s),i=-1;if(2===t.getPathUserIndex(n,l)){n=o.n;for(let e=t.getNextVertex(s);e!==s;e=t.getNextVertex(e)){const i=t.getPathFromVertex(e);if(2!==t.getPathUserIndex(i,l)){n=i,s=e;break}}n===o.n&&(n=t.insertPath(e,o.n),t.setClosedPath(n,!0),u++),(0,r.g)(n!==o.n)}t.setPathUserIndex(n,l,2),i=t.getFirstVertex(n);let a=0,h=!1,m=s;do{i===m&&(h=!0),t.setUserIndex(m,this.m_pointsIndex,1);const e=t.getPathFromVertex(m);e!==n&&(2!==t.getPathUserIndex(e,l)&&(t.setPathUserIndex(e,l,1),t.setFirstVertex(e,o.n)),t.setPathToVertex(m,n)),a++,m=t.getNextVertex(m)}while(m!==s);h||t.setFirstVertex(n,s),t.setPathSize(n,a)}for(let r=t.getFirstPath(e);r!==o.n;){const e=t.getNextPath(r);1!==t.getPathUserIndex(r,l)&&t.getFirstVertex(r)!==o.n||(t.removePathOnly(r),u--),r=e}t.setGeometryVertexCount(e,m),t.setGeometryPathCount(e,u),t.removePathUserIndex(l),t.removeUserIndex(this.m_pointsIndex),this.m_pointsIndex=-1,t.dbgVerifyVertexCounts(),t.filterClosePoints(0,!0,!1,!1,e)}processBunch_(t,e){t.sort(((t,s)=>{const n=this.m_shape.getXY(t.vertex1).sub(e),i=this.m_shape.getXY(s.vertex1).sub(e),r=h.P.compareVectors(n,i);return 0===r?t.dir<s.dir?-1:1:r}));let s=0;const n=this.m_shape.getXY(t[0].vertex1);let i=1;const r=this.m_shape.hasCurves();for(let o=1,a=t.length;o<a;o++){const e=this.m_shape.getXY(t[o].vertex1);if(!(e.isEqualPoint2D(n)&&(i++,o+1<a))){if(2===i){const e=t[s],n=t[s+1],i=e.dir;if(i!==n.dir){let t=!0;if(r&&(t=!this.m_shape.isCurve(1===e.dir?e.vertex0:e.vertex1)&&!this.m_shape.isCurve(1===n.dir?n.vertex0:n.vertex1)),t){if(1===i){const t=e.vertex0,s=n.vertex0;this.m_shape.setNextVertex(t,s),this.m_shape.setPrevVertex(s,t),this.m_shape.getPrevVertex(t)===s&&(this.m_shape.setUserIndex(t,this.m_pointsIndex,-1),this.m_shape.setUserIndex(s,this.m_pointsIndex,-1));const i=e.vertex1,r=n.vertex1;this.m_shape.setPrevVertex(i,r),this.m_shape.setNextVertex(r,i),this.m_shape.getNextVertex(i)===r&&(this.m_shape.setUserIndex(i,this.m_pointsIndex,-1),this.m_shape.setUserIndex(r,this.m_pointsIndex,-1))}else{const t=e.vertex0,s=n.vertex0;this.m_shape.setPrevVertex(t,s),this.m_shape.setNextVertex(s,t),this.m_shape.getNextVertex(t)===s&&(this.m_shape.setUserIndex(t,this.m_pointsIndex,-1),this.m_shape.setUserIndex(s,this.m_pointsIndex,-1));const i=e.vertex1,r=n.vertex1;this.m_shape.setNextVertex(i,r),this.m_shape.setPrevVertex(r,i),this.m_shape.getPrevVertex(i)===r&&(this.m_shape.setUserIndex(i,this.m_pointsIndex,-1),this.m_shape.setUserIndex(r,this.m_pointsIndex,-1))}this.m_dissolvedEdges+=2}}}n.assign(e),s=o,i=1}}t.length=0}}function Tt(t){for(let e=t.getFirstGeometry();e!==o.n;e=t.getNextGeometry(e))if((0,r.h)(t.getGeometryType(e)))return!0;return!1}function Nt(t,e,s,n,i){if(!Tt(e))return!1;let r=new Gt(i);if(r.m_shape=e,r.m_tolerance=s,r.m_bAllowCoincident=t,r.m_bNeedsNonSimpleResult=null!==n,r.needsCrackingImpl_())return n&&n.assign(r.m_nonSimpleResult),!0;const o=new l.T;o.setSwapCoordinates(),e.applyTransformation(o),r=new Gt(i),r.m_shape=e,r.m_tolerance=s,r.m_bAllowCoincident=t,r.m_bNeedsNonSimpleResult=null!==n;const a=r.needsCrackingImpl_();return e.applyTransformation(o),!!a&&(n&&n.assign(r.m_nonSimpleResult),!0)}function At(t,e){return{t:t,index:e}}class Gt{crackBruteForce_(){let t=this.crackBruteForceImpl_();if(!t&&this.m_shape.hasCurves()){const e=new l.T;e.setSwapCoordinates(),this.m_shape.applyTransformation(e),t=this.crackBruteForceImpl_(),this.m_shape.applyTransformation(e)}return t}crackBruteForceImpl_(){let t=!1;const e=new o.S,s=new o.S,n=i.Envelope2D.constructEmpty(),h=i.Envelope2D.constructEmpty(),m=!1,l=new a.P,u=new dt,c=this.m_shape.getTotalPointCount(),g=c*c*2,d=this.m_shape.queryVertexIteratorOnSelection();for(let i=d.next();i!==o.n;i=d.next()){const a=this.m_shape.getGeometryType(d.currentGeometry());let c=1,_=1,p=1,f=0,P=0,x=0;const y=this.m_shape.getSegmentParentage(i);let E=!1,C=!1,S=null,v=!1;if((0,r.e)(a))c=this.m_shape.getWeight(i),f=this.m_shape.getRank(i);else{if(S=this.getSegment_(i,e),null===S)continue;const t=this.m_shape.getVertexIndex(i);c=this.m_shape.getWeightWithIndex(t),f=this.m_shape.getRankWithIndex(t),p=this.m_shape.getSegmentWeightWithIndex(t),x=this.m_shape.getSegmentRankWithIndex(t),E=this.m_shape.getSegmentParentageBreakVertex(i);{const t=this.m_shape.getNextVertex(i);_=this.m_shape.getWeight(t),P=this.m_shape.getRank(t),C=this.m_shape.getSegmentParentageBreakVertex(t)}if(S.queryLooseEnvelope(n),n.inflateCoords(this.m_tolerance,this.m_tolerance),S.isDegenerate(this.m_tolerance)){if(!S.isDegenerate(0))continue;v=!0,S=null}}const b=new o.a1({copy:d});let I=b.next();I!==o.n&&(I=b.next());let w=0;for(;I!==o.n;I=b.next()){if(0!==w){w--;continue}if(this.m_shape.getTotalPointCount()>g)return t;this.progress_();const a=this.m_shape.getGeometryType(b.currentGeometry());let D=null,T=!1,N=0,A=0,G=0,M=0,F=0,q=0,V=!1,Y=!1;const X=this.m_shape.getSegmentParentage(I);if((0,r.e)(a))N=this.m_shape.getWeight(I),M=this.m_shape.getRank(I);else{if(D=this.getSegment_(I,s),null===D)continue;const t=this.m_shape.getVertexIndex(I);N=this.m_shape.getWeightWithIndex(t),M=this.m_shape.getRankWithIndex(t),G=this.m_shape.getSegmentWeightWithIndex(t),q=this.m_shape.getSegmentRankWithIndex(t),V=this.m_shape.getSegmentParentageBreakVertex(I);{const t=this.m_shape.getNextVertex(I);A=this.m_shape.getWeight(t),F=this.m_shape.getRank(t),Y=this.m_shape.getSegmentParentageBreakVertex(t)}if(D.queryLooseEnvelope(h),D.isDegenerate(this.m_tolerance)){if(!D.isDegenerate(0))continue;T=!0,D=null}}let k=0,R=0;if(null!==S&&null!==D)n.isIntersectingNe(h)&&0!==(0,o.a2)(!0,!0,S,D,this.m_tolerance,!0)&&(u.pushSegment(S,c,f,_,P,p,x,E,C,y),u.pushSegment(D,N,M,A,F,G,q,V,Y,X),u.intersect2D(this.m_tolerance,!0),t||(t=u.getSegmentChanged(0)||u.getSegmentChanged(1)),k=u.getResultSegmentCount(0),R=u.getResultSegmentCount(1),k+R>0&&(this.m_shape.splitSegmentWithIntersector(i,u,0,!0,!0),this.m_shape.splitSegmentWithIntersector(I,u,1,!0,!0),this.m_bTrackChanges&&(u.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(i,!0),u.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(I,!0))),R>1&&(w+=R-1),u.clear());else if(null!==S){const e=this.m_shape.getXY(I);if(n.contains(e)){if(u.pushSegment(S,c,f,_,P,p,x,E,C,y),this.m_shape.queryPoint(I,l),u.intersect2DEx(this.m_tolerance,l,M,N,m),t||(t=u.getSegmentChanged(0)||u.getResultPointChanged()),k=u.getResultSegmentCount(0),k>0)if(this.m_bTrackChanges&&(u.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(i,!0),u.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(I,!0)),this.m_shape.splitSegmentWithIntersector(i,u,0,!0,!0),T){let t=o.n;for(let e=this.m_shape.getNextVertex(I);e!==o.n&&e!==I&&(D=this.getSegment_(e,s),t=e,null!=D&&D.isDegenerate(0));e=this.m_shape.getNextVertex(e));for(let e=I;e!==o.n&&(this.m_shape.setPoint(e,u.getResultPoint(),!0),e!==t);e=this.m_shape.getNextVertex(e));}else this.m_shape.setPoint(I,u.getResultPoint(),!0);u.clear()}}else{if(null===D)continue;{const e=this.m_shape.getXY(i);if(h.inflateCoords(this.m_tolerance,this.m_tolerance),h.contains(e)){if(u.pushSegment(D,N,M,A,F,G,q,V,Y,X),this.m_shape.queryPoint(i,l),u.intersect2DEx(this.m_tolerance,l,f,c,m),t||(t=u.getSegmentChanged(0)||u.getResultPointChanged()),R=u.getResultSegmentCount(0),R>0)if(this.m_bTrackChanges&&(u.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(I,!0),u.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(i,!0)),this.m_shape.splitSegmentWithIntersector(I,u,0,!0,!0),w+=R-1,v){let t=o.n;for(let e=this.m_shape.getNextVertex(i);e!==o.n&&e!==i&&(D=this.getSegment_(e,s),t=e,null!=D&&D.isDegenerate(0));e=this.m_shape.getNextVertex(e));for(let e=i;e!==o.n&&(this.m_shape.setPoint(e,u.getResultPoint(),!0),e!==t);e=this.m_shape.getNextVertex(e));}else this.m_shape.setPoint(i,u.getResultPoint(),!0);u.clear()}}}if(k+R!==0&&0!==k){let t=!1;for(;S=this.getSegment_(i,e),null!=S&&(S.queryEnvelope(n),S.isDegenerate(this.m_tolerance));){if(!(k>1)){t=!0;break}i=d.next(),k--,(0,r.g)(i!==o.n)}if(t)break}}}return t}crackerPlaneSweep_(){return this.planesweep_()}planesweep_(){return new It(this.m_progressTracker,this.m_bTrackChanges).sweep(this.m_shape,this.m_tolerance)}needsCrackingImpl_(){let t=!1;const e=new a.A(0);e.resize(this.m_shape.getSelectedCount());const s=this.m_shape.queryVertexIteratorOnSelection();for(let r=0,a=s.next();a!==o.n;++r,a=s.next())e.write(r,a);this.m_shape.sortVerticesSimpleByY(e,0,e.size()),e.add(o.n);const n=this.m_shape.createUserIndex(),i=this.m_shape.createUserIndex();this.m_sweepComparator=new rt(this.m_shape,this.m_tolerance,!this.m_bAllowCoincident),this.m_sweepStructure.setComparator(this.m_sweepComparator);let m=null;const l=[],u=[];let c=0;const g=new h.P;for(let a=e.read(c++);a!==o.n;){this.m_shape.queryXY(a,g);let s=!1;do{let t=this.m_shape.getNextVertex(a),r=this.m_shape.getPrevVertex(a);s||(s=t!==o.n||r!==o.n),t===o.n||this.m_shape.selected(t)||(t=o.n),r===o.n||this.m_shape.selected(r)||(r=o.n),t!==o.n&&this.m_shape.compareVerticesSimpleY(a,t)<0&&(u.push(a),u.push(t)),r!==o.n&&this.m_shape.compareVerticesSimpleY(a,r)<0&&(u.push(r),u.push(r));const h=this.m_shape.getUserIndex(a,n);-1!==h&&(l.push(h),this.m_shape.setUserIndex(a,n,-1));const m=this.m_shape.getUserIndex(a,i);-1!==m&&(l.push(m),this.m_shape.setUserIndex(a,i,-1)),a=e.read(c++)}while(a!==o.n&&this.m_shape.isEqualXYPoint2D(a,g));if(!s&&(null===m&&(m=new ot(this.m_shape,this.m_tolerance)),m.setPoint(g),this.m_sweepStructure.searchUpperBound(m),m.intersectionDetected())){t=!0,this.m_bNeedsNonSimpleResult&&((0,r.c)("needsCrackingIMpl_"),this.m_nonSimpleResult=new p(6,-1,-1));break}let d=1===l.length&&2===u.length;const _=32;l.length>_&&(0,h.v)(l);let f=-1,P=-1;if(!d)for(let e=0,n=l.length;e<n;e++){const s=l[e],n=this.m_sweepStructure.getPrev(s);if(-1!==n&&-1===l.indexOf(n))if(-1===f)f=n;else{if(t=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new p(6,-1,-1)}const i=this.m_sweepStructure.getNext(s);if(-1!==i&&-1===l.indexOf(i))if(-1===P)P=i;else{if(t=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new p(6,-1,-1)}if(-1!==f&&-1!==P)break}if(t&&!this.m_bNeedsNonSimpleResult)break;if(this.m_sweepComparator.setSweepY(g.y,g.x),!d){for(let t=0,e=l.length;t<e;t++){const e=l[t];this.m_sweepStructure.deleteNode(e)}l.length=0}if(!d&&-1!==f&&-1!==P&&this.checkForIntersections_(f,P)){t=!0,this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult());break}for(let e=0,r=u.length;e<r;e+=2){const s=u[e],r=u[e+1];let o;if(d?(o=this.m_sweepStructure.replaceElementAtPosition(l[0],s,!0,!0),l.length=0,d=!1):o=this.m_sweepStructure.addElement(s),this.m_sweepComparator.intersectionDetected()){this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult()),t=!0;break}-1===this.m_shape.getUserIndex(r,n)?this.m_shape.setUserIndex(r,n,o):this.m_shape.setUserIndex(r,i,o)}if(t)break;u.length=0}return this.m_shape.removeUserIndex(n),this.m_shape.removeUserIndex(i),t}checkForIntersections_(t,e){const s=this.m_sweepStructure.getElement(t);this.m_sweepComparator.compare(this.m_sweepStructure,s,e);const n=this.m_sweepComparator.intersectionDetected();return this.m_sweepComparator.clearIntersectionDetectedFlag(),n}getSegment_(t,e){return Gt.st_getSegment(this.m_shape,t,e)}static st_getSegment(t,e,s){return t.querySegment(e,s,!1,!1)?s.get():null}dbgPrintSweepEdge(t){}dbgPrintSweepStructure(){}dbgSaveSweepStructure(){}dbgCheckSweepStructure(){}progress_(){this.m_progressCounter++}crackAWithBMultiPath_(t,e,s){const n=i.Envelope2D.constructEmpty();t.queryLooseEnvelope(n);const m=i.Envelope2D.constructEmpty();if(e.queryLooseEnvelope(m),m.inflateCoords(s,s),!m.isIntersecting(n))return t;const l=t.getImpl(),u=l.getAccelerators();let c=null,g=null;u&&(g=u.getQuadTree()),function(t,e){const s=t.getPointCount();if(s<16)return!1;const n=1;return 2*s+Math.log(s)/Math.log(2)*1*e<n*s*e}(t,(0,r.v)(e))&&(c=(0,a.G)(l,m),g=c);const d=g?g.getIteratorForQT():null,_=e.querySegmentIterator(),p=t.querySegmentIterator(),f=(0,h.d)(15,Number.NaN),P=[];for(;_.nextPath();)for(;_.hasNextSegment();){const t=_.nextSegment();if(g){d.resetIterator(t,s);for(let e=d.next();-1!==e;e=d.next()){this.progress_();const n=g.getElement(e);if(p.resetToVertex(n,-1),p.hasNextSegment()){const e=p.nextSegment().intersect(t,null,f,null,s);for(let t=0;t<e;t++){const e=f[t];if(0===e||1===e)continue;const s=At(e,p.getStartPointIndex());P.push(s)}}}}else{const e=i.Envelope2D.constructEmpty();if(t.queryLooseEnvelope(e),e.inflateCoords(s,s),!n.isIntersecting(e))continue;for(p.resetToFirstPath();p.nextPath();)for(;p.hasNextSegment();){const n=p.nextSegment(),r=i.Envelope2D.constructEmpty();if(n.queryLooseEnvelope(r),!r.isIntersecting(e))continue;const o=n.intersect(t,null,f,null,s);for(let t=0;t<o;t++){const e=f[t];if(0===e||1===e)continue;const s=At(e,p.getStartPointIndex());P.push(s)}}}}if(0===P.length)return t;P.sort(((t,e)=>t.index<e.index?-1:t.index>e.index?1:t.t<e.t?-1:t.t>e.t?1:0));const x=t.createInstance();for(x.getGeometryType()===r.G.enumPolygon&&x.setFillRule(t.getFillRule()),p.resetToFirstPath();p.nextPath()&&!p.hasNextSegment(););(0,r.g)(p.hasNextSegment());let y=p.nextSegment();const E=new o.S;let C=-1;for(let i=0,o=P.length;i<o;){const t=P[i].index;let e=i+1;for(;e<o&&P[e].index===t;)++e;for(;p.getStartPointIndex()<t;){this.progress_();const t=p.hasNextSegment(),e=p.getPathIndex();if((t||!p.isClosingSegment()||p.isCurve())&&((0,r.g)(null!==y),x.addSegment(y,C!==e)),C=e,!t){for(p.isPathClosed();p.nextPath()&&!p.hasNextSegment(););(0,r.g)(p.hasNextSegment())}y=p.nextSegment()}let s=0;for(let o=i;o<e;o++){const t=P[o].t;if(t===s)continue;(0,r.g)(null!==y),y.queryCut(s,t,E),s=t;const e=p.getPathIndex();x.addSegment(E.get(),C!==e),C=e}const n=p.hasNextSegment();if((n||!p.isClosingSegment()||p.isCurve())&&((0,r.g)(null!=y),y.queryCut(s,1,E),x.addSegment(E.get(),!1)),n)y=p.nextSegment();else{for(;p.nextPath()&&!p.hasNextSegment(););y=p.hasNextSegment()?p.nextSegment():null}i=e}if(null!==y){const t=p.getPathIndex();(p.hasNextSegment()||!p.isClosingSegment()||p.isCurve())&&x.addSegment(y,C!==t),C=t}let S=p.hasNextSegment();for(;;){if(!S){for(;p.nextPath()&&(S=p.hasNextSegment(),!S););if(!S)break}y=p.nextSegment();const t=p.getPathIndex();S=p.hasNextSegment(),(S||!p.isClosingSegment()||p.isCurve())&&x.addSegment(y,C!==t),C=t}return x}constructor(t){this.m_shape=null,this.m_progressTracker=null,this.m_nonSimpleResult=new p,this.m_tolerance=0,this.m_sweepComparator=null,this.m_progressCounter=0,this.m_bTrackChanges=!1,this.m_bNeedsNonSimpleResult=!1,this.m_bAllowCoincident=!0,this.m_sweepStructure=new a.T,this.m_progressTracker=t}}Gt.s_bForceBruteForce=!0;class Mt{constructor(t,e){this.m_monotoneParts=(0,h.m)(o.S,16),this.m_xOrds=(0,h.d)(16,Number.NaN),this.m_inputPoint=h.P.getNAN(),this.m_miny=0,this.m_maxy=0,this.m_windnum=0,this.m_bAlternate=t,this.m_tolerance=e,this.m_toleranceSqr=e*e,this.m_bTestBorder=!!e,this.m_bBreak=!1}_DoOne(t){if(!this.m_bTestBorder&&(this.m_bAlternate&&this.m_inputPoint.equals(t.getStartXY())||this.m_inputPoint.equals(t.getEndXY())))return void(this.m_bBreak=!0);if(t.getStartY()===this.m_inputPoint.y&&t.getStartY()===t.getEndY()){if(this.m_bAlternate&&!this.m_bTestBorder){const e=Math.min(t.getStartX(),t.getEndX()),s=Math.max(t.getStartX(),t.getEndX());this.m_inputPoint.x>e&&this.m_inputPoint.x<s&&(this.m_bBreak=!0)}return}let e=!1;const s=Math.max(t.getStartX(),t.getEndX());if(this.m_inputPoint.x>s)e=!0;else if(this.m_inputPoint.x>=Math.min(t.getStartX(),t.getEndX())){const n=t.intersectionOfYMonotonicWithAxisX(this.m_inputPoint.y,s);e=!Number.isNaN(n)&&n<=this.m_inputPoint.x}if(e){if(this.m_inputPoint.y===t.getStartY()){if(this.m_inputPoint.y<t.getEndY())return}else if(this.m_inputPoint.y===t.getEndY()&&this.m_inputPoint.y<t.getStartY())return;this.m_bAlternate?this.m_windnum^=1:this.m_windnum+=t.getStartY()>t.getEndY()?1:-1}}_Result(){return!!this.m_windnum}testBorder(t){const e=t.getClosestCoordinate(this.m_inputPoint,!1),s=t.getCoord2D(e);return h.P.sqrDistance(s,this.m_inputPoint)<=this.m_toleranceSqr}setInputPoint(t){this.m_inputPoint.setCoordsPoint2D(t),this.m_miny=t.y-this.m_tolerance,this.m_maxy=t.y+this.m_tolerance}processSegment(t){const e=t.queryInterval(0,1);if(e.vmin>this.m_maxy||e.vmax<this.m_miny)return!1;if(this.m_bTestBorder&&this.testBorder(t))return!0;if(e.vmin>this.m_inputPoint.y||e.vmax<this.m_inputPoint.y)return!1;let s=0;if(t.isCurve()&&(0===this.m_monotoneParts.length&&(this.m_monotoneParts.length=128),s=t.getMonotonicParts(this.m_monotoneParts,!0),(0,r.g)(this.m_monotoneParts.length>=s)),s>0)for(let n=0;n<s;n++){const t=this.m_monotoneParts[n].get(),e=h.E.construct(t.getStartY(),t.getEndY());if(!(e.vmin>this.m_inputPoint.y||e.vmax<this.m_inputPoint.y)&&(this._DoOne(t),this.m_bBreak))return!0}else if(this._DoOne(t),this.m_bBreak)return!0;return!1}result(){return(0,r.g)(0),2}}function Ft(t,e,s){if(t.isEmpty())return 0;const n=i.Envelope2D.constructEmpty();if(t.queryLooseEnvelope(n),n.inflateCoords(s,s),!n.contains(e))return 0;const o=t.getImpl().getAccelerators();if(o){o.getRasterizedGeometry()&&(0,r.g)(0);const n=o.getQuadTree();if(n)return function(t,e,s,n){const r=new i.Envelope2D;t.queryLooseEnvelope(r),r.inflateCoords(n,n);const o=0===t.getFillRule(),a=new Mt(o,n);a.setInputPoint(s);const h=r.clone();h.xmax=s.x+n,h.ymin=s.y-n,h.ymax=s.y+n;const m=t.getImpl().querySegmentIterator(),l=e.getIterator(h,n);for(let i=l.next();-1!==i;i=l.next())if(m.resetToVertex(e.getElement(i),-1),m.hasNextSegment()){const t=m.nextSegment();if(a.processSegment(t))return-1}return a._Result()?1:0}(t,n,e,s)}return function(t,e,s){const n=0===t.getFillRule(),i=new Mt(n,s);i.setInputPoint(e);const r=t.getImpl().querySegmentIterator();for(;r.nextPath();)for(;r.hasNextSegment();){const t=r.nextSegment();if(i.processSegment(t))return-1}return i._Result()?1:0}(t,e,s)}function qt(t,e){const s=t.getPointCount();if(s<16)return!1;return 2*s+Math.log(s)/Math.log(2)*1*e<1*s*e}function Vt(t,e,s){const n=new Rt(s);return n.m_shape=t,n.m_geometry=e,n.m_sortedVertices=null,n.m_bFixSelfTangency=!1,n.fixRingOrientationForMp2sp_()}class Yt{getDirection_(t){return this.m_shape.getNextVertex(this.getEnd1(t))===this.getEnd2(t)}getEnd_(t){const e=this.getEnd1(t),s=this.getEnd2(t);return this.m_shape.getNextVertex(e)===s?s:e}constructor(t){this.m_end1Nodes=[],this.m_end2Nodes=[],this.m_directions=[],this.m_shape=t,this.m_firstFree=-1}getSegment(t){return this.m_shape.getSegment(this.getStart(t))}isBottomUp(t){let e=this.getEnd1(t),s=this.getEnd2(t);this.m_shape.getPrevVertex(e)===s&&(s=(0,h.b)(e,e=s));const n=h.P.getNAN(),i=h.P.getNAN();return this.m_shape.queryXY(e,n),this.m_shape.queryXY(s,i),(0,r.g)(!n.equals(i)),n.y<i.y}getStart(t){const e=this.getEnd1(t),s=this.getEnd2(t);return this.m_shape.getNextVertex(e)===s?e:s}getEnd1(t){return this.m_end1Nodes[t]}getEnd2(t){return this.m_end2Nodes[t]}freeEdge(t){this.m_end1Nodes[t]=this.m_firstFree,this.m_firstFree=t}newEdge(t){if(-1!==this.m_firstFree){const e=this.m_firstFree;return this.m_firstFree=this.m_end1Nodes[e],this.m_end1Nodes[e]=t,this.m_end2Nodes[e]=this.m_shape.getNextVertex(t),e}const e=this.m_end1Nodes.length;return this.m_end1Nodes.push(t),this.m_end2Nodes.push(this.m_shape.getNextVertex(t)),e}getShape(){return this.m_shape}getPath(t){return this.m_shape.getPathFromVertex(this.getEnd1(t))}}let Xt=class extends a.a6{constructor(t){super(),this.m_line1=new o.L,this.m_line2=new o.L,this.m_leftElm=-1,this.m_leftx=0,this.m_seg1=null,this.m_helper=t}compare(t,e,s){const n=t.getElement(s),i=this.m_helper.m_edges;let o;this.m_leftElm===e?o=this.m_leftx:(this.m_seg1=i.getSegment(e),this.m_seg1?o=this.m_seg1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0):(i.getShape().queryLineConnector(i.getStart(e),this.m_line1,!0),this.m_seg1=this.m_line1,o=this.m_line1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)),this.m_leftx=o,this.m_leftElm=e);let a,h=i.getSegment(n);if(h?a=h.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0):(i.getShape().queryLineConnector(i.getStart(n),this.m_line2,!0),h=this.m_line2,a=this.m_line2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)),o===a){const t=i.isBottomUp(e),s=i.isBottomUp(n),m=t?this.m_seg1.getEndY():this.m_seg1.getStartY(),l=s?h.getEndY():h.getStartY(),u=Math.min(m,l);let c=.5*(u+this.m_helper.m_yScanline);c===this.m_helper.m_yScanline&&(c=u),o=this.m_seg1.intersectionOfYMonotonicWithAxisX(c,0),a=h.intersectionOfYMonotonicWithAxisX(c,0),o===a&&(0,r.D)("")}return o<a?-1:o>a?1:0}reset(){this.m_leftElm=-1}};class kt{constructor(t){this.m_node=-1,this.m_index=0,this.m_sortedVertices=t.m_sortedVertices,this.m_sortedVerticesArray=t.m_sortedVerticesArray,this.m_sortedVertices&&(this.m_node=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()))}next(){if(this.m_sortedVertices){const t=this.m_node;if(-1===t)return o.n;const e=this.m_sortedVertices.getData(t);return this.m_node=this.m_sortedVertices.getNext(t),e}if(this.m_index<this.m_sortedVerticesArray.size()){const t=this.m_sortedVerticesArray.read(this.m_index);return this.m_index++,t}return o.n}}class Rt{constructor(t){this.m_edges=null,this.m_shape=null,this.m_AET=new a.T,this.m_yScanline=0,this.m_geometry=o.n,this.m_unknownRingOrientationCount=-1,this.m_sortedVertices=null,this.m_sortedVerticesArray=null,this.m_unknownNodes=[],this.m_node1UserIndex=-1,this.m_node2UserIndex=-1,this.m_pathOrientationIndex=-1,this.m_pathParentageIndex=-1,this.m_pathParentsIndex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_progressTracker=t,this.m_AET.disableBalancing(),this.m_sweepComparator=new Xt(this),this.m_AET.setComparator(this.m_sweepComparator)}fixRingOrientation_(){const t=this.fixRingOrientationImplMain_();return-1===this.m_pathOrientationIndex||this.fixRingOrientationImplSimplify_(),t}fixRingOrientationForMp2sp_(){return this.fixRingOrientationImplMain_(),-1===this.m_pathOrientationIndex?-1:this.fixRingOrientationImplMp2sp_()}processBunchForRingOrientationTest_(t){return this.processBunchForRingOrientationTestOddEven_(t)}processBunchForRingOrientationTestOddEven_(t){let e=!1;if(this.m_edges||(this.m_edges=new Yt(this.m_shape)),this.m_unknownNodes.length=0,this.processBunchForRingOrientationRemoveEdges_(t),!this.m_AET.isAutoBalancing()){let e=0;for(let s=0,n=t.length;s<n;s++)-1!==t[s]&&e++;(e>10||this.m_AET.getMaxDepthEver()>4)&&this.m_AET.enableBalancing()}for(let s=0,n=t.length;s<n;s++){const e=t[s];e!==o.n&&this.insertEdge_(e,-1)}for(let s=0;s<this.m_unknownNodes.length&&this.m_unknownRingOrientationCount>0;s++){const t=this.m_unknownNodes[s],n=this.m_AET.getElement(t),i=this.m_edges.getPath(n),h=this.m_shape.getPathUserIndex(i,this.m_pathOrientationIndex);let m=o.n;if(0===h){let s=this.m_AET.getPrev(t),n=t,i=!1;for(;s!==a.T.st_nullNode();){const t=this.m_AET.getElement(s),e=this.m_edges.getPath(t);if(0!==this.m_shape.getPathUserIndex(e,this.m_pathOrientationIndex)){m=e;break}n=s,s=this.m_AET.getPrev(s)}if(s===a.T.st_nullNode())i=!0,s=n;else{const t=this.m_AET.getElement(s);i=this.m_edges.isBottomUp(t),s=this.m_AET.getNext(s),i=!i}do{const t=this.m_AET.getElement(s),o=this.m_edges.getPath(t);if(0===this.m_shape.getPathUserIndex(o,this.m_pathOrientationIndex)){if(i!==this.m_edges.isBottomUp(t)){const t=this.m_shape.getFirstVertex(o);this.m_shape.reverseRingInternal(t),this.m_shape.setLastVertex(o,this.m_shape.getPrevVertex(t)),e=!0}if(this.m_shape.setPathUserIndex(o,this.m_pathOrientationIndex,i?3:2),!i){let t=this.m_shape.getPathUserIndex(m,this.m_pathOrientationIndex);2===t?(m=this.m_shape.getPathUserIndex(m,this.m_pathParentsIndex),t=this.m_shape.getPathUserIndex(m,this.m_pathOrientationIndex),(0,r.g)(3===t)):(0,r.g)(3===t);const e=this.m_shape.getPathUserIndex(m,this.m_pathParentageIndex);this.m_shape.setPathUserIndex(m,this.m_pathParentageIndex,o),this.m_shape.setPathUserIndex(o,this.m_pathParentageIndex,e),this.m_shape.setPathUserIndex(o,this.m_pathParentsIndex,m)}if(this.m_unknownRingOrientationCount--,!this.m_unknownRingOrientationCount)return e}m=o,n=s,s=this.m_AET.getNext(s),i=!i}while(n!==t)}}return e}processBunchForRingOrientationRemoveEdges_(t){for(let e=0,s=t.length;e<s;e++){const s=t[e],n=this.m_shape.getUserIndex(s,this.m_node1UserIndex),i=this.m_shape.getUserIndex(s,this.m_node2UserIndex);if(-1!==n){const t=this.m_AET.getElement(n);this.m_edges.freeEdge(t),this.m_shape.setUserIndex(s,this.m_node1UserIndex,-1)}if(-1!==i){const t=this.m_AET.getElement(i);this.m_edges.freeEdge(t),this.m_shape.setUserIndex(s,this.m_node2UserIndex,-1)}let r=-1;-1!==n&&-1!==i?(this.m_AET.deleteNode(n),this.m_AET.deleteNode(i),t[e]=o.n):r=-1!==n?n:i,-1!==r&&(this.insertEdge_(s,r)||this.m_AET.deleteNode(r),t[e]=o.n)}}dbgVerifyRingOrientation_(){}insertEdge_(t,e){const s=h.P.getNAN(),n=h.P.getNAN();this.m_shape.queryXY(t,s);const i=this.m_shape.getNextVertex(t);this.m_shape.queryXY(i,n);let r=!1;if(s.y<n.y){r=!0;const s=this.m_edges.newEdge(t);let n;-1===e?n=this.m_AET.addElement(s):(n=e,this.m_AET.setElement(n,s)),-1===this.m_shape.getUserIndex(i,this.m_node1UserIndex)?this.m_shape.setUserIndex(i,this.m_node1UserIndex,n):this.m_shape.setUserIndex(i,this.m_node2UserIndex,n);const o=this.m_shape.getPathFromVertex(t);0===this.m_shape.getPathUserIndex(o,this.m_pathOrientationIndex)&&this.m_unknownNodes.push(n)}const o=this.m_shape.getPrevVertex(t);if(this.m_shape.queryXY(o,n),s.y<n.y){r=!0;const s=this.m_edges.newEdge(o);let n;-1===e?n=this.m_AET.addElement(s):(n=e,this.m_AET.setElement(n,s)),-1===this.m_shape.getUserIndex(o,this.m_node1UserIndex)?this.m_shape.setUserIndex(o,this.m_node1UserIndex,n):this.m_shape.setUserIndex(o,this.m_node2UserIndex,n);const i=this.m_shape.getPathFromVertex(t);0===this.m_shape.getPathUserIndex(i,this.m_pathOrientationIndex)&&this.m_unknownNodes.push(n)}return r}fixRingSelfTangency_(){const t=[],e=[];let s=-1,n=-1;const i=new h.P;let a=o.n,m=o.n,l=-1;const u=new kt(this);for(let r=u.next();r!==o.n;r=u.next()){const o=new h.P;this.m_shape.queryXY(r,o);const u=this.m_shape.getPathFromVertex(r);i.equals(o)&&m===u?(-1===n&&(s=this.m_shape.createPathUserIndex(),this.m_shape.fillPathUserIndexForGeometry(this.m_geometry,s,-1),n=this.m_shape.createUserIndex(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,n,-1)),-1===l&&(l=e.length,this.m_shape.setUserIndex(a,n,l),e.push(1),-1===this.m_shape.getPathUserIndex(u,s)&&(this.m_shape.setPathUserIndex(u,s,a),t.push(u))),this.m_shape.setUserIndex(r,n,l),e[e.length-1]++):(l=-1,i.assign(o)),a=r,m=u}if(0===t.length)return!1;(0,r.g)(-1!==s);for(let r=0,o=t.length;r<o;r++){const i=t[r];let o=this.m_shape.getPathUserIndex(i,s);const a=this.m_shape.getUserIndex(o,n),h=[],m=[];h.push(o),m.push(a);for(let t=this.m_shape.getNextVertex(o);t!==o;t=this.m_shape.getNextVertex(t)){const s=t,i=this.m_shape.getUserIndex(s,n);if(-1!==i){if(0===m.length){m.push(i),h.push(s);continue}if(m.at(-1)===i){const r=h.at(-1);this.m_shape.peelALoopIntoAPath(r,s),this.m_shape.setUserIndex(t,n,-1),e[i]--,1===e[i]&&(e[i]=0,m.pop(),h.pop()),o=r,t=r}else h.push(t),m.push(i)}}}return this.m_shape.removePathUserIndex(s),this.m_shape.removeUserIndex(n),this.m_shape.dbgVerifyVertexCounts(),!0}progress_(){}fixRingOrientationImplMain_(){const t={stack:[],error:void 0,hasError:!1};try{let e,s=!1;const n=(0,m.b)(t,(0,h.h)((()=>{this.m_sortedVerticesArray=null})),!1);if(null===this.m_sortedVertices){const t=this.m_shape.getPointCount(this.m_geometry);e=new a.A(0);for(let s=this.m_shape.getFirstPath(this.m_geometry);s!==o.n;s=this.m_shape.getNextPath(s)){let t=this.m_shape.getFirstVertex(s);for(let n=0,i=this.m_shape.getPathSize(s);n<i;n++)e.add(t),t=this.m_shape.getNextVertex(t)}this.m_shape.sortVerticesSimpleByY(e,0,t),this.progress_(!0),this.m_sortedVerticesArray=e}else n.bForget=!0;if(this.m_bFixSelfTangency&&(s=this.fixRingSelfTangency_()),1===this.m_shape.getPathCount(this.m_geometry)){const t=this.m_shape.getFirstPath(this.m_geometry),e=this.m_shape.getRingArea(t);if(this.m_shape.setExterior(t,!0),e<0){const e=this.m_shape.getFirstVertex(t);return this.m_shape.reverseRingInternal(e),this.m_shape.setLastVertex(t,this.m_shape.getPrevVertex(e)),!0}return!1}this.m_shape.dbgVerifyCurves(),this.m_pathOrientationIndex=this.m_shape.createPathUserIndex(),this.m_pathParentageIndex=this.m_shape.createPathUserIndex(),this.m_pathParentsIndex=this.m_shape.createPathUserIndex();for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==o.n;t=this.m_shape.getNextPath(t))this.m_shape.setPathUserIndex(t,this.m_pathOrientationIndex,0),this.m_shape.setPathUserIndex(t,this.m_pathParentageIndex,-1),this.m_shape.setPathUserIndex(t,this.m_pathParentsIndex,-1);const i=[];this.m_yScanline=Number.NaN;const r=h.P.getNAN();this.m_unknownRingOrientationCount=this.m_shape.getPathCount(this.m_geometry),this.m_node1UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node1UserIndex,-1),this.m_node2UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node2UserIndex,-1);const l=new kt(this);for(let t=l.next();t!==o.n&&(this.progress_(),this.m_shape.queryXY(t,r),r.y!==this.m_yScanline&&i.length&&(s=this.processBunchForRingOrientationTest_(i)||s,this.m_sweepComparator.reset(),i.length=0),i.push(t),this.m_yScanline=r.y,0!==this.m_unknownRingOrientationCount);t=l.next());return this.m_unknownRingOrientationCount>0&&(s=this.processBunchForRingOrientationTest_(i)||s,i.length=0),this.m_shape.removeUserIndex(this.m_node1UserIndex),this.m_shape.removeUserIndex(this.m_node2UserIndex),this.dbgVerifyRingOrientation_(),s}catch(e){t.error=e,t.hasError=!0}finally{(0,m.c)(t)}}fixRingOrientationImplSimplify_(){const t=[];for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==o.n;)if(this.progress_(),3===this.m_shape.getPathUserIndex(e,this.m_pathOrientationIndex)){this.m_shape.setExterior(e,!0);for(let i=this.m_shape.getPathUserIndex(e,this.m_pathParentageIndex);i!==o.n;){const s=this.m_shape.getPathUserIndex(i,this.m_pathParentageIndex);t.push(i),this.m_shape.setExterior(i,!1),this.m_shape.setPathUserIndex(i,this.m_pathParentageIndex,e),i=s}let s=e,n=t.length;for(let t=this.m_shape.getNextPath(e);n>0&&t!==o.n;t=this.m_shape.getNextPath(t),--n){if(this.m_shape.getPathUserIndex(t,this.m_pathParentageIndex)!==e){s=o.n;break}s=t}if(0!==n){s=e;for(let e=0,n=t.length;e<n;e++){const n=t[e];this.m_shape.setPathUserIndex(n,this.m_pathParentageIndex,a.X),this.m_shape.movePath(this.m_geometry,this.m_shape.getNextPath(s),n),s=n}}t.length=0,e=this.m_shape.getNextPath(s)}else e=this.m_shape.getNextPath(e);this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex)}fixRingOrientationImplMp2sp_(){const t=this.m_shape.createPathUserIndex();let e=0;const s=[];for(let n=this.m_shape.getFirstPath(this.m_geometry);n!==o.n;)if(this.progress_(),3===this.m_shape.getPathUserIndex(n,this.m_pathOrientationIndex)){this.m_shape.setExterior(n,!0),this.m_shape.setPathUserIndex(n,t,e),e++;for(let t=this.m_shape.getPathUserIndex(n,this.m_pathParentageIndex);t!==o.n;){const e=this.m_shape.getPathUserIndex(t,this.m_pathParentageIndex);s.push(t),this.m_shape.setExterior(t,!1),this.m_shape.setPathUserIndex(t,this.m_pathParentageIndex,n),t=e}let i=n,r=s.length,h=e;for(let e=this.m_shape.getNextPath(n);r>0&&e!==o.n;e=this.m_shape.getNextPath(e),--r){if(this.m_shape.getPathUserIndex(e,this.m_pathParentageIndex)!==n){i=o.n;break}i=e,this.m_shape.setPathUserIndex(e,t,-h),h++}if(0!==r){i=n,h=e;for(let e=0,n=s.length;e<n;e++){const n=s[e];this.m_shape.setPathUserIndex(n,t,-h),h++,this.m_shape.setPathUserIndex(n,this.m_pathParentageIndex,a.X)}i=n}e=h,s.length=0,n=this.m_shape.getNextPath(i)}else n=this.m_shape.getNextPath(n);return this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex),t}}function Ht(t,e,s,n,i,r){const o=new Lt(r);return o.m_shape=t,o.m_geometry=e,o.m_knownSimpleResult=s,o.m_bFixSelfTangency=n,o.m_polylineDegeneracies=i,o.m_bHasSegmentParentage=t.hasSegmentParentage(),o.m_bHasSegments=t.hasCurves(),o.simplify_()}class Lt{constructor(t){this.m_shape=null,this.m_geometry=o.n,this.m_sortedVertices=new a.a2,this.m_bunchEdgeEndPoints=[],this.m_bunchEdgeCenterPoints=[],this.m_bunchEdgeIndices=[],this.m_knownSimpleResult=-1,this.m_sortedVerticesListIndex=-1,this.m_polylineDegeneracies=o.n,this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_bHasSegmentParentage=!1,this.m_bHasSegments=!1,this.m_progressTracker=t}compareAngles_(t,e){if(this.m_bHasSegments)return this.compareAnglesCurves_(t,e);const s=this.m_bunchEdgeEndPoints[t],n=new h.P;this.m_shape.queryXY(s,n);const i=new h.P,o=this.m_bunchEdgeEndPoints[e];if(this.m_shape.queryXY(o,i),n.equals(i))return 0;const a=this.m_bunchEdgeCenterPoints[t],m=new h.P;this.m_shape.queryXY(a,m);const l=this.m_bunchEdgeCenterPoints[e],u=new h.P;this.m_shape.queryXY(l,u);const c=new h.P;c.setSub(n,m);const g=new h.P;return g.setSub(i,u),(c.isZero()||g.isZero())&&(0,r.D)(""),h.P.compareVectors(c,g)}compareAnglesCurves_(t,e){const s=this.m_bunchEdgeEndPoints[t],n=this.m_bunchEdgeEndPoints[e],i=this.m_bunchEdgeCenterPoints[t],a=this.m_bunchEdgeCenterPoints[e],m=this.m_shape.getNextVertex(i)===s,l=this.m_shape.getNextVertex(a)===n,u=new o.S,c=new h.P;m?(this.m_shape.querySegment(i,u,!1,!0),c.assign(u.get().getTangent(0))):(this.m_shape.querySegment(s,u,!1,!0),c.assign(u.get().getTangent(1)),c.negateThis());const g=new h.P;return l?(this.m_shape.querySegment(a,u,!1,!0),g.assign(u.get().getTangent(0))):(this.m_shape.querySegment(n,u,!1,!0),g.assign(u.get().getTangent(1)),g.negateThis()),(c.isZero()||g.isZero())&&(0,r.D)(""),h.P.compareVectors(c,g)}beforeRemoveVertex_(t,e){const s=this.m_shape.getUserIndex(t,this.m_userIndexSortedIndexToVertex);if(this.m_nextVertexToProcess===s&&(this.m_nextVertexToProcess=this.m_sortedVertices.getNext(this.m_nextVertexToProcess)),this.m_firstCoincidentVertex===s&&(this.m_firstCoincidentVertex=this.m_sortedVertices.getNext(this.m_firstCoincidentVertex)),this.m_sortedVertices.deleteElement(this.m_sortedVerticesListIndex,s),this.removeAngleSortInfo_(t),e){const e=this.m_shape.getPathFromVertex(t);if(e!==o.n&&this.m_shape.getFirstVertex(e)===t){const s=this.m_shape.getNextVertex(t);if(s!==t){if(this.m_shape.getPathFromVertex(s)===e)return void this.m_shape.setFirstVertex(e,s);{const s=this.m_shape.getPrevVertex(t);if(s!==t&&this.m_shape.getPathFromVertex(s)===e)return void this.m_shape.setFirstVertex(e,s)}}this.m_shape.setFirstVertex(e,o.n),this.m_shape.setLastVertex(e,o.n)}}}processBunch_(){let t=!1;const e=new h.P(0,0);for(;;){this.m_bunchEdgeEndPoints.length=0,this.m_bunchEdgeCenterPoints.length=0,this.m_bunchEdgeIndices.length=0;let s=this.m_firstCoincidentVertex,n=0,i=!0;for(;s!==this.m_nextVertexToProcess;){const t=this.m_sortedVertices.getData(s);i&&(this.m_shape.queryXY(t,e),i=!1);const r=this.m_shape.getPrevVertex(t),o=this.m_shape.getNextVertex(t);this.m_shape.getUserIndex(r,this.m_userIndexSortedAngleIndexToVertex)!==a.X&&(this.m_bunchEdgeEndPoints.push(r),this.m_shape.setUserIndex(r,this.m_userIndexSortedAngleIndexToVertex,a.X),this.m_bunchEdgeCenterPoints.push(t),this.m_bunchEdgeIndices.push(n++)),this.m_shape.getUserIndex(o,this.m_userIndexSortedAngleIndexToVertex)!==a.X&&(this.m_bunchEdgeEndPoints.push(o),this.m_shape.setUserIndex(o,this.m_userIndexSortedAngleIndexToVertex,a.X),this.m_bunchEdgeCenterPoints.push(t),this.m_bunchEdgeIndices.push(n++)),s=this.m_sortedVertices.getNext(s)}if(this.m_bunchEdgeEndPoints.length<2){1===this.m_bunchEdgeEndPoints.length&&this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[0],this.m_userIndexSortedAngleIndexToVertex,-1);break}this.m_bunchEdgeIndices.sort(((t,e)=>this.compareAngles_(t,e)));for(let t=0,e=this.m_bunchEdgeIndices.length;t<e;t++){const e=this.m_bunchEdgeIndices[t],s=this.m_bunchEdgeEndPoints[e];this.m_shape.setUserIndex(s,this.m_userIndexSortedAngleIndexToVertex,t)}const r=this.processCrossOvers_(e);for(let t=0,e=this.m_bunchEdgeIndices.length;t<e;t++){const e=this.m_bunchEdgeIndices[t];if(-1===e)continue;const s=this.m_bunchEdgeEndPoints[e];this.m_shape.setUserIndex(s,this.m_userIndexSortedAngleIndexToVertex,-1)}if(!r)break;t=!0}return t}processCrossOvers_(t){let e=!1,s=!0;for(;s;){s=!1;let n=0;-1===this.m_bunchEdgeIndices[n]&&(n=this.getNextEdgeIndex_(n));let i=this.getNextEdgeIndex_(n);for(let r=0,o=this.m_bunchEdgeIndices.length;r<o&&-1!==n&&-1!==i&&n!==i;r++){const r=this.m_bunchEdgeIndices[n],o=this.m_bunchEdgeIndices[i],a=this.m_bunchEdgeEndPoints[r],h=this.m_bunchEdgeEndPoints[o];let m=this.m_shape.getNextVertex(a),l=!1;this.m_shape.isEqualXYPoint2D(m,t)||(m=this.m_shape.getPrevVertex(a),l=!0);let u=this.m_shape.getNextVertex(h),c=!1;this.m_shape.isEqualXYPoint2D(u,t)||(u=this.m_shape.getPrevVertex(h),c=!0);const g=l?this.m_shape.getPrevVertex(m):this.m_shape.getNextVertex(m),d=c?this.m_shape.getPrevVertex(u):this.m_shape.getNextVertex(u);let _=!1;(this.removeSpike_(m)||this.removeSpike_(u)||this.removeSpike_(a)||this.removeSpike_(h)||this.removeSpike_(g)||this.removeSpike_(d))&&(_=!0),m!==u&&(!_&&this.m_shape.isEqualXY(a,h)&&(_=this.resolveOverlap_(l,c,m,a,u,h)),!_&&this.m_shape.isEqualXY(g,d)&&(_=this.resolveOverlap_(!l,!c,m,g,u,d)),!_&&this.m_shape.isEqualXY(a,d)&&(_=this.resolveOverlap_(l,!c,m,a,u,d)),!_&&this.m_shape.isEqualXY(g,h)&&(_=this.resolveOverlap_(!l,c,m,g,u,h))),_&&(e=!0),s||(s=_),n=_?this.getNextEdgeIndex_(n):i,i=this.getNextEdgeIndex_(n)}}if(!e){let s=0;-1===this.m_bunchEdgeIndices[s]&&(s=this.getNextEdgeIndex_(s));let n=this.getNextEdgeIndex_(s);for(let i=0,r=this.m_bunchEdgeIndices.length;i<r&&-1!==s&&-1!==n&&s!==n;i++){const i=this.m_bunchEdgeIndices[s],r=this.m_bunchEdgeIndices[n],o=this.m_bunchEdgeEndPoints[i],a=this.m_bunchEdgeEndPoints[r];let h=this.m_shape.getNextVertex(o);this.m_shape.isEqualXYPoint2D(h,t)||(h=this.m_shape.getPrevVertex(o));let m=this.m_shape.getNextVertex(a);this.m_shape.isEqualXYPoint2D(m,t)||(m=this.m_shape.getPrevVertex(a));const l=this.getDirection_(h,o),u=this.getDirection_(m,a),c=l?this.m_shape.getPrevVertex(h):this.m_shape.getNextVertex(h),g=u?this.m_shape.getPrevVertex(m):this.m_shape.getNextVertex(m),d=this.detectAndResolveCrossOver_(l,u,o,h,c,a,m,g);1!==d?0===d?(s=this.getNextEdgeIndex_(s),n=this.getNextEdgeIndex_(s)):(s=this.getPrevEdgeIndex_(s),n=this.getNextEdgeIndex_(s)):e=!0}}return e}simplify_(){this.m_shape.getGeometryType(this.m_geometry)===r.G.enumPolygon&&1===this.m_shape.getFillRule(this.m_geometry)&&new Bs(this.m_progressTracker).planarSimplifyNoCrackingAndCluster(this.m_bFixSelfTangency,this.m_shape,this.m_geometry,0);let t=!1;this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=this.m_shape.createUserIndexUninitialized();const e=this.m_shape.getPointCount(this.m_geometry),s=new a.A(0);this.m_shape.dbgVerifyMonotone();for(let r=this.m_shape.getFirstPath(this.m_geometry);r!==o.n;r=this.m_shape.getNextPath(r)){let t=this.m_shape.getFirstVertex(r);for(let e=0,n=this.m_shape.getPathSize(r);e<n;e++)this.m_shape.setUserIndex(t,this.m_userIndexSortedAngleIndexToVertex,-1),s.add(t),t=this.m_shape.getNextVertex(t)}this.m_shape.sortVerticesSimpleByY(s,0,e),this.progress_(!0),this.m_userIndexSortedIndexToVertex=this.m_shape.createUserIndexUninitialized(),this.m_sortedVertices.reserveNodes(e),this.m_sortedVerticesListIndex=this.m_sortedVertices.createList(0);for(let r=0;r<e;r++){const t=s.read(r),e=this.m_sortedVertices.addElement(this.m_sortedVerticesListIndex,t);this.m_shape.setUserIndex(t,this.m_userIndexSortedIndexToVertex,e)}this.m_nextVertexToProcess=-1,this.cleanupSpikes_()&&(t=!0);let n=0,i=!1;do{i=!1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=this.m_sortedVertices.getFirst(this.m_sortedVerticesListIndex);const e=new h.P(0,0);this.m_firstCoincidentVertex!==a.a2.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(this.m_firstCoincidentVertex),e);let s=0,o=this.m_firstCoincidentVertex;for(;o!==a.a2.st_nullNode()&&(o=this.m_sortedVertices.getNext(o),o!==a.a2.st_nullNode());){this.progress_();const t=this.m_sortedVertices.getData(o),n=h.P.getNAN();if(this.m_shape.queryXY(t,n),e.equals(n))s++;else{if(s>0){this.m_nextVertexToProcess=o;const t=this.processBunch_();o=this.m_nextVertexToProcess,o!==a.a2.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(o),n),t&&(i=!0)}e.setCoordsPoint2D(n),this.m_firstCoincidentVertex=o,s=0}}this.m_nextVertexToProcess=-1,s>0&&this.processBunch_()&&(i=!0),n++>10&&(0,r.c)(""),i&&this.fixOrphanVertices_(),this.cleanupSpikes_()&&(i=!0),t||(t=i)}while(i);return this.m_shape.dbgVerifyMonotone(),this.m_shape.dbgVerifyCurves(),this.m_shape.removeUserIndex(this.m_userIndexSortedIndexToVertex),this.m_shape.removeUserIndex(this.m_userIndexSortedAngleIndexToVertex),t=function(t,e,s,n,i){const r=new Rt(i);return r.m_shape=t,r.m_geometry=e,r.m_sortedVertices=s,r.m_bFixSelfTangency=n,r.fixRingOrientation_()}(this.m_shape,this.m_geometry,this.m_sortedVertices,this.m_bFixSelfTangency,this.m_progressTracker)||t,this.m_shape.dbgVerifyCurves(),t}getDirection_(t,e){return this.m_shape.getNextVertex(e)!==t}detectAndResolveCrossOver_(t,e,s,n,i,r,o,a){if(n===o)return this.removeAngleSortInfo_(s),this.removeAngleSortInfo_(r),-1;const m=this.m_shape.getUserIndex(s,this.m_userIndexSortedAngleIndexToVertex),l=this.m_shape.getUserIndex(i,this.m_userIndexSortedAngleIndexToVertex),u=this.m_shape.getUserIndex(r,this.m_userIndexSortedAngleIndexToVertex),c=this.m_shape.getUserIndex(a,this.m_userIndexSortedAngleIndexToVertex),g=(0,h.d)(8,Number.NaN),d=(0,h.d)(4,Number.NaN);g[0]=0,d[0]=m,g[1]=0,d[1]=l,g[2]=1,d[2]=u,g[3]=1,d[3]=c;for(let h=1;h<4;h++){const t=d[h],e=g[h];let s=h-1;for(;s>=0&&d[s]>t;)d[s+1]=d[s],g[s+1]=g[s],s--;d[s+1]=t,g[s+1]=e}let _=0;if(g[0]&&(_|=1),g[1]&&(_|=2),g[2]&&(_|=4),g[3]&&(_|=8),5!==_&&10!==_)return 0;if(t!==e&&(a=(0,h.b)(r,r=a)),t)this.m_shape.setNextVertex(a,n),this.m_shape.setPrevVertex(n,a),this.m_shape.setNextVertex(i,o),this.m_shape.setPrevVertex(o,i),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(n,!0),this.m_shape.setSegmentParentageBreakVertex(o,!0));else{if(this.m_shape.setPrevVertex(a,n),this.m_shape.setNextVertex(n,a),this.m_shape.setPrevVertex(i,o),this.m_shape.setNextVertex(o,i),this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(n),e=this.m_shape.getSegmentParentage(o);this.m_shape.setSegmentParentageAndBreak(n,e,!0),this.m_shape.setSegmentParentageAndBreak(o,t,!0)}if(this.m_bHasSegments){const t=this.m_shape.getVertexIndex(n),e=this.m_shape.getVertexIndex(o),s=this.m_shape.getSegmentFromIndex(t);this.m_shape.setSegmentToIndex(t,null);const i=this.m_shape.getSegmentFromIndex(e);this.m_shape.setSegmentToIndex(e,null),this.m_shape.setSegmentToIndex(t,i),this.m_shape.setSegmentToIndex(e,s)}}return 1}resolveOverlap_(t,e,s,n,i,r){return this.resolveOverlapOddEven_(t,e,s,n,i,r)}resolveOverlapOddEven_(t,e,s,n,i,r){if(t!==e){t||(i=(0,h.b)(s,s=i),r=(0,h.b)(n,n=r));const e=this.m_shape.getNextVertex(i),o=this.m_shape.getNextVertex(s);if(this.m_shape.setNextVertex(s,e),this.m_shape.setPrevVertex(e,s),this.m_shape.setNextVertex(i,o),this.m_shape.setPrevVertex(o,i),this.m_bHasSegments){const t=this.m_shape.getVertexIndex(s),e=this.m_shape.getVertexIndex(i),n=this.m_shape.getSegmentFromIndex(t);this.m_shape.setSegmentToIndex(t,null);const r=this.m_shape.getSegmentFromIndex(e);this.m_shape.setSegmentToIndex(e,null),this.m_shape.setSegmentToIndex(t,r),this.m_shape.setSegmentToIndex(e,n)}if(this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(s),e=this.m_shape.getSegmentParentage(i);this.m_shape.setSegmentParentageAndBreak(s,e,!0),this.m_shape.setSegmentParentageAndBreak(i,t,!0),this.m_shape.setSegmentParentageBreakVertex(n,!0),this.m_shape.setSegmentParentageBreakVertex(r,!0)}this.removeSpike_(i)}else{const o=t?s:n,a=e?i:r,h=t?n:s,m=e?r:i;let l=null;if(this.m_bHasSegments){const t=this.m_shape.getVertexIndex(m);l=this.m_shape.getSegmentFromIndex(t),this.m_shape.setSegmentToIndex(t,null);const e=this.m_shape.getVertexIndex(a);this.m_shape.setSegmentToIndex(e,null);const s=this.m_shape.getVertexIndex(o);this.m_shape.setSegmentToIndex(s,null)}let u=-1;this.m_bHasSegmentParentage&&(u=this.m_shape.getSegmentParentage(m));let c=!1;this.m_shape.setNextVertex(o,a),this.m_shape.setNextVertex(a,o),this.m_shape.setPrevVertex(h,m),this.m_shape.setPrevVertex(m,h);let g=m;for(;g!==a;){const t=this.m_shape.getPrevVertex(g),e=this.m_shape.getNextVertex(g);if(this.m_shape.setPrevVertex(g,e),this.m_shape.setNextVertex(g,t),c||(c=g===o),this.m_bHasSegments&&g!==o){const t=this.m_shape.getVertexIndex(e),s=l;l=this.m_shape.getSegmentFromIndex(t),null!==s&&s.reverse(),this.m_shape.setSegmentToIndex(t,s)}if(this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(e);this.m_shape.setSegmentParentagePreserveBreak(e,u),u=t}g=e}let d=null;if(!c){const t=this.m_shape.getPrevVertex(a),e=this.m_shape.getNextVertex(a);if(this.m_shape.setPrevVertex(a,e),this.m_shape.setNextVertex(a,t),this.m_bHasSegments){const t=this.m_shape.getVertexIndex(a);d=this.m_shape.getSegmentFromIndex(t),this.m_shape.setSegmentToIndex(t,null)}}let _=-1,p=-1;if(this.m_bHasSegmentParentage&&(_=c?this.m_shape.getSegmentParentage(o):this.m_shape.getSegmentParentage(a),p=this.m_shape.getSegmentParentage(h)),this.transferVertexData_(a,o),this.beforeRemoveVertex_(a,!0),this.m_shape.removeVertexInternal(a,!0),this.removeAngleSortInfo_(o),this.transferVertexData_(m,h),this.beforeRemoveVertex_(m,!0),this.m_shape.removeVertexInternal(m,!0),this.removeAngleSortInfo_(h),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageAndBreak(o,_,!0),this.m_shape.setSegmentParentageAndBreak(h,p,!0)),d){const t=this.m_shape.getVertexIndex(o);this.m_shape.setSegmentToIndex(t,d)}}return!0}cleanupSpikes_(){let t=!1;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==o.n;){const s=this.m_shape.getNextPath(e);let n=this.m_shape.getFirstVertex(e);for(let i=0,r=this.m_shape.getPathSize(e);i<r&&r>1;){this.progress_();const{v:s,bModified:a}=this.checkAndCleanupSpike_(e,n);if(s===o.n)break;a?(t=!0,n=s,i=0,r=this.m_shape.getPathSize(e)):(n=s,i++)}e=s}return t}checkAndCleanupSpike_(t,e){const s={v:o.n,bModified:!1};let n=this.m_shape.getPrevVertex(e),i=this.m_shape.getNextVertex(e),r=o.n,a=o.n;for(;this.m_shape.isEqualXY(n,i)&&(r=n,a=i,i!==e);)n=this.m_shape.getPrevVertex(n),i=this.m_shape.getNextVertex(i);if(r===o.n)return s.v=i,s;s.bModified=!0;for(let o=this.m_shape.getNextVertex(r);this.beforeRemoveVertex_(o,!1),o!==a;o=this.m_shape.getNextVertex(o));if(r===e)return this.m_polylineDegeneracies!==o.n?this.m_shape.movePath(this.m_polylineDegeneracies,o.n,t):this.m_shape.removePath(t),s.v=o.n,s;{const t=this.m_shape.peelALoopIntoAPath(r,a);this.m_polylineDegeneracies!==o.n?this.m_shape.movePath(this.m_polylineDegeneracies,o.n,t):this.m_shape.removePath(t)}return s.v=r,s}removeSpike_(t){let e=this.m_shape.getPrevVertex(t),s=this.m_shape.getNextVertex(t),n=o.n,i=o.n;for(;this.m_shape.isEqualXY(e,s)&&(n=e,i=s,s!==t);)e=this.m_shape.getPrevVertex(e),s=this.m_shape.getNextVertex(s);if(n===o.n)return!1;if(this.m_shape.peelALoop(n,i),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(n,!0),this.m_shape.setSegmentParentageBreakVertex(i,!0)),this.removeAngleSortInfo_(n),this.m_polylineDegeneracies===o.n)for(let r=this.m_shape.getNextVertex(i);;){const t=this.m_shape.getNextVertex(r);if(this.removeAngleSortInfo_(r),this.beforeRemoveVertex_(r,!0),this.m_shape.setSegmentToIndex(this.m_shape.getVertexIndex(r),null),this.m_shape.removeVertexInternal(r,!1),r===i)break;r=t}else{for(let e=i;;){const t=this.m_shape.getNextVertex(e);if(this.removeAngleSortInfo_(e),this.beforeRemoveVertex_(e,!1),e=t,e===i)break}const t=[!1];this.m_shape.insertClosedPath(this.m_polylineDegeneracies,o.n,i,i,t)}return!0}fixOrphanVertices_(){let t=0;for(let n=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());-1!==n;n=this.m_sortedVertices.getNext(n)){const t=this.m_sortedVertices.getData(n);this.m_shape.setPathToVertex(t,o.n)}let e=0;for(let n=this.m_shape.getFirstPath(this.m_geometry);n!==o.n;){const s=this.m_shape.getFirstVertex(n);if(s===o.n||this.m_shape.getPathFromVertex(s)!==o.n){const t=n;n=this.m_shape.getNextPath(n),this.m_shape.removePathOnly(t);continue}this.m_shape.setPathToVertex(s,n);let i=1;for(let t=this.m_shape.getNextVertex(s);t!==s;t=this.m_shape.getNextVertex(t))this.m_shape.setPathToVertex(t,n),i++;this.m_shape.setRingAreaValid(n,!1),this.m_shape.setPathSize(n,i),this.m_shape.setLastVertex(n,this.m_shape.getPrevVertex(s)),e+=i,t++,n=this.m_shape.getNextPath(n)}for(let n=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());-1!==n;n=this.m_sortedVertices.getNext(n)){const s=this.m_sortedVertices.getData(n);if(this.m_shape.getPathFromVertex(s)!==o.n)continue;const i=[!1],r=this.m_shape.insertClosedPath(this.m_geometry,o.n,s,s,i);e+=this.m_shape.getPathSize(r),t++}this.m_shape.setGeometryPathCount(this.m_geometry,t),this.m_shape.setGeometryVertexCount(this.m_geometry,e);let s=0;for(let n=this.m_shape.getFirstGeometry();n!==o.n;n=this.m_shape.getNextGeometry(n))s+=this.m_shape.getPointCount(n);this.m_shape.setTotalPointCount(s)}getNextEdgeIndex_(t){if(-1===t)return-1;for(let e=0,s=this.m_bunchEdgeIndices.length-1;e<s;e++)if(t=(t+1)%this.m_bunchEdgeIndices.length,-1!==this.m_bunchEdgeIndices[t])return t;return-1}getPrevEdgeIndex_(t){if(-1===t)return-1;for(let e=0,s=this.m_bunchEdgeIndices.length-1;e<s;e++)if(t=(this.m_bunchEdgeIndices.length+t-1)%this.m_bunchEdgeIndices.length,-1!==this.m_bunchEdgeIndices[t])return t;return-1}transferVertexData_(t,e){const s=this.m_shape.getUserIndex(e,this.m_userIndexSortedIndexToVertex),n=this.m_shape.getUserIndex(e,this.m_userIndexSortedAngleIndexToVertex);this.m_shape.transferAllDataToTheVertex(t,e),this.m_shape.setUserIndex(e,this.m_userIndexSortedIndexToVertex,s),this.m_shape.setUserIndex(e,this.m_userIndexSortedAngleIndexToVertex,n)}removeAngleSortInfo_(t){const e=this.m_shape.getUserIndex(t,this.m_userIndexSortedAngleIndexToVertex);-1!==e&&(this.m_bunchEdgeIndices[e]=-1,this.m_shape.setUserIndex(t,this.m_userIndexSortedAngleIndexToVertex,-1))}progress_(){}}function Bt(t,e,s,n,m){let l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];switch(Ut(n)){case 0:break;case 1:(0,r.t)("relation string length has to be 9 characters");break;default:(0,r.t)("relation string")}if(l){const i=function(t,e,s){return function(t){return"T*F**FFF*"===t}(t)?3:function(t){return"FF*FF****"===t}(t)?4:function(t,e,s){return(0!==e||0!==s)&&(2===e&&2===s?"F***T****"===t:(2===e||1===e)&&0===s&&"F**T*****"===t)}(t,e,s)?8:function(t,e,s){return e>s?"T*****T**"===t:1===e&&1===s&&"0********"===t}(t,e,s)?16:function(t){return"T**FF*FF*"===t}(t)?64:function(t){return"T*****FF*"===t}(t)?1:function(t,e,s){return e===s&&(1!==e?"T*T***T**"===t:"1*T***T**"===t)}(t,e,s)?32:0}(n,t.getDimension(),e.getDimension());if(0!==i)return oe(t,e,s,i,m)}let u=0;if("number"==typeof s)u=s;else{const n=i.Envelope2D.constructEmpty();t.queryEnvelope(n);const r=i.Envelope2D.constructEmpty();e.queryEnvelope(r);const o=i.Envelope2D.constructEmpty();o.setCoords({env2D:n}),o.mergeEnvelope2D(r),u=(0,a.c)(s,o,!1)}const c=ee(t,u),g=ee(e,u);if(c.isEmpty()||g.isEmpty())return function(t,e,s){const n=(0,h.d)(9,-1);if(t.isEmpty()&&e.isEmpty())return Kt(n,s);let a,m=!1;t.isEmpty()?(a=e,m=!0):a=t,n[0]=-1,n[1]=-1,n[3]=-1,n[4]=-1,n[6]=-1,n[7]=-1,n[8]=2;const l=a.getGeometryType();if((0,r.h)(l))if(l===r.G.enumPolygon)if(0!==a.calculateArea2D())n[2]=2,n[5]=1;else{n[5]=-1;const t=i.Envelope2D.constructEmpty();a.queryEnvelope(t),n[2]=t.height()||t.width()?1:0}else{const t=0!==a.calculateLength2D();n[2]=t?1:0,n[5]=(0,o.J)(a)?0:-1}else n[2]=0,n[5]=-1;return m&&te(n),Kt(n,s)}(c,g,n);const d=c.getGeometryType(),_=g.getGeometryType();let p=!1;switch(d){case r.G.enumPolygon:switch(_){case r.G.enumPolygon:p=function(t,e,s,n,r){const h=new $t;h.resetMatrix_(),h.setPredicates_(n),h.setAreaAreaPredicates_();const m=i.Envelope2D.constructEmpty(),l=i.Envelope2D.constructEmpty();t.queryEnvelope(m),e.queryEnvelope(l);let u=!1;if(he(m,l,s)&&(h.areaAreaDisjointPredicates_(t,e),u=!0),u||me(t,e),!u){const n=new o.E,i=n.addGeometry(t),m=n.addGeometry(e);h.setEditShapeCrackAndCluster_(n,new a.C(s,0),r),h.computeMatrixTopoGraphHalfEdges_(i,m),h.m_topoGraph.removeShape()}return Kt(h.m_matrix,h.m_scl)}(c,g,u,n,m);break;case r.G.enumPolyline:p=zt(c,g,u,n,m);break;case r.G.enumPoint:p=jt(c,g,u,n);break;case r.G.enumMultiPoint:p=Ot(c,g,u,n,m)}break;case r.G.enumPolyline:switch(_){case r.G.enumPolygon:p=zt(g,c,u,se(n),m);break;case r.G.enumPolyline:p=function(t,e,s,n,r){const h=new $t;h.resetMatrix_(),h.setPredicates_(n),h.setLineLinePredicates_();const m=i.Envelope2D.constructEmpty(),l=i.Envelope2D.constructEmpty();t.queryEnvelope(m),e.queryEnvelope(l);let u=!1;if(he(m,l,s)&&(h.lineLineDisjointPredicates_(t,e),u=!0),u||me(t,e),!u){const n=new o.E,i=n.addGeometry(t),m=n.addGeometry(e);h.setEditShapeCrackAndCluster_(n,new a.C(s,0),r),h.m_clusterIndexA=h.m_topoGraph.createUserIndexForClusters(),h.m_clusterIndexB=h.m_topoGraph.createUserIndexForClusters(),Jt(i,h.m_topoGraph,h.m_clusterIndexA),Jt(m,h.m_topoGraph,h.m_clusterIndexB),h.computeMatrixTopoGraphHalfEdges_(i,m),h.m_topoGraph.deleteUserIndexForClusters(h.m_clusterIndexA),h.m_topoGraph.deleteUserIndexForClusters(h.m_clusterIndexB),h.m_topoGraph.removeShape()}return Kt(h.m_matrix,h.m_scl)}(c,g,u,n,m);break;case r.G.enumPoint:p=Zt(c,g,u,n,m);break;case r.G.enumMultiPoint:p=Wt(c,g,u,n,m)}break;case r.G.enumPoint:switch(_){case r.G.enumPolygon:p=jt(g,c,u,se(n));break;case r.G.enumPolyline:p=Zt(g,c,u,se(n),m);break;case r.G.enumPoint:p=function(t,e,s,n){const i=t.getXY(),r=e.getXY(),o=(0,h.d)(9,-1);return h.P.sqrDistance(i,r)<=s*s?o[0]=0:(o[2]=0,o[6]=0),o[8]=2,Kt(o,n)}(c,g,u,n);break;case r.G.enumMultiPoint:p=Qt(g,c,u,se(n))}break;case r.G.enumMultiPoint:switch(_){case r.G.enumPolygon:p=Ot(g,c,u,se(n),m);break;case r.G.enumPolyline:p=Wt(g,c,u,se(n),m);break;case r.G.enumMultiPoint:p=function(t,e,s,n,r){const h=new $t;h.resetMatrix_(),h.setPredicates_(n),h.setPointPointPredicates_();const m=new i.Envelope2D,l=new i.Envelope2D;t.queryEnvelope(m),e.queryEnvelope(l);let u=!1;if(he(m,l,s)&&(h.pointPointDisjointPredicates_(),u=!0),!u){const n=new o.E,i=n.addGeometry(t),m=n.addGeometry(e);h.setEditShapeCrackAndCluster_(n,new a.C(s,0),r),h.computeMatrixTopoGraphClusters_(i,m),h.m_topoGraph.removeShape()}return Kt(h.m_matrix,h.m_scl)}(c,g,u,n,m);break;case r.G.enumPoint:p=Qt(c,g,u,n)}break;default:p=!1}return p}function Ut(t){if(9!==t.length)return 1;for(let e=0;e<9;e++){const s=t[e];if("*"!==s&&"T"!==s&&"F"!==s&&"0"!==s&&"1"!==s&&"2"!==s)return 2}return 0}function zt(t,e,s,n,r){const h=new $t;h.resetMatrix_(),h.setPredicates_(n),h.setAreaLinePredicates_();const m=i.Envelope2D.constructEmpty(),l=i.Envelope2D.constructEmpty();t.queryEnvelope(m),e.queryEnvelope(l);let u=!1;if(he(m,l,s)&&(h.areaLineDisjointPredicates_(t,e),u=!0),u||me(t,e),!u){const n=new o.E,i=n.addGeometry(t),m=n.addGeometry(e);h.setEditShapeCrackAndCluster_(n,new a.C(s,0),r),h.m_clusterIndexB=h.m_topoGraph.createUserIndexForClusters(),Jt(m,h.m_topoGraph,h.m_clusterIndexB),h.computeMatrixTopoGraphHalfEdges_(i,m),h.m_topoGraph.deleteUserIndexForClusters(h.m_clusterIndexB),h.m_topoGraph.removeShape()}return Kt(h.m_matrix,h.m_scl)}function Ot(t,e,s,n,r){const h=new $t;h.resetMatrix_(),h.setPredicates_(n),h.setAreaPointPredicates_();const m=i.Envelope2D.constructEmpty(),l=i.Envelope2D.constructEmpty();t.queryEnvelope(m),e.queryEnvelope(l);let u=!1;if(he(m,l,s)&&(h.areaPointDisjointPredicates_(t),u=!0),u||me(t,e),!u){const n=new o.E,i=n.addGeometry(t),m=n.addGeometry(e);h.setEditShapeCrackAndCluster_(n,new a.C(s,0),r),h.computeMatrixTopoGraphClusters_(i,m),h.m_topoGraph.removeShape()}return Kt(h.m_matrix,h.m_scl)}function Wt(t,e,s,n,r){const h=new $t;h.resetMatrix_(),h.setPredicates_(n),h.setLinePointPredicates_();const m=i.Envelope2D.constructEmpty(),l=i.Envelope2D.constructEmpty();t.queryEnvelope(m),e.queryEnvelope(l);let u=!1;if(he(m,l,s)&&(h.linePointDisjointPredicates_(t),u=!0),u||me(t,e),!u){const n=new o.E,i=n.addGeometry(t),m=n.addGeometry(e);h.setEditShapeCrackAndCluster_(n,new a.C(s,0),r),h.m_clusterIndexA=h.m_topoGraph.createUserIndexForClusters(),Jt(i,h.m_topoGraph,h.m_clusterIndexA),h.computeMatrixTopoGraphClusters_(i,m),h.m_topoGraph.deleteUserIndexForClusters(h.m_clusterIndexA),h.m_topoGraph.removeShape()}return Kt(h.m_matrix,h.m_scl)}function jt(t,e,s,n,r){const o=new $t;o.resetMatrix_(),o.setPredicates_(n),o.setAreaPointPredicates_();const a=i.Envelope2D.constructEmpty();t.queryEnvelope(a);const h=e.getXY();let m=!1;if(le(h,a,s)&&(o.areaPointDisjointPredicates_(t),m=!0),!m){const e=as(t,h,s);if(1===e)o.m_matrix[0]=0,o.m_matrix[2]=2,o.m_matrix[3]=-1,o.m_matrix[5]=1,o.m_matrix[6]=-1;else if(2===e)if(o.m_matrix[6]=-1,0!==t.calculateArea2D())o.m_matrix[0]=-1,o.m_matrix[3]=0,o.m_matrix[2]=2,o.m_matrix[5]=1;else{o.m_matrix[0]=0,o.m_matrix[3]=-1,o.m_matrix[5]=-1;const e=i.Envelope2D.constructEmpty();t.queryEnvelope(e),o.m_matrix[2]=e.height()||e.width()?1:-1}else o.areaPointDisjointPredicates_(t)}return Kt(o.m_matrix,n)}function Zt(t,e,s,n,r){const a=new $t;a.resetMatrix_(),a.setPredicates_(n),a.setLinePointPredicates_();const h=i.Envelope2D.constructEmpty();t.queryEnvelope(h);let m=!1;if(le(e.getXY(),h,s)&&(a.linePointDisjointPredicates_(t),m=!0),!m){let n=null,i=!1,h=!1;if((a.m_performPredicates[0]||a.m_performPredicates[6])&&(oe(t,e,s,4,r)?(a.m_matrix[0]=-1,a.m_matrix[6]=0):(a.m_performPredicates[0]&&(n=(0,o.c)(t),h=!oe(n,e,s,4,r),i=!0,a.m_matrix[0]=h?-1:0),a.m_matrix[6]=-1)),a.m_performPredicates[3]&&(null!==n&&n.isEmpty()?a.m_matrix[3]=-1:(i||(null==n&&(n=(0,o.c)(t)),h=!oe(n,e,s,4,r),i=!0),a.m_matrix[3]=h?0:-1)),a.m_performPredicates[5])if(null!==n&&n.isEmpty())a.m_matrix[5]=-1;else if(i&&!h)a.m_matrix[5]=0;else{null===n&&(n=(0,o.c)(t));const i=oe(n,e,s,3,r);a.m_matrix[5]=i?-1:0}if(a.m_performPredicates[2])if(0!==t.calculateLength2D())a.m_matrix[2]=1;else{const n=new o.M({vd:t.getDescription()});n.addPoints(t,0,t.getPointCount());const i=oe(n,e,s,3,r);a.m_matrix[2]=i?-1:0}}return Kt(a.m_matrix,a.m_scl)}function Qt(t,e,s,n,r){const o=new $t;o.resetMatrix_(),o.setPredicates_(n),o.setPointPointPredicates_();const a=i.Envelope2D.constructEmpty();t.queryEnvelope(a);const m=e.getXY(),l=new h.P;let u=!1;if(le(m,a,s)&&(o.pointPointDisjointPredicates_(),u=!0),!u){let e=!1,n=!0;const i=s*s;for(let s=0;s<t.getPointCount()&&(t.queryXY(s,l),h.P.sqrDistance(l,m)<=i?e=!0:n=!1,!e||n);s++);e?(o.m_matrix[0]=0,o.m_matrix[2]=n?-1:0,o.m_matrix[6]=-1):(o.m_matrix[0]=-1,o.m_matrix[2]=0,o.m_matrix[6]=0)}return Kt(o.m_matrix,n)}function Kt(t,e){for(let s=0;s<9;s++)switch(e[s]){case"T":if(-1===t[s])return!1;break;case"F":if(-1!==t[s])return!1;break;case"0":if(0!==t[s])return!1;break;case"1":if(1!==t[s])return!1;break;case"2":if(2!==t[s])return!1}return!0}function Jt(t,e,s){const n=e.getGeometryID(t);for(let i=e.getFirstCluster();i!==o.n;i=e.getNextCluster(i)){if(!(e.getClusterParentage(i)&n))continue;const t=e.getClusterHalfEdge(i);if(t===o.n){e.setClusterUserIndex(i,s,0);continue}let r=t,a=0;do{const t=r;e.getHalfEdgeParentage(t)&n&&a++,r=e.getHalfEdgeNext(e.getHalfEdgeTwin(t))}while(r!==t);e.setClusterUserIndex(i,s,a)}}class $t{nullFunc(){return(0,r.c)("should not be called"),!1}constructor(){this.m_clusterIndexA=-1,this.m_clusterIndexB=-1,this.m_visitedIndex=-1,this.m_topoGraph=new st,this.m_matrix=(0,h.d)(9,0),this.m_maxDim=(0,h.d)(9,0),this.m_performPredicates=(0,h.d)(9,!1),this.m_scl="",this.m_predicateCount=0,this.m_predicatesHalfEdge=this.nullFunc,this.m_predicatesCluster=this.nullFunc}resetMatrix_(){this.m_matrix.fill(-2),this.m_maxDim.fill(-2)}setPredicates_(t){this.m_scl=t;for(let e=0;e<9;e++)"*"!==this.m_scl[e]?(this.m_performPredicates[e]=!0,this.m_predicateCount++):this.m_performPredicates[e]=!1}setRemainingPredicatesToFalse_(){for(let t=0;t<9;t++)this.m_performPredicates[t]&&-2===this.m_matrix[t]&&(this.m_matrix[t]=-1,this.m_performPredicates[t]=!1)}isPredicateKnown_(t){return-2!==this.m_matrix[t]&&(-1===this.m_matrix[t]?(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0):"T"!==this.m_scl[t]&&"F"!==this.m_scl[t]?!(this.m_matrix[t]<this.m_maxDim[t])&&(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0):(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0))}setAreaAreaPredicates_(){this.m_predicatesHalfEdge=this.areaAreaPredicates_,this.m_maxDim[0]=2,this.m_maxDim[1]=1,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=1,this.m_maxDim[5]=1,this.m_maxDim[6]=2,this.m_maxDim[7]=1,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaLinePredicates_(){this.m_predicatesHalfEdge=this.areaLinePredicates_,this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=0,this.m_maxDim[5]=1,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLineLinePredicates_(){this.m_predicatesHalfEdge=this.lineLinePredicates_,this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=0,this.m_maxDim[5]=0,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaPointPredicates_(){this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=2,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLinePointPredicates_(){this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=0,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setPointPointPredicates_(){this.m_predicatesCluster=this.pointPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=0,this.m_maxDim[3]=-1,this.m_maxDim[4]=-1,this.m_maxDim[5]=-1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[3]&&(this.m_matrix[3]=-1,this.m_performPredicates[3]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[5]&&(this.m_matrix[5]=-1,this.m_performPredicates[5]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}areaAreaDisjointPredicates_(t,e){this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5]),this.areaGeomContainsOrDisjointPredicates_(e,this.m_performPredicates[6]?6:-1,this.m_scl[6],this.m_performPredicates[7]?7:-1,this.m_scl[7])}areaGeomContainsOrDisjointPredicates_(t,e,s,n,r){const o=-1!==e,a=-1!==n;if(o||a)if(("T"!==s&&"F"!==s&&o||"T"!==r&&"F"!==r&&a)&&0===t.calculateArea2D()){if(a&&(this.m_matrix[n]=-1),o){const s=i.Envelope2D.constructEmpty();t.queryEnvelope(s),this.m_matrix[e]=s.height()||s.width()?1:0}}else o&&(this.m_matrix[e]=2),a&&(this.m_matrix[n]=1)}areaAreaContainsPredicates_(t){this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1,this.m_matrix[7]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[0]?0:-1,this.m_scl[0],this.m_performPredicates[1]?1:-1,this.m_scl[1])}areaAreaWithinPredicates_(t){this.areaAreaContainsPredicates_(t),te(this.m_matrix)}areaLineDisjointPredicates_(t,e){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[6]){const t=this.m_scl[6],s="T"===t||"F"===t||0!==e.calculateLength2D();this.m_matrix[6]=s?1:0}if(this.m_performPredicates[7]){const t=(0,o.J)(e);this.m_matrix[7]=t?0:-1}this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaLineContainsPredicates_(t,e){if(this.m_performPredicates[0]){const t=this.m_scl[0],s="T"===t||"F"===t||0!==e.calculateLength2D();this.m_matrix[0]=s?1:0}if(this.m_performPredicates[1]){const t=(0,o.J)(e);this.m_matrix[1]=t?0:-1}this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1,this.m_matrix[7]=-1}areaPointDisjointPredicates_(t){this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_matrix[6]=0,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaPointContainsPredicates_(t){this.m_matrix[0]=0,this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1}lineLineDisjointPredicates_(t,e){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[2]){const e=this.m_scl[2],s="T"===e||"F"===e||0!==t.calculateLength2D();this.m_matrix[2]=s?1:0}if(this.m_performPredicates[5]){const e=(0,o.J)(t);this.m_matrix[5]=e?0:-1}if(this.m_performPredicates[6]){const t=this.m_scl[6],s="T"===t||"F"===t||0!==e.calculateLength2D();this.m_matrix[6]=s?1:0}if(this.m_performPredicates[7]){const t=(0,o.J)(e);this.m_matrix[7]=t?0:-1}}linePointDisjointPredicates_(t){if(this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_performPredicates[2]){const e=this.m_scl[2],s="T"===e||"F"===e||0!==t.calculateLength2D();this.m_matrix[2]=s?1:0}if(this.m_performPredicates[5]){const e=(0,o.J)(t);this.m_matrix[5]=e?0:-1}this.m_matrix[6]=0}pointPointDisjointPredicates_(){this.m_matrix[0]=-1,this.m_matrix[2]=0,this.m_matrix[6]=0}areaAreaPredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorArea_(t,e,s);const i=this.isPredicateKnown_(0);n&&(n=i)}if(this.m_performPredicates[1]){this.interiorAreaBoundaryArea_(t,e,1);const s=this.isPredicateKnown_(1);n&&(n=s)}if(this.m_performPredicates[2]){this.interiorAreaExteriorArea_(t,e,s,2);const i=this.isPredicateKnown_(2);n&&(n=i)}if(this.m_performPredicates[3]){this.interiorAreaBoundaryArea_(t,s,3);const e=this.isPredicateKnown_(3);n&&(n=e)}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryArea_(t,e,s);const i=this.isPredicateKnown_(4);n&&(n=i)}if(this.m_performPredicates[5]){this.boundaryAreaExteriorArea_(t,e,s,5);const i=this.isPredicateKnown_(5);n&&(n=i)}if(this.m_performPredicates[6]){this.interiorAreaExteriorArea_(t,s,e,6);const i=this.isPredicateKnown_(6);n&&(n=i)}if(this.m_performPredicates[7]){this.boundaryAreaExteriorArea_(t,s,e,7);const i=this.isPredicateKnown_(7);n&&(n=i)}return n}areaLinePredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorLine_(t,e,s);const i=this.isPredicateKnown_(0);n&&(n=i)}if(this.m_performPredicates[1]){this.interiorAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const i=this.isPredicateKnown_(1);n&&(n=i)}if(this.m_performPredicates[2]){this.interiorAreaExteriorLine_(t,e,s);const i=this.isPredicateKnown_(2);n&&(n=i)}if(this.m_performPredicates[3]){this.boundaryAreaInteriorLine_(t,e,s,this.m_clusterIndexB);const i=this.isPredicateKnown_(3);n&&(n=i)}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const i=this.isPredicateKnown_(4);n&&(n=i)}if(this.m_performPredicates[5]){this.boundaryAreaExteriorLine_(t,e,s);const i=this.isPredicateKnown_(5);n&&(n=i)}if(this.m_performPredicates[6]){this.exteriorAreaInteriorLine_(t,e);const s=this.isPredicateKnown_(6);n&&(n=s)}if(this.m_performPredicates[7]){this.exteriorAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const i=this.isPredicateKnown_(7);n&&(n=i)}return n}lineLinePredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB);const i=this.isPredicateKnown_(0);n&&(n=i)}if(this.m_performPredicates[1]){this.interiorLineBoundaryLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB,1);const i=this.isPredicateKnown_(1);n&&(n=i)}if(this.m_performPredicates[2]){this.interiorLineExteriorLine_(t,e,s,2);const i=this.isPredicateKnown_(2);n&&(n=i)}if(this.m_performPredicates[3]){this.interiorLineBoundaryLine_(t,s,e,this.m_clusterIndexB,this.m_clusterIndexA,3);const i=this.isPredicateKnown_(3);n&&(n=i)}if(this.m_performPredicates[4]){this.boundaryLineBoundaryLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB);const i=this.isPredicateKnown_(4);n&&(n=i)}if(this.m_performPredicates[5]){this.boundaryLineExteriorLine_(t,e,s,this.m_clusterIndexA,5);const i=this.isPredicateKnown_(5);n&&(n=i)}if(this.m_performPredicates[6]){this.interiorLineExteriorLine_(t,s,e,6);const i=this.isPredicateKnown_(6);n&&(n=i)}if(this.m_performPredicates[7]){this.boundaryLineExteriorLine_(t,s,e,this.m_clusterIndexB,7);const i=this.isPredicateKnown_(7);n&&(n=i)}return n}areaPointPredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorPoint_(t,e);const s=this.isPredicateKnown_(0);n&&(n=s)}if(this.m_performPredicates[2]){this.interiorAreaExteriorPoint_(t,e);const s=this.isPredicateKnown_(2);n&&(n=s)}if(this.m_performPredicates[3]){this.boundaryAreaInteriorPoint_(t,e,s);const i=this.isPredicateKnown_(3);n&&(n=i)}if(this.m_performPredicates[5]){this.boundaryAreaExteriorPoint_(t,e);const s=this.isPredicateKnown_(5);n&&(n=s)}if(this.m_performPredicates[6]){this.exteriorAreaInteriorPoint_(t,e);const s=this.isPredicateKnown_(6);n&&(n=s)}return n}linePointPredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorPoint_(t,e,s,this.m_clusterIndexA);const i=this.isPredicateKnown_(0);n&&(n=i)}if(this.m_performPredicates[2]){this.interiorLineExteriorPoint_(t,e,s,this.m_clusterIndexA);const i=this.isPredicateKnown_(2);n&&(n=i)}if(this.m_performPredicates[3]){this.boundaryLineInteriorPoint_(t,e,s,this.m_clusterIndexA);const i=this.isPredicateKnown_(3);n&&(n=i)}if(this.m_performPredicates[5]){this.boundaryLineExteriorPoint_(t,e,s,this.m_clusterIndexA);const i=this.isPredicateKnown_(5);n&&(n=i)}if(this.m_performPredicates[6]){this.exteriorLineInteriorPoint_(t,e,s);const i=this.isPredicateKnown_(6);n&&(n=i)}return n}pointPointPredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorPointInteriorPoint_(t,e,s);const i=this.isPredicateKnown_(0);n&&(n=i)}if(this.m_performPredicates[2]){this.interiorPointExteriorPoint_(t,e,s,2);const i=this.isPredicateKnown_(2);n&&(n=i)}if(this.m_performPredicates[6]){this.interiorPointExteriorPoint_(t,s,e,6);const i=this.isPredicateKnown_(6);n&&(n=i)}return n}interiorAreaInteriorArea_(t,e,s){if(2===this.m_matrix[0])return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t);n&e&&n&s&&(this.m_matrix[0]=2)}interiorAreaBoundaryArea_(t,e,s){if(1===this.m_matrix[s])return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t),i=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));n&e&&i&e&&(this.m_matrix[s]=1)}interiorAreaExteriorArea_(t,e,s,n){if(2===this.m_matrix[n])return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t);i&e&&!(i&s)&&(this.m_matrix[n]=2)}boundaryAreaBoundaryArea_(t,e,s){if(1===this.m_matrix[4])return;const n=this.m_topoGraph.getHalfEdgeParentage(t);if(n&e&&n&s)this.m_matrix[4]=1;else if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const n=this.m_topoGraph.getHalfEdgeTo(t),i=this.m_topoGraph.getClusterParentage(n);if(i&e&&i&s)return void(this.m_matrix[4]=0)}}boundaryAreaExteriorArea_(t,e,s,n){if(1===this.m_matrix[n])return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t),r=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));i&s||r&s||(this.m_matrix[n]=1)}interiorAreaInteriorLine_(t,e,s){if(1===this.m_matrix[0])return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t),i=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));n&e&&i&e&&(this.m_matrix[0]=1)}interiorAreaBoundaryLine_(t,e,s,n){if(0!==this.m_matrix[1]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(i);if(!(r&e)&&this.m_topoGraph.getHalfEdgeFaceParentage(t)&e){const t=this.m_topoGraph.getClusterUserIndex(i,n);if(r&s&&t%2!=0)return void(this.m_matrix[1]=0)}}}interiorAreaExteriorLine_(t,e,s){2!==this.m_matrix[2]&&this.m_topoGraph.getHalfEdgeParentage(t)&e&&(this.m_matrix[2]=2)}boundaryAreaInteriorLine_(t,e,s,n){if(1===this.m_matrix[3])return;const i=this.m_topoGraph.getHalfEdgeParentage(t);if(i&e&&i&s)this.m_matrix[3]=1;else if(0!==this.m_matrix[3]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(i);if(r&e){const t=this.m_topoGraph.getClusterUserIndex(i,n);if(r&s&&t%2==0)return void(this.m_matrix[3]=0)}}}boundaryAreaBoundaryLine_(t,e,s,n){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(i);if(r&e){const t=this.m_topoGraph.getClusterUserIndex(i,n);if(r&s&&t%2!=0)return void(this.m_matrix[4]=0)}}}boundaryAreaExteriorLine_(t,e,s){if(1===this.m_matrix[5])return;const n=this.m_topoGraph.getHalfEdgeParentage(t);n&e&&!(n&s)&&(this.m_matrix[5]=1)}exteriorAreaInteriorLine_(t,e){if(1===this.m_matrix[6])return;const s=this.m_topoGraph.getHalfEdgeFaceParentage(t),n=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));s&e||n&e||(this.m_matrix[6]=1)}exteriorAreaBoundaryLine_(t,e,s,n){if(0!==this.m_matrix[7]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(i);if(!(r&e)&&!(this.m_topoGraph.getHalfEdgeFaceParentage(t)&e)){const t=this.m_topoGraph.getClusterUserIndex(i,n);if(r&s&&t%2!=0)return void(this.m_matrix[7]=0)}}}interiorLineInteriorLine_(t,e,s,n,i){if(1===this.m_matrix[0])return;const r=this.m_topoGraph.getHalfEdgeParentage(t);if(r&e&&r&s)this.m_matrix[0]=1;else if(0!==this.m_matrix[0]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const r=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(r);if(o&e&&o&s){const t=this.m_topoGraph.getClusterUserIndex(r,n),e=this.m_topoGraph.getClusterUserIndex(r,i);if(t%2==0&&e%2==0)return void(this.m_matrix[0]=0)}}}interiorLineBoundaryLine_(t,e,s,n,i,r){if(0!==this.m_matrix[r]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const o=this.m_topoGraph.getHalfEdgeTo(t),a=this.m_topoGraph.getClusterParentage(o);if(a&e&&a&s){const t=this.m_topoGraph.getClusterUserIndex(o,n),e=this.m_topoGraph.getClusterUserIndex(o,i);if(t%2==0&&e%2!=0)return void(this.m_matrix[r]=0)}}}interiorLineExteriorLine_(t,e,s,n){if(1===this.m_matrix[n])return;const i=this.m_topoGraph.getHalfEdgeParentage(t);i&e&&!(i&s)&&(this.m_matrix[n]=1)}boundaryLineBoundaryLine_(t,e,s,n,i){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const r=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(r);if(o&e&&o&s){const t=this.m_topoGraph.getClusterUserIndex(r,n),e=this.m_topoGraph.getClusterUserIndex(r,i);if(t%2!=0&&e%2!=0)return void(this.m_matrix[4]=0)}}}boundaryLineExteriorLine_(t,e,s,n,i){if(0!==this.m_matrix[i]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const e=this.m_topoGraph.getHalfEdgeTo(t);if(!(this.m_topoGraph.getClusterParentage(e)&s)&&this.m_topoGraph.getClusterUserIndex(e,n)%2!=0)return void(this.m_matrix[i]=0)}}interiorAreaInteriorPoint_(t,e){if(0!==this.m_matrix[0]&&!(this.m_topoGraph.getClusterParentage(t)&e)){const s=this.m_topoGraph.getClusterChain(t);if(this.m_topoGraph.getChainParentage(s)&e)return void(this.m_matrix[0]=0)}}interiorAreaExteriorPoint_(t,e){2!==this.m_matrix[2]&&this.m_topoGraph.getClusterParentage(t)&e&&(this.m_matrix[2]=2)}boundaryAreaInteriorPoint_(t,e,s){if(0===this.m_matrix[3])return;const n=this.m_topoGraph.getClusterParentage(t);n&e&&n&s&&(this.m_matrix[3]=0)}boundaryAreaExteriorPoint_(t,e){1!==this.m_matrix[5]&&this.m_topoGraph.getClusterParentage(t)&e&&(this.m_matrix[5]=1)}exteriorAreaInteriorPoint_(t,e){if(0!==this.m_matrix[6]&&!(this.m_topoGraph.getClusterParentage(t)&e)){const s=this.m_topoGraph.getClusterChain(t);if(!(this.m_topoGraph.getChainParentage(s)&e))return void(this.m_matrix[6]=0)}}interiorLineInteriorPoint_(t,e,s,n){if(0===this.m_matrix[0])return;const i=this.m_topoGraph.getClusterParentage(t);i&e&&i&s&&this.m_topoGraph.getClusterUserIndex(t,n)%2==0&&(this.m_matrix[0]=0)}interiorLineExteriorPoint_(t,e,s,n){if(1!==this.m_matrix[2])if(-1===this.m_topoGraph.getClusterHalfEdge(t)){if(0!==this.m_matrix[2]&&!(this.m_topoGraph.getClusterParentage(t)&s))return void(this.m_matrix[2]=0)}else this.m_matrix[2]=1}boundaryLineInteriorPoint_(t,e,s,n){if(0===this.m_matrix[3])return;const i=this.m_topoGraph.getClusterParentage(t);i&e&&i&s&&this.m_topoGraph.getClusterUserIndex(t,n)%2!=0&&(this.m_matrix[3]=0)}boundaryLineExteriorPoint_(t,e,s,n){if(0===this.m_matrix[5])return;const i=this.m_topoGraph.getClusterParentage(t);!(i&e)||i&s||this.m_topoGraph.getClusterUserIndex(t,n)%2==0||(this.m_matrix[5]=0)}exteriorLineInteriorPoint_(t,e,s){if(0===this.m_matrix[6])return;const n=this.m_topoGraph.getClusterParentage(t);n&e||!(n&s)||(this.m_matrix[6]=0)}interiorPointInteriorPoint_(t,e,s){if(0===this.m_matrix[0])return;const n=this.m_topoGraph.getClusterParentage(t);n&e&&n&s&&(this.m_matrix[0]=0)}interiorPointExteriorPoint_(t,e,s,n){if(0===this.m_matrix[n])return;const i=this.m_topoGraph.getClusterParentage(t);!(i&e)||i&s||(this.m_matrix[n]=0)}computeMatrixTopoGraphHalfEdges_(t,e){let s=!1;const n=this.m_topoGraph.getGeometryID(t),i=this.m_topoGraph.getGeometryID(e);this.m_visitedIndex=this.m_topoGraph.createUserIndexForHalfEdges();for(let r=this.m_topoGraph.getFirstCluster();r!==o.n;r=this.m_topoGraph.getNextCluster(r)){const t=this.m_topoGraph.getClusterHalfEdge(r);if(t===o.n){if(null!==this.m_predicatesCluster&&(s=this.m_predicatesCluster(r,n,i),s))break;continue}let e=t;do{let t=e;if(1!==this.m_topoGraph.getHalfEdgeUserIndex(t,this.m_visitedIndex))do{if(s=this.m_predicatesHalfEdge(t,n,i),s)break;this.m_topoGraph.setHalfEdgeUserIndex(t,this.m_visitedIndex,1),t=this.m_topoGraph.getHalfEdgeNext(t)}while(t!==e&&!s);if(s)break;e=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t))}while(e!==t);if(s)break}s||this.setRemainingPredicatesToFalse_(),this.m_topoGraph.deleteUserIndexForHalfEdges(this.m_visitedIndex)}computeMatrixTopoGraphClusters_(t,e){let s=!1;const n=this.m_topoGraph.getGeometryID(t),i=this.m_topoGraph.getGeometryID(e);for(let r=this.m_topoGraph.getFirstCluster();r!==o.n&&(s=this.m_predicatesCluster(r,n,i),!s);r=this.m_topoGraph.getNextCluster(r));s||this.setRemainingPredicatesToFalse_()}setEditShape_(t,e){this.m_topoGraph.setEditShape(t,e)}setEditShapeCrackAndCluster_(t,e,s){let n=0;if(t.hasCurves()){const i=new ys,r=t.getEnvelope2D(s),o=fs(e.total(),r);n=xs(o,0),ds(t,o,e.total(),12e3,i,null,s),i.clearStitcher(t)}Cs(t,e.add(n),s,!1,!1),t.filterClosePoints(0,!0,!0,!1,o.n);for(let i=t.getFirstGeometry();i!==o.n;i=t.getNextGeometry(i))t.getGeometryType(i)===r.G.enumPolygon&&Ht(t,i,-1,!1,o.n,s);this.setEditShape_(t,s)}}function te(t){const e=t[1],s=t[2],n=t[5];t[1]=t[3],t[2]=t[6],t[5]=t[7],t[3]=e,t[6]=s,t[7]=n}function ee(t,e,s){const n=t.getGeometryType();if((0,r.f)(n)){const e=new o.P({vd:t.getDescription()});return e.addSegment(t,!0),e}if(n===r.G.enumEnvelope){const s=t,n=i.Envelope2D.constructEmpty();if(t.queryEnvelope(n),n.height()<=e&&n.width()<=e){const e=new a.P({vd:t.getDescription()});return s.getCenter(e),e}if(n.height()<=e||n.width()<=e){const e=new o.P({vd:t.getDescription()}),n=new a.P;return s.queryCornerByVal(0,n),e.startPathPoint(n),s.queryCornerByVal(2,n),e.lineToPoint(n),e}const r=new o.a({vd:t.getDescription()});return r.addEnvelope(s,!1),r}return t}function se(t){return"".concat(t[0]).concat(t[3]).concat(t[6]).concat(t[1]).concat(t[4]).concat(t[7]).concat(t[2]).concat(t[5]).concat(t[8])}class ne{nullFunc(){return(0,r.c)("should not be called"),!1}constructor(t,e,s){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.m_bDone=!1,this.m_tolerance=0,this.m_elementHandle=-1,this.m_query=i.Envelope2D.constructEmpty(),this.m_envInter=i.Envelope2D.constructEmpty(),this.m_quadTree=null,this.m_intersector=null,this.m_function=this.nullFunc;const o=t.getAccelerators();let h=null;null!=o&&(h=n?o.getQuadTreeForPaths():o.getQuadTree());const m=e.getAccelerators();let l=null;if(null!=m&&(l=n?m.getQuadTreeForPaths():m.getQuadTree()),null===h&&null===l&&!n){const n=t.getPointCount(),o=e.getPointCount();if(n>10&&o>10){const m=i.Envelope2D.constructEmpty(),u=i.Envelope2D.constructEmpty(),c=i.Envelope2D.constructEmpty();t.queryLooseEnvelope(m),e.queryLooseEnvelope(u),m.inflateCoords(s,s),u.inflateCoords(s,s),c.setCoords({env2D:m}),c.intersect(u),n>=o?h=(0,r.h)(t.getGeometryType())?(0,a.G)(t,c):(0,a.Y)(t,c):l=(0,r.h)(e.getGeometryType())?(0,a.G)(e,c):(0,a.Y)(e,c)}}this.construct_(t,h,e,l,s,n)}next(){if(this.m_bQuadTree){if(this.m_bDone)return!1;for(;this.m_function(););return!this.m_bDone}return!!this.m_intersector&&this.m_intersector.next()}getRedElement(){return this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElement(this.m_elementHandle):(0,r.h)(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_bSwapElements?this.m_intersector.getBlueElement(this.m_intersector.getHandleB()):this.m_intersector.getRedElement(this.m_intersector.getHandleA())}getBlueElement(){return this.m_bQuadTree?this.m_bSwapElements?(0,r.h)(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_quadTree.getElement(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedElement(this.m_intersector.getHandleA()):this.m_intersector.getBlueElement(this.m_intersector.getHandleB())}getRedEnvelope(){return this.m_bPaths||(0,r.m)(""),this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_query:this.m_bSwapElements?this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB()):this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA())}getBlueEnvelope(){return this.m_bPaths||(0,r.m)(""),this.m_bQuadTree?this.m_bSwapElements?this.m_query:this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA()):this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB())}construct_(t,e,s,n,o,h){const m=i.Envelope2D.constructEmpty(),l=i.Envelope2D.constructEmpty();t.queryLooseEnvelope(m),s.queryLooseEnvelope(l),m.inflateCoords(o,o),l.inflateCoords(o,o),this.m_envInter.setCoords({env2D:m}),this.m_envInter.intersect(l),this.m_multiVertexImplA=t,this.m_multiVertexImplB=s;const u=t.getGeometryType(),c=s.getGeometryType();this.m_bPaths=h,this.m_pathIndex=-1,this.m_pointIndex=-1,this.m_bSwapElements=!1,this.m_queryType=r.G.enumUnknown,this.m_bQuadTree=!1,null!==e&&(this.m_bDone=!1,this.m_tolerance=o,this.m_quadTree=e,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!0,(0,r.h)(c)?(this.m_queryType=c,this.m_function=this.nextPath_,h?this.m_pathIndex=s.getPathCount():this.m_segIter=s.querySegmentIterator()):(this.m_queryType=c,this.m_function=this.nextPoint_,this.m_pointIndex=s.getPointCount())),this.m_bQuadTree||null!==n&&(this.m_bDone=!1,this.m_tolerance=o,this.m_quadTree=n,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!1,(0,r.h)(u)?(this.m_queryType=u,this.m_function=this.nextPath_,h?this.m_pathIndex=t.getPathCount():this.m_segIter=t.querySegmentIterator()):(this.m_queryType=u,this.m_function=this.nextPoint_,this.m_pointIndex=t.getPointCount())),this.m_bQuadTree||(h&&(0,r.h)(u)&&(0,r.h)(c)?this.m_intersector=(0,a.a0)(t,s,o):(0,r.h)(u)&&(0,r.h)(c)?(this.m_intersector=(0,a.Z)(t,s,o),this.m_bSwapElements=!1):(0,r.h)(u)&&!(0,r.h)(c)?(this.m_intersector=(0,a._)(t,s,o),this.m_bSwapElements=!1):!(0,r.h)(u)&&(0,r.h)(c)?(this.m_intersector=(0,a._)(s,t,o),this.m_bSwapElements=!0):(this.m_intersector=(0,a.$)(t,s,o),this.m_bSwapElements=!1))}nextPath_(){return this.m_bPaths?-1==--this.m_pathIndex?(this.m_bDone=!0,!1):(this.m_bSwapElements?this.m_multiVertexImplB.queryPathEnvelope(this.m_pathIndex,this.m_query):this.m_multiVertexImplA.queryPathEnvelope(this.m_pathIndex,this.m_query),this.m_qtIter.resetIterator(this.m_query,this.m_tolerance),this.m_function=this.iterate_,!0):this.m_segIter.nextPath()?(this.m_function=this.nextSegment_,!0):(this.m_bDone=!0,!1)}nextSegment_(){if(!this.m_segIter.hasNextSegment())return this.m_function=this.nextPath_,!0;const t=this.m_segIter.nextSegment(),e=new i.Envelope2D;return t.queryLooseEnvelope(e),!e.isIntersecting(this.m_envInter)||(this.m_qtIter.resetIterator(t,this.m_tolerance),this.m_function=this.iterate_,!0)}nextPoint_(){if(-1==--this.m_pointIndex)return this.m_bDone=!0,!1;const t=new h.P;if(this.m_bSwapElements){const e=this.m_multiVertexImplB.getXY(this.m_pointIndex);t.setCoordsPoint2D(e)}else{const e=this.m_multiVertexImplA.getXY(this.m_pointIndex);t.setCoordsPoint2D(e)}return!this.m_envInter.contains(t)||(this.m_qtIter.resetIterator(i.Envelope2D.construct(t.x,t.y,t.x,t.y),this.m_tolerance),this.m_function=this.iterate_,!0)}iterate_(){return this.m_elementHandle=this.m_qtIter.next(),-1===this.m_elementHandle&&((0,r.h)(this.m_queryType)?(this.m_function=this.m_bPaths?this.nextPath_:this.nextSegment_,!0):(this.m_function=this.nextPoint_,!0))}}function ie(t){return 2===t?1:1===t?2:128===t?64:64===t?128:t}function re(t,e,s){let n;if(t instanceof So||null===t){const r=i.Envelope2D.constructEmpty();r.setCoords({env2D:e}),r.mergeEnvelope2D(s),n=(0,a.c)(t,r,!1)}else n=t;return n}function oe(t,e,s,n,m){if(t.isEmpty()||e.isEmpty())return 4===n;(0,r.d)(t),(0,r.d)(e);let l=t.getGeometryType(),c=e.getGeometryType();if(l===r.G.enumEnvelope){if(c===r.G.enumEnvelope)return function(t,e,s,n){if(t.isEmpty()||e.isEmpty())return 4===n;const r=i.Envelope2D.constructEmpty();t.queryEnvelope(r);const o=i.Envelope2D.constructEmpty();e.queryEnvelope(o);const a=re(s,r,o);switch(n){case 4:return he(r,o,a);case 2:return Ye(o,r,a,!1);case 128:return Ye(o,r,a,!0);case 1:return Ye(r,o,a,!1);case 64:return Ye(r,o,a,!0);case 3:return Ve(r,o,a);case 8:return function(t,e,s){if(t.height()<=s||t.width()<=s||e.height()<=s||e.width()<=s)return!1;const n=new i.Envelope2D;return n.setCoords({env2D:t}),n.inflateCoords(-s,-s),n.intersect(e),!(!n.isEmpty()&&n.height()>s&&n.width()>s)&&(n.setCoords({env2D:t}),n.inflateCoords(s,s),n.intersect(e),!n.isEmpty())}(r,o,a);case 32:return function(t,e,s){if(t.height()<=s||t.width()<=s||e.height()<=s||e.width()<=s)return!1;if(Re(t,e,s))return!1;if(Re(e,t,s))return!1;const n=new i.Envelope2D;return n.setCoords({env2D:t}),n.inflateCoords(-s,-s),n.intersect(e),!n.isEmpty()&&(n.height()>s||n.width()>s)}(r,o,a);case 16:return!1}return!1}(t,e,s,n);if(c===r.G.enumPoint)return ae(e,t,s,ie(n))}else if(l===r.G.enumPoint){if(c===r.G.enumEnvelope)return ae(t,e,s,n);if(c===r.G.enumPoint)return function(t,e,s,n){if(t.isEmpty()||e.isEmpty())return 4===n;const r=t.getXY(),o=e.getXY();let m;if(s instanceof So||null===s){const t=i.Envelope2D.constructEmpty();t.setCoords({pt:r}),t.merge(o),m=(0,a.c)(s,t,!1)}else m=s;switch(n){case 4:return function(t,e,s){return h.P.sqrDistance(t,e)>s*s}(r,o,m);case 2:case 128:return qe(o,r,m);case 1:case 64:return qe(r,o,m);case 3:return Fe(r,o,m)}return!1}(t,e,s,n)}const g=i.Envelope2D.constructEmpty();t.queryEnvelope(g);const d=i.Envelope2D.constructEmpty();e.queryEnvelope(d);const _=re(s,g,d);if(he(g,d,_))return 4===n;let p=!1,f=null,P=null,x=null,y=null;switch((0,r.f)(l)?(f=new o.P({vd:t.getDescription()}),f.addSegment(t,!0),x=f,l=r.G.enumPolyline):x=t,(0,r.f)(c)?(P=new o.P({vd:e.getDescription()}),P.addSegment(e,!0),y=P,c=r.G.enumPolyline):y=e,l!==r.G.enumEnvelope&&c!==r.G.enumEnvelope?(x.getDimension()<y.getDimension()||l===r.G.enumPoint&&c===r.G.enumMultiPoint)&&(n=ie(n)):l!==r.G.enumPolygon&&c!==r.G.enumEnvelope&&(n=ie(n)),l){case r.G.enumPolygon:switch(c){case r.G.enumPolygon:p=function(t,e,s,n,i){switch(n){case 4:return function(t,e,s){return me(t,e,s,!0),1===Xe(t,e,s,!0)}(t,e,s);case 2:return Ee(e,t,s,i);case 128:return Ce(e,t,s);case 1:return Ee(t,e,s,i);case 64:return Ce(t,e,s);case 3:return ye(t,e,s,i);case 8:return function(t,e,s){return me(t,e),Je(t,e,s,null)}(t,e,s);case 32:return function(t,e,s,n){return me(t,e),$e(t,e,s,n)}(t,e,s,i)}return!1}(x,y,_,n,m);break;case r.G.enumPolyline:p=ue(x,y,_,n,m);break;case r.G.enumPoint:p=ce(x,y,_,n);break;case r.G.enumMultiPoint:p=ge(x,y,_,n);break;case r.G.enumEnvelope:p=de(x,y,_,n,m)}break;case r.G.enumPolyline:switch(c){case r.G.enumPolygon:p=ue(y,x,_,n,m);break;case r.G.enumPolyline:p=function(t,e,s,n,r){switch(n){case 4:return function(t,e,s){me(t,e);const n=t.getImpl(),i=e.getImpl();return!new ne(n,i,s,!0).next()||!We(t,e,s)}(t,e,s);case 2:return we(e,t,s,r);case 128:return De(e,t,s,r);case 1:return we(t,e,s,r);case 64:return De(t,e,s,r);case 3:return function(t,e,s,n){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();if(t.queryEnvelope(r),e.queryEnvelope(o),!Ve(r,o,s))return!1;if(me(t,e),Be(t,e,s))return!0;if(t.hasNonLinearSegments()||e.hasNonLinearSegments())return Bt(t,e,s,"**F**FFF*",n,!1);return ze(t,e,s,!1)}(t,e,s,r);case 8:return function(t,e,s,n){me(t,e);const r=[],a=je(t,e,s,r);if(-2===a){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty(),a=i.Envelope2D.constructEmpty();let h,m;if(t.queryEnvelope(r),e.queryEnvelope(o),r.inflateCoords(1e3*s,1e3*s),o.inflateCoords(1e3*s,1e3*s),a.setCoords({env2D:r}),a.intersect(o),t.getPointCount()>10){if(h=(0,u.c)(t,a,s,0,n),h.isEmpty())return!1}else h=t;if(e.getPointCount()>10){if(m=(0,u.c)(e,a,s,0,n),m.isEmpty())return!1}else m=e;return Bt(h,m,s,"F********",n,!1)}if(0!==a)return!1;const h=new o.M;for(let i=0;i<r.length;i+=2){const t=r[i],e=r[i+1];h.addXY(t,e)}const m=t.getBoundary(),l=e.getBoundary();return m.addPoints(l,0,l.getPointCount()),!m.isEmpty()&&Ne(m,h,s)}(t,e,s,r);case 32:return function(t,e,s,n){me(t,e);const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();t.queryEnvelope(r),e.queryEnvelope(o);const a=Le(r,o,s),h=Le(o,r,s),m=t.hasNonLinearSegments(),l=e.hasNonLinearSegments(),c=je(t,e,s,null);if(-1===c)return!1;if(1===c){if(a&&h)return!0;if(!m&&!l)return a&&!h?!Oe(e,t,s,!1):h&&!a?!Oe(t,e,s,!1):!Oe(t,e,s,!1)&&!Oe(e,t,s,!1)}const g=i.Envelope2D.constructEmpty(),d=i.Envelope2D.constructEmpty(),_=i.Envelope2D.constructEmpty();let p,f;g.setCoords({env2D:r}),g.inflateCoords(1e3*s,1e3*s),d.setCoords({env2D:o}),d.inflateCoords(1e3*s,1e3*s),_.setCoords({env2D:g}),_.intersect(d);let P="";if(P+="1*",a){if(e.getPointCount()>10){if(f=(0,u.c)(e,_,s,0,n),f.isEmpty())return!1}else f=e;P+="****"}else f=e,P+="T***";if(h){if(t.getPointCount()>10){if(p=(0,u.c)(t,_,s,0,n),p.isEmpty())return!1}else p=t;P+="***"}else p=t,P+="T**";return Bt(p,f,s,P,n,!1)}(t,e,s,r);case 16:return function(t,e,s,n){me(t,e);const r=[],a=je(t,e,s,r);if(-2===a){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty(),a=i.Envelope2D.constructEmpty();let h,m;if(t.queryEnvelope(r),e.queryEnvelope(o),r.inflateCoords(1e3*s,1e3*s),o.inflateCoords(1e3*s,1e3*s),a.setCoords({env2D:r}),a.intersect(o),t.getPointCount()>10){if(h=(0,u.c)(t,a,s,0,n),h.isEmpty())return!1}else h=t;if(e.getPointCount()>10){if(m=(0,u.c)(e,a,s,0,n),m.isEmpty())return!1}else m=e;return Bt(h,m,s,"0********",n,!1)}if(0!==a)return!1;const h=new o.M;for(let i=0;i<r.length;i+=2){const t=r[i],e=r[i+1];h.addXY(t,e)}const m=t.getBoundary(),l=e.getBoundary();return m.addPoints(l,0,l.getPointCount()),!!m.isEmpty()||!Ne(m,h,s)}(t,e,s,r)}return!1}(x,y,_,n,m);break;case r.G.enumPoint:p=_e(x,y,_,n);break;case r.G.enumMultiPoint:p=pe(x,y,_,n);break;case r.G.enumEnvelope:p=fe(x,y,_,n,m)}break;case r.G.enumPoint:switch(c){case r.G.enumPolygon:p=ce(y,x,_,n);break;case r.G.enumPolyline:p=_e(y,x,_,n);break;case r.G.enumMultiPoint:p=Pe(y,x,_,n)}break;case r.G.enumMultiPoint:switch(c){case r.G.enumPolygon:p=ge(y,x,_,n);break;case r.G.enumPolyline:p=pe(y,x,_,n);break;case r.G.enumMultiPoint:p=function(t,e,s,n){switch(n){case 4:return function(t,e,s){const n=t,i=e,r=new ne(n,i,s,!1),o=s*s,a=new h.P,m=new h.P;for(;r.next();){const t=r.getRedElement(),e=r.getBlueElement();if(n.queryXY(t,a),i.queryXY(e,m),h.P.sqrDistance(a,m)<=o)return!1}return!0}(t,e,s);case 2:case 128:return Ne(e,t,s);case 1:case 64:return Ne(t,e,s);case 3:return function(t,e,s){const n=i.Envelope2D.constructEmpty(),r=i.Envelope2D.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!!Ve(n,r,s)&&(!!function(t,e,s){if(t.getPointCount()!==e.getPointCount())return!1;const n=new h.P,i=new h.P;let r=!0;const o=s*s;for(let a=0;a<t.getPointCount();a++)if(t.queryXY(a,n),e.queryXY(a,i),h.P.sqrDistance(n,i)>o){r=!1;break}return!!r}(t,e,s)||Ue(t,e,s,!1,!0,!1))}(t,e,s);case 32:return function(t,e,s){return Ue(t,e,s,!1,!1,!0)}(t,e,s)}return!1}(x,y,_,n);break;case r.G.enumPoint:p=Pe(x,y,_,n);break;case r.G.enumEnvelope:p=xe(x,y,_,n)}break;case r.G.enumEnvelope:switch(c){case r.G.enumPolygon:p=de(y,x,_,n,m);break;case r.G.enumPolyline:p=fe(y,x,_,n,m);break;case r.G.enumMultiPoint:p=xe(y,x,_,n)}}return p}function ae(t,e,s,n,r){if(t.isEmpty()||e.isEmpty())return 4===n;const o=t.getXY(),h=i.Envelope2D.constructEmpty();e.queryEnvelope(h);const m=function(t,e,s){let n;if(t instanceof So||null===t){const r=i.Envelope2D.constructEmpty();r.setCoords({pt:e}),r.mergeEnvelope2D(s),n=(0,a.c)(t,r,!1)}else n=t;return n}(s,o,h);switch(n){case 4:return le(o,h,m);case 2:case 128:return function(t,e,s){if(e.height()<=s||e.width()<=s)return!1;const n=i.Envelope2D.constructEmpty();return n.setCoords({env2D:e}),n.inflateCoords(-s,-s),n.containsExclusive(t)}(o,h,m);case 1:case 64:return!1;case 3:return function(t,e,s){const n=new i.Envelope2D;return n.setCoords({pt:t}),Ve(n,e,s)}(o,h,m);case 8:return function(t,e,s){if(e.height()<=s||e.width()<=s)return!1;const n=new i.Envelope2D,r=new i.Envelope2D;return n.setCoords({env2D:e}),n.inflateCoords(s,s),!!n.contains(t)&&(r.setCoords({env2D:e}),r.inflateCoords(-s,-s),!r.containsExclusive(t))}(o,h,m)}return!1}function he(t,e,s){const n=i.Envelope2D.constructEmpty();return n.setCoords({env2D:e}),n.inflateCoords(s,s),!t.isIntersecting(n)}function me(t,e,s){const n=t.getGeometryType(),i=e.getGeometryType();if((0,r.i)(n)){const e=t.getImpl().getAccelerators();if(null!==e){const t=e.getRasterizedGeometry();(0,r.g)(null===t)}}if((0,r.i)(i)){const t=e.getImpl().getAccelerators();if(null!==t){const e=t.getRasterizedGeometry();(0,r.g)(null===e)}}return 0}function le(t,e,s,n){const r=i.Envelope2D.constructEmpty();return r.setCoords({env2D:e}),r.inflateCoords(s,s),!r.contains(t)}function ue(t,e,s,n,r){switch(n){case 4:return function(t,e,s){return me(t,e,s,!0),1===Xe(t,e,s,!0)}(t,e,s);case 1:return function(t,e,s,n){const r=i.Envelope2D.constructEmpty(),h=i.Envelope2D.constructEmpty();return t.queryEnvelope(r),e.queryEnvelope(h),!!Re(r,h,s)&&(me(t,e),function(t,e,s,n){const r=[!1],h=ke(t,e,s,r);if(r[0])return h;const m=i.Envelope2D.constructEmpty();let l;if(e.queryEnvelope(m),m.inflateCoords(1e3*s,1e3*s),t.getPointCount()>10){if(l=(0,u.c)(t,m,s,0,n),l.isEmpty())return!1}else l=t;return function(t,e,s,n){const r=new $t;r.resetMatrix_(),r.setPredicates_("T*****F**"),r.setAreaLinePredicates_();const h=i.Envelope2D.constructEmpty(),m=i.Envelope2D.constructEmpty();t.queryEnvelope(h),e.queryEnvelope(m);let l=!1;if(he(h,m,s)&&(r.areaLineDisjointPredicates_(t,e),l=!0),l||me(t,e),l)return Kt(r.m_matrix,r.m_scl);const u=new o.E,c=u.addGeometry(t),g=u.addGeometry(e);return r.setEditShapeCrackAndCluster_(u,new a.C(s,0),n),0!==u.getPointCount(c)&&(r.computeMatrixTopoGraphHalfEdges_(c,g),r.m_topoGraph.removeShape(),Kt(r.m_matrix,r.m_scl))}(l,e,s,n)}(t,e,s,n))}(t,e,s,r);case 64:return function(t,e,s){const n=i.Envelope2D.constructEmpty(),r=i.Envelope2D.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!!Re(n,r,s)&&(me(t,e),2===Xe(t,e,s,!1))}(t,e,s);case 8:return Se(t,e,s,r);case 16:return function(t,e,s){return me(t,e),function(t,e,s,n){const r=t.getImpl(),o=e.getImpl(),a=r.querySegmentIterator(),m=o.querySegmentIterator(),l=(0,h.d)(2,Number.NaN),c=(0,h.d)(2,Number.NaN),g=new ne(r,o,s);let d=!1;for(;g.next();){const t=g.getRedElement(),e=g.getBlueElement();a.resetToVertex(t,-1),m.resetToVertex(e,-1);const n=a.nextSegment(),i=m.nextSegment();let r=0;if(ns(n,i)?!d&&i.isIntersecting(n,s)&&(d=!0):r=i.intersect(n,null,c,l,s),2===r)d=!0;else if(r){const t=l[0],e=c[0];if(t>0&&t<1&&e>0&&e<1)return!0;d=!0}}if(!d)return!1;const _=i.Envelope2D.constructEmpty(),p=i.Envelope2D.constructEmpty(),f=i.Envelope2D.constructEmpty(),P=i.Envelope2D.constructEmpty(),x=i.Envelope2D.constructEmpty();if(t.queryEnvelope(_),e.queryEnvelope(p),Le(p,_,s)){let i,r;if(f.setCoords({env2D:_}),f.inflateCoords(1e3*s,1e3*s),P.setCoords({env2D:p}),P.inflateCoords(1e3*s,1e3*s),x.setCoords({env2D:f}),x.intersect(P),t.getPointCount()>10){if(i=(0,u.c)(t,x,s,0,n),i.isEmpty())return!1}else i=t;if(e.getPointCount()>10){if(r=(0,u.c)(e,x,s,0,n),r.isEmpty())return!1}else r=e;return Bt(i,r,s,"T********",n,!1)}return Bt(t,e,s,"T*****T**",n,!1)}(t,e,s,null)}(t,e,s)}return!1}function ce(t,e,s,n,i){switch(n){case 4:return function(t,e,s){return 0===os(t,e,s)}(t,e,s);case 1:case 64:return function(t,e,s){return function(t,e,s){return 1===as(t,e,s)}(t,e.getXY(),s)}(t,e,s);case 8:return function(t,e,s){return function(t,e,s){return 2===as(t,e,s)}(t,e.getXY(),s)}(t,e,s)}return!1}function ge(t,e,s,n,r){switch(n){case 4:return function(t,e,s){return me(t,e),1===function(t,e,s){const n=i.Envelope2D.constructEmpty();t.queryEnvelope(n),n.inflateCoords(s,s);const r=new h.P,a=t.getImpl(),m=new o.a;let l=t,u=!1,c=!1,g=!1;for(let i=0;i<e.getPointCount();i++){if(e.queryXY(i,r),n.contains(r)){const t=as(l,r,s);if(1===t)return c=!0,4;if(2===t)return 4;g=!0}else g=!0;u||(!qt(t,e.getPointCount()-1)||null!==a.getAccelerators()&&null!=a.getAccelerators().getQuadTree()?l=t:(t.copyTo(m),m.getImpl().buildQuadTreeAccelerator(1),l=m),u=!0)}return c?g?4:2:1}(t,e,s)}(t,e,s);case 1:return ve(t,e,s,!1);case 64:return ve(t,e,s,!0);case 8:return function(t,e,s){me(t,e);const n=i.Envelope2D.constructEmpty();t.queryEnvelope(n),n.inflateCoords(s,s);const r=new h.P;let a=!1;const m=t.getImpl(),l=new o.a;let u=t,c=!1;for(let i=0;i<e.getPointCount();i++){if(e.queryXY(i,r),n.contains(r)){const t=as(u,r,s);if(2===t)a=!0;else if(1===t)return!1}c||(!qt(t,e.getPointCount()-1)||null!==m.getAccelerators()&&null!==m.getAccelerators().getQuadTree()?u=t:(t.copyTo(l),l.getImpl().buildQuadTreeAccelerator(1),u=l),c=!0)}return!!a}(t,e,s);case 16:return function(t,e,s){me(t,e);const n=new i.Envelope2D,r=new i.Envelope2D,a=new i.Envelope2D;t.queryEnvelope(n),e.queryEnvelope(a),r.setCoords({env2D:n}),r.inflateCoords(s,s);let m=!1,l=!1;const u=new h.P,c=t.getImpl(),g=new o.a;let d=t,_=!1;for(let i=0;i<e.getPointCount();i++){if(e.queryXY(i,u),r.contains(u)){const t=as(d,u,s);0===t?l=!0:1===t&&(m=!0)}else l=!0;if(m&&l)return!0;_||(!qt(t,e.getPointCount()-1)||null!==c.getAccelerators()&&null!==c.getAccelerators().getQuadTree()?d=t:(t.copyTo(g),g.getImpl().buildQuadTreeAccelerator(1),d=g),_=!0)}return!1}(t,e,s)}return!1}function de(t,e,s,n,r){if(function(t,e,s){me(t,e);const n=i.Envelope2D.constructEmpty(),r=i.Envelope2D.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!Re(r,n,s)&&(0===as(t,r.getLowerLeft(),0)&&!r.contains(t.getXY(0))&&!Ke(t,r,s))}(t,e,s))return 4===n;if(4===n)return!1;switch(n){case 2:return be(t,e,s,!1);case 128:return be(t,e,s,!0);case 1:return Ie(t,e,s,!1,r);case 64:return Ie(t,e,s,!0,r);case 3:return function(t,e,s,n){const r=new i.Envelope2D,a=new i.Envelope2D;if(t.queryEnvelope(r),e.queryEnvelope(a),!Ve(r,a,s))return!1;const h=new o.a;return h.addEnvelope(e,!1),ye(t,h,s,n)}(t,e,s,r);case 8:return function(t,e,s,n){me(t,e);const r=new i.Envelope2D,a=new i.Envelope2D;if(t.queryEnvelope(r),e.queryEnvelope(a),Re(a,r,s))return!1;if(a.height()<=s||a.width()<=s)return!1;const h=new o.a;return h.addEnvelope(e,!1),Je(t,h,s,n)}(t,e,s,r);case 32:return function(t,e,s,n){me(t,e);const r=new i.Envelope2D,a=new i.Envelope2D;if(t.queryEnvelope(r),e.queryEnvelope(a),Re(a,r,s))return!1;if(a.height()<=s||a.width()<=s)return!1;const h=new o.a;return h.addEnvelope(e,!1),$e(t,h,s,n)}(t,e,s,r);case 16:return!1}return!1}function _e(t,e,s,n,i){switch(n){case 4:return function(t,e,s){return me(t,e),!Qe(t,e.getXY(),s)}(t,e,s);case 1:case 64:return function(t,e,s){return me(t,e),function(t,e,s){return Qe(t,e,s)&&!ss(t,e,s)}(t,e.getXY(),s)}(t,e,s);case 8:return function(t,e,s){return me(t,e),ss(t,e.getXY(),s)}(t,e,s)}return!1}function pe(t,e,s,n,r){switch(n){case 4:return function(t,e,s){return me(t,e),!Ze(t,e,s,!1)}(t,e,s);case 1:case 64:return function(t,e,s){const n=i.Envelope2D.constructEmpty(),r=i.Envelope2D.constructEmpty();if(t.queryEnvelope(n),e.queryEnvelope(r),!Re(n,r,s))return!1;me(t,e);const o=Ze(t,e,s,!0);if(!o)return o;const a=t.getBoundary();return a.isEmpty()?o:!Ne(a,e,s)}(t,e,s);case 8:return function(t,e,s){me(t,e);const n=t.getImpl(),i=e.getImpl(),r=new o.M,a=new ne(n,i,s,!1),h=n.querySegmentIterator();let m=!1;for(;a.next();){const t=a.getRedElement(),e=a.getBlueElement();h.resetToVertex(t,-1);const n=h.nextSegment(),o=i.getXY(e);n.isIntersectingPoint(o,s)&&(m=!0,r.addPoint2D(o))}if(!m)return!1;const l=t.getBoundary();return!l.isEmpty()&&Ne(l,r,s)}(t,e,s);case 16:return function(t,e,s){me(t,e);const n=t.getImpl(),i=e.getImpl(),r=i.getPointCount(),a=(0,h.d)(r,!1),m=new ne(n,i,s,!1),l=n.querySegmentIterator();let u=!1;for(;m.next();){const t=m.getRedElement(),e=m.getBlueElement();l.resetToVertex(t,-1);const n=l.nextSegment(),r=i.getXY(e);n.isIntersectingPoint(r,s)&&(u=!0,a[e]=!0)}if(!u)return!1;let c=!1;for(let o=0;o<r;o++)if(!a[o]){c=!0;break}if(!c)return!1;const g=t.getBoundary();if(g.isEmpty())return!0;const d=new o.M;for(let o=0;o<r;o++)a[o]&&d.addPoint2D(i.getXY(o));return!Ne(g,d,s)}(t,e,s)}return!1}function fe(t,e,s,n,a){if(function(t,e,s){const n=i.Envelope2D.constructEmpty(),r=i.Envelope2D.constructEmpty();t.queryEnvelope(n),e.queryEnvelope(r);const o=function(t,e,s){const n=i.Envelope2D.constructEmpty();return n.setCoords({env2D:t}),n.inflateCoords(s,s),n.containsEnvelope(e)?1073741824:n.isIntersecting(e)?t.isIntersecting(e)?t.xmin<e.xmin&&e.xmax<t.xmax?e.ymin<t.ymin&&e.ymax>t.ymax?0:1073741824:t.ymin<e.ymin&&e.ymax<t.ymax?e.xmin<t.xmin&&e.xmax>t.xmax?0:1073741824:0:0:4}(r,n,s);return 0===o?!Ke(t,r,s):4===o}(t,e,s))return 4===n;if(4===n)return!1;switch(n){case 2:return Te(t,e,s,!1);case 128:return Te(t,e,s,!0);case 1:case 64:case 32:return!1;case 3:return function(t,e,s){const n=new i.Envelope2D,r=new i.Envelope2D;return t.queryEnvelope(n),e.queryEnvelope(r),!(r.height()>s&&r.width()>s)&&Ve(n,r,s)}(t,e,s);case 8:return function(t,e,s,n){const a=new i.Envelope2D,m=new i.Envelope2D;if(t.queryEnvelope(a),e.queryEnvelope(m),m.height()<=s||m.width()<=s)return!1;const l=new i.Envelope2D,u=new i.Envelope2D;if(l.setCoords({env2D:m}),u.setCoords({env2D:m}),l.inflateCoords(s,s),u.inflateCoords(-s,-s),u.containsEnvelope(a)||!a.isIntersecting(l))return!1;const c=t.getImpl().querySegmentIterator();c.stripAttributes();const g=t.getImpl().getAccelerators();let d=null,_=null;null!==g&&(d=g.getQuadTree(),null!==d&&(_=d.getIterator(m,s))),_||c.nextPath()||(0,r.c)("relational_operations");let p=!1,f=null;const P=new h.P,x=new h.P,y=t.hasNonLinearSegments();let E=!1;for(;;){if(null!==_){const t=_.next();if(-1===t)break;c.resetToVertex(d.getElement(t),-1),f=c.nextSegment()}else{for(;!c.hasNextSegment()&&c.nextPath(););if(!c.hasNextSegment())break;f=c.nextSegment()}if(y&&f.getGeometryType()!==r.G.enumLine){const t=new i.Envelope2D;if(f.queryEnvelope(t),u.containsEnvelope(t))return!1;if(l.isIntersecting(t)){E=!0;break}}else{P.assign(f.getStartXY()),x.assign(f.getEndXY());let t=u.clipLine(P,x);if(0!==t)return!1;p||(t=l.clipLine(P,x),0!==t&&(p=!0))}}if(!E)return p;const C=new o.a;return C.addEnvelope(m,!1),Se(C,t,s,n)}(t,e,s,a);case 16:return function(t,e,s){const n=new i.Envelope2D,a=new i.Envelope2D;if(t.queryEnvelope(n),e.queryEnvelope(a),a.height()<=s||a.width()<=s)return!1;const m=new i.Envelope2D;if(m.setCoords({env2D:a}),m.inflateCoords(s,s),m.containsEnvelope(n))return!1;const l=!0,u=new i.Envelope2D;if(u.setCoords({env2D:a}),u.inflateCoords(-s,-s),!u.isIntersecting(n))return!1;const c=t.getImpl().querySegmentIterator();c.stripAttributes();const g=t.getImpl().getAccelerators();let d=null,_=null;if(null!==g&&(d=g.getQuadTree(),null!==d&&(_=d.getIterator(a,s))),!_){const t=c.nextPath();(0,r.g)(t)}let p=!1,f=null;const P=new h.P,x=new h.P;let y=null,E=null,C=null,S=null;for(t.hasNonLinearSegments()&&(y=new o.L,E=new o.L,C=new o.L,S=new o.L,u.querySide(0,y),u.querySide(1,E),u.querySide(2,C),u.querySide(3,S));;){if(null!==_){const t=_.next();if(-1===t)break;c.resetToVertex(d.getElement(t),-1),f=c.nextSegment()}else{for(;!c.hasNextSegment()&&c.nextPath(););if(!c.hasNextSegment())break;f=c.nextSegment()}if(f.getGeometryType()===r.G.enumLine){if(P.assign(f.getStartXY()),x.assign(f.getEndXY()),0!==u.clipLine(P,x)){p=!0;break}}else{if(y.isIntersecting(f,s)){p=!0;break}if(E.isIntersecting(f,s)){p=!0;break}if(C.isIntersecting(f,s)){p=!0;break}if(S.isIntersecting(f,s)){p=!0;break}}}return p&&l}(t,e,s)}return!1}function Pe(t,e,s,n,i){switch(n){case 4:return Ge(t,e,s);case 2:case 128:return function(t,e,s){return Ae(t,e,s)}(t,e,s);case 1:case 64:return function(t,e,s){return!Ge(t,e,s)}(t,e,s);case 3:return Ae(t,e,s)}return!1}function xe(t,e,s,n,r){switch(n){case 4:return function(t,e,s){const n=i.Envelope2D.constructEmpty(),r=i.Envelope2D.constructEmpty();if(t.queryEnvelope(n),e.queryEnvelope(r),Re(r,n,s))return!1;const o=i.Envelope2D.constructEmpty();o.setCoords({env2D:r}),o.inflateCoords(s,s);const a=new h.P;for(let i=0;i<t.getPointCount();i++)if(t.queryXY(i,a),o.contains(a))return!1;return!0}(t,e,s);case 2:return Me(t,e,s,!1);case 128:return Me(t,e,s,!0);case 1:case 64:return!1;case 3:return function(t,e,s){const n=new i.Envelope2D,r=new i.Envelope2D;return t.queryEnvelope(n),e.queryEnvelope(r),!(r.height()>s||r.width()>s)&&Ve(n,r,s)}(t,e,s);case 8:return function(t,e,s){const n=new i.Envelope2D,r=new i.Envelope2D,o=new i.Envelope2D;if(e.queryEnvelope(n),n.height()<=s||n.width()<=s)return!1;r.setCoords({env2D:n}),o.setCoords({env2D:n}),r.inflateCoords(s,s),o.inflateCoords(-s,-s);const a=new h.P;let m=!1;for(let i=0;i<t.getPointCount();i++)if(t.queryXY(i,a),r.contains(a)){if(o.containsExclusive(a))return!1;m=!0}return m}(t,e,s);case 16:return function(t,e,s){const n=new i.Envelope2D,r=new i.Envelope2D;if(t.queryEnvelope(n),e.queryEnvelope(r),Re(r,n,s))return!1;if(r.height()<=s||r.width()<=s)return!1;const o=new i.Envelope2D,a=new i.Envelope2D;o.setCoords({env2D:r}),o.inflateCoords(-s,-s),a.setCoords({env2D:r}),a.inflateCoords(s,s);const m=new h.P;let l=!1,u=!1;for(let i=0;i<t.getPointCount();i++)if(t.queryXY(i,m),!l&&o.containsExclusive(m)&&(l=!0),u||a.contains(m)||(u=!0),l&&u)return!0;return!1}(t,e,s)}return!1}function ye(t,e,s,n){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();if(t.queryEnvelope(r),e.queryEnvelope(o),!Ve(r,o,s))return!1;if(me(t,e),Be(t,e,s))return!0;const a=t.calculateLength2D(),h=e.calculateLength2D(),m=Math.max(t.getPointCount(),e.getPointCount());return!(Math.abs(a-h)>4*m*s)&&(t.hasNonLinearSegments()||e.hasNonLinearSegments()?Bt(t,e,s,"**F**FFF*",n,!1):ze(t,e,s,!0))}function Ee(t,e,s,n){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();return t.queryEnvelope(r),e.queryEnvelope(o),!!Re(r,o,s)&&(me(t,e),ts(t,e,s,n))}function Ce(t,e,s,n){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();return t.queryEnvelope(r),e.queryEnvelope(o),!!Re(r,o,s)&&(me(t,e),2===Xe(t,e,s,!1))}function Se(t,e,s,n){return me(t,e),function(t,e,s,n){const r=t.getImpl(),o=e.getImpl(),a=r.querySegmentIterator(),m=o.querySegmentIterator(),l=(0,h.d)(2,Number.NaN),c=(0,h.d)(2,Number.NaN),g=new ne(r,o,s);let d=!1;for(;g.next();){const t=g.getRedElement(),e=g.getBlueElement();a.resetToVertex(t,-1),m.resetToVertex(e,-1);const n=a.nextSegment(),i=m.nextSegment();let r=0;if(ns(n,i)?!d&&i.isIntersecting(n,s)&&(d=!0):r=i.intersect(n,null,c,l,s),2===r)d=!0;else if(r){const t=l[0],e=c[0];if(t>0&&t<1&&e>0&&e<1)return!1;d=!0}}if(!d)return!1;const _=i.Envelope2D.constructEmpty(),p=i.Envelope2D.constructEmpty(),f=i.Envelope2D.constructEmpty();let P,x;if(t.queryEnvelope(_),e.queryEnvelope(p),_.inflateCoords(1e3*s,1e3*s),p.inflateCoords(1e3*s,1e3*s),f.setCoords({env2D:_}),f.intersect(p),t.getPointCount()>10){if(P=(0,u.c)(t,f,s,0,n),P.isEmpty())return!1}else P=t;if(e.getPointCount()>10){if(x=(0,u.c)(e,f,s,0,n),x.isEmpty())return!1}else x=e;return Bt(P,x,s,"F********",n,!1)}(t,e,s,n)}function ve(t,e,s,n,r){const a=i.Envelope2D.constructEmpty(),m=i.Envelope2D.constructEmpty();if(t.queryEnvelope(a),e.queryEnvelope(m),!Re(a,m,s))return!1;me(t,e);let l=!1;const u=new h.P,c=t.getImpl(),g=new o.a;let d=t,_=!1;for(let i=0;i<e.getPointCount();i++){if(e.queryXY(i,u),!a.contains(u))return!1;const r=as(d,u,s);if(1===r)l=!0;else if(0===r)return!1;if(n&&2===r)return!1;_||(!qt(t,e.getPointCount()-1)||null!==c.getAccelerators()&&null!==c.getAccelerators().getQuadTree()?d=t:(t.copyTo(g),g.getImpl().buildQuadTreeAccelerator(1),d=g),_=!0)}return l}function be(t,e,s,n,r){const o=i.Envelope2D.constructEmpty(),a=i.Envelope2D.constructEmpty();return t.queryEnvelope(o),e.queryEnvelope(a),n?He(a,o,s):Re(a,o,s)}function Ie(t,e,s,n,r){const a=i.Envelope2D.constructEmpty(),h=i.Envelope2D.constructEmpty();if(t.queryEnvelope(a),e.queryEnvelope(h),!Re(a,h,s))return!1;me(t,e);const m=new o.a;return m.addEnvelope(e,!1),n?2===Xe(t,m,s,!1):ts(t,m,s,r)}function we(t,e,s,n){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();return t.queryEnvelope(r),e.queryEnvelope(o),!!Re(r,o,s)&&(me(t,e),t.hasNonLinearSegments()||e.hasNonLinearSegments()?Bt(t,e,s,"******FF*",n,!1):Oe(e,t,s,!1))}function De(t,e,s,n){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();return t.queryEnvelope(r),e.queryEnvelope(o),!!Re(r,o,s)&&(me(t,e),Bt(t,e,s,"T**FF*FF*",n,!1))}function Te(t,e,s,n,a){const h=i.Envelope2D.constructEmpty(),m=i.Envelope2D.constructEmpty();if(t.queryEnvelope(h),e.queryEnvelope(m),m.height()<=s||m.width()<=s)return!1;if(n)return He(m,h,s);if(!Re(m,h,s))return!1;const l=i.Envelope2D.constructEmpty();l.setCoords({env2D:m}),l.inflateCoords(-s,-s);const u=i.Envelope2D.constructEmpty();if(u.setCoords({env2D:m}),u.inflateCoords(s,s),l.containsEnvelope(h))return!0;const c=t.getImpl().querySegmentIterator();c.stripAttributes(),c.nextPath()||(0,r.c)("relational_operations");let g,d,_,p,f,P,x=!1;const y=t.hasNonLinearSegments();for(y&&(_=new o.L,p=new o.L,f=new o.L,P=new o.L,l.querySide(0,_),l.querySide(1,p),l.querySide(2,f),l.querySide(3,P));;){for(;!c.hasNextSegment()&&c.nextPath(););if(!c.hasNextSegment())break;const t=c.nextSegment();if(y&&t.getGeometryType()!==r.G.enumLine){if(t.isIntersecting(_,s)){x=!0;break}if(t.isIntersecting(p,s)){x=!0;break}if(t.isIntersecting(f,s)){x=!0;break}if(t.isIntersecting(P,s)){x=!0;break}}else if(g=t.getStartXY(),d=t.getEndXY(),0!==l.clipLine(g,d)){x=!0;break}}return x}function Ne(t,e,s,n){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();return t.queryEnvelope(r),e.queryEnvelope(o),!!Re(r,o,s)&&Ue(e,t,s,!0,!1,!1)}function Ae(t,e,s,n){const r=i.Envelope2D.constructEmpty(),o=i.Envelope2D.constructEmpty();return t.queryEnvelope(r),e.queryEnvelope(o),Ve(r,o,s)}function Ge(t,e,s,n){return es(t,e.getXY(),s)}function Me(t,e,s,n,r){const o=i.Envelope2D.constructEmpty(),a=i.Envelope2D.constructEmpty();if(t.queryEnvelope(o),e.queryEnvelope(a),a.height()<=s||a.width()<=s)return!1;if(n)return He(a,o,s);if(!Re(a,o,s))return!1;let m=!1;const l=i.Envelope2D.constructEmpty(),u=i.Envelope2D.constructEmpty();l.setCoords({env2D:a}),u.setCoords({env2D:a}),l.inflateCoords(-s,-s),u.inflateCoords(s,s);const c=new h.P;for(let i=0;i<t.getPointCount();i++){if(t.queryXY(i,c),!u.contains(c))return!1;l.containsExclusive(c)&&(m=!0)}return m}function Fe(t,e,s,n){return h.P.sqrDistance(t,e)<=s*s}function qe(t,e,s,n){return Fe(t,e,s)}function Ve(t,e,s,n){return Re(t,e,s)&&Re(e,t,s)}function Ye(t,e,s,n,r){if(t.height()<=s||t.width()<=s)return!1;if(n)return He(t,e,s);if(!Re(t,e,s))return!1;const o=i.Envelope2D.constructEmpty();return o.setCoords({env2D:t}),o.inflateCoords(-s,-s),o.intersect(e),!o.isEmpty()}function Xe(t,e,s,n,a){const m=new h.P,l=new h.P,u=i.Envelope2D.constructEmpty(),c=i.Envelope2D.constructEmpty(),g=t.getImpl(),d=e.getImpl(),_=d.getGeometryType(),p=new ne(g,d,s,!0);if(!p.next())return 1;if(We(t,e,s))return n?4:0;const f=new o.a;let P=t;const x=new o.a;let y=null;_===r.G.enumPolygon&&(y=e);const E=_===r.G.enumPolygon?(0,h.d)(g.getPathCount(),!1):[],C=(0,h.d)(d.getPathCount(),!1);let S=!1,v=!1,b=!1,I=!1,w=!1,D=!1;do{if(b&&w||I&&D)break;if(b&&I)break;const i=p.getRedElement(),o=p.getBlueElement();if(!C[o]&&(l.assign(e.getXY(e.getPathStart(o))),u.setCoords({env2D:p.getRedEnvelope()}),u.inflateCoords(s,s),u.contains(l))){if(0!==as(P,l,0)){if(I=!0,n)return 4}else D=!0;C[o]=!0}if(_===r.G.enumPolygon&&!E[i]&&(m.assign(t.getXY(t.getPathStart(i))),c.setCoords({env2D:p.getBlueEnvelope()}),c.inflateCoords(s,s),c.contains(m))){if(0!==as(y,m,0)){if(b=!0,n)return 4}else w=!0;E[i]=!0}if(S||(!qt(t,e.getPathCount()-1)||null!==g.getAccelerators()&&null!==g.getAccelerators().getQuadTree()?P=t:(t.copyTo(f),f.getImpl().buildQuadTreeAccelerator(1),P=f),S=!0),_===r.G.enumPolygon&&!v){const s=e;!qt(s,t.getPathCount()-1)||null!==d.getAccelerators()&&null!==d.getAccelerators().getQuadTree()?y=e:(s.copyTo(x),x.getImpl().buildQuadTreeAccelerator(1),y=x),v=!0}}while(p.next());if(!b&&!I)return 1;if(!w||!D){if(_===r.G.enumPolygon)for(let t=0,e=g.getPathCount();t<e;t++)if(!E[t]){w=!0;break}for(let t=0,e=d.getPathCount();t<e;t++)if(!C[t]){D=!0;break}}return b&&w||I&&D||b&&I?4:I?2:3}function ke(t,e,s,n,a){n[0]=!1;const h=t.getImpl(),m=e.getImpl(),l=h.querySegmentIterator(),u=m.querySegmentIterator(),c=[0,0],g=[0,0],d=new ne(h,m,s);let _=!1;for(;d.next();){const t=d.getRedElement(),e=d.getBlueElement();l.resetToVertex(t,-1),u.resetToVertex(e,-1);const i=l.nextSegment(),r=u.nextSegment();let o=0;if(ns(i,r)?!_&&r.isIntersecting(i,s)&&(_=!0):o=r.intersect(i,null,g,c,s),0!==o&&(_=!0,1===o)){const t=c[0],e=g[0];if(t>0&&t<1&&e>0&&e<1)return n[0]=!0,!1}}if(!_){n[0]=!0;const a=i.Envelope2D.constructEmpty();t.queryEnvelope(a),a.inflateCoords(s,s);const l=new o.a;let u=t,c=!1;for(let s=0,n=e.getPathCount();s<n;s++)if(e.getPathSize(s)>0){const n=i.Envelope2D.constructEmpty();if(e.queryPathEnvelope(s,n),!a.isIntersecting(n))return!1;{const t=Ft(u,e.getXY(e.getPathStart(s)),0);if((0,r.g)(-1!==t),0===t)return!1}c||(!qt(t,e.getPathCount()-1)||null!==h.getAccelerators()&&null!==h.getAccelerators().getQuadTree()?u=t:(t.copyTo(l),l.getImpl().buildQuadTreeAccelerator(1),u=l),c=!0)}if(1===t.getPathCount()||e.getGeometryType()===r.G.enumPolyline)return!0;const g=e,d=i.Envelope2D.constructEmpty();g.queryEnvelope(d),d.inflateCoords(s,s);const _=new o.a;let p=g,f=!1;for(let e=0,s=t.getPathCount();e<s;e++)if(t.getPathSize(e)>0){const s=i.Envelope2D.constructEmpty();if(t.queryPathEnvelope(e,s),d.isIntersecting(s)){const s=Ft(p,t.getXY(t.getPathStart(e)),0);if((0,r.g)(-1!==s),1===s)return!1}f||(!qt(g,t.getPathCount()-1)||null!==m.getAccelerators()&&null!==m.getAccelerators().getQuadTree()?p=g:(g.copyTo(_),_.getImpl().buildQuadTreeAccelerator(1),p=_),f=!0)}return!0}return!1}function Re(t,e,s){const n=i.Envelope2D.constructEmpty();return n.setCoords({env2D:t}),n.inflateCoords(s,s),n.containsEnvelope(e)}function He(t,e,s){const n=i.Envelope2D.constructEmpty();return n.setCoords({env2D:e}),n.inflateCoords(s,s),t.containsExclusiveEnvelope(n)}function Le(t,e,s){const n=i.Envelope2D.constructEmpty();return n.setCoords({env2D:e}),n.inflateCoords(s,s),!n.contains(t.getLowerLeft())||!n.contains(t.getLowerRight())||!n.contains(t.getUpperLeft())||!n.contains(t.getUpperRight())}function Be(t,e,s,n){if(t.getPathCount()!==e.getPathCount()||t.getPointCount()!==e.getPointCount())return!1;if(t.hasNonLinearSegments()||e.hasNonLinearSegments())return t.equals(e);const i=new h.P,r=new h.P;let o=!0;const a=s*s;for(let m=0;m<t.getPathCount();m++){if(t.getPathEnd(m)!==e.getPathEnd(m)){o=!1;break}for(let s=t.getPathStart(m);s<e.getPathEnd(m);s++)if(t.queryXY(s,i),e.queryXY(s,r),h.P.sqrDistance(i,r)>a){o=!1;break}if(!o)break}return!!o}function Ue(t,e,s,n,i,r,o){const a=t.getImpl(),m=e.getImpl(),l=a.getPointCount(),u=m.getPointCount(),c=(0,h.d)(l,!1),g=i||r?(0,h.d)(u,!1):[],d=s*s,_=new ne(a,m,s);for(;_.next();){const t=_.getRedElement(),e=_.getBlueElement(),s=a.getXY(t),n=m.getXY(e);h.P.sqrDistance(s,n)<=d&&(c[t]=!0,(i||r)&&(g[e]=!0))}let p=!1,f=!1;for(let h=0;h<l;h++){const t=c[h];if(p||(p=!t),f||(f=t),(i||n)&&p)return!1}if(n)return!0;let P=!1,x=!1;for(let h=0;h<u;h++){const t=g[h];if(P||(P=!t),x||(x=t),i&&P)return!1}return!!i||p&&f&&P&&x}function ze(t,e,s,n){return Oe(t,e,s,n)&&Oe(e,t,s,n)}function Oe(t,e,s,n){if((0,r.l)(t),(0,r.l)(e),e.isEmpty())return!1;let o=!0;const m=(0,h.d)(2,Number.NaN),l=(0,h.d)(2,Number.NaN),u=[],c=new rs;let g;const d=i.Envelope2D.constructEmpty(),_=i.Envelope2D.constructEmpty(),p=i.Envelope2D.constructEmpty();t.queryEnvelope(d),e.queryEnvelope(_),d.inflateCoords(s,s),_.inflateCoords(s,s),p.setCoords({env2D:d}),p.intersect(_);const f=t.getImpl().querySegmentIterator(),P=e.getImpl().querySegmentIterator(),x=e.getImpl().getAccelerators();let y=null,E=null,C=null,S=null;if(null!==x&&(y=x.getQuadTree(),E=x.getQuadTreeForPaths(),null!==E&&(S=E.getIteratorForQT())),null===y){const s=t.getPointCount(),n=e.getPointCount();s>10&&n>10&&(y=(0,a.G)(e.getImpl(),p))}for(null!==y&&(C=y.getIteratorForQT());f.nextPath();)for(;f.hasNextSegment();){let t=f.nextSegment();if(t.queryEnvelope(d),!d.isIntersecting(p))return o=!1,!1;if(null!==S&&(S.resetIterator(d,s),-1===S.next()))continue;let e=0,i=null;if(null!=C)C.resetIterator(t,s);else if(P.resetToFirstPath(),!P.nextPath())return o=!1,!1;do{if(e=0,null!==C){const n=C.next();if(-1===n)return o=!1,!1;P.resetToVertex(y.getElement(n),-1),i=P.nextSegment(),e=t.intersect(i,null,m,l,s)}else{for(;!P.hasNextSegment();)if(!P.nextPath())return o=!1,!1;i=P.nextSegment(),i.queryEnvelope(_),_.inflateCoords(s,s),d.isIntersecting(_)&&(e=t.intersect(i,null,m,l,s))}}while(2!==e||0!==m[0]||n&&!(l[0]<=l[1]));let h=Number.NaN,x=!1;do{let n=!1;if(1===m[1]){if(!f.hasNextSegment()){x=!0;break}t=f.nextSegment(),n=!0}if(1===l[1]&&l[0]<=l[1]){if(-1===h)break;if(h=1,!P.hasNextSegment())break;i=P.nextSegment(),n=!0}if(0===l[1]&&l[0]>l[1]){if(1===h)break;if(Number.isNaN(h)){if(!P.hasPreviousSegment())break;P.previousSegment(),h=-1}if(!P.hasPreviousSegment())break;i=P.previousSegment(),n=!0}if(!n)break;e=t.intersect(i,null,m,l,s)}while(2===e&&(!n||l[0]<=l[1]));if(x)continue;const E=t.calculateLength2D();t.queryEnvelope(d),u.length=0,c.m_overlapEvents.length=0;let v=!1,b=!1,I=0;const w=(0,a.c)(null,d,!0);for(null!==C?C.resetIterator(t,s):(P.resetToFirstPath(),P.nextPath()||(0,r.c)("relational_operations"));;){if(e=0,null!==C){const n=C.next();if(-1===n)break;P.resetToVertex(y.getElement(n),-1),i=P.nextSegment(),e=t.intersect(i,null,m,l,s)}else{for(;!P.hasNextSegment()&&P.nextPath(););if(!P.hasNextSegment())break;i=P.nextSegment(),i.queryEnvelope(_),_.inflateCoords(s,s),d.isIntersecting(_)&&(e=t.intersect(i,null,m,l,s))}if(2===e&&(!n||l[0]<=l[1])){const t=f.getStartPointIndex(),e=f.getPathIndex(),n=P.getStartPointIndex(),i=P.getPathIndex();if(g=is(t,e,m[0],m[1],n,i,l[0],l[1]),c.m_overlapEvents.push(g),u.push(u.length),!(v||g.m_scalarA0<I&&g.m_scalarA1<I))if(0===I&&E*(g.m_scalarA0-I)>s)v=!0;else if(0!==I&&E*(g.m_scalarA0-I)>w)v=!0;else if(I=g.m_scalarA1,E*(1-I)<=s||1===I){b=!0;break}}}if(!b){if(!v)return o=!1,!1;u.length>1&&u.sort(((t,e)=>c.compareOverlapEvents(t,e))),I=0;for(let t=0;t<c.m_overlapEvents.length;t++)if(g=c.m_overlapEvents[u[t]],!(g.m_scalarA0<I&&g.m_scalarA1<I)){if(0===I&&E*(g.m_scalarA0-I)>s)return o=!1,!1;if(0!==I&&E*(g.m_scalarA0-I)>w)return o=!1,!1;if(I=g.m_scalarA1,E*(1-I)<=s||1===I)break}if(E*(1-I)>s)return o=!1,!1;u.length=0,c.m_overlapEvents.length=0}}return o}function We(t,e,s){const n=t.getImpl(),i=e.getImpl(),r=n.querySegmentIterator(),o=i.querySegmentIterator(),a=new ne(n,i,s);for(;a.next();){const t=a.getRedElement(),e=a.getBlueElement();r.resetToVertex(t,-1),o.resetToVertex(e,-1);const n=r.nextSegment();if(o.nextSegment().isIntersecting(n,s))return!0}return!1}function je(t,e,s,n){const i=t.getImpl(),r=e.getImpl(),o=i.querySegmentIterator(),a=r.querySegmentIterator(),m=(0,h.d)(2,Number.NaN),l=new ne(i,r,s);let u=!1,c=-1;for(;l.next();){const t=l.getRedElement(),e=l.getBlueElement();o.resetToVertex(t,-1),a.resetToVertex(e,-1);const i=o.nextSegment(),r=a.nextSegment();let g=0;if(ns(i,r)){if(r.isIntersecting(i,s))return-2}else g=i.intersect(r,null,m,null,s);if(g)if(2===g){const t=i.calculateLength2D(),e=m[0];if(t*(m[1]-e)>s)return c=1,c;u=!0}else if(c=0,n){const t=m[0],e=new h.P;i.queryCoord2D(t,e),n.push(e.x),n.push(e.y)}}return u?-2:c}function Ze(t,e,s,n){const i=t.getImpl(),r=e,o=r.getPointCount(),a=n?(0,h.d)(o,!1):[],m=new ne(i,r,s,!1),l=i.querySegmentIterator();for(;m.next();){const t=m.getRedElement(),e=m.getBlueElement();l.resetToVertex(t,-1);const i=l.nextSegment(),o=r.getXY(e);if(i.isIntersectingPoint(o,s)){if(!n)return!0;a[e]=!0}}if(!n)return!1;for(let h=0;h<o;h++)if(!a[h])return!1;return!0}function Qe(t,e,s){const n=new h.P,r=s*s,o=t.querySegmentIterator(),a=t.getImpl().getAccelerators();if(null!==a){const t=a.getQuadTree();if(null!==t){const a=i.Envelope2D.constructEmpty();a.setCoords({pt:e});const m=t.getIterator(a,s);for(let s=m.next();-1!==s;s=m.next())if(o.resetToVertex(t.getElement(s),-1),o.hasNextSegment()){const t=o.nextSegment(),s=t.getClosestCoordinate(e,!1);if(t.queryCoord2D(s,n),h.P.sqrDistance(e,n)<=r)return!0}return!1}}const m=i.Envelope2D.constructEmpty();for(;o.nextPath();)for(;o.hasNextSegment();){const t=o.nextSegment();if(t.queryEnvelope(m),m.inflateCoords(s,s),!m.contains(e))continue;const i=t.getClosestCoordinate(e,!1);if(t.queryCoord2D(i,n),h.P.sqrDistance(e,n)<=r)return!0}return!1}function Ke(t,e,s,n){const a=t.querySegmentIterator(),m=t.getImpl().getAccelerators(),l=t.hasNonLinearSegments();let u=null,c=null,g=null,d=null;if(null!==m){const t=m.getQuadTree();if(null!==t){const n=t.getIterator(e,s);l&&(u=new o.L,c=new o.L,g=new o.L,d=new o.L,e.querySide(0,u),e.querySide(1,c),e.querySide(2,g),e.querySide(3,d));const h=i.Envelope2D.constructEmpty();h.setCoords({env2D:e}),h.inflateCoords(s,s);for(let i=n.next();-1!==i;i=n.next())if(a.resetToVertex(t.getElement(i),-1),a.hasNextSegment()){const t=a.nextSegment();if(t.getGeometryType()===r.G.enumLine){const e=t.getStartXY(),s=t.getEndXY();if(h.clipLine(e,s))return!0;continue}if(e.contains(t.getStartXY())||e.contains(t.getEndXY()))return!0;if(t.isIntersecting(u,s))return!0;if(t.isIntersecting(c,s))return!0;if(t.isIntersecting(g,s))return!0;if(t.isIntersecting(d,s))return!0}return!1}}if(l){u=new o.L,c=new o.L,g=new o.L,d=new o.L,e.querySide(0,u),e.querySide(1,c),e.querySide(2,g),e.querySide(3,d);const n=t.querySegmentIterator();for(;n.nextPath();)for(;n.hasNextSegment();){const t=n.nextSegment();if(e.contains(t.getStartXY())||e.contains(t.getEndXY()))return!0;if(t.isIntersecting(u,s))return!0;if(t.isIntersecting(c,s))return!0;if(t.isIntersecting(g,s))return!0;if(t.isIntersecting(d,s))return!0}}else{const n=i.Envelope2D.constructEmpty();n.setCoords({env2D:e}),n.inflateCoords(s,s);const r=t.getImpl(),o=r.getAttributeStreamRef(0),a=new h.P;for(let t=0,e=r.getPathCount();t<e;t++){let e=!0;const s=new h.P,i=new h.P,m=new h.P,l=r.getPathStart(t),u=new h.P;for(let h=l,c=r.getPathEnd(t);h<c;h++)if(e)o.queryPoint2D(2*h,s),u.assign(s),e=!1;else{if(o.queryPoint2D(2*h,a),i.setCoordsPoint2D(s),m.setCoordsPoint2D(a),n.clipLine(i,m))return!0;s.assign(a)}if(r.isClosedPath(t)&&!e&&(i.setCoordsPoint2D(s),m.setCoordsPoint2D(u),n.clipLine(i,m)))return!0}}return!1}function Je(t,e,s,n){const r=t.getImpl(),o=e.getImpl(),m=[0],l=(0,a.M)(r.getIsSimple(0,m))&&(0,a.M)(o.getIsSimple(0,m)),c=r.querySegmentIterator(),g=o.querySegmentIterator(),d=(0,h.d)(2,0),_=(0,h.d)(2,0),p=new ne(r,o,s);let f=!1;for(;p.next();){const t=p.getRedElement(),e=p.getBlueElement();c.resetToVertex(t,-1),g.resetToVertex(e,-1);const n=c.nextSegment(),i=g.nextSegment();let r=0;if(ns(n,i)){if(i.isIntersecting(n,s)){f=!0;break}}else r=i.intersect(n,null,_,d,s);if(2===r){const t=d[0],e=d[1],i=n.calculateLength2D();if(l&&(e-t)*i>s)return!1;f=!0}else if(r){const t=d[0],e=_[0];if(t>0&&t<1&&e>0&&e<1)return!1;f=!0}}if(!f)return!1;const P=i.Envelope2D.constructEmpty(),x=i.Envelope2D.constructEmpty(),y=i.Envelope2D.constructEmpty();let E,C;if(t.queryEnvelope(P),e.queryEnvelope(x),P.inflateCoords(1e3*s,1e3*s),x.inflateCoords(1e3*s,1e3*s),y.setCoords({env2D:P}),y.intersect(x),t.getPointCount()>10){if(E=(0,u.c)(t,y,s,0,n),E.isEmpty())return!1}else E=t;if(e.getPointCount()>10){if(C=(0,u.c)(e,y,s,0,n),C.isEmpty())return!1}else C=e;return Bt(E,C,s,"F********",n,!1)}function $e(t,e,s,n){const r=t.getImpl(),o=e.getImpl(),m=[0],l=(0,a.M)(r.getIsSimple(0,m))&&(0,a.M)(o.getIsSimple(0,m)),c=i.Envelope2D.constructEmpty(),g=i.Envelope2D.constructEmpty(),d=i.Envelope2D.constructEmpty();t.queryEnvelope(c),e.queryEnvelope(g);let _=!1;const p=Le(c,g,s),f=Le(g,c,s),P=r.querySegmentIterator(),x=o.querySegmentIterator(),y=(0,h.d)(2,Number.NaN),E=(0,h.d)(2,Number.NaN),C=new ne(r,o,s);for(;C.next();){const t=C.getRedElement(),e=C.getBlueElement();P.resetToVertex(t,-1),x.resetToVertex(e,-1);const n=P.nextSegment(),i=x.nextSegment();let r=0;if(ns(n,i)){if(i.isIntersecting(n,s))break}else r=i.intersect(n,null,E,y,s);if(2===r){const t=y[0],e=y[1],i=n.calculateLength2D();if(l&&(e-t)*i>s&&(_=!0,p&&f))return!0}else if(r){const t=y[0],e=E[0];if(t>0&&t<1&&e>0&&e<1)return!0}}const S=i.Envelope2D.constructEmpty(),v=i.Envelope2D.constructEmpty();let b,I;S.setCoords({env2D:c}),S.inflateCoords(1e3*s,1e3*s),v.setCoords({env2D:g}),v.inflateCoords(1e3*s,1e3*s),d.setCoords({env2D:S}),d.intersect(v);let w="";if(w+=_?"**":"T*",p){if(e.getPointCount()>10){if(I=(0,u.c)(e,d,s,0,n),I.isEmpty())return!1}else I=e;w+="****"}else I=e,w+="T***";if(f){if(t.getPointCount()>10){if(b=(0,u.c)(t,d,s,0,n),b.isEmpty())return!1}else b=t;w+="***"}else b=t,w+="T**";return Bt(b,I,s,w,n,!1)}function ts(t,e,s,n){const r=[!1],h=ke(t,e,s,r);if(r[0])return h;const m=i.Envelope2D.constructEmpty();let l;if(e.queryEnvelope(m),m.inflateCoords(1e3*s,1e3*s),t.getPointCount()>10){if(l=(0,u.c)(t,m,s,0,n),l.isEmpty())return!1}else l=t;return function(t,e,s,n){const r=new $t;r.resetMatrix_(),r.setPredicates_("T*****F**"),r.setAreaAreaPredicates_();const h=i.Envelope2D.constructEmpty(),m=i.Envelope2D.constructEmpty();t.queryEnvelope(h),e.queryEnvelope(m);let l=!1;if(he(h,m,s)&&(r.areaAreaDisjointPredicates_(t,e),l=!0),l||me(t,e),l)return Kt(r.m_matrix,r.m_scl);let u=new o.E,c=u.addGeometry(t),g=u.addGeometry(e),d=null,_=0;if(t.hasNonLinearSegments()||e.hasNonLinearSegments()){d=new ys;const t=fs(s,u.getEnvelope2D(n));_=xs(t,0),ds(u,t,s,12e3,d,null,n)}Cs(u,new a.C(s,0).add(_),n,!1,!1);const p=u.getGeometry(g).getBoundary();if(u.filterClosePoints(0,!0,!0,!1,o.n),Ht(u,c,-1,!1,o.n,n),0===u.getPointCount(c))return!1;Ht(u,g,-1,!1,o.n,n),r.setEditShape_(u,n);const f=0===u.getPointCount(g);if(!f){r.computeMatrixTopoGraphHalfEdges_(c,g),r.m_topoGraph.removeShape();const t=Kt(r.m_matrix,r.m_scl);if(!t)return t}const P=u.getGeometry(c);return u=new o.E,c=u.addGeometry(P),g=u.addGeometry(p),r.setEditShape_(u,n),r.m_predicateCount=0,r.resetMatrix_(),r.setPredicates_(f?"T*****F**":"******F**"),r.setAreaLinePredicates_(),r.computeMatrixTopoGraphHalfEdges_(c,g),r.m_topoGraph.removeShape(),Kt(r.m_matrix,r.m_scl)}(l,e,s,n)}function es(t,e,s,n){const i=new h.P,r=s*s;for(let o=0;o<t.getPointCount();o++)if(t.queryXY(o,i),h.P.sqrDistance(i,e)<=r)return!1;return!0}function ss(t,e,s){const n=t.getBoundary();return!n.isEmpty()&&!es(n,e,s)}function ns(t,e){return t.getGeometryType()!==r.G.enumLine||e.getGeometryType()!==r.G.enumLine}function is(t,e,s,n,i,r,o,a){return{m_ivertexA:t,m_ipathA:e,m_scalarA0:s,m_scalarA1:n,m_ivertexB:i,m_ipathB:r,m_scalarB0:o,m_scalarB1:a}}class rs{constructor(){this.m_overlapEvents=[]}compareOverlapEvents(t,e){const s=this.m_overlapEvents[t],n=this.m_overlapEvents[e];if(s.m_ipathA<n.m_ipathA)return-1;if(s.m_ipathA===n.m_ipathA){if(s.m_ivertexA<n.m_ivertexA)return-1;if(s.m_ivertexA===n.m_ivertexA){if(s.m_scalarA0<n.m_scalarA0)return-1;if(s.m_scalarA0===n.m_scalarA0){if(s.m_scalarA1<n.m_scalarA1)return-1;if(s.m_scalarA1===n.m_scalarA1&&s.m_ivertexB<n.m_ivertexB)return-1}}}return 1}}function os(t,e,s){const n=function(t,e,s){return e.isEmpty()?0:Ft(t,e.getXY(),s)}(t,e,s);return n?1===n?1:2:0}function as(t,e,s){const n=Ft(t,e,s);return n?1===n?1:2:0}function hs(t,e,s,n,o){if(t.getGeometryType()===r.G.enumPolygon)!function(t,e,s,n,i){for(let r=0;r<s;r++)i[r]=as(t,e[r],n)}(t,e,s,n,o);else if(t.getGeometryType()===r.G.enumEnvelope){const r=i.Envelope2D.constructEmpty();t.queryEnvelope(r),function(t,e,s,n,i){if(t.isEmpty()){for(let t=0;t<s;t++)i[t]=0;return}const r=t.clone();r.inflateCoords(.5*-n,.5*-n);const o=t.clone();o.inflateCoords(.5*n,.5*n);for(let a=0;a<s;a++)r.contains(e[a])?i[a]=1:o.contains(e[a])?i[a]=2:i[a]=0}(r,e,s,n,o)}else(0,r.m)("")}function ms(t,e,s,n,o){const h=t.getGeometryType();h===r.G.enumPolyline?function(t,e,s,n,o){const h=t.getImpl(),m=h.getAccelerators();let l=null;m&&(l=m.getRasterizedGeometry());let u=s;for(let i=0;i<s;i++)o[i]=1,l&&(0,r.g)(0);if(u){if(m){let t=null;null!==m&&null!==m.getQuadTree()&&(t=m.getQuadTree());const r=h.getPointCount();if(null===t&&r>20&&r*s>4*r+Math.log(r)*s&&(t=(0,a.G)(h)),t){let r=null;const a=h.querySegmentIterator(),m=new i.Envelope2D;for(let i=0;i<s&&u;i++)if(1===o[i]){m.setCoords(e[i]),null===r?r=t.getIterator(m,n):r.resetIterator(m,n);let s=-1;for(let h=r.next();-1!==h;h=r.next()){if(a.resetToVertex(t.getElement(h),s),s=a.getPathIndex(),a.nextSegment().isIntersectingPoint(e[i],n)){o[i]=2,u--;break}o[i]=0}}return}}const t=h.querySegmentIterator();for(;t.nextPath()&&u;)for(;t.hasNextSegment()&&u;){const i=t.nextSegment();for(let t=0;t<s&&u;t++)1===o[t]&&i.isIntersectingPoint(e[t],n)&&(o[t]=2,u--)}}for(let i=0;i<s;i++)1===o[i]&&(o[i]=0)}(t,e,s,n,o):(0,r.f)(h)?(0,r.g)(0):(0,r.m)("")}function ls(t){if(t.isEmpty())return 0;switch(t.getGeometryType()){case r.G.enumMultiPoint:return t.getImpl().getPointCount();case r.G.enumPolyline:return t.getImpl().getPathCount();case r.G.enumPolygon:return t.getImpl().getOGCPolygonCount();case r.G.enumGeometryCollection:return t.getGeometryCount()}return 1}function us(){return Number.isNaN(this.radius.value())}function cs(t,e,s,n){return{pt:t.clone(),t:e,err:s,checkCount:n}}class gs{constructor(t,e,s,n,i){this.m_left=t,this.m_tracker=i,this.m_eps=s,this.m_trackerCounter=0,this.m_tolerance=n,this.m_circleCheckCounter=0,this.m_bReversedLeft=!1,this.m_leftArc={ptStart:new h.P,ptEnd:new h.P,center:new o.W,radius:new h.F,fcenter:new o.Y,fradius2:new h.M,maxError:Number.NaN,isLine:us}}closeToCircularArc(t,e,s,n,i,r){if(this.m_circleCheckCounter++,r.maxError=0,!gs.checkSweepAngle(t,e))return!1;if(r.ptStart.setCoordsPoint2D(s),r.ptEnd.setCoordsPoint2D(i),t.isCircular()){const e=t;return r.fradius2=h.M.constructDouble(e.getSemiMajorAxis()).mulDouble(e.getSemiMajorAxis()),r.radius.set(e.getSemiMajorAxis()),r.fcenter.assignPoint2D(e.getCenter()),r.center.set(e.getCenter()),!0}const a=r.ptEnd.sub(r.ptStart).clone();if(a.leftPerpendicularThis(),a.normalize(),Math.abs(a.dotProduct(n.sub(r.ptStart)))<=this.m_eps)return!!this.confirmIsLine(r,a)&&(r.radius.set(Number.NaN),r.center.setCoords(0,0),!0);{const s=r.ptEnd.sub(r.ptStart),i=n.sub(r.ptStart),o=s.crossProduct(i);if(0===o)return!1;const a=.5*s.sqrLength(),h=.5*i.sqrLength();let m=a*i.y-h*s.y;m/=o;let l=s.x*h-i.x*a;l/=o;const u=Math.sqrt(m*m+l*l);if(4*Number.EPSILON*u>this.m_eps)return!1;const c=m+r.ptStart.x,g=l+r.ptStart.y;r.radius.set(u),r.center.setCoords(c,g);const d=this.maxCircleApproximationError(t,e,r);if(d>this.m_eps)return r.maxError=d,!1}const m=(new o.Y).assignPoint2D(r.ptStart),l=(new o.Y).assignPoint2D(r.ptEnd).sub(m),u=(new o.Y).assignPoint2D(n).sub(m),c=l.crossProduct(u);if(c.isZero())return!1;const g=l.sqrLength().mulDouble(.5),d=u.sqrLength().mulDouble(.5),_=g.mul(u.y).sub(d.mul(l.y)),p=l.x.mul(d).sub(u.x.mul(g)),f=_.mul(_).add(p.mul(p)),P=c.clone();P.invertThis(),r.fradius2=f.mul(P).mul(P),r.fcenter.setCoords(_.mul(P).add(m.x),p.mul(P).add(m.y)),r.center.setWithEps(r.fcenter.asPoint2D()),r.radius.setWithEps(Math.sqrt(r.fradius2.toDouble()));const x=o.W.constructPoint2D(r.ptStart).subE(r.center),y=o.W.constructPoint2D(r.ptEnd).subE(r.center);if(!x.dotProduct(y).gt(h.H))return!1;const E=this.maxCircleApproximationError(t,e,r);return r.maxError=E,E<=this.m_eps}static checkSweepAngle(t,e){if(t.getGeometryType()===r.G.enumEllipticArc){const s=t,n=(0,o.Z)(s,e.vmin),i=(0,o.Z)(s,e.vmax);return!(Math.abs(i-n)>.5*h.l)}return!0}confirmIsLine(t,e){const s=t.ptEnd.sub(t.ptStart);return!(Math.abs(e.dotProduct(s.mul(.25)))>this.m_eps)&&!(Math.abs(e.dotProduct(s.mul(.75)))>this.m_eps)}maxCircleApproximationError(t,e,s){const n=[.25,.75],i=[.1,.25,.75,.9];let o,a;t.getGeometryType()===r.G.enumEllipticArc?(o=n,a=n.length):(o=i,a=i.length);let m=0;for(let r=0;r<a;++r){const n=new h.P;t.queryCoord2D((0,h.q)(e.vmin,e.vmax,o[r]),n);const i=n.sub(s.center.value()).length(),a=Math.abs(i-s.radius.value());a>m&&(m=a)}return m}approximateWithCirclesImpl(t,e){let s=1;e&&e.push(0);const n=(0,h.d)(9,Number.NaN);let i;t?i=this.m_left.getMonotonicPartParams(n.length,n):(n[0]=0,n[1]=1,i=2);const r=[],o=[],a=new h.P(0,0);for(let m=1;m<i;m++){const t=new h.E(n[m-1],n[m]);for(this.m_bReversedLeft=!gs.goodOrientation(this.m_left,t),this.m_bReversedLeft?(r.push(cs(a,t.vmin,0,0)),r.push(cs(a,t.vmax,0,0))):(r.push(cs(a,t.vmax,0,0)),r.push(cs(a,t.vmin,0,0))),r[0].pt=this.m_left.getCoord2D(r[0].t),r[1].pt=this.m_left.getCoord2D(r[1].t);r.length>1;){this.progress_();const t=r.at(-1);let n=t.checkCount,i=t.err;const a=t.pt.clone(),m=t.t,l=r[r.length-2].t,u=.5*(m+l),c=this.m_left.getCoord2D(u);if(i<=this.m_eps||n>=5){const t=new h.E;if(t.setCoords(m,l),this.closeToCircularArc(this.m_left,t,a,c,r[r.length-2].pt,this.m_leftArc)){e&&(this.m_bReversedLeft?o.push(m):e.push(l)),s++,r.pop();continue}n=0,i=this.m_leftArc.maxError}t.t=u,t.pt.setCoordsPoint2D(c),i*=.125,n++,t.err=i,t.checkCount=n,r.push(cs(a,m,i,n))}this.m_bReversedLeft&&e&&(e.length=e.length+o.length,(0,h.a)(e,o.reverse(),e.length-o.length,0,o.length),o.length=0),r.length=0}return s}approximateWithCirclesImplPolyline(t){const e=new o.P,s=[];if(!this.approximateWithCirclesImpl(!0,s))return e;let n=0;const i=this.m_left.getStartXY();e.startPath(i);for(let r=1;r<s.length;++r)if(t)e.lineTo(this.m_left.getCoord2D(s[r]));else{const t=new h.P;this.m_left.queryCoord2D(s[r],t);const a=new h.P;this.m_left.queryCoord2D(.5*(s[r]+n),a);const m=new o.l;m.constructCircularArcThreePoint(i,t,a),e.addSegment(m,!1),i.assign(t),n=s[r]}return e}static goodOrientation(t,e){const s=t.getCoord2D(e.vmin),n=t.getCoord2D(e.vmax);return s.compare(n)<0}progress_(){}}function ds(t,e,s,n,i,r,o){!function(t,e,s,n,i,r){t.hasCurves()?(t.setCurveStitcherPointer(n),n.m_impl=new Es(r,!1,null),n.m_impl.buildMonotonicCurveParentage(t,e,s,i)):n.m_impl=null}(t,e,s,i,r,o)}function _s(t,e,s,n){if(!(0,r.h)(t.getGeometryType()))return t;const i=t.getImpl();if(!i.hasNonLinearSegments())return t;const h=t.createInstance();h.getGeometryType()===r.G.enumPolygon&&h.setFillRule(t.getFillRule()),new o.E;const m=new a.P,l=new o.S,u=[],c=[],g=[],d=t.getDescription().getAttributeCount()>1,_=i.querySegmentIterator();for(;_.nextPath();){let t=!0;for(;_.hasNextSegment();){const n=_.isClosingSegment(),i=_.nextSegment();if(!i.isCurve()){h.addSegment(i,t,n),t=!1;continue}let a,p=!1;const f=!0,P=!0;switch(i.getGeometryType()){case r.G.enumEllipticArc:case r.G.enumRationalBezier2:a=(0,o.N)(i,e,s,f,P,c,g,u),p=!0;break;default:a=(0,o.K)(i,e,s,!0,f,c,u)}const x=p?2:3;c[1].isNAN()?(l.createLine(),l.get().construct(c[0],c[x])):p?(l.createQuadraticRationalBezier(),l.get().constructArrayWeights(c,g)):(l.createCubicBezier(),l.get().constructPoints(c)),d&&t&&(i.queryCoord(u[0],m),l.get().setStart(m)),d&&(i.queryCoord(u[1],m),l.get().setEnd(m)),h.addSegment(l.get(),t,n&&1===a),t=!1;for(let t=1,e=a,s=x;t<e;++t,s+=x)c[s+1].isNAN()?(l.createLine(),l.get().construct(c[s],c[s+x])):p?(l.createQuadraticRationalBezier(),l.get().constructArrayWeights(c.slice(s),g.slice(s))):(l.createCubicBezier(),l.get().constructPoints(c.slice(s))),d&&(i.queryCoord(u[t+1],m),l.get().setEnd(m)),h.addSegment(l.get(),!1,n&&t+1===e)}}return h}function ps(t,e,s,n,i,r,o,a){t.hasCurves()?(t.setCurveStitcherPointer(r),r.m_impl=new Es(a,!0,i),r.m_impl.buildMonotonicCurveParentage(t,e,s,o),function(t,e,s){Is.fixCurveTwoPointLoops(t,e,s)}(t,s,a)):r.m_impl=null}function fs(t,e){return e||(e=i.Envelope2D.constructEmpty()),function(t,e){let s=e.isEmpty()?t:(0,a.a)(null,e,!0).total();return s>t&&(s=t),.125*s}(t,e)}function Ps(t,e){return.125*t}function xs(t,e){return 3*t+3*e}class ys{constructor(){this.m_impl=null}stitchCurves(t,e,s,n){this.m_impl&&(this.m_impl.stitchCurves(t,e,s),n&&this.clearStitcher(t))}clearStitcher(t){this.m_impl&&(this.m_impl.clearStitcher(t),this.m_impl=null)}getOriginalVertexIndex(t,e){return this.m_impl.getOriginalVertexIndex(t,e)}getOriginalSegmentTypeInfo(t){return this.m_impl.getOriginalSegmentTypeInfo(t)}}class Es{constructor(t,e,s){this.m_originalPlanarSegments=[],this.m_progressTracker=null,this.m_nsr=null,this.m_progressTracker=t,this.m_nsr=s,this.m_tolerance=0,this.m_originalVertexIndex=-1,this.m_type=0,this.m_progressCounter=0,this.m_bIsSimple=e}buildMonotonicCurveParentage(t,e,s,n){const i=!1;if(!t.hasCurves())return;(0,r.g)(!t.hasSegmentParentage()),this.m_type=1,this.m_originalPlanarSegments.length=0,this.m_bIsSimple&&(this.m_originalVertexIndex=t.createUserIndex()),this.m_tolerance=s;const h=new a.P,m=new o.S,l=[],u=[],c=[];for(let a=t.getFirstGeometry();a!==o.n;a=t.getNextGeometry(a))for(let n=t.getFirstPath(a);n!==o.n;n=t.getNextPath(n)){let a=t.getPathSize(n),g=t.getFirstVertex(n),d=0,_=-1;for(let f=0;f<a;f++){let P=t.getNextVertex(g);if(!t.querySegment(g,m,!0,!1)){g=P;continue}if(0===d){_=t.getVertexIndex(g);const e=Es.regularizeCurve(t,m.get(),g,s);if(e>=0){this.m_nsr&&0===this.m_nsr.m_reason&&this.m_nsr.assign(new p(13,_,-1)),d=e,a=t.getPathSize(n),P=t.getNextVertex(g);const s=t.querySegment(g,m,!0,!1);(0,r.g)(s)}}else d--;const x=t.getVertexIndex(g);let y;-1!==this.m_originalVertexIndex&&t.setUserIndex(g,this.m_originalVertexIndex,_),t.setSegmentToIndex(x,null);let E=!1;switch(m.get().getGeometryType()){case r.G.enumEllipticArc:case r.G.enumRationalBezier2:y=(0,o.N)(m.get(),e,s,i,true,u,c,l),E=!0;break;default:{const t=!this.m_bIsSimple||!m.get().isMonotoneQuickAndDirty();y=(0,o.K)(m.get(),e,s,t,i,u,l)}}const C=this.m_originalPlanarSegments.length;if(t.setSegmentParentageAndBreak(g,C,!0),!u[1].isNAN()){let e=null;e=E?new o.Q({points:u,weights:c}):new o.y({cp:u}),e.snapControlPoints(s*s),t.setSegmentToIndex(x,e)}const S=E?2:3;for(let e=1,i=y,r=S;e<i;++e,r+=S){m.get().queryCoord(l[e],h);const i=t.insertVertex(n,P,h);if(-1!==this.m_originalVertexIndex&&t.setUserIndex(i,this.m_originalVertexIndex,_),!u[r+1].isNAN())if(E){const e=new o.Q({points:u.slice(r),weights:c.slice(r)});e.snapControlPoints(s*s),t.setSegmentToIndex(t.getVertexIndex(i),e)}else{const e=new o.y({cp:u.slice(r)});e.snapControlPoints(s*s),t.setSegmentToIndex(t.getVertexIndex(i),e)}t.setSegmentParentageAndBreak(i,C,!1)}y>1&&(f+=y-1,a=t.getPathSize(n)),this.m_originalPlanarSegments.push(m.releaseSegment()),g=P}}}stitchCurves(t,e,s){Es.st_stitchCurvesImpl(this,t,e,s,!1)}clearStitcher(t){this.m_originalPlanarSegments.length=0,-1!==this.m_originalVertexIndex&&(t.removeUserIndex(this.m_originalVertexIndex),this.m_originalVertexIndex=-1),t.deleteSegmentParentage()}static st_verifyParentage(t){Es.st_stitchCurvesImpl(null,t,o.n,0,!0)}getOriginalVertexIndex(t,e){return-1!==this.m_originalVertexIndex&&e!==o.n?t.getUserIndex(e,this.m_originalVertexIndex):-1}getOriginalSegmentTypeInfo(t){if(-1!==t){const e=this.m_originalPlanarSegments[t];switch(e.getGeometryType()){case r.G.enumEllipticArc:return 0===e.projectionBehavior()?0:1;case r.G.enumBezier:return 2;case r.G.enumBezier2:return 3;case r.G.enumLine:return-1;case r.G.enumRationalBezier2:return 4;default:(0,r.b)("")}}return-1}progress_(){this.m_progressCounter++}processSpan_(t,e,s,n,i,a,h){if(e===s&&0===n)return(0,r.g)(t.getNextVertex(e)===o.n),t.setSegmentToIndex(t.getVertexIndex(e),null),void t.setSegmentParentageAndBreak(e,-1);const m=t.getNextVertex(e);{let e=2;for(let n=m;n!==s;n=t.getNextVertex(n))e++;(0,r.g)(e===n)}if(null===i){t.setSegmentToIndex(t.getVertexIndex(e),null);for(let e=m;e!==s;)e=t.removeVertex(e,!0);return}const l=t.getXY(e),u=t.getXY(s);if(i.isClosed()){if(l.isEqualPoint2D(u)&&l.isEqualPoint2D(i.getStartXY())){let r;if(r=this.verifySegmentFitness(t,e,s,n,i,a,h)){const n=i.clone();return n.dropAllAttributes(),r<0&&n.reverse(),this.removeSpan(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),n)}}}else if(l.isEqualPoint2D(i.getStartXY())){if(u.isEqualPoint2D(i.getEndXY())){const r=i.clone();if(r.dropAllAttributes(),this.verifySegmentFitness(t,e,s,n,r,a,h))return this.removeSpan(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),r)}}else if(u.isEqualPoint2D(i.getStartXY())&&l.isEqualPoint2D(i.getEndXY())){const r=i.getReversed();if(r.dropAllAttributes(),this.verifySegmentFitness(t,e,s,n,r,a,h))return this.removeSpan(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),r)}this.processSpanSplitSegment(t,e,s,n,i,a,h)}processSpanSplitSegment(t,e,s,n,i,r,o){if(i.isLine())return;if(this.fitSegmentToSpan(t,e,s,n,i,r,o))return;const a=o*o;let m=n,l=e;const u=t.getXY(e);let c=i.getClosestCoordinate(u,!1);const g=i.getCoord2D(c);let d=!1;const _=h.P.sqrDistance(u,g);if(_>a){const n=t.getNextVertex(e);if(this.approximateSpanSection(t,e,i,r,o),n===s)return;l=n,d=!0,m-=1}let p=s;const f=t.getXY(s);c=i.getClosestCoordinate(f,!1);const P=i.getCoord2D(c);let x=!1;const y=h.P.sqrDistance(f,P);if(y>a){const e=t.getPrevVertex(s);if(this.approximateSpanSection(t,e,i,r,o),e===l)return;p=e,x=!0,m-=1}if((d||x)&&this.fitSegmentToSpan(t,l,p,m,i,r,o))return;let E=!1;if(!d&&_>0){const s=t.getNextVertex(e);if(this.approximateSpanSection(t,e,i,r,o),s===p)return;l=s,d=!0,E=!0,m-=1}if(!x&&y>0){const e=t.getPrevVertex(s);if(this.approximateSpanSection(t,e,i,r,o),e===l)return;p=e,x=!0,E=!0,m-=1}if(E&&this.fitSegmentToSpan(t,l,p,m,i,r,o))return;let C=l;for(;;){const e=t.getNextVertex(C);if(this.approximateSpanSection(t,C,i,r,o),C=e,C===p)return}}fitSegmentToSpan(t,e,s,n,i,a,m){const l=0===this.m_type,u=[];if(u.push(t.getXY(e)),l){let i=e;const o=32;if(n>o){const e=BigInt(n-1),a=BigInt(o-1);let h=a,m=0n;for(let s=1;s<n;s++,h+=a)if(i=t.getNextVertex(i),h>=m+e){m+=e;const s=t.getXY(i);u.push(s)}(0,r.g)(i===s)}else{for(let e=1;e<n;e++){i=t.getNextVertex(i);const e=t.getXY(i);u.push(e)}(0,r.g)(i===s)}}else{let i=e;const r=new o.S;for(;;){t.querySegment(i,r,!1,!0);const e=[.1,.25,.4,.5,.6,.75,.9,1];let o=0;for(const t of e)(2===n||1&o)&&u.push(r.get().getCoord2D(t)),o++;if(i=t.getNextVertex(i),i===s)break}}const c=(()=>{let t=u[0].compare(u.at(-1));if(0===t){const e=new h.K(0);(function(t,e,s){if(s.reset(),e<3)return;const n=t[0].clone(),i=n.x,r=n.y,o=t[1].clone(),a=new h.P;for(let h=2;h<e;h++)a.assign(t[h]),s.pe((a.x-n.x)*(o.y-r)),n.assign(o),o.assign(a);s.pe((i-n.x)*(o.y-r))})(u,u.length,e),t=e.getResult()>=0?-1:1}return t>0})();c&&u.reverse();const g=i.clone();if(g.dropAllAttributes(),g.setSegmentFromCoords(u,u.length),c&&g.reverse(),g.snapControlPoints(this.m_tolerance*this.m_tolerance),this.verifySegmentFitness(t,e,s,n,g,a,m)){this.removeSpan(t,e,s);const n=t.getVertexIndex(e);return t.setSegmentToIndex(n,g),!0}return!1}approximateSpanSection(t,e,s,n,i){const m=new o.S;if(!t.querySegment(e,m,!0,!1))return;const l=s.getGeometryType();if(l!==m.get().getGeometryType()){if(l===r.G.enumEllipticArc){if(m.get().getGeometryType()!==r.G.enumRationalBezier2)return;if(0===s.projectionBehavior()){const s=[];!function(t,e,s,n,i){const r=(0,o.X)(e),a=Math.max(4*r,s);new gs(e,null,a,Number.NaN,i).approximateWithCirclesImpl(t,n)}(!1,m.get(),i,s,this.m_progressTracker);const n=t.getNextVertex(e),r=t.getPathFromVertex(e),l=new a.P;let u=e;for(let e=1,i=s.length;e<i;e++){const i=s[e],a=m.get().getCoord2D(s[e-1]),c=m.get().getCoord2D((0,h.q)(s[e-1],i,.5));m.get().queryCoord(i,l);const g=l.getXY(),d=new o.l;d.constructCircularArcThreePoint(a,g,c);let _=o.n;i<1&&(_=t.insertVertex(r,n,l)),t.setSegmentToIndex(t.getVertexIndex(u),d),u=_}return}{const s=(0,h.m)(h.P,3);m.get().queryControlPoints(s);const n=[0,0,0];m.get().queryWeights(n);const i=(0,o.O)(n),r=new o.l;return(0,o.R)(s,i*i,null,!1,r),void t.setSegmentToIndex(t.getVertexIndex(e),r)}}(0,r.c)("approximate_span_section_")}}verifySegmentFitness(t,e,s,n,i,r,o){return 0===this.m_type?this.verifySegmentFitnessLines(t,e,s,n,i,r,o):this.verifySegmentFitnessCurves(t,e,s,n,i,r,o)}verifySegmentFitnessCurves(t,e,s,n,i,r,a){const m=t.getXY(e),l=t.getXY(s);if(!m.isEqualPoint2D(i.getStartXY())||!l.isEqualPoint2D(i.getEndXY()))return 0;let u=0;if(i.isClosed()){const t=i.getCoord2D(.1).sub(m);u=i.getCoord2D(.7).sub(m).crossProduct(t)>=0?1:-1}const c=(0,h.d)(o.T.s_maxMonotonicPartParams,Number.NaN);let g=i.getMonotonicPartParams(c.length,c);g--;const d=new o.L,_=[1,.5,.75,.25];let p=0,f=e;const P=m.clone();for(;;){const e=t.getNextVertex(f);let n=t.getSegment(f);null===n&&(t.queryLineConnector(f,d,!0),n=d);for(let t=e===s?1:0;t<_.length;t++){const e=n.getCoord2D(_[t]);if(!i.isCloserThanDistance(e,h.E.unit(),a))return 0}if(g>1)for(let t=1;t<g;){const e=i.getCoord2D(c[t]);n.isCloserThanDistance(e,h.E.unit(),a)?(c[g-1]=(0,h.b)(c[t],c[t]=c[g-1]),g--):t++}if(u){const t=n.getCoord2D(.25);p+=t.sub(m).crossProduct(P.sub(m)),P.assign(t),t.assign(n.getCoord2D(.75)),p+=t.sub(m).crossProduct(P.sub(m)),P.assign(t)}if(f=e,f===s)return g>1?0:u?p<0?-u:u:1}}verifySegmentFitnessLines(t,e,s,n,i,o,a){return(0,r.g)(0),0}removeSpan(t,e,s){t.setSegmentToIndex(t.getVertexIndex(e),null);const n=t.getNextVertex(e);n!==s&&t.removeVertices(n,s)}static st_stitchCurvesImpl(t,e,s,n,i){if(e.hasSegmentParentage())return e.hasCurves()?Es.st_stitchCurvesFromCurvesImpl(t,e,s,n,i):Es.st_stitchCurvesFromLinesImpl(t,e,s,n,i)}static st_stitchCurvesFromLinesImpl(t,e,s,n,i){let a=s===o.n?e.getFirstGeometry():s;for(;a!==o.n;){for(let s=e.getFirstPath(a);s!==o.n;s=e.getNextPath(s)){let a=e.getPathSize(s);e.isClosedPath(s)&&(a+=1);let h=!0,m=!1;const l=e.getFirstVertex(s);let u=l;for(let s=0;s<a&&u!==o.n;){let c=e.getSegmentParentage(u);if(-1===c||h){h=!1,s++,u=e.getNextVertex(u),m=!0;continue}let g,d,_=0;if(m?(g=e.getPrevVertex(u),d=u,(0,r.g)(g!==o.n),(0,r.g)(d!==g),(0,r.g)(-1===e.getSegmentParentage(g)||l===g)):(g=u,d=e.getNextVertex(g),s++,(0,r.g)(d!==o.n),(0,r.g)(d!==g),c=e.getSegmentParentage(d)),_=2,m=!1,-1===c||e.getSegmentParentageBreakVertex(d)){u=d;continue}let p=e.getNextVertex(d);for(s++;s<a&&p!==o.n;){d=p,_++;const t=e.getSegmentParentage(p);if(-1===t||e.getSegmentParentageBreakVertex(p))break;(0,r.g)(t===c),s++,p=e.getNextVertex(p)}if(!i){const s=t.m_originalPlanarSegments[c];t.processSpan_(e,g,d,_,s,c,n)}u=d}}if(s!==o.n)break;a=e.getNextGeometry(a)}}static st_stitchCurvesFromCurvesImpl(t,e,s,n,i){let a=s===o.n?e.getFirstGeometry():s;for(;a!==o.n;)if((0,r.q)(e.getGeometryType(a))){for(let s=e.getFirstPath(a);s!==o.n;s=e.getNextPath(s)){let a=e.getPathSize(s);const h=e.isClosedPath(s);h&&(a+=1);let m=e.getFirstVertex(s);if(h){if(-1!==e.getSegmentParentage(m)){let t=m;for(let n=0;!e.getSegmentParentageBreakVertex(t);n++){if(n===a){m=e.getFirstVertex(s),e.setSegmentParentageBreakVertex(t,!0);break}t=e.getPrevVertex(t)}}}else(0,r.g)(-1===e.getSegmentParentage(m)||e.getSegmentParentageBreakVertex(m));let l=m;for(let s=0;s<a&&l!==o.n;){const h=e.getSegmentParentage(l);if(-1===h){s++,l=e.getNextVertex(l);continue}let m=0,u=o.n;const c=l;m=1;let g=e.getNextVertex(c);for(;s<a&&g!==o.n;){s++,u=g,m++;const t=e.getSegmentParentage(g);if(-1===t||e.getSegmentParentageBreakVertex(g))break;(0,r.g)(t===h),g=e.getNextVertex(g)}if(u===o.n)break;if(!i){const s=t.m_originalPlanarSegments[h];t.processSpan_(e,c,u,m,s,h,n)}l=u}}if(s!==o.n)break;a=e.getNextGeometry(a)}else a=s===o.n?e.getNextGeometry(a):o.n}static regularizeCurve(t,e,s,n){let i=e.snapControlPoints(n*n);if(i){const n=t.getVertexIndex(s),i=e.clone();t.setSegmentToIndex(n,i)}if(e.getGeometryType()===o.y.type){const r=[],o=e.calculateSpecialPointsForCracking(n,r);if(o>0){t.splitSegment(s,r,o),i=t.snapControlPoints(s,o+1,n*n)||i;for(let e=0;e<o;e++)s=t.getNextVertex(s),t.setSegmentParentageBreakVertex(s,!0);return o}}return i?0:-1}}function Cs(t,e,s,n,i){return new Is(t,s,e,n,i).do_()}function Ss(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(n>r)return t;if(r>n)return e;const o=new a.P;return function(t,e,s,n,i,r,o,a,h){const m=t.equals(e);if(n>r)return o.assignCopy(t),h[0]=n,a[0]=s,m;if(r>n)return o=e,h[0]=r,a[0]=i,m;o.assignCopy(t);const l=lt(t.getXY(),e.getXY(),s,n,i,r);o.setXY(l.pt),a[0]=l.weight,h[0]=l.rank}(t,e,s,n,i,r,o,[0],[0]),o}function vs(t,e,s){const n=(0,a.d)(e),i=(0,a.a1)(e);return!!function(t,e,s,n,i){const r=new gt(i);return r.m_shape=t,r.m_sqrTolerance=e*e,r.m_cellSize=2*e,r.m_invCellSize=1/r.m_cellSize,r.m_geometry=s,r.m_bTrackChanges=!1,r.needsClustering()}(t,n,o.n,0,s)||Nt(!0,t,i,null,s)}function bs(t){return(0,a.d)(t)}class Is{constructor(t,e,s,n,i){this.m_shape=t,this.m_progressTracker=e,this.m_tolerance=s,this.m_bFilterDegenerateSegments=n,this.m_bTrackChanges=i,this.m_progressCounter=0}do_(){const t=new a.C(this.m_tolerance.tolerance,this.m_tolerance.resolution),e=bs(t);let s=(0,a.a1)(t);const n=1.00001*s;s*=1.000001;let i=!1;const m=this.m_shape.getTotalPointCount()+10>30?1e3:(this.m_shape.getTotalPointCount()+10)*(this.m_shape.getTotalPointCount()+10),l=this.m_shape.hasPointFeatures();for(let a=0;;a++){this.m_shape.dbgCheckSelection(),a>m&&(0,r.c)("crack_and_cluster_iteration_exceeded"),this.m_shape.dbgVerifyMonotone();let t=-1;0===a&&(t=this.firstCrack_(),i||(i=t>0));const h=this.cluster_(e);if(this.m_shape.dbgVerifyMonotone(),i||(i=h),this.m_bFilterDegenerateSegments){const t=0!==this.m_shape.filterClosePoints(e,!0,!1,this.m_bTrackChanges,o.n);i||(i=t),this.m_shape.dbgVerifyMonotone()}const u=this.m_shape.snapControlPointsOnSelection(n*n);i||(i=u),this.m_shape.dbgCheckSelection();let c=!1;if((0===a&&-1===t||l||Nt(!0,this.m_shape,s,null,this.m_progressTracker))&&(c=this.crack_(n),i||(i=c),this.m_shape.dbgVerifyMonotone()),!c&&!Is.fixCurveTwoPointLoops(this.m_shape,e,this.m_progressTracker)){this.m_shape.dbgVerifyMonotone();break}}return i&&function(t){if(!t.hasSegmentParentage())return;const e=new a.A(0),s=t.queryVertexIteratorOnSelection();for(let a=s.next();a!==o.n;a=s.next())e.add(a);if(0===e.size())return;t.sortVerticesSimpleByY(e,0,e.size()),e.add(o.n);const n=h.P.getNAN();t.queryXY(e.read(0),n);let i=0;const r=h.P.getNAN();for(let a=1,h=e.size();a<h;a++){{const s=e.read(a);s!==o.n?t.queryXY(s,r):r.setNAN()}if(!r.isEqualPoint2D(n)){let s=!1,h=-2;for(let n=i;n<a;++n){const i=e.read(n);if(t.getSegmentParentageBreakVertex(i)){s=!0;break}let r=t.getSegmentParentage(i);const a=t.getPrevVertex(i);if(a!==o.n){let e=t.getSegmentParentage(a);if(-1===r&&(r=e),-1===e&&(e=r),r!==e){s=!0;break}}if(-2!==h&&r!==h){s=!0;break}h=r}if(s)for(let n=i;n<a;++n)t.setSegmentParentageBreakVertex(e.read(n),!0);n.setCoordsPoint2D(r),i=a}}}(this.m_shape),i}cluster_(t){return ht(this.m_shape,t,o.n,this.m_bTrackChanges,this.m_progressTracker)}crack_(t){return function(t,e,s,n){if(!Tt(t))return!1;const i=new Gt(n);i.m_shape=t,i.m_tolerance=e,i.m_bTrackChanges=s;let r=!1;const o=t.hasCurves()?5:15;return r=t.getTotalPointCount()<o?i.crackBruteForce_():i.crackerPlaneSweep_(),r}(this.m_shape,t,this.m_bTrackChanges,this.m_progressTracker)}static fixCurveTwoPointLoops(t,e,s){if(!t.hasCurves())return!1;t.dbgVerifyCurves();const n=t.createUserIndexUninitialized(),i=new a.A(0),m=t.queryVertexIteratorOnSelection();for(let r=m.next();r!==o.n;r=m.next())i.add(r),t.setUserIndex(r,n,-1);if(0===i.size())return!1;i.add(o.n),t.sortVerticesSimpleByY(i,0,i.size()-1);let l=0;const u=t.getXY(i.read(l)),c=new h.P(Number.NaN,Number.NaN),g=[];for(let r=1,a=i.size();r<a;++r){const e=i.read(r),s=e!==o.n?t.getXY(e):c;if(s.equals(u))continue;const a=[];for(let m=l;m<r;m++){const e=i.read(m),s=t.getPrevVertex(e);if(s!==o.n&&-1===t.getUserIndex(s,n)){const e=ws(t.getXY(s),t.getSegment(s));0!==h.P.sqrDistance(u,e.otherPt)&&(e.vert=s,e.dir=-1,a.push(e)),t.setUserIndex(s,n,1)}const r=t.getNextVertex(e);if(r!==o.n&&-1===t.getUserIndex(e,n)){const s=ws(t.getXY(r),t.getSegment(e));0!==h.P.sqrDistance(u,s.otherPt)&&(s.vert=e,s.dir=1,a.push(s)),t.setUserIndex(e,n,1)}}if(a.length>1){a.sort(((t,e)=>Ts(t,e)));const t=ws(c.clone(),null);a.push(t);let e=0;for(let s=1,n=a.length;s<n;s++)if(!a[s].otherPt.equals(a[s-1].otherPt)){if(s-e>1&&null!==a[e].seg){let t=!1;const n=e;for(let i=e+1;i<s;i++)if(!Ds(a[n],a[i])){t=!0;break}if(t)for(let i=e;i<s&&null!==a[i].seg;i++)g.push(a[i].vert)}e=s}}l=r,u.setCoordsPoint2D(s)}for(const o of g){const s=t.getSegment(o);(0,r.g)(null!==s);const n=t.getXY(o),i=t.getXY(t.getNextVertex(o));if(h.P.distance(n,i)<3*e)t.setSegmentToIndex(t.getVertexIndex(o),null);else{const e=s.lengthToT(.5*s.calculateLength2D());t.splitSegment(o,[e],1)}}return t.removeUserIndex(n),g.length>0}firstCrack_(){const t=this.m_shape.getEnvelope2D(this.m_progressTracker),e=(0,a.a)(null,t,!0).total();if(4*e<this.m_tolerance.total()){let t=!1;const s=1.1*e,n=e,i=this.cluster_(s);t||(t=i);let r=0;this.m_bFilterDegenerateSegments&&(r=this.m_shape.filterClosePoints(0,!0,!1,this.m_bTrackChanges,o.n));const a=this.crack_(n);return t||(t=a),t?1:r?2:0}return-1}progress_(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.m_progressCounter++,!t&&4095&this.m_progressCounter||(this.m_progressCounter=0)}}function ws(t,e){return{otherPt:t,seg:e,vert:-1,dir:0}}function Ds(t,e){if((0,r.g)(t.otherPt.equals(e.otherPt)),null===t.seg)return null===e.seg;if(null===e.seg)return!1;const s=t.seg.getGeometryType();if(s!==e.seg.getGeometryType())return!1;if(s===r.G.enumBezier){const s=t.seg,n=e.seg;let i=s.getControlPoint1(),r=s.getControlPoint2();-1===t.dir&&(r=(0,h.b)(i,i=r));let o=n.getControlPoint1(),a=n.getControlPoint2();return-1===e.dir&&(a=(0,h.b)(o,o=a)),i.equals(o)&&r.equals(a)}if(s===r.G.enumRationalBezier2){const s=t.seg,n=e.seg,i=s.getControlPoint1(),r=n.getControlPoint1();if(!i.equals(r))return!1;const o=[0,0,0];s.queryWeights(o),-1===t.dir&&(o[2]=(0,h.b)(o[0],o[0]=o[2]));const a=[0,0,0];return n.queryWeights(a),-1===e.dir&&(a[2]=(0,h.b)(a[0],a[0]=a[2])),o[0]===a[0]&&o[1]===a[1]&&o[2]===a[2]}(0,r.c)("")}function Ts(t,e){const s=t.otherPt.compare(e.otherPt);return 0!==s?s:function(t,e){if(null===t.seg||null===e.seg)return null!==t.seg?-1:null!==e.seg?1:0;const s=t.seg.getGeometryType(),n=e.seg.getGeometryType();return s<n?-1:s>n?1:0}(t,e)}var Ns=r.h,As=r.f,Gs=r.A;function Ms(t){switch(t){case 1:return 1;case 2:return 2;case 3:return 3;case 4:return 4;case 0:return 0;default:(0,r.g)(0,"unrecognized cut side")}return 3}function Fs(t,e,s,n){return new Bs(n).autoCompleteImpl(t,e,s)}function qs(t,e,s,n,i,o,h){const m=new Bs(i);m.m_bOGCOutput=!0;const l=t.getGeometryType()===r.G.enumPolygon&&1===t.getFillRule()&&!(0,a.M)(n);return m.planarSimplifyImpl_(t,e,l,s,n,i,o,h)}function Vs(t,e,s,n,i,r,o,a){return new Bs(r).planarSimplifyImpl_(t,e,s,n,i,r,o,a)}function Ys(t,e,s){return function(t,e,s){const n=t.createInstance(),i=(0,h.m)(h.P,100),o=new Array(100),a=t.getPointCount();let m=!0;const l=2===e.getDimension();1!==e.getDimension()&&2!==e.getDimension()&&(0,r.c)("");for(let r=0;r<a;){const a=t.queryCoordinates(i,i.length,r,-1)-r;l?hs(e,i,a,s.total(),o):ms(e,i,a,s.total(),o);let h=0;for(let e=0;e<a;e++)0===o[e]&&(m&&(m=!1,n.addPoints(t,0,r)),h!==e&&n.addPoints(t,r+h,r+e),h=e+1);m||h===a||n.addPoints(t,r+h,r+a),r+=a}return m?t:n}(t,e,s)}function Xs(t,e,s,n){if(t.getDimension()>e.getDimension())return Us(zs(t),t,e,"^");if(t.getDimension()<e.getDimension())return Us(zs(e),t,e,"^");if(t.isEmpty())return Us(zs(e),t,e,"^");if(e.isEmpty())return Us(zs(t),t,e,"^");const h=new i.Envelope2D;t.queryEnvelope(h);const m=new i.Envelope2D;e.queryEnvelope(m);const l=new i.Envelope2D;l.setCoords({env2D:h}),l.mergeEnvelope2D(m);const u=(0,a.a)(s,l,!0),c=new Bs(n),g=new o.E,d=g.addGeometry(zs(t)),_=g.addGeometry(zs(e));let p=0,f=null;if(g.hasCurves()){f=new ys;const t=g.getEnvelope2D(n);p=Ps(u.total()),ds(g,fs(u.total(),t),u.total(),0,f,null,n)}c.setEditShapeCrackAndCluster(g,u);const P=c.symmetricDifference(d,_);null!==f&&f.stitchCurves(g,P,p,!0);const x=Us(g.getGeometry(P),t,e,"^");return Ns(x.getGeometryType())&&(x.getImpl().setIsSimple(4,u.total()),x.getGeometryType()===r.G.enumPolygon&&x.getImpl().updateOGCFlagsProtected()),x}function ks(t,e,s){return function(t,e,s,n){if(t.isEmpty())return t.createInstance();if(e.isEmpty())return n?t.createInstance():new a.P({copy:t});const i=[new h.P],o=[0],m=2===e.getDimension();1!==e.getDimension()&&2!==e.getDimension()&&(0,r.c)(""),i[0]=t.getXY(),m?hs(e,i,1,s.total(),o):ms(e,i,1,s.total(),o);let l=0===o[0];return n||(l=!l),l?t.createInstance():t}(t,e,s,!0)}function Rs(t,e,s){return t.isEmpty()||e.isEmpty()?t.createInstance():function(t,e,s){const n=(0,a.d)(t);return mt(e.getX(),e.getY(),s.getX(),s.getY(),(0,h.s)(n))}(s,t,e)?new a.P({copy:Ss(t,e)}):t.createInstance()}function Hs(t,e,s,n,i){let h=arguments.length>5&&void 0!==arguments[5]&&arguments[5];0===e&&(0,r.t)("not enough geometries to dissolve");let m=0;for(let r=0,o=e;r<o;r++)m=Math.max(t[r].getDimension(),m);if(2===m||1===m)return new Bs(n).dissolveMultiPaths_(m,!1,t,e,s,i,h);let l=0,u=-1;for(let r=0,o=e;r<o;r++)t[r].getDimension()===m&&(-1===u&&(u=r),t[r].isEmpty()||(u=r,l++));if(l<2)return zs(t[u]);const c=a.n.constructEmpty(),g=new o.E;let d=o.n;for(let r=0,f=e;r<f;r++)if(t[r].getDimension()===m&&!t[r].isEmpty()){d===o.n?d=g.addGeometry(zs(t[r])):g.appendGeometry(d,zs(t[r]));const e=a.n.constructEmpty();t[r].queryLooseEnvelope(e),c.mergeEnv3D(e)}const _=(0,a.a)(s,c.getEnvelope2D(),!0),p=new Bs(n);if(h){const t=(0,a.N)(s,c.getEnvelopeZs(),!0);return p.planarSimplify3DImpl_(g,_,t,0,!0)}return p.m_bOGCOutput=!0,p.planarSimplifyMultiPoints(g,_,!1,-1)}function Ls(t,e,s,n,i){let h=arguments.length>5&&void 0!==arguments[5]&&arguments[5];e<2&&(0,r.t)("not enough geometries to dissolve");let m=0;for(let r=0,o=e;r<o;r++)m=Math.max(t[r].getDimension(),m);if(2===m||1===m)return new Bs(n).dissolveMultiPaths_(m,!0,t,e,s,i,h);const l=a.n.constructEmpty(),u=new o.E;let c=o.n,g=0,d=-1;for(let r=0,P=e;r<P;r++)if(t[r].getDimension()===m&&(-1===d&&(d=r),!t[r].isEmpty())){d=r,c===o.n?c=u.addGeometry(zs(t[r])):u.appendGeometry(c,zs(t[r]));const e=a.n.constructEmpty();t[r].queryLooseEnvelope(e),l.mergeEnv3D(e),g++}if(g<2)return zs(t[d]);const _=0===m?s:null,p=(0,a.a)(_,l.getEnvelope2D(),!0),f=new Bs(n);if(h){const t=(0,a.N)(_,l.getEnvelopeZs(),!0);return f.m_bOGCOutput=!0,f.planarSimplify3DImpl_(u,p,t,0,!0)}return f.planarSimplifyMultiPoints(u,p,!0,-1)}class Bs{constructor(t){this.m_topoGraph=null,this.m_maskLookup=[],this.m_dummyPt1=h.P.getNAN(),this.m_dummyPt2=h.P.getNAN(),this.m_fromEdgeForPolylines=o.n,this.m_progressCounter=0,this.m_bOGCOutput=!1,this.m_progressTracker=t}linesToPolygonsImpl(t,e){let s=0,n=0,i=null;if(t.hasCurves()){i=new ys;const r=t.getEnvelope2D(this.m_progressTracker);n=Ps(e.total());const o=fs(e.total(),r);s=xs(o,n),ds(t,o,e.total(),0,i,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,e.add(s));const r=this.m_topoGraph.createUserIndexForChains(),a=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(a,r,1);for(let m=this.m_topoGraph.getChainFirstIsland(a);m!==o.n;m=this.m_topoGraph.getChainNextInParent(m))this.m_topoGraph.setChainUserIndex(m,r,1);const h=[];for(let m=this.m_topoGraph.getFirstChain();m!==o.n;m=this.m_topoGraph.getChainNext(m)){if(1===this.m_topoGraph.getChainUserIndex(m,r))continue;this.m_topoGraph.setChainUserIndex(m,r,1);for(let t=this.m_topoGraph.getChainFirstIsland(m);t!==o.n;t=this.m_topoGraph.getChainNextInParent(t))this.m_topoGraph.setChainUserIndex(t,r,1);if(0===this.m_topoGraph.getChainArea(m))continue;const e=this.m_topoGraph.extractPolygonFromChainAndIslands(t,o.n,m,o.n);null!=i&&i.stitchCurves(t,e,n,!1);const s=t.getGeometry(e);h.push(s)}return new g.S(h)}autoCompleteImpl(t,e,s){let n=0,i=0,r=null;if(t.hasCurves()){r=new ys;const e=t.getEnvelope2D(this.m_progressTracker);i=Ps(s.total());const o=fs(s.total(),e);n=xs(o,i),ds(t,o,s.total(),0,r,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,s.add(n));const a=this.m_topoGraph.getGeometryID(e),h=this.m_topoGraph.createUserIndexForChains(),m=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(m,h,1);for(let u=this.m_topoGraph.getChainFirstIsland(m);u!==o.n;u=this.m_topoGraph.getChainNextInParent(u))this.m_topoGraph.setChainUserIndex(u,h,1);const l=[];for(let u=this.m_topoGraph.getFirstChain();u!==o.n;u=this.m_topoGraph.getChainNext(u)){if(1===this.m_topoGraph.getChainUserIndex(u,h))continue;this.m_topoGraph.setChainUserIndex(u,h,1);for(let t=this.m_topoGraph.getChainFirstIsland(u);t!==o.n;t=this.m_topoGraph.getChainNextInParent(t))this.m_topoGraph.setChainUserIndex(t,h,1);if(0!==this.m_topoGraph.getChainParentage(u))continue;const e=this.m_topoGraph.getChainHalfEdge(u);let s=e,n=!1;do{const t=this.m_topoGraph.getHalfEdgeTwin(s);if(this.m_topoGraph.getHalfEdgeChain(t)!==u&&this.m_topoGraph.getHalfEdgeParentage(s)&a){n=!0;break}s=this.m_topoGraph.getHalfEdgeNext(s)}while(s!==e);if(!n)continue;if(0===this.m_topoGraph.getChainArea(u))continue;const m=this.m_topoGraph.extractPolygonFromChainAndIslands(t,o.n,u,o.n);null!==r&&r.stitchCurves(t,m,i,!1);const c=t.getGeometry(m);l.push(c)}return new g.S(l)}setEditShape(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this.m_topoGraph&&(this.m_topoGraph=new st),this.m_topoGraph.setEditShape(t,this.m_progressTracker,!0,e)}setEditShapeCrackAndCluster(t,e){Cs(t,e,this.m_progressTracker,!0,!1);for(let s=t.getFirstGeometry();s!==o.n;s=t.getNextGeometry(s))t.getGeometryType(s)===r.G.enumPolygon&&Ht(t,s,-1,this.m_bOGCOutput,o.n,this.m_progressTracker);this.setEditShape(t)}setHalfEdgeOrientations_(t,e){const s=this.m_topoGraph.getShape();for(let n=s.getFirstGeometry();n!==o.n;n=s.getNextGeometry(n))if(n===e)for(let e=s.getFirstPath(n);e!==o.n;e=s.getNextPath(e)){let n=s.getFirstVertex(e);if(n===o.n)continue;let i=s.getNextVertex(n);for(;i!==o.n;){const e=this.m_topoGraph.getClusterFromVertex(n),r=this.m_topoGraph.getClusterFromVertex(i),a=this.m_topoGraph.getHalfEdgeConnector(e,r);if(a!==o.n){const e=this.m_topoGraph.getHalfEdgeTwin(a);this.m_topoGraph.setHalfEdgeUserIndex(a,t,1),this.m_topoGraph.setHalfEdgeUserIndex(e,t,2)}n=i,i=s.getNextVertex(n)}}}flushVertices_(t,e){const s=this.m_topoGraph.getShape(),n=s.hasSegmentParentage(),i=new o.S,r=s.insertPath(t,o.n);e.push(e[0]);const a=e.length;let h=o.n;for(let o=0;o<a;o++){const t=e[o];if(h=s.addVertex(r,t),!n)continue;const m=this.m_topoGraph.getClusterFromVertex(t);if(o>0&&this.m_topoGraph.isBreakNode(m)&&s.setSegmentParentageBreakVertex(h,!0),o<a-1){const t=this.m_topoGraph.getHalfEdgeConnector(m,this.m_topoGraph.getClusterFromVertex(e[o+1])),n=this.m_topoGraph.getSegmentParentage(t);s.setSegmentParentageAndBreak(h,n,o>0||this.m_topoGraph.isBreakNode(m)),this.m_topoGraph.isHalfEdgeCurve(t)&&(this.m_topoGraph.querySegmentXY(t,i),s.setSegmentToIndex(s.getVertexIndex(h),i.get().clone()))}}if(n){const t=this.m_topoGraph.getClusterFromVertex(e[a-1]);this.m_topoGraph.isBreakNode(t)&&s.setSegmentParentageBreakVertex(h,!0)}s.setClosedPath(r,!0)}processPolygonCuts_(t,e,s,n){const i=this.m_topoGraph.getGeometryID(s),a=this.m_topoGraph.getGeometryID(n),h=[],m=this.m_topoGraph.getShape(),l=this.m_topoGraph.createUserIndexForHalfEdges();for(let u=this.m_topoGraph.getFirstCluster();u!==o.n;u=this.m_topoGraph.getNextCluster(u)){const s=this.m_topoGraph.getClusterHalfEdge(u);if(s===o.n)continue;let n=s;do{if(1!==this.m_topoGraph.getHalfEdgeUserIndex(n,l)){let s=n,o=n,u=!1,c=0;do{if(this.m_topoGraph.setHalfEdgeUserIndex(s,l,1),u||this.m_topoGraph.getHalfEdgeParentage(s)&a&&this.m_topoGraph.getHalfEdgeFaceParentage(s)&i&&(o=s,u=!0),u){const e=this.m_topoGraph.getHalfEdgeOrigin(s),n=this.m_topoGraph.getClusterVertexIterator(e),i=this.m_topoGraph.getVertexFromVertexIterator(n);h.push(i),-1!==t&&this.m_topoGraph.getHalfEdgeParentage(s)&a&&(c|=this.m_topoGraph.getHalfEdgeUserIndex(s,t))}s=this.m_topoGraph.getHalfEdgeNext(s)}while(s!==o);if(u&&this.m_topoGraph.getChainArea(this.m_topoGraph.getHalfEdgeChain(o))>0){const t=m.createGeometry(r.G.enumPolygon);this.flushVertices_(t,h),-1!==e&&m.setGeometryUserIndex(t,e,c)}h.length=0}n=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(n))}while(n!==s)}this.m_topoGraph.deleteUserIndexForHalfEdges(l)}cutPolygonPolyline_(t,e,s,n){this.m_topoGraph.removeSpikes_();let i=-1;-1!==t&&(i=this.m_topoGraph.createUserIndexForHalfEdges(),this.setHalfEdgeOrientations_(i,s)),this.processPolygonCuts_(i,t,e,s),-1!==i&&(this.m_topoGraph.deleteUserIndexForHalfEdges(i),i=-1);const r=this.m_topoGraph.getShape();for(let a=r.getFirstGeometry();a!==o.n;a=r.getNextGeometry(a))a!==e&&a!==s&&n.push(a);n.sort(((t,e)=>{const s=r.getFirstPath(t),n=r.getRingArea(s),i=r.getFirstPath(e),o=r.getRingArea(i);return n<o?-1:n>o?1:0}))}cut(t,e,s,n,i){const o=this.m_topoGraph.getShape().getGeometryType(s),a=this.m_topoGraph.getShape().getGeometryType(n),h=(0,r.A)(o),m=(0,r.A)(a);2!==h||1!==m?1!==h||1!==m?(0,r.c)(""):new Ws(this,t,e,s,n,i).Do():this.cutPolygonPolyline_(e,s,n,i)}progress_(){}isGoodParentage(t){return t>=0&&t<this.m_maskLookup.length&&this.m_maskLookup[t]}normalizeInputGeometry(t){const e=t.getGeometryType();if(e===r.G.enumEnvelope){const e=new o.a({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(e===r.G.enumPoint){const e=new o.M({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if((0,r.f)(e)){const e=new o.P({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}return e!==r.G.enumMultiPoint&&e!==r.G.enumPolyline&&e!==r.G.enumPolygon&&(0,r.t)("Unexpected geometry type"),t}dissolveNonSimplePolygons(t,e,s,n){(0,r.g)(e>0);const i=new o.E;let a=0,h=-1;for(let r=0,o=e;r<o;r++)2===t[r].getDimension()&&(-1===h&&(h=r),t[r].isEmpty()||(a++,i.addGeometry(t[r])));return 0===a?((0,r.g)(h>=0),this.normalizeInputGeometry(t[h])):this.planarSimplifyPolygons(i,s,!0,!1,-1,!0)}dissolveMultiPaths_(t,e,s,n,m,l,u){(0,r.g)(t>=1&&t<=2),(0,r.g)(n>0);const c=8&l?1:2,g=a.n.constructEmpty();let d=0,_=-1,p=!0;for(let i=0,o=n;i<o;i++)if(s[i].getDimension()===t&&(-1===_&&(_=i),!s[i].isEmpty())){_=i,d++;const e=a.n.constructEmpty();if(s[i].queryLooseEnvelope(e),g.mergeEnv3D(e),2===t&&p&&s[i].getGeometryType()===r.G.enumPolygon)if(16&l){const t=[0],e=s[i].getImpl().getIsSimple(0,t),n=this.m_bOGCOutput?5===e:(0,a.i)(e);p&&(p=n)}else{const t=(0,a.f)(s[i],0);p&&(p=t)}}if(d<2&&((0,r.g)(_>=0),0===d||!(16&l)))return this.normalizeInputGeometry(s[_]);if(!p){const t=(0,a.a)(e?null:m,g.getEnvelope2D(),!0);return this.dissolveNonSimplePolygons(s,n,t,l)}const f=s.slice(0,n),P=(0,a.a)(m,g.getEnvelope2D(),!0),x=10*(0,a.d)(P);let y=new a.C(0,0);if(u&&(y=(0,a.N)(m,g.getEnvelopeZs(),!0)),1===d&&1===t&&2===c&&!e)return u?((0,r.g)(0),{}):this.m_bOGCOutput?qs(f[_],P,!1,-1,this.m_progressTracker,c,!1):Vs(f[_],P,!1,!1,-1,this.m_progressTracker,c,!1);const E=new a.Q;E.startConstruction();let C=2===t?3:4,S=0;for(let o=0,h=n;o<h;o++){if(f[o].getDimension()!==t||f[o].isEmpty())continue;let s=f[o].getGeometryType();if(s!==r.G.enumEnvelope){if((0,r.f)(s)?(f[o]=this.normalizeInputGeometry(f[o]),s=r.G.enumPolyline):(0,r.g)((0,r.h)(s)),1===t){(0,r.g)(s===r.G.enumPolyline);let t=-1;if(u)(0,r.g)(0,"3d not implemented yet");else{const e=[0];t=f[o].getImpl().getIsSimple(P.total(),e)}if(this.m_bOGCOutput?5!==t:!(0,a.i)(t))if(e)C=-1;else{u?(0,r.g)(0,"3d not implemented yet"):this.m_bOGCOutput?f[o]=qs(f[o],P,!1,-1,this.m_progressTracker,c,!1):f[o]=Vs(f[o],P,!1,!1,-1,this.m_progressTracker,c,!1);const t=[0];(0,r.g)((0,a.i)(f[o].getImpl().getIsSimple(P.total(),t)))}}else{(0,r.g)(s===r.G.enumPolygon);const t=[0],e=f[o].getImpl().getIsSimple(0,t);(0,r.g)((0,a.M)(e))}const n=f[o].getImpl();for(let t=0,e=n.getPathCount();t<e;t++){const e=i.Envelope2D.constructEmpty();n.queryLoosePathEnvelope(t,e),e.inflateCoords(x,x),E.addEnvelope(S,e),S++}}else{(0,r.g)(s===r.G.enumEnvelope);const t=i.Envelope2D.constructEmpty();f[o].queryLooseEnvelope(t),t.inflateCoords(x,x),E.addEnvelope(S,t),S++,C=-1}}E.endConstruction();const v=S,b=(0,h.d)(v,-2147483647),I=(0,h.d)(v,-1);let w=0;_=-1,S=0;for(let i=0,o=n;i<o;i++){if(f[i].getDimension()!==t)continue;if(-1===_&&(_=i),f[i].isEmpty())continue;_=i,w++;const e=f[i].getGeometryType();if((0,r.h)(e))for(let t=0,s=f[i].getPathCount();t<s;t++)I[S]=i,b[S]=-t-1,S++;else(0,r.g)(e===r.G.enumEnvelope),I[S]=i,b[S]=-1,S++}if(w<2&&2===t)return(0,r.g)(_>=0),this.normalizeInputGeometry(f[_]);let D=v;for(;E.next()&&D>0;){this.progress_();const t=E.getHandleA(),e=E.getHandleB(),s=E.getElement(t),n=E.getElement(e);I[s]!==I[n]&&(b[s]<0&&(D--,b[s]=-(b[s]+1)),b[n]<0&&(D--,b[n]=-(b[n]+1)))}const T=new o.E;let N,A=!1,G=0;for(let i=0,a=n;i<a;i++){if(f[i].getDimension()!==t||f[i].isEmpty())continue;const e=f[i].getGeometryType(),s=G;let n=0,a=0;const h=(0,r.h)(e)?f[i]:null;for(let t=s,o=b.length;t<o&&I[t]===i;t++)b[t]>=0&&(n++,a+=h?h.getPathSize(b[t]):(0,r.v)(f[i])),G++;if(a>.95*(0,r.v)(f[i])){T.addGeometry(this.normalizeInputGeometry(f[i]));for(let t=s;t<G;t++)b[t]<0&&(b[t]=-(b[t]+1))}else{if(0===n){A=!0;continue}{A=!0,(0,r.g)((0,r.h)(e)),(0,r.g)(null!=h);const t=new o.a({vd:f[i].getDescription()}),n=new o.P({vd:f[i].getDescription()}),a=e===r.G.enumPolygon?t:n;for(let e=s;e<G;e++)b[e]>=0&&a.addPath(h,b[e],!0);T.addGeometry(a)}}}if(T.getFirstGeometry()!==o.n){const s=2===t,n=e?(0,a.a)(null,g.getEnvelope2D(),!0):P;let i=new a.C(0,0);if(u&&(i=e?(0,a.N)(null,g.getEnvelopeZs(),!0):y),2===t&&!(2&l)){T.collapseAllGeometriesToFirst();let t=0,e=null;if(T.hasCurves()&&!T.hasSegmentParentage()){e=new ys;const s=T.getEnvelope2D(this.m_progressTracker);t=Ps(n.total()),ds(T,fs(n.total(),s),n.total(),0,e,null,this.m_progressTracker)}(function(t,e,s,n){s>0&&ht(t,s,e,!1,n),new Dt(n).executeImpl_(t,e)})(T,T.getFirstGeometry(),n.total(),this.m_progressTracker),null!==e&&e.stitchCurves(T,o.n,t,!0)}if(u)N=this.planarSimplify3DImpl_(T,n,i,c,!0);else if(2===t)N=this.planarSimplifyPolygons(T,n,s,e,-1,!1);else{const t={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};t.ogcRule=this.m_bOGCOutput,t.allCrossRoadsImpassable=!0,t.unsplitBehavior=c,N=this.planarSimplifyPolylines(T,n,e,t,-1)}if(!A){const t=[0];C=N.getImpl().getIsSimple(n.total(),t)}}else(0,r.g)(A),(0,r.g)(_>=0),N=2===t?new o.a({vd:f[_].getDescription()}):new o.P({vd:f[_].getDescription()});if(A){let t=0;for(let e=0,s=b.length;e<s;e++){const s=I[e];if(!(s<0)&&b[e]<0){const n=f[s].getGeometryType(),i=(0,r.h)(n)?f[s]:null;if(i){const s=-(b[e]+1);t+=i.getPathSize(s)}else t+=4}}N.reserve(N.getPointCount()+t);for(let e=0,s=b.length;e<s;e++){const t=I[e];if(!(t<0)&&b[e]<0){const s=f[t].getGeometryType(),n=(0,r.h)(s)?f[t]:null;if(n){const t=-(b[e]+1);N.addPath(n,t,!0)}else s===r.G.enumEnvelope?N.addEnvelope(f[t],!1):((0,r.g)((0,r.f)(s)),N.addSegment(f[t],!0))}}}let M=0;if(2===t?-1!==C&&(C=3,M=e?0:P.total()):((0,r.g)(1===t),e||-1===C||(M=P.total())),u||N.getImpl().setIsSimple(C,M),!e&&A)if(2===t){if(!u)return(new ln).execute(N,m,!1,this.m_progressTracker);(0,r.g)(0,"3d not yet implemented")}else 1===t&&1!==c&&(N=u?((0,r.g)(0),{}):function(t,e,s,n){const i=new Bs(n),a=new o.E,h=a.addGeometry(e),m=i.planarSimplifyNoCrackingAndCluster(t,a,h,s);return(0,r.g)(m,"planar_simplify_no_cracking_and_cluster"),a.getGeometry(h)}(this.m_bOGCOutput,N,c,this.m_progressTracker),N.getImpl().setIsSimple(C,M));return N}dissolveTopoGraphCommonEdges_(){const t=this.m_topoGraph.createUserIndexForHalfEdges(),e=[];for(let s=this.m_topoGraph.getFirstCluster();s!==o.n;s=this.m_topoGraph.getNextCluster(s)){const n=this.m_topoGraph.getClusterHalfEdge(s);let i=n;if(n!==o.n)do{if(this.progress_(),1!==this.m_topoGraph.getHalfEdgeUserIndex(i,t)){const s=this.m_topoGraph.getHalfEdgeTwin(i);this.m_topoGraph.setHalfEdgeUserIndex(s,t,1),this.m_topoGraph.setHalfEdgeUserIndex(i,t,1);const n=this.m_topoGraph.getHalfEdgeFaceParentage(i);if(this.isGoodParentage(n)){const t=this.m_topoGraph.getHalfEdgeFaceParentage(s);this.isGoodParentage(t)&&e.push(i)}}i=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(i))}while(i!==n)}this.m_topoGraph.deleteUserIndexForHalfEdges(t),this.m_topoGraph.deleteEdgesBreakFaces_(e)}chooseVertexByOrder(t,e,s,n){let i=(0,h.j)(),a=o.n;for(let r=this.m_topoGraph.getClusterVertexIterator(t);r!==o.n;r=this.m_topoGraph.incrementVertexIterator(r)){const t=this.m_topoGraph.getVertexFromVertexIterator(r),n=e.getUserIndex(t,s);n>=0&&n<i&&(i=n,a=t)}(0,r.g)(a!==o.n);let m=e.getUserIndex(a,n);return m>0&&(e.setUserIndex(a,n,--m),0===m&&e.setUserIndex(a,s,-1)),a}chooseVertexFromCluster_(t,e){return this.m_topoGraph.getVertexDominantFromCluster(t,e)}chooseVertexFromVertexCluster_(t,e){return this.m_topoGraph.getVertexDominant(t,e)}collectPolygonPathsPreservingFrom_(t,e,s,n,i){const a=this.m_topoGraph.getShape();if(a.getGeometryType(t)!==r.G.enumPolygon)return;const h=a.hasSegmentParentage(),m=new o.S;for(let r=a.getFirstPath(t);r!==o.n;r=a.getNextPath(r)){const t=a.getFirstVertex(r);this.m_topoGraph.getClusterFromVertex(t);const l=this.m_topoGraph.getHalfEdgeFromVertex(t);if(l===o.n)continue;const u=this.m_topoGraph.getHalfEdgeUserIndex(l,s);if(1===u||2===u)continue;const c=this.m_topoGraph.getHalfEdgeFaceParentage(l);if(!this.isGoodParentage(c)){this.m_topoGraph.setHalfEdgeUserIndex(l,s,2);continue}this.m_topoGraph.setHalfEdgeUserIndex(l,s,1);const g=a.insertPath(e,o.n);a.setClosedPath(g,!0);let d=l,_=t,p=this.m_topoGraph.getClusterFromVertex(_),f=1;do{this.progress_();const t=this.chooseVertexFromVertexCluster_(_,i),e=a.addVertex(g,t);if(this.m_topoGraph.isHalfEdgeCurve(d)&&(this.m_topoGraph.querySegmentXY(d,m),a.setSegmentToIndex(a.getVertexIndex(e),m.get().clone())),h){const t=this.m_topoGraph.getSegmentParentage(d);a.setSegmentParentageAndBreak(e,t,this.m_topoGraph.isBreakNode(p))}let r,l;-1!==n&&this.m_topoGraph.setClusterUserIndex(p,n,1),this.m_topoGraph.setHalfEdgeUserIndex(d,s,1),d=this.m_topoGraph.getHalfEdgeNext(d);do{r=1===f?a.getNextVertex(_):a.getPrevVertex(_),l=r!==o.n?this.m_topoGraph.getClusterFromVertex(r):o.n}while(l===p);const u=this.m_topoGraph.getHalfEdgeOrigin(d);if(u!==l){do{r=1===f?a.getPrevVertex(_):a.getNextVertex(_),l=r!==o.n?this.m_topoGraph.getClusterFromVertex(r):o.n}while(l===p);if(u!==l){l=u;const t=this.m_topoGraph.getClusterVertexIterator(l);r=this.m_topoGraph.getVertexFromVertexIterator(t)}else f=-f}p=l,_=r}while(d!==l)}}topoOperationPolygonPolygonHelper_(t,e,s,n,i,r){this.progress_(!0),t!==o.n&&this.collectPolygonPathsPreservingFrom_(t,s,i,r,n),e!==o.n&&this.collectPolygonPathsPreservingFrom_(e,s,i,r,n);const a=new o.S,h=this.m_topoGraph.getShape();h.dbgVerifyCurves();const m=h.hasSegmentParentage();for(let l=this.m_topoGraph.getFirstCluster();l!==o.n;l=this.m_topoGraph.getNextCluster(l)){const t=this.m_topoGraph.getClusterHalfEdge(l);if(t===o.n)continue;let e=t;do{this.progress_();const t=this.m_topoGraph.getHalfEdgeUserIndex(e,i);if(1!==t&&2!==t){const t=this.m_topoGraph.getHalfEdgeFaceParentage(e);if(this.isGoodParentage(t)){const t=h.insertPath(s,o.n);h.setClosedPath(t,!0);let l=e;do{const e=this.m_topoGraph.getHalfEdgeVertexIterator(l);let s=o.n;if(e!==o.n)s=this.m_topoGraph.getVertexFromVertexIterator(e);else{const t=this.m_topoGraph.getHalfEdgeVertexIterator(this.m_topoGraph.getHalfEdgeTwin(l));s=this.m_topoGraph.getVertexFromVertexIterator(t),s=h.getNextVertex(s)}const u=this.chooseVertexFromVertexCluster_(s,n),c=h.addVertex(t,u);if(m){const t=this.m_topoGraph.getSegmentParentage(l),e=this.m_topoGraph.getHalfEdgeOrigin(l);h.setSegmentParentageAndBreak(c,t,this.m_topoGraph.isBreakNode(e))}if(this.m_topoGraph.isHalfEdgeCurve(l)&&(this.m_topoGraph.querySegmentXY(l,a),h.setSegmentToIndex(h.getVertexIndex(c),a.get().clone())),this.m_topoGraph.setHalfEdgeUserIndex(l,i,1),-1!==r){const t=this.m_topoGraph.getClusterFromVertex(u);this.m_topoGraph.setClusterUserIndex(t,r,1)}l=this.m_topoGraph.getHalfEdgeNext(l)}while(l!==e)}else this.m_topoGraph.setHalfEdgeUserIndex(e,i,2)}e=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(e))}while(e!==t)}}topoOperationPolygonPolygon_(t,e,s){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.dissolveTopoGraphCommonEdges_();const i=this.m_topoGraph.getShape(),a=i.createGeometry(r.G.enumPolygon),h=this.m_topoGraph.createUserIndexForHalfEdges();return this.topoOperationPolygonPolygonHelper_(t,e,a,s,h,-1),this.m_topoGraph.deleteUserIndexForHalfEdges(h),n||Ht(i,a,3,this.m_bOGCOutput,o.n,this.m_progressTracker),a}topoOperationPolyline_(t,e){const s={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return s.allCrossRoadsImpassable=!1,s.ogcRule=e,s.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(o.n,t,!1,s).first}topoOperationMultiPoint_(){const t=this.m_topoGraph.getShape(),e=t.createGeometry(r.G.enumMultiPoint),s=t.insertPath(e,o.n);for(let n=this.m_topoGraph.getFirstCluster();n!==o.n;n=this.m_topoGraph.getNextCluster(n)){const e=this.m_topoGraph.getClusterParentage(n);if(this.isGoodParentage(e)){let e=o.n;for(let s=this.m_topoGraph.getClusterVertexIterator(n);s!==o.n;s=this.m_topoGraph.incrementVertexIterator(s)){const n=this.m_topoGraph.getVertexFromVertexIterator(s);e===o.n&&(e=n);const i=t.getGeometryFromPath(t.getPathFromVertex(n)),r=this.m_topoGraph.getGeometryID(i);if(this.isGoodParentage(r)){e=n;break}}t.addVertex(s,e)}}return e}intersection(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),n=this.m_topoGraph.getShape().getGeometryType(e),i=(0,r.A)(s),a=(0,r.A)(n),h=this.m_topoGraph.getGeometryID(t),m=this.m_topoGraph.getGeometryID(e);(0,r.g)(h>=0),(0,r.g)(m>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(h|m),this.m_maskLookup[h|m]=!0;let l=o.n;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(l=t),2===i&&2===a?this.topoOperationPolygonPolygon_(t,e,l):1===i&&a>0||1===a&&i>0?this.topoOperationPolyline_(l,this.m_bOGCOutput):0===i||0===a?this.topoOperationMultiPoint_():void(0,r.c)("")}topoOperationPolygonPolygonEx(t,e,s){const n=this.m_topoGraph.getShape(),i=n.createGeometry(r.G.enumPolygon),a=n.createGeometry(r.G.enumPolyline),h=n.createGeometry(r.G.enumMultiPoint);this.dissolveTopoGraphCommonEdges_();let m=o.n;const l=this.m_topoGraph.createUserIndexForHalfEdges(),u=this.m_topoGraph.createUserIndexForClusters();n.dbgVerifyCurves(),this.topoOperationPolygonPolygonHelper_(t,e,i,s,l,u),n.dbgVerifyCurves();const c=n.hasSegmentParentage(),g=new o.S;for(let r=this.m_topoGraph.getFirstCluster();r!==o.n;r=this.m_topoGraph.getNextCluster(r)){const t=this.m_topoGraph.getClusterHalfEdge(r);if(t===o.n)continue;let e=t;do{let t=this.m_topoGraph.getHalfEdgeUserIndex(e,l),i=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(e),l),h=t|i;if(2===h){let m=this.m_topoGraph.getHalfEdgeParentage(e);if(this.isGoodParentage(m)){const d=n.insertPath(a,o.n);let _=e;const p=this.chooseVertexFromCluster_(r,s);let f=n.addVertex(d,p);if(c){const t=this.m_topoGraph.getSegmentParentage(e),s=this.m_topoGraph.getHalfEdgeOrigin(e);n.setSegmentParentageAndBreak(f,t,this.m_topoGraph.isBreakNode(s))}this.m_topoGraph.isHalfEdgeCurve(e)&&(this.m_topoGraph.querySegmentXY(e,g),n.setSegmentToIndex(n.getVertexIndex(f),g.get().clone())),this.m_topoGraph.setClusterUserIndex(r,u,1);do{this.progress_();const r=this.m_topoGraph.getHalfEdgeTo(_),o=this.chooseVertexFromCluster_(r,s);if(f=n.addVertex(d,o),c){const t=this.m_topoGraph.getSegmentParentage(e),s=this.m_topoGraph.getHalfEdgeOrigin(e);n.setSegmentParentageAndBreak(f,t,this.m_topoGraph.isBreakNode(s))}if(this.m_topoGraph.setHalfEdgeUserIndex(_,l,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_),l,1),this.m_topoGraph.setClusterUserIndex(r,u,1),_=this.m_topoGraph.getHalfEdgeNext(_),t=this.m_topoGraph.getHalfEdgeUserIndex(_,l),i=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_),l),h=t|i,2!==h)break;if(m=this.m_topoGraph.getHalfEdgeParentage(_),!this.isGoodParentage(m)){this.m_topoGraph.setHalfEdgeUserIndex(_,l,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_),l,1);break}this.m_topoGraph.isHalfEdgeCurve(e)&&_!==e&&(this.m_topoGraph.querySegmentXY(e,g),n.setSegmentToIndex(n.getVertexIndex(f),g.get().clone()))}while(_!==e)}else this.m_topoGraph.setHalfEdgeUserIndex(e,l,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(e),l,1)}e=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(e))}while(e!==t)}for(let r=this.m_topoGraph.getFirstCluster();r!==o.n;r=this.m_topoGraph.getNextCluster(r)){if(this.progress_(),1===this.m_topoGraph.getClusterUserIndex(r,u))continue;const t=this.m_topoGraph.getClusterParentage(r);if(this.isGoodParentage(t)){m===o.n&&(m=n.insertPath(h,o.n));const t=this.m_topoGraph.getClusterVertexIterator(r);let e=o.n;if(t!==o.n){e=this.m_topoGraph.getVertexFromVertexIterator(t);const i=this.chooseVertexFromVertexCluster_(e,s);n.addVertex(m,i)}}}this.m_topoGraph.deleteUserIndexForClusters(u),this.m_topoGraph.deleteUserIndexForHalfEdges(l),n.dbgVerifyCurves(),Ht(n,i,3,this.m_bOGCOutput,o.n,this.m_progressTracker);const d=[o.n,o.n,o.n];return d[0]=h,d[1]=a,d[2]=i,d}topoOperationPolylinePolylineOrPolygonEx(t,e){const s={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return s.allCrossRoadsImpassable=!1,s.ogcRule=e,s.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(o.n,t,!0,s)}topoOperationMultiPoint(){const t=this.m_topoGraph.getShape(),e=t.createGeometry(r.G.enumMultiPoint),s=t.insertPath(e,o.n);for(let n=this.m_topoGraph.getFirstCluster();n!==o.n;n=this.m_topoGraph.getNextCluster(n)){const e=this.m_topoGraph.getClusterParentage(n);if(this.isGoodParentage(e)){let e=o.n;for(let s=this.m_topoGraph.getClusterVertexIterator(n);s!==o.n;s=this.m_topoGraph.incrementVertexIterator(s)){const n=this.m_topoGraph.getVertexFromVertexIterator(s);e===o.n&&(e=n);const i=t.getGeometryFromPath(t.getPathFromVertex(n)),r=this.m_topoGraph.getGeometryID(i);if(this.isGoodParentage(r)){e=n;break}}t.addVertex(s,e)}}return e}intersectionEx(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),n=this.m_topoGraph.getShape().getGeometryType(e),i=Gs(s),a=Gs(n),h=this.m_topoGraph.getGeometryID(t),m=this.m_topoGraph.getGeometryID(e);(0,r.g)(h>=0),(0,r.g)(m>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(h|m),this.m_maskLookup[h|m]=!0;let l=o.n;if(this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(l=t),2===i&&2===a)return this.topoOperationPolygonPolygonEx(t,e,l);if(1===i&&a>0||1===a&&i>0){const{first:t,second:e}=this.topoOperationPolylinePolylineOrPolygonEx(l,this.m_bOGCOutput);return[e,t]}if(0===i||0===a){const t=[];return t.push(this.topoOperationMultiPoint()),t}(0,r.c)("")}getCombinedHalfEdgeParentage(t){return this.m_topoGraph.getHalfEdgeParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t))}prevailingDirection(t,e){const s=this.getCombinedHalfEdgeParentage(e),n=this.m_topoGraph.getHalfEdgeOrigin(e),i=this.m_topoGraph.getHalfEdgeTo(e);let r=0,a=0;for(let h=this.m_topoGraph.getClusterVertexIterator(n);h!==o.n;h=this.m_topoGraph.incrementVertexIterator(h)){const n=this.m_topoGraph.getVertexFromVertexIterator(h),m=t.getPathFromVertex(n),l=t.getGeometryFromPath(m),u=this.m_topoGraph.getGeometryID(l),c=t.getFirstVertex(m),g=!!(u&s);g&&c===n&&(this.m_fromEdgeForPolylines=e);const d=t.getNextVertex(n);if(d!==o.n&&this.m_topoGraph.getClusterFromVertex(d)===i){if(r++,g){if(this.m_fromEdgeForPolylines===o.n&&c===d){const t=this.m_topoGraph.getHalfEdgeNext(e);this.isGoodParentage(this.getCombinedHalfEdgeParentage(t))&&(this.m_fromEdgeForPolylines=t)}a++}}else{const s=t.getPrevVertex(n);if(s!==o.n&&this.m_topoGraph.getClusterFromVertex(s)===i&&(r--,g)){if(this.m_fromEdgeForPolylines===o.n&&c===s){const t=this.m_topoGraph.getHalfEdgeNext(e);this.isGoodParentage(this.getCombinedHalfEdgeParentage(t))&&(this.m_fromEdgeForPolylines=t)}a--}}}return this.m_topoGraph.queryXY(n,this.m_dummyPt1),this.m_topoGraph.queryXY(i,this.m_dummyPt2),(0!==a?a:r)*h.P.distance(this.m_dummyPt1,this.m_dummyPt2)}tryMoveThroughCrossroadBackwards(t,e){const s=this.m_topoGraph.getHalfEdgePrev(t),n=this.m_topoGraph.getHalfEdgeTwin(s);if(!e){if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t)))return o.n;const e=this.m_topoGraph.getHalfEdgeTwin(t);if(n===this.m_topoGraph.getHalfEdgeNext(e))return s}let i=n,r=o.n;for(;i!==t;){const t=this.getCombinedHalfEdgeParentage(i);if(this.isGoodParentage(t)){if(r!==o.n)return o.n;r=this.m_topoGraph.getHalfEdgeTwin(i)}i=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgePrev(i))}return r}tryMoveThroughCrossroadForward(t,e){const s=this.m_topoGraph.getHalfEdgeNext(t),n=this.m_topoGraph.getHalfEdgeTwin(s);if(!e){const e=this.m_topoGraph.getHalfEdgeTwin(t);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e)))return o.n;if(n===this.m_topoGraph.getHalfEdgePrev(e))return s}let i=n,r=o.n;for(;i!==t;){const t=this.getCombinedHalfEdgeParentage(i);if(this.isGoodParentage(t)){if(r!==o.n)return o.n;r=this.m_topoGraph.getHalfEdgeTwin(i)}i=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgeNext(i))}return r}isOnALoop(t,e){let s=t;const n=2*this.m_topoGraph.getShape().getTotalPointCount()+10;for(let i=0;i<n;i++){if(1===this.m_topoGraph.getHalfEdgeUserIndex(s,e))return!1;const n=this.m_topoGraph.getHalfEdgeNext(s);if(n===this.m_topoGraph.getHalfEdgeTwin(s))return!1;if(s=n,s===t)return!0}(0,r.c)("is_on_a_loop_")}restorePolylineParts(t,e,s,n,i,a,m,l,u,c){(0,r.g)(i===o.n&&a>=0&&m>=0||-1===a&&-1===m),(0,r.g)(-1===l&&1!==c.unsplitBehavior||-1!==l&&1===c.unsplitBehavior);const g=c.ogcRule,d=c.allCrossRoadsImpassable,_=1===c.unsplitBehavior,p=0===c.unsplitBehavior,f=this.m_topoGraph.getShape(),P=f.hasSegmentParentage();let x=t,y=this.m_topoGraph.getHalfEdgeTwin(x);const E=new o.S;this.m_fromEdgeForPolylines=o.n;let C=this.prevailingDirection(f,x),S=x,v=o.n,b=!1,I=!1,w=!1;if(!_)for(;;){const e=this.m_topoGraph.getHalfEdgePrev(x);if(e===y){w=!0;break}const n=this.m_topoGraph.getHalfEdgeNext(y);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(n))){b=!0;break}if(this.m_topoGraph.getHalfEdgeTwin(e)!==n){if(d){b=!0;break}if(x=this.tryMoveThroughCrossroadBackwards(x,!0),x===o.n){b=!0;break}y=this.m_topoGraph.getHalfEdgeTwin(x)}else x=e,y=n;if(1===this.m_topoGraph.getHalfEdgeUserIndex(x,s)){w=!0;break}if(x===t){v=t,I=!0;break}const i=this.getCombinedHalfEdgeParentage(x);if(!this.isGoodParentage(i))break;S=x,C+=this.prevailingDirection(f,x)}if(v===o.n){for(x=t,y=this.m_topoGraph.getHalfEdgeTwin(x),v=x;;){const t=this.m_topoGraph.getHalfEdgeNext(x),e=this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t));if(e){b=!0;break}if(t===y){w=!0;break}if(-1!==l){const t=this.m_topoGraph.getHalfEdgeOrigin(y);if(1===this.m_topoGraph.getClusterUserIndex(t,l)){b=!0;break}}const n=this.m_topoGraph.getHalfEdgePrev(y);if(this.m_topoGraph.getHalfEdgeTwin(t)!==n){if(e||d){b=!0;break}if(x=this.tryMoveThroughCrossroadForward(x,!0),x===o.n){b=!0;break}y=this.m_topoGraph.getHalfEdgeTwin(x)}else x=t,y=n;if(1===this.m_topoGraph.getHalfEdgeUserIndex(x,s)){w=!0;break}const i=this.getCombinedHalfEdgeParentage(x);if(!this.isGoodParentage(i))break;v=x,C+=this.prevailingDirection(f,x)}const e=this.m_topoGraph.getHalfEdgeOrigin(S);I=this.m_topoGraph.getHalfEdgeTo(v)===e}else if(this.m_fromEdgeForPolylines!==o.n){S=t,v=this.tryMoveThroughCrossroadBackwards(S,!1),(0,r.g)(v!==o.n);const e=this.m_topoGraph.getHalfEdgeTwin(S);this.m_topoGraph.getHalfEdgeNext(e)}let D=I;I||w||u&&(D=this.isOnALoop(t,s),D||(D=this.isOnALoop(y,s)));const T=C>=0;let N=!1;D&&b&&(I?(N=g,T&&(N||_||p)&&S!==t&&((0,r.g)(!_),S=t,N=!1)):(_||T&&p)&&(S=t));let A=0;for(x=S;y=this.m_topoGraph.getHalfEdgeTwin(x),this.m_topoGraph.setHalfEdgeUserIndex(x,s,1),this.m_topoGraph.setHalfEdgeUserIndex(y,s,1),A++,x!==v;)x=d?this.m_topoGraph.getHalfEdgeNext(x):this.tryMoveThroughCrossroadForward(x,!1);T||(v=(0,h.b)(S,S=v),v=this.m_topoGraph.getHalfEdgeTwin(v),S=this.m_topoGraph.getHalfEdgeTwin(S));let G=f.insertPath(e,o.n);x=S;const M=this.m_topoGraph.getHalfEdgeOrigin(S);let F;F=-1!==a?this.chooseVertexByOrder(M,f,a,m):this.chooseVertexFromCluster_(M,i),this.m_topoGraph.isStrongPathNode(M)&&f.setStrongPathStart(G,!0);let q=f.addVertex(G,F),V=q;-1!==n&&this.m_topoGraph.setClusterUserIndex(M,n,1);let Y=0;const X=N?Math.trunc((A+1)/2):-1;let k=o.n,R=!0,H=o.n;for(;;){if(P){const t=this.m_topoGraph.getSegmentParentage(x),e=this.m_topoGraph.getHalfEdgeOrigin(x);f.setSegmentParentageAndBreak(V,t,R||this.m_topoGraph.isBreakNode(e))}R=!1,this.m_topoGraph.isHalfEdgeCurve(x)&&(this.m_topoGraph.querySegmentXY(x,E),f.setSegmentToIndex(f.getVertexIndex(V),E.get().clone())),k!==o.n&&-1!==m&&f.addToUserIndex(k,m,-1);const t=d?this.m_topoGraph.getHalfEdgeNext(x):this.tryMoveThroughCrossroadForward(x,!1),s=this.m_topoGraph.getHalfEdgeTo(x);let r;if(r=-1!==a?this.chooseVertexByOrder(s,f,a,m):this.chooseVertexFromCluster_(s,i),q=f.addVertex(G,r),H=s,-1!==n&&this.m_topoGraph.setClusterUserIndex(s,n,1),P&&this.m_topoGraph.isBreakNode(s)&&f.setSegmentParentageBreakVertex(q,!0),k=r,Y++,N&&Y===X&&(G=f.insertPath(e,o.n),q=f.addVertex(G,r),R=!0,-1!==m&&f.addToUserIndex(r,m,-1),k=o.n),x===v)break;x=t,V=q}H!==o.n&&this.m_topoGraph.isStrongPathNode(H)&&f.setStrongPathEnd(G,!0)}topoOperationPolylineSimplify_(t,e){return this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,o.n,!1,e).first}topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,e,s,n){(0,r.g)(e===o.n||t===o.n);const i=this.m_topoGraph.getShape(),a=e=>t===o.n?e===o.n?i.getFirstGeometry():i.getNextGeometry(e):e===o.n?t:o.n,m=i.createGeometry(r.G.enumPolyline);let l=-1;s&&(l=this.m_topoGraph.createUserIndexForClusters());const u=this.m_topoGraph.createUserIndexForHalfEdges(),c=e===o.n?i.createUserIndex():-1,g=e===o.n?i.createUserIndex():-1;let d=-1;if(1===n.unsplitBehavior){d=this.m_topoGraph.createUserIndexForClusters();for(let t=a(o.n);t!==o.n;t=a(t))for(let e=i.getFirstPath(t);e!==o.n;e=i.getNextPath(e)){{const t=i.getFirstVertex(e),s=this.m_topoGraph.getClusterFromVertex(t);this.m_topoGraph.setClusterUserIndex(s,d,1)}if(!i.isClosedPath(e)){const t=i.getLastVertex(e),s=this.m_topoGraph.getClusterFromVertex(t);this.m_topoGraph.setClusterUserIndex(s,d,1)}}}if(e===o.n){let t=0;for(let e=a(o.n);e!==o.n;e=a(e))for(let s=i.getFirstPath(e);s!==o.n;s=i.getNextPath(s))if(i.isClosedPath(s)){let e=i.getFirstVertex(s);for(let n=0,r=i.getPathSize(s);n<r;n++,e=i.getNextVertex(e))i.setUserIndex(e,c,t++),i.setUserIndex(e,g,2)}else{const e=i.getFirstVertex(s);i.setUserIndex(e,c,t++),i.setUserIndex(e,g,1);let n=i.getNextVertex(e);for(let r=1,o=i.getPathSize(s)-1;r<o;++r)i.setUserIndex(n,c,t++),i.setUserIndex(n,g,2),n=i.getNextVertex(n);i.setUserIndex(n,c,t++),i.setUserIndex(n,g,1)}}for(let r=a(o.n);r!==o.n;r=a(r))for(let t=i.getFirstPath(r);t!==o.n;t=i.getNextPath(t)){let s=i.getFirstVertex(t);for(let r=0,a=i.getPathSize(t);r<a;r++,s=i.getNextVertex(s)){const t=this.m_topoGraph.getHalfEdgeFromVertex(s);if(t===o.n)continue;if(1===this.m_topoGraph.getHalfEdgeUserIndex(t,u))continue;const i=this.getCombinedHalfEdgeParentage(t);if(this.isGoodParentage(i)){const s=0===r;this.restorePolylineParts(t,m,u,l,e,c,g,d,s,n)}}}let _=o.n;if(s){_=i.createGeometry(r.G.enumMultiPoint);let t=o.n;for(let s=this.m_topoGraph.getFirstCluster();s!==o.n;s=this.m_topoGraph.getNextCluster(s))if(this.progress_(),1!==this.m_topoGraph.getClusterUserIndex(s,l)){const n=this.m_topoGraph.getClusterParentage(s);if(this.isGoodParentage(n)){t===o.n&&(t=i.insertPath(_,o.n));const n=this.m_topoGraph.getClusterVertexIterator(s);if(n!==o.n){let r;this.m_topoGraph.getVertexFromVertexIterator(n),r=-1!==c?this.chooseVertexByOrder(s,i,c,g):this.chooseVertexFromCluster_(s,e),i.addVertex(t,r)}}}}return-1!==g&&i.removeUserIndex(g),-1!==c&&i.removeUserIndex(c),-1!==l&&i.removeUserIndex(l),this.m_topoGraph.deleteUserIndexForHalfEdges(u),(0,h.n)(m,_)}difference(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),n=this.m_topoGraph.getShape().getGeometryType(e),i=(0,r.A)(s),a=(0,r.A)(n);if(i>a)return t;const h=this.m_topoGraph.getGeometryID(t),m=this.m_topoGraph.getGeometryID(e);if(this.m_maskLookup.length=0,this.m_maskLookup.length=1+(h|m),this.m_maskLookup[h]=!0,2===i&&2===a){let s=o.n;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(s=t),this.topoOperationPolygonPolygon_(t,e,s)}if(1===i&&2===a){const e={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return e.allCrossRoadsImpassable=!1,e.ogcRule=this.m_bOGCOutput,e.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,o.n,!1,e).first}if(1===i&&1===a){const e={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return e.allCrossRoadsImpassable=!0,e.ogcRule=this.m_bOGCOutput,e.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,o.n,!1,e).first}if(0===i)return this.topoOperationMultiPoint_();(0,r.c)("")}symmetricDifference(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),n=this.m_topoGraph.getShape().getGeometryType(e),i=Gs(s),a=Gs(n),h=this.m_topoGraph.getGeometryID(t),m=this.m_topoGraph.getGeometryID(e);return(0,r.g)(h>=0),(0,r.g)(m>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(h|m),this.m_maskLookup[h]=!0,this.m_maskLookup[h]=!0,this.m_maskLookup[m]=!0,2===i&&2===a?this.topoOperationPolygonPolygon_(t,e,o.n):1===i&&1===a?this.topoOperationPolyline_(o.n,this.m_bOGCOutput):0===i&&0===a?this.topoOperationMultiPoint():void(0,r.c)("")}planarSimplifyNoCrackingAndCluster(t,e,s,n){this.m_bOGCOutput=t,this.m_topoGraph=new st;const i=e.getFillRule(s),a=e.getGeometryType(s);if(1!==i||a===r.G.enumMultiPoint?this.m_topoGraph.setAndSimplifyEditShapeAlternate(e,s,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeWinding(e,s,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return!1;this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const h=this.m_topoGraph.getGeometryID(s);if((0,r.g)(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=h+1,this.m_maskLookup[h]=!0,e.getGeometryType(s)===r.G.enumPolygon||1===i&&e.getGeometryType(s)!==r.G.enumMultiPoint){e.setFillRule(s,0);const r=this.topoOperationPolygonPolygon_(s,o.n,o.n);if(e.swapGeometry(r,s),e.removeGeometry(r),1===i&&this.m_bOGCOutput)return this.planarSimplifyNoCrackingAndCluster(t,e,s,n)}else if(e.getGeometryType(s)===r.G.enumPolyline){const t={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};t.ogcRule=this.m_bOGCOutput,t.allCrossRoadsImpassable=!0,t.unsplitBehavior=n;const i=this.topoOperationPolylineSimplify_(e.getFirstGeometry(),t);e.swapGeometry(i,s),e.removeGeometry(i)}else if(e.getGeometryType(s)===r.G.enumMultiPoint){const t=this.topoOperationMultiPoint_();e.swapGeometry(t,s),e.removeGeometry(t)}else(0,r.c)("");return!0}unsplitPolylineExact(t){return(0,r.g)(0),new o.P}planarSimplifyPolylines(t,e,s,n,i){for(let d=t.getFirstGeometry();d!==o.n;d=t.getNextGeometry(d)){const e=t.getGeometryType(d);(0,r.g)(e===r.G.enumPolyline)}let a=0,h=0,m=null;if(t.hasCurves()&&!t.hasSegmentParentage()){m=new ys;const s=t.getEnvelope2D(this.m_progressTracker);h=Ps(e.total());const n=fs(e.total(),s);a=xs(n,h),ds(t,n,e.total(),0,m,null,this.m_progressTracker)}{const s=bs(e.add(a));t.filterClosePoints(s,!1,!1,!1,o.n)}if(this.m_topoGraph=new st,4!==i&&5!==i)if(null===m&&s){const n=new It(this.m_progressTracker,!1);n.sweepVertical(t,e.total()),n.hadComplications()?(Cs(t,e,this.m_progressTracker,!0,!1),s=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(e.total())}else Cs(t,e.add(a),this.m_progressTracker,!0,!1),s=!1;else s=!1;t.removeSelection(),t.collapseAllGeometriesToFirst();const l=t.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,l,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return(0,r.g)(s&&null===m),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolylines(t,e,!1,n,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const u=this.m_topoGraph.getGeometryID(l);(0,r.g)(u>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=u+1,this.m_maskLookup[u]=!0;const c=this.topoOperationPolylineSimplify_(t.getFirstGeometry(),n);null!==m&&m.stitchCurves(t,c,h,!0);const g=t.getGeometry(c);return s||g.getImpl().setIsSimple(4,e.total()),g}planarSimplifyMultiPoints(t,e,s,n){for(let l=t.getFirstGeometry();l!==o.n;l=t.getNextGeometry(l)){const e=t.getGeometryType(l);(0,r.g)(e===r.G.enumMultiPoint)}this.m_topoGraph=new st,4!==n&&5!==n?(Cs(t,e,this.m_progressTracker,!0,!1),s=!1):s=!1,t.removeSelection(),t.collapseAllGeometriesToFirst();const i=t.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,i,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return(0,r.g)(s),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyMultiPoints(t,e,!1,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const a=this.m_topoGraph.getGeometryID(i);(0,r.g)(a>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=a+1,this.m_maskLookup[a]=!0;const h=this.topoOperationMultiPoint(),m=t.getGeometry(h);return s||m.getImpl().setIsSimple(4,e.total()),m}planarSimplifyPolygons(t,e,s,n,i,a){for(let f=t.getFirstGeometry();f!==o.n;f=t.getNextGeometry(f)){const e=t.getGeometryType(f);(0,r.g)(e===r.G.enumPolygon||e===r.G.enumPolyline&&s)}let h=0,m=0,l=null;if(t.hasCurves()&&!t.hasSegmentParentage()){l=new ys;const s=t.getEnvelope2D(this.m_progressTracker);m=Ps(e.total());const n=fs(e.total(),s);h=xs(n,m),ds(t,n,e.total(),0,l,null,this.m_progressTracker)}if(a){Cs(t,e.add(h),this.m_progressTracker,!0,!1);for(let e=t.getFirstGeometry();e!==o.n;e=t.getNextGeometry(e))t.getGeometryType(e)===r.G.enumPolygon&&Ht(t,e,-1,!1,o.n,this.m_progressTracker)}if(this.m_topoGraph=new st,a||4===i||5===i)n=!1;else if(null===l&&n){const s=new It(this.m_progressTracker,!1);s.sweepVertical(t,e.total()),s.hadComplications()?(Cs(t,e,this.m_progressTracker,!0,!1),n=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(e.total())}else Cs(t,e.add(h),this.m_progressTracker,!0,!1),n=!1;t.removeSelection(),t.collapseAllGeometriesToFirst();const u=t.getFirstGeometry();if(s?this.m_topoGraph.setAndSimplifyEditShapeWinding(t,u,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,u,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return(0,r.g)(n&&null===l),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolygons(t,e,s,!1,-1,!1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const c=this.m_topoGraph.getGeometryID(u);(0,r.g)(c>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=c+1,this.m_maskLookup[c]=!0,t.setFillRule(u,0);const g=this.m_bOGCOutput&&s,d=g;let _=this.topoOperationPolygonPolygon_(u,o.n,o.n,d);g&&(this.m_topoGraph.removeShape(),this.m_topoGraph=null,t.removeGeometry(u),this.m_topoGraph=new st,this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,_,this.m_progressTracker),_=this.topoOperationPolygonPolygon_(_,o.n,o.n,!1)),null!==l&&l.stitchCurves(t,_,m,!0);const p=t.getGeometry(_);return p.setFillRule(0),n?p.getImpl().setIsSimple(3,0):(p.getImpl().setIsSimple(4,e.total()),p.getImpl().updateOGCFlagsProtected()),p}planarSimplify3DImpl_(t,e,s,n,i){return(0,r.g)(0),{}}planarSimplifyImpl_(t,e,s,n,i,h,m,l){if(t.isEmpty())return t.clone();const u=t.getGeometryType(),c=new o.E,g=c.addGeometry(t);if((0,a.M)(i)&&u===r.G.enumPolygon&&(s=!1,c.setFillRule(g,0)),l&&(t.hasAttribute(1)&&c.replaceNaNs(1,0),c.removeNaNVertices()),u===r.G.enumPolygon||u===r.G.enumPolyline&&s)return this.planarSimplifyPolygons(c,e,s,n,i,!1);if(u===o.P.type){const t={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return t.allCrossRoadsImpassable=!0,t.ogcRule=this.m_bOGCOutput,t.unsplitBehavior=m,this.planarSimplifyPolylines(c,e,n,t,i)}if(u===r.G.enumMultiPoint)return this.planarSimplifyMultiPoints(c,e,n,i);(0,r.c)("what else?")}}function Us(t,e,s,n){const i=t.getGeometryType();if(i===r.G.enumEnvelope){const e=new o.a({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(i===r.G.enumPoint&&("|"===n||"^"===n)){const e=new o.M({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if(i===r.G.enumLine){const e=new o.P({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}if(i===r.G.enumMultiPoint&&"-"===n&&e.getGeometryType()===r.G.enumPoint){const e=new a.P({vd:t.getDescription()});return t.isEmpty()||t.getPointByVal(0,e),e}if(i===r.G.enumMultiPoint&&"&"===n&&e.getGeometryType()===r.G.enumPoint){const e=new a.P({vd:t.getDescription()});return t.isEmpty()||t.getPointByVal(0,e),e}return t}function zs(t){const e=t.getGeometryType();if(e===r.G.enumEnvelope){const e=new o.a({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(e===r.G.enumPoint){const e=new o.M({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if(As(e)){const e=new o.P({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}return e!==r.G.enumMultiPoint&&e!==r.G.enumPolyline&&e!==r.G.enumPolygon&&(0,r.t)("Unexpected geometry type"),t}function Os(t,e,s,n){const i=s===o.n?t.getClusterHalfEdge(e):s;let a=i;(0,r.g)(t.getHalfEdgeOrigin(i)===e);do{n(a),a=t.getHalfEdgeNext(t.getHalfEdgeTwin(a))}while(a!==i)}class Ws{constructor(t,e,s,n,i,r){this.m_rParent=t,this.m_rTopoGraph=t.m_topoGraph,this.m_rShape=this.m_rTopoGraph.getShape(),this.m_IDCuttee=this.m_rTopoGraph.getGeometryID(n),this.m_IDCutter=this.m_rTopoGraph.getGeometryID(i),this.m_IDBoth=this.m_IDCuttee|this.m_IDCutter,this.m_bConsiderTouch=e,this.m_sideIndex=s,this.m_cuttee=n,this.m_cutter=i,this.m_rCutHandles=r,this.m_cutteeBreadcrumbsIndex=this.m_rShape.createUserIndexUninitialized(),this.m_clusterParentageIndex=this.m_rShape.createUserIndexUninitialized();for(let a=this.m_rShape.getFirstPath(this.m_cuttee);a!==o.n;a=this.m_rShape.getNextPath(a)){let t=0;const e=this.m_rShape.getPathSize(a);for(let s=this.m_rShape.getFirstVertex(a);t<e;t++,s=this.m_rShape.getNextVertex(s))this.m_rShape.setUserIndex(s,this.m_clusterParentageIndex,this.m_rTopoGraph.getClusterParentage(this.m_rTopoGraph.getClusterFromVertex(s)))}}Do(){this.cutPolylinePolyline_(),this.m_rShape.removeUserIndex(this.m_cutteeBreadcrumbsIndex),this.m_rShape.removeUserIndex(this.m_clusterParentageIndex)}setTbd(t){return 8|t}classifyStandardCut(t,e,s,n){const i=this.m_rShape.getPrevVertex(t),r=this.m_rShape.getNextVertex(t),a=i===o.n?o.n:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(i)),h=r===o.n?o.n:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(r)),m=this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(s)),l=this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(n));let u=1,c=32,g=32;if(Os(this.m_rTopoGraph,e,l,(t=>{t===m&&(u=2),t===a&&(c=u),t===h&&(g=u)})),this.m_bConsiderTouch)32!==c&&this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex)|c),32!==g&&this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|g);else{if(32===c||32===g)return 1;if(c===g&&a!==m&&a!==l&&h!==m&&h!==l)return 1;this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex)|c),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|g)}return 0}classifyTouchCut(t,e,s,n){const i=this.m_rShape.getPrevVertex(t),r=this.m_rShape.getNextVertex(t),a=i===o.n?o.n:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(i)),h=r===o.n?o.n:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(r)),m=s===o.n?o.n:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(s)),l=n===o.n?o.n:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(n));if(!this.m_bConsiderTouch){let e;return(e=m===a||l===a)?this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))):(e=m===h||l===h)&&this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),e?0:1}if(a===o.n)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(h===o.n)return this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),0;if(a===h)return this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(l!==o.n){if(a===l)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(h===l)return this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),0;let s=1;Os(this.m_rTopoGraph,e,l,(e=>{if(e===a){const t=this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,t),s=2}else if(e===h){const e=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,e),s=2}}))}else{if(a===m)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(h===m)return this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),0;let s=2;Os(this.m_rTopoGraph,e,m,(e=>{if(e===a){const t=this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,t),s=1}else if(e===h){const e=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,e),s=1}}))}return 0}classifyCutVertex(t,e){let s=0,n=0;for(let i=this.m_rTopoGraph.getClusterVertexIterator(e);i!==o.n;i=this.m_rTopoGraph.incrementVertexIterator(i)){const r=this.m_rTopoGraph.getVertexFromVertexIterator(i);if(this.m_rShape.getGeometryFromVertex(r)===this.m_cutter){n++;const i=this.m_rShape.getPrevVertex(r),a=this.m_rShape.getNextVertex(r);s+=i===o.n||a===o.n?this.classifyTouchCut(t,e,i,a):this.classifyStandardCut(t,e,i,a)}}n&&s===n&&!this.m_bConsiderTouch&&this.m_rShape.setUserIndex(t,this.m_clusterParentageIndex,this.m_IDCuttee)}cutPolylinePolyline_(){this.m_rShape.getGeometryType(this.m_cuttee),this.m_rShape.getGeometryType(this.m_cutter),this.m_rParent.m_maskLookup.length=0,this.m_rParent.m_maskLookup.length=this.m_IDBoth+1,this.m_rParent.m_maskLookup[this.m_IDBoth]=!0;for(let r=this.m_rShape.getFirstPath(this.m_cuttee);r!==o.n;r=this.m_rShape.getNextPath(r)){const t=this.m_rShape.getPathSize(r);let e=this.m_rShape.getFirstVertex(r);for(let s=0;s<t;++s,e=this.m_rShape.getNextVertex(e))this.m_rShape.setUserIndex(e,this.m_cutteeBreadcrumbsIndex,0);e=this.m_rShape.getFirstVertex(r);for(let s=0;s<t;++s,e=this.m_rShape.getNextVertex(e)){const t=this.m_rTopoGraph.getClusterFromVertex(e);this.m_rTopoGraph.getClusterParentage(t)===this.m_IDBoth&&this.classifyCutVertex(e,t)}}const t=(t,e)=>{let s=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex);const n=this.m_rTopoGraph.getHalfEdgeConnector(this.m_rTopoGraph.getClusterFromVertex(t),this.m_rTopoGraph.getClusterFromVertex(e));return(this.m_rTopoGraph.getHalfEdgeParentage(n)&this.m_IDBoth)===this.m_IDBoth&&(s|=4),s};for(let r=this.m_rShape.getFirstPath(this.m_cuttee);r!==o.n;r=this.m_rShape.getNextPath(r)){let e=this.m_rShape.getFirstVertex(r);const s=this.m_rShape.isClosedPath(r),n=this.m_rShape.getPathSize(r)+(s?1:0);let i=1,o=32;for(let r=this.m_rShape.getNextVertex(e);i<n;++i,e=r,r=this.m_rShape.getNextVertex(r)){const s=t(e,r);this.m_rShape.getUserIndex(e,this.m_clusterParentageIndex)===this.m_IDBoth&&(o=s),32!==o&&this.m_rShape.setUserIndex(e,this.m_cutteeBreadcrumbsIndex,o|s)}e=this.m_rShape.getLastVertex(r);let a=32;i=1;for(let r=this.m_rShape.getPrevVertex(e);i<n;++i,e=r,r=this.m_rShape.getPrevVertex(r)){const s=t(r,e);this.m_rShape.getUserIndex(e,this.m_clusterParentageIndex)===this.m_IDBoth&&(a=s),32!==a&&this.m_rShape.setUserIndex(r,this.m_cutteeBreadcrumbsIndex,a|s)}}let e=o.n,s=o.n,n=32;const i=this.m_rShape.hasSegmentParentage(),a=new o.S;for(let h=this.m_rShape.getFirstPath(this.m_cuttee);h!==o.n;h=this.m_rShape.getNextPath(h)){const t=this.m_rShape.isClosedPath(h),m=this.m_rShape.getPathSize(h)+(t?1:0);let l=1,u=this.m_rShape.getFirstVertex(h),c=o.n,g=!0;for(let h=this.m_rShape.getNextVertex(u);l<m;++l,h=this.m_rShape.getNextVertex(h)){let t=this.m_rShape.getUserIndex(u,this.m_cutteeBreadcrumbsIndex);8===t?t=3:(t&=-9,4&t?t=4:3&~t||(t=3)),t!==n?(e!==o.n&&(c=this.m_rShape.addVertex(s,u),i&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(u))&&this.m_rShape.setSegmentParentageBreakVertex(c,!0),this.m_rCutHandles.push(e),this.m_rShape.setGeometryUserIndex(e,this.m_sideIndex,n)),e=this.m_rShape.createGeometry(r.G.enumPolyline),s=this.m_rShape.insertPath(e,o.n),n=t,g=!0):this.m_rShape.getUserIndex(u,this.m_clusterParentageIndex)===this.m_IDBoth&&4!==t&&(c=this.m_rShape.addVertex(s,u),i&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(u))&&this.m_rShape.setSegmentParentageBreakVertex(c,!0),s=this.m_rShape.insertPath(e,o.n),g=!0),c=this.m_rShape.addVertex(s,u);const m=this.m_rTopoGraph.getClusterFromVertex(u);!g&&i&&this.m_rTopoGraph.isBreakNode(m)&&this.m_rShape.setSegmentParentageBreakVertex(c,!0);const l=this.m_rTopoGraph.getHalfEdgeFromVertex(u);if(i){const t=this.m_rTopoGraph.getSegmentParentage(l);this.m_rShape.setSegmentParentageAndBreak(c,t,g||this.m_rTopoGraph.isBreakNode(m))}this.m_rTopoGraph.isHalfEdgeCurve(l)&&(this.m_rTopoGraph.querySegmentXY(l,a),this.m_rShape.setSegmentToIndex(this.m_rShape.getVertexIndex(c),a.get().clone())),u=h,g=!1}c=this.m_rShape.addVertex(s,u),i&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(u))&&this.m_rShape.setSegmentParentageBreakVertex(c,!0),this.m_rCutHandles.push(e),this.m_rShape.setGeometryUserIndex(e,this.m_sideIndex,n),e=o.n,s=o.n,n=32}}}function js(t,e,s){return new Bs(s).linesToPolygonsImpl(t,e)}function Zs(t,e,s,n,h){if(n&&(n.m_reason=0,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),t.isEmpty())return 5;const m=t.getGeometryType();if(m===r.G.enumPoint)return $s(t,n);const l=(0,a.b)(e,t,!1).total();if(m===r.G.enumEnvelope){const e=t,s=new i.Envelope2D;return e.queryEnvelope(s),s.isDegenerate(l)?(n&&(n.m_reason=4,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),0):5}if((0,r.f)(m)){const i=t,r=new o.P({vd:i.getDescription()});return r.addSegment(i,!0),Zs(r,e,s,n,h)}(0,r.C)(m),(0,r.i)(m)||(0,r.b)("OGC simplify is not implemented for this geometry type");const u=t.getImpl().getIsSimple(l,[0]);let c=s?-1:u;if(5===c||0===c)return c;const g=new mn(t,e,c,h,!0);return m===r.G.enumMultiPoint||m===r.G.enumPolyline||m===r.G.enumPolygon?(c=g.isSimplePlanarImpl(),(0,a.i)(c)&&(c=5)):(0,r.c)(""),t.getImpl().setIsSimple(c,l),n&&n.assign(g.m_nonSimpleResult),c}function Qs(t,e,s,n,h){if(n&&(n.m_reason=0,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),t.isEmpty())return 5;const m=t.getGeometryType();if(m===r.G.enumPoint)return $s(t,n);const l=(0,a.b)(e,t,!1).total();if(m===r.G.enumEnvelope){const e=t,s=i.Envelope2D.constructEmpty();return e.queryEnvelope(s),s.isDegenerate(l)?(n&&(n.m_reason=4,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),0):5}if((0,r.f)(m)){const i=t,r=new o.P({vd:i.getDescription()});return r.addSegment(i,!0),Qs(r,e,s,n,h)}const u=t.getImpl().getIsSimple(l,[0]);let c=s?-1:u;if(-1!==c)return c;const g=new mn(t,e,c,h,!1);return m===r.G.enumMultiPoint?c=g.multipointIsSimpleAsFeature():m===r.G.enumPolyline?c=g.polylineIsSimpleAsFeature():m===r.G.enumPolygon?c=g.polygonIsSimpleAsFeature():(0,r.c)(""),t.getImpl().setIsSimple(c,l),n&&n.assign(g.m_nonSimpleResult),c}function Ks(t,e,s,n){if(t.isEmpty())return t;const h=t.getGeometryType();if(h===r.G.enumPoint){const e=new p;if($s(t,e),3===e.m_reason){const e=t.clone();return e.replaceNaNs(1,0),e}return 2===e.m_reason?t.createInstance():t}if(h===r.G.enumEnvelope){const s=(0,a.b)(e,t,!0).total(),n=t,r=i.Envelope2D.constructEmpty();return n.queryEnvelope(r),r.isDegenerate(s)?n.createInstance():t}if((0,r.f)(h)){const i=t,r=new o.P({vd:i.getDescription()});return r.addSegment(i,!0),Ks(r,e,s,n)}(0,r.C)(h);const m=(0,a.b)(e,t,!1).total(),l=t.getImpl().getIsSimple(m,[0]),u=s?-1:l;if((0,a.i)(u)){if(h===r.G.enumPolygon&&0!==t.getFillRule()){const e=t.clone();return e.setFillRule(0),e}return t}if((h===r.G.enumMultiPoint||h===r.G.enumPolyline)&&u>=1)return t;const c=new mn(t,e,u,n,!1);let g;return h===r.G.enumMultiPoint?g=c.multipointSimplifyAsFeature():h===r.G.enumPolyline?g=c.polylineSimplifyAsFeature():h===r.G.enumPolygon?g=c.polygonSimplifyAsFeature():(0,r.c)(""),g}function Js(t,e,s,n){if(t.isEmpty())return t;const h=t.getGeometryType();if(h===r.G.enumPoint){const e=new p;if($s(t,e),3===e.m_reason){const e=t.clone();return e.replaceNaNs(1,0),e}return 2===e.m_reason?t.createInstance():t}if(h===r.G.enumEnvelope){const s=t,n=new i.Envelope2D;s.queryEnvelope(n);const r=(0,a.b)(e,t,!0).total();return n.isDegenerate(r)?s.createInstance():t}if((0,r.f)(h)){const i=t,r=new o.P({vd:i.getDescription()});return r.addSegment(i,!0),Js(r,e,s,n)}(0,r.C)(h),(0,r.i)(h)||(0,r.b)("OGC simplify is not implemented for this geometry type");const m=(0,a.b)(e,t,!1).total(),l=t.getImpl().getIsSimple(m,[0]),u=s?-1:l;if(5===u){if(h===r.G.enumPolygon&&0!==t.getFillRule()){const e=t.clone();return e.setFillRule(0),e}return t}return qs(t,(0,a.b)(e,t,!0),!1,u,n,0,!0)}function $s(t,e){const s=t.getX(),n=t.getY();if(!Number.isFinite(s)||!Number.isFinite(n))return e&&(e.m_reason=2,e.m_vertexIndex1=-1,e.m_vertexIndex2=-1),0;if(t.hasAttribute(1)){const s=t.getZ();if(!Number.isFinite(s))return e&&(e.m_reason=Number.isNaN(s)?3:2,e.m_vertexIndex1=-1,e.m_vertexIndex2=-1),0}return 5}class tn{constructor(){this.m_segment=null,this.m_vertexIndex=-1,this.m_pathIndex=-1,this.m_flags=0}setReversed(t){this.m_flags&=-2,this.m_flags=this.m_flags|(t?1:0)}getReversed(){return!!(1&this.m_flags)}getRightSide(){return this.getReversed()?0:1}}function en(t,e,s,n,i){return{x:t,y:e,ipath:s,ivertex:n,ipolygon:i}}function sn(t,e){return t.x===e.x&&t.y===e.y&&t.ipath===e.ipath&&t.ivertex===e.ivertex&&t.ipolygon===e.ipolygon}function nn(t,e){t.x=e.x,t.y=e.y,t.ipath=e.ipath,t.ivertex=e.ivertex,t.ipolygon=e.ipolygon}function rn(t,e,s,n,i,r){return{x:t,y:e,ipath:s,ivertex:n,bBoundary:i,bEndPoint:r}}function on(t,e){t.x=e.x,t.y=e.y,t.ipath=e.ipath,t.ivertex=e.ivertex,t.bBoundary=e.bBoundary,t.bEndPoint=e.bEndPoint}class an extends a.a6{constructor(t){super(),this.m_helper=t}compare(t,e,s){const n=t.getElement(s),i=this.m_helper.m_xy.read(2*e)-this.m_helper.m_xy.read(2*n);return i<0?-1:i>0?1:0}}class hn extends a.a6{constructor(t){super(),this.m_helper=t}compare(t,e,s){const n=t.getElement(s),i=this.m_helper.m_edges[e],r=this.m_helper.m_edges[n],o=i.getReversed(),a=r.getReversed();let h=i.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0),m=r.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0);if(h===m){const t=o?i.m_segment.getStartY():i.m_segment.getEndY(),e=a?r.m_segment.getStartY():r.m_segment.getEndY(),s=Math.min(t,e);let n=.5*(s-this.m_helper.m_yScanline)+this.m_helper.m_yScanline;n===this.m_helper.m_yScanline&&(n=s),h=i.m_segment.intersectionOfYMonotonicWithAxisX(n,0),m=r.m_segment.intersectionOfYMonotonicWithAxisX(n,0)}return h<m?-1:h>m?1:0}}class mn{constructor(t,e,s,n,i){this.m_multiVertexGeom=null,this.m_edges=[],this.m_freeEdges=[],this.m_lineEdgesRecycle=[],this.m_newEdges=[],this.m_recycledSegIter=null,this.m_crossOverHelperList=new a.a2,this.m_progressTracker=null,this.m_progressCounter=0,this.m_AET=new a.T,this.m_xyToNode1=null,this.m_xyToNode2=null,this.m_pathOrientations=null,this.m_pathParentage=null,this.m_xy=null,this.m_pairs=[],this.m_pairIndices=null,this.m_pathsForOGCTests=[],this.m_curveStitcher=null,this.m_editShape=null,this.m_multiPathStitcher=null,this.m_nonSimpleResult=new p,this.m_progressCounter=0,this.m_progressTracker=n,this.m_geometry=t,this.m_knownSimpleResult=s,this.m_sr=e;const r=(0,a.b)(e,t,!1);this.m_toleranceIsSimple=r,this.m_toleranceIsSimpleClustering=(0,a.d)(r),this.m_toleranceIsSimpleCracking=(0,a.a1)(r),this.m_toleranceSimplify=(0,a.b)(e,t,!0),this.m_description=this.m_geometry.getDescription(),this.m_attributeCount=this.m_description.getAttributeCount(),this.m_bOGCRestrictions=i,this.m_bPlanarSimplify=this.m_bOGCRestrictions,this.m_unknownOrientationPathCount=-1,this.m_yScanline=0,this.m_progressCounter=0}isSimplePlanarImpl(){if(this.m_bPlanarSimplify=!0,!this.checkStructure())return 0;const t=this.m_geometry.getGeometryType();return(0,r.h)(t)&&!this.checkDegenerateSegments(!1)?0:this._CheckClustering()?(0,r.h)(t)?this._CheckCracking()?this.m_geometry.getGeometryType()===r.G.enumPolyline?this.checkSelfIntersectionsPolylinePlanar()?4:0:this._CheckSelfIntersections()?this._CheckValidRingOrientation():0:0:5:0}isSimplePlanarImpl3D(){return(0,r.g)(0),7}generateSortedPairs(t){let e=null;(0,r.h)(t.getGeometryType())&&(e=t);const s=(this.m_bPlanarSimplify||this.m_bOGCRestrictions)&&null!==e,n=t.getPointCount();this.m_xy=t.getAttributeStreamRef(0),this.m_pairs.length=0,this.m_pairIndices=new a.A(0),s&&(this.m_pathsForOGCTests.length=0);let i=0;for(let r=0;r<n;r++)if(this.m_pairs.push(2*r),this.m_pairs.push(2*r+1),this.m_pairIndices.add(2*r),this.m_pairIndices.add(2*r+1),s){for(;r>=e.getPathEnd(i);)i++;this.m_pathsForOGCTests.push(i)}const o=new a.B,m={parent:this,workPt:new h.P,userSort(t,e,n){n.sort(t,e,((t,e)=>this.parent.compareVerticesForPlanarClustering(t,e,s)))},getValue(t){const e=this.parent.m_pairs[t],s=e>>1;return this.parent.m_xy.queryPoint2D(2*s,this.workPt),this.workPt.y+(1&e?this.parent.m_toleranceIsSimpleClustering:-this.parent.m_toleranceIsSimpleClustering)}};o.sort(this.m_pairIndices,0,2*n,m)}_TestToleranceDistancePlanar(t,e){const s=this.m_xy.read(2*t),n=this.m_xy.read(2*t+1),i=this.m_xy.read(2*e),r=this.m_xy.read(2*e+1);return!mt(s,n,i,r,this.m_toleranceIsSimpleClustering*this.m_toleranceIsSimpleClustering)||0!==this.m_geometry.getDimension()&&(s===i&&n===r)}checkStructure(){const t=this.m_geometry.getGeometryType();if((0,r.h)(t)){const t=this.m_geometry.getImpl(),e=this.m_geometry.getGeometryType()===r.G.enumPolygon?3:2;for(let s=0,n=t.getPathCount();s<n;s++)if(t.getPathSize(s)<e){if(t.hasNonLinearSegments()&&t.hasNonLinearSegmentsPath(s)&&t.getPathSize(s)>0)continue;return this.m_nonSimpleResult=new p(1,s,0),!1}}if((0,r.i)(t)){const t=this.m_geometry.getImpl(),e=t.getAttributeStreamRef(0);for(let s=0,n=t.getPointCount();s<n;s++)if(!e.readPoint2D(2*s).isFinite())return this.m_nonSimpleResult=new p(2,s,0),!1;if(this.m_geometry.hasAttribute(1)){const e=t.getAttributeStreamRef(1);for(let s=0,n=t.getPointCount();s<n;s++){const t=e.read(s);if(!Number.isFinite(t))return Number.isNaN(t)?this.m_nonSimpleResult=new p(3,s,0):this.m_nonSimpleResult=new p(2,s,0),!1}}}return!0}checkDegenerateSegments(t){const e=this.m_geometry.getImpl(),s=e.querySegmentIterator(),n=e.hasAttribute(1),i=n?(0,a.a3)(this.m_sr,e,!1).total():0,r=e.hasNonLinearSegments(),o=this.m_toleranceIsSimple.total();for(;s.nextPath();)for(;s.hasNextSegment();){const e=s.nextSegment();let a=e.calculateLowerLength2D();if(!(a>o)&&!(r&&e.isCurve()&&(a=e.calculateLength2D(),a>o))){if(t&&n){const t=e.getStartAttributeAsDbl(1,0),s=e.getEndAttributeAsDbl(1,0);if(Math.abs(s-t)>i)continue}return this.m_nonSimpleResult=new p(4,s.getStartPointIndex(),-1),!1}}return!0}checkDegenerateSegments3D(){return(0,r.g)(0),!1}_CheckClustering(){const t=this.m_geometry.getImpl();this.generateSortedPairs(t);const e=t.getPointCount();this.m_AET.clear(),this.m_AET.setComparator(new an(this)),this.m_AET.setCapacity(e);for(let s=0,n=2*e;s<n;s++){this.progress_();const t=this.m_pairIndices.read(s),e=this.m_pairs[t],n=e>>1;if(1&e){const t=this.m_AET.search(n),e=this.m_AET.getPrev(t),s=this.m_AET.getNext(t);if(this.m_AET.deleteNode(t),e!==a.T.st_nullNode()&&s!==a.T.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(e),this.m_AET.getElement(s)))return this.m_nonSimpleResult=new p(5,this.m_AET.getElement(e),this.m_AET.getElement(s)),!1}else{const t=this.m_AET.addElement(n),e=this.m_AET.getPrev(t);if(e!==a.T.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(e),n))return this.m_nonSimpleResult=new p(5,n,this.m_AET.getElement(e)),!1;const s=this.m_AET.getNext(t);if(s!==a.T.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(s),n))return this.m_nonSimpleResult=new p(5,n,this.m_AET.getElement(s)),!1}}return!0}_CheckCracking(){const t=this.m_geometry.getImpl(),e=t.getPointCount();return!t.hasNonLinearSegments()&&e<10?this._CheckCrackingBrute():this._CheckCrackingPlanesweep()}_CheckCrackingPlanesweep(){if(this.m_editShape=new o.E,this.m_editShape.addGeometry(this.m_geometry),this.m_editShape.hasCurves()){this.m_curveStitcher=new ys;const t=i.Envelope2D.constructEmpty();this.m_geometry.queryEnvelope(t);const e=fs(this.m_toleranceSimplify.total(),t),s=new p;if(ps(this.m_editShape,e,this.m_toleranceSimplify.total(),0,s,this.m_curveStitcher,null,this.m_progressTracker),0!==s.m_reason)return this.m_editShape=null,this.m_nonSimpleResult.assign(s),!1}const t=new p;return Nt(!1,this.m_editShape,this.m_toleranceIsSimpleCracking,t,this.m_progressTracker)?(null!=this.m_curveStitcher?(t.m_vertexIndex1=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,t.m_vertexIndex1),t.m_vertexIndex2=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,t.m_vertexIndex2),this.m_curveStitcher=null):(t.m_vertexIndex1=this.m_editShape.getVertexIndex(t.m_vertexIndex1),t.m_vertexIndex2=this.m_editShape.getVertexIndex(t.m_vertexIndex2)),this.m_editShape=null,this.m_nonSimpleResult.assign(t),!1):(null==this.m_curveStitcher&&(this.m_editShape=null),!0)}_CheckCrackingBrute(){const t=this.m_geometry.getImpl(),e=t.querySegmentIterator(),s=t.querySegmentIterator();for(;e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(!e.isLastSegmentInPath()||!e.isLastPath()){s.resetTo(e);do{for(;s.hasNextSegment();){const n=s.nextSegment(),i=(0,o._)(!0,t,n,this.m_toleranceIsSimpleCracking,!0);if(i){const t=2===i?7:6;return this.m_nonSimpleResult=new p(t,e.getStartPointIndex(),s.getStartPointIndex()),!1}}}while(s.nextPath())}}return!0}_CheckSelfIntersections(){let t=this.m_geometry.getImpl();null!==this.m_curveStitcher&&(this.m_multiPathStitcher=this.m_editShape.getGeometry(this.m_editShape.getFirstGeometry()),t=this.m_multiPathStitcher.getImpl(),this.generateSortedPairs(t)),this.m_edges.length=0,this.m_lineEdgesRecycle.length=0,this.m_recycledSegIter=t.querySegmentIterator(),this.m_recycledSegIter.setCirculator(!0);const e=[],s=t.getPointCount();let n=Number.NaN,i=0;for(let r=0,o=2*s;r<o;r++){this.progress_();const t=this.m_pairIndices.read(r),s=this.m_pairs[t];if(1&s)continue;const o=s>>1,a=this.m_xy.read(2*o),h=this.m_xy.read(2*o+1);if(e.length&&(a!==n||h!==i)){if(!this.processBunchForSelfIntersectionTest(e))return!1;e.length=0}e.push(o),n=a,i=h}return!!this.processBunchForSelfIntersectionTest(e)}checkSelfIntersectionsPolylinePlanar(){const t=this.m_geometry.getImpl(),e=[];for(let o=0,a=t.getPathCount();o<a;o++)e.push(t.isClosedPathInXYPlane(o));const s={x:-1,y:-1,ipath:-1,ivertex:-1,bBoundary:!1,bEndPoint:!1};let n,i,r;{const o=this.m_pairIndices.read(0),a=this.m_pairs[o]>>1,h=this.m_xy.readPoint2D(2*a),m=this.m_pathsForOGCTests[a];n=e[m],i=t.getPathStart(m),r=t.getPathEnd(m)-1,s.bEndPoint=a===i||a===r,this.m_bOGCRestrictions?s.bBoundary=!n&&s.bEndPoint:s.bBoundary=s.bEndPoint,s.ipath=m,s.x=h.x,s.y=h.y,s.ivertex=a}for(let o=1,a=this.m_pairIndices.size();o<a;o++){const a=this.m_pairIndices.read(o),h=this.m_pairs[a];if(1&h)continue;const m=h>>1,l=this.m_xy.readPoint2D(2*m),u=this.m_pathsForOGCTests[m];let c;u!==s.ipath&&(n=e[u],i=t.getPathStart(u),r=t.getPathEnd(u)-1);const g=m===i||m===r;c=this.m_bOGCRestrictions?!n&&g:g;const d=rn(l.x,l.y,u,m,c,g);if(d.x===s.x&&d.y===s.y)if(this.m_bOGCRestrictions){if(!(d.bBoundary&&s.bBoundary||d.ipath===s.ipath&&d.bEndPoint&&s.bEndPoint))return this.m_nonSimpleResult=new p(10,d.ivertex,s.ivertex),!1}else if(!d.bEndPoint||!s.bEndPoint)return this.m_nonSimpleResult=new p(7,d.ivertex,s.ivertex),!1;on(s,d)}return!0}checkSelfIntersectionsPolylinePlanar3D(t){return(0,r.g)(0),!1}checkSelfIntersectionsPolygonsOGC(){const t=this.m_geometry.getImpl(),e=[];let s=-1,i=!1;for(let n=0,a=t.getPathCount();n<a;n++)t.isExteriorRingOGC(n)&&(i=!1,s++,n<a-1&&(t.isExteriorRingOGC(n+1)||(i=!0))),e.push(i?s:-1);const r={x:-1,y:-1,ipath:-1,ivertex:-1,ipolygon:-1};{const t=this.m_pairIndices.read(0),s=this.m_pairs[t]>>1,n=this.m_xy.readPoint2D(2*s),i=this.m_pathsForOGCTests[s];r.ipath=i,r.x=n.x,r.y=n.y,r.ivertex=s,r.ipolygon=e[i]}const o=[];for(let a=1,h=this.m_pairIndices.size();a<h;a++){const t=this.m_pairIndices.read(a),s=this.m_pairs[t];if(1&s)continue;const i=s>>1,h=this.m_xy.readPoint2D(2*i),m=this.m_pathsForOGCTests[i],l=en(h.x,h.y,m,i,e[m]);if(l.x===r.x&&l.y===r.y){if(l.ipath===r.ipath)return this.m_nonSimpleResult=new p(11,l.ivertex,r.ivertex),!1;e[l.ipath]>=0&&e[l.ipath]===e[r.ipath]&&(0!==o.length&&sn(o.at(-1),r)||o.push((0,n.A)({},r)),o.push(l))}nn(r,l)}if(0===o.length)return!0;const m=new a.a2(!0);e.fill(-1);let l=-1;const u=new h.P;for(let n=0,a=o.length;n<a;n++){const t=o[n];t.x===u.x&&t.y===u.y||(l=m.createList(0),u.x=t.x,u.y=t.y);let s=e[t.ipath];-1===s&&(s=m.createList(2),e[t.ipath]=s),m.addElement(s,l),m.addElement(l,s)}const c=[];for(let n=m.getFirstList();-1!==n;n=m.getNextList(n)){const t=m.getListData(n);if(1&t||!(2&t))continue;let s=-1;for(c.push(n),c.push(-1);c.length;){const t=c.at(-1);c.pop();const e=c.at(-1);c.pop();const n=m.getListData(e);if(1&n){s=2&n?e:t;break}m.setListData(e,1|n);for(let s=m.getFirst(e);-1!==s;s=m.getNext(s)){const n=m.getData(s);n!==t&&(c.push(n),c.push(e))}}if(-1!==s){const t=e.indexOf(s);return this.m_nonSimpleResult=new p(12,t,-1),!1}}return!0}_CheckValidRingOrientation(){const t=null!==this.m_multiPathStitcher?this.m_multiPathStitcher.getImpl():this.m_geometry.getImpl();if(t.calculateArea2D()<=0)return this.m_nonSimpleResult=new p(8,1===t.getPathCount()?1:-1,-1),0;if(1===t.getPathCount())return this.m_bOGCRestrictions&&!this.checkSelfIntersectionsPolygonsOGC()?0:4;this.m_pathOrientations=new a.a4(t.getPathCount(),0),this.m_pathParentage=new a.A(t.getPathCount(),-1);let e=-1,s=0;for(let r=0,o=t.getPathCount();r<o;r++){const n=t.calculateRingArea2D(r);if(this.m_pathOrientations.write(r,n<0?0:8),n>0)e=r,s=n;else{if(0===n)return this.m_nonSimpleResult=new p(8,r,-1),0;if((e<0||s<Math.abs(n))&&(this.m_nonSimpleResult=new p(9,r,-1),this.m_bOGCRestrictions))return 0;this.m_pathParentage.write(r,e)}}this.m_unknownOrientationPathCount=t.getPathCount(),this.m_newEdges.length=0;const n=t.getPointCount();this.m_yScanline=Number.NaN;const i=[];this.m_xyToNode1=new a.A(n,a.T.st_nullNode()),this.m_xyToNode2=new a.A(n,a.T.st_nullNode()),this.m_freeEdges.length=0,this.m_AET.clear(),this.m_AET.setComparator(new hn(this));for(let r=0,o=2*n;this.m_unknownOrientationPathCount>0&&r<o;r++){const t=this.m_pairIndices.read(r),e=this.m_pairs[t];if(1&e)continue;const s=e>>1,n=this.m_xy.read(2*s+1);if(n!==this.m_yScanline&&i.length){if(!this.processBunchForRingOrientationTest(i))return 0;i.length=0}i.push(s),this.m_yScanline=n}return this.m_unknownOrientationPathCount>0&&!this.processBunchForRingOrientationTest(i)?0:this.m_bOGCRestrictions?0!==this.m_nonSimpleResult.m_reason?0:this.checkSelfIntersectionsPolygonsOGC()?5:0:0===this.m_nonSimpleResult.m_reason?4:3}processBunchForSelfIntersectionTest(t){if(1===t.length)return!0;for(let o=0,a=t.length;o<a;o++){const e=t[o];this.m_recycledSegIter.resetToVertex(e,-1);const s=this.m_recycledSegIter.previousSegment();this.m_edges.push(this.createEdge(s,e,this.m_recycledSegIter.getPathIndex(),!0)),this.m_recycledSegIter.nextSegment();const n=this.m_recycledSegIter.nextSegment();this.m_edges.push(this.createEdge(n,e,this.m_recycledSegIter.getPathIndex(),!1))}this.m_edges.sort(((t,e)=>this.edgeAngleCompare(t,e)));let e=this.m_crossOverHelperList.getFirstList();-1===e&&(e=this.m_crossOverHelperList.createList(0)),this.m_crossOverHelperList.reserveNodes(this.m_edges.length);for(let o=0,a=this.m_edges.length;o<a;o++)this.m_crossOverHelperList.addElement(e,o);let s=!0,n=-1,i=-1;for(;s;){s=!1;let t=this.m_crossOverHelperList.getFirst(e);if(-1===t)break;let r=this.m_crossOverHelperList.getNext(t);for(;-1!==r;){const o=this.m_crossOverHelperList.getData(t),a=this.m_crossOverHelperList.getData(r);if(n=this.m_edges[o].m_vertexIndex,i=this.m_edges[a].m_vertexIndex,n!==i)t=r,r=this.m_crossOverHelperList.getNext(t);else if(s=!0,this.m_crossOverHelperList.deleteElement(e,t),t=this.m_crossOverHelperList.getPrev(r),r=this.m_crossOverHelperList.deleteElement(e,r),-1===r||-1===t)break}}const r=this.m_crossOverHelperList.getListSize(e);if(this.m_crossOverHelperList.clear(e),r>0)return this.m_nonSimpleResult=new p(7,n,i),!1;for(let o=0,a=t.length;o<a;o++)this.recycleEdge(this.m_edges[o]);return this.m_edges.length=0,!0}processBunchForRingOrientationTest(t){for(let e=0,s=t.length;e<s;e++){const s=t[e];let n=this.m_xyToNode1.read(s);if(n!==a.T.st_nullNode()){const t=this.m_AET.getElement(n);this.m_freeEdges.push(t),this.m_AET.deleteNode(n),this.recycleEdge(this.m_edges[t]),this.m_edges[t]=null,this.m_xyToNode1.write(s,a.T.st_nullNode())}if(n=this.m_xyToNode2.read(s),n!==a.T.st_nullNode()){const t=this.m_AET.getElement(n);this.m_freeEdges.push(t),this.m_AET.deleteNode(n),this.recycleEdge(this.m_edges[t]),this.m_edges[t]=null,this.m_xyToNode2.write(s,a.T.st_nullNode())}}for(let e=0,s=t.length;e<s;e++){const s=t[e];this.m_recycledSegIter.resetToVertex(s,-1);const n=this.m_recycledSegIter.previousSegment();if(n.getStartY()>n.getEndY()){const t=this.m_recycledSegIter.getStartPointIndex(),e=this.createEdge(n,s,this.m_recycledSegIter.getPathIndex(),!0);let i;this.m_freeEdges.length>0?(i=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[i]=e):(i=this.m_edges.length,this.m_edges.push(e));const r=this.m_AET.addElement(i);this.m_xyToNode1.read(t)===a.T.st_nullNode()?this.m_xyToNode1.write(t,r):this.m_xyToNode2.write(t,r),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(r)}this.m_recycledSegIter.nextSegment();const i=this.m_recycledSegIter.nextSegment();if(i.getStartY()<i.getEndY()){const t=this.m_recycledSegIter.getEndPointIndex(),e=this.createEdge(i,s,this.m_recycledSegIter.getPathIndex(),!1);let n;this.m_freeEdges.length>0?(n=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[n]=e):(n=this.m_edges.length,this.m_edges.push(e));const r=this.m_AET.addElement(n);this.m_xyToNode1.read(t)===a.T.st_nullNode()?this.m_xyToNode1.write(t,r):this.m_xyToNode2.write(t,r),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(r)}}for(let e=0,s=this.m_newEdges.length;e<s&&this.m_unknownOrientationPathCount>0;e++){const t=this.m_newEdges[e],s=this.m_AET.getElement(t),n=this.m_edges[s].m_pathIndex;if(!(3&this.m_pathOrientations.read(n))){let e=-1,s=this.m_AET.getPrev(t),n=t,i=0;{let t=-1,r=null,o=-1,h=0;for(;s!==a.T.st_nullNode()&&(t=this.m_AET.getElement(s),r=this.m_edges[t],o=r.m_pathIndex,h=this.m_pathOrientations.read(o),!(3&h));)n=s,s=this.m_AET.getPrev(s);s===a.T.st_nullNode()?(i=1,s=n):(e=1==(3&h)?o:this.m_pathParentage.read(o),i=r.getRightSide()?0:1,s=this.m_AET.getNext(s))}do{const t=this.m_AET.getElement(s),r=this.m_edges[t],o=r.m_pathIndex;let a=this.m_pathOrientations.read(o);if(!(3&a)){if(i!==r.getRightSide())return this.m_nonSimpleResult=new p(8,o,-1),!1;const t=i&&!r.getReversed()?1:2;if(a=-4&a|t,this.m_pathOrientations.write(o,a),2===t&&0===this.m_nonSimpleResult.m_reason){const t=this.m_pathParentage.read(o);if(t!==e&&(this.m_nonSimpleResult=new p(9,o,t),this.m_bOGCRestrictions))return!1}if(this.m_unknownOrientationPathCount--,!this.m_unknownOrientationPathCount)return!0}e=1==(3&a)?o:this.m_pathParentage.read(o),n=s,s=this.m_AET.getNext(s),i=i?0:1}while(n!==t)}}return this.m_newEdges.length=0,!0}createEdge(t,e,s,n){let i;return t.getGeometryType()===r.G.enumLine?i=this.createEdgeLine(t):(i=new tn,i.m_segment=t.clone()),i.m_vertexIndex=e,i.m_pathIndex=s,i.m_flags=0,i.setReversed(n),i}createEdgeLine(t){let e;return this.m_lineEdgesRecycle.length>0?(e=this.m_lineEdgesRecycle.at(-1),this.m_lineEdgesRecycle.pop(),t.copyTo(e.m_segment)):(e=new tn,e.m_segment=t.clone()),e}recycleEdge(t){t.m_segment.getGeometryType()===r.G.enumLine&&this.m_lineEdgesRecycle.push(t)}static isShortSegment(t,e,s,n){let i=t.calculateLowerLength2D();if(i<=s){let r=!0;if(t.isCurve()&&(i=t.calculateLength2D(),r=i<=s),r){if(e){let e=t.getEndAttributeAsDbl(1,0);Number.isNaN(e)&&(e=0);let s=t.getStartAttributeAsDbl(1,0);return Number.isNaN(s)&&(s=0),Math.abs(s-e)<=n}return!0}return!1}return!1}static isShortSegmentPoints(t,e,s,n,i){if(s){const s=t.getXYZ(),r=e.getXYZ();return(0,a.a5)(s,r,n,i)}{const s=t.getXY(),i=e.getXY();return h.P.sqrDistance(s,i)<=n*n}}removeDegenerateSegmentsFromCurvedPath(t,e,s,n){const i=t.hasAttribute(1),o=t.querySegmentIterator();o.resetToPath(e),(0,r.g)(o.nextPath());const m=this.m_toleranceSimplify.total();let l=!1,u=!0;const c=new a.P,g=new a.P,d=new h.P;for(;o.hasNextSegment();){this.progress_();const t=o.nextSegment();if(mn.isShortSegment(t,i,m,s))if(l){if(t.queryEnd(g),mn.isShortSegmentPoints(c,g,i,m,s))continue;u&&(n.startPathPoint(c),u=!1),t.queryEnd(c),n.lineToPoint(c),l=!1}else d.assign(t.getStartXY()),t.queryStart(c),l=!0;else if(l)if(t.isCurve()){const e=t.clone();if(e.setCoordsForIntersector(d,t.getEndXY(),!1),e.setStart(c),mn.isShortSegment(e,i,m,s))continue;n.addSegment(e,u),u=!1,l=!1}else{if(t.queryEnd(g),mn.isShortSegmentPoints(c,g,i,m,s))continue;u&&(n.startPathPoint(c),u=!1),n.lineToPoint(g),l=!1}else n.addSegment(t,u),u=!1}if(u)return;if(!l)return;t.isClosedPath(e)?t.getPointByVal(t.getPathStart(e),c):t.getPointByVal(t.getPathEnd(e)-1,c);const _=n.querySegmentIterator();_.resetToLastPath(),_.resetToLastSegment();const p=n.getDescription().getAttributeCount()>1;for((0,r.g)(_.previousPath());_.hasPreviousSegment();){const t=_.previousSegment();if(t.isCurve()){const e=t.clone();if(e.setCoordsForIntersector(t.getStartXY(),c.getXY(),!1),!mn.isShortSegment(e,i,m,s)){p&&e.setEnd(c);const t=_.getEndPointIndex();for(let e=n.getPointCount()-1;e>=t;e--)n.removePoint(e);return void n.addSegment(e,!1)}}else if(t.queryStart(g),!mn.isShortSegmentPoints(g,c,i,m,s)){const t=_.getEndPointIndex();for(let e=n.getPointCount()-1;e>=t;e--)n.removePoint(e);return void n.lineToPoint(c)}}n.removePath(n.getPathCount()-1)}multipointIsSimpleAsFeature(){if(!this.checkStructure())return 0;const t=this.m_geometry.getImpl();this.m_multiVertexGeom=t;const e=t.getPointCount(),s=(0,h.d)(e,0);for(let n=0;n<e;n++)s[n]=n;s.sort(((t,e)=>this.compareVerticesMultiPoint(t,e)));for(let n=1;n<e;n++)if(0===this.compareVerticesMultiPoint(s[n-1],s[n]))return this.m_nonSimpleResult=new p(5,s[n-1],s[n]),0;return 1}polylineIsSimpleAsFeature(){return this.checkStructure()&&this.checkDegenerateSegments(!0)?1:0}polygonIsSimpleAsFeature(){return this.isSimplePlanarImpl()}multipointSimplifyAsFeature(){let t=this.m_geometry.getImpl();const e=mn.hasNanZs(t);let s,n=this.m_geometry;e&&(s=this.m_geometry.clone(),t=s.getImpl(),s.replaceNaNs(1,a.V.getDefaultValue(1)),n=s),this.m_multiVertexGeom=t;const i=t.getPointCount(),r=(0,h.d)(i,0);for(let a=0;a<i;a++)r[a]=a;r.sort(((t,e)=>this.compareVerticesMultiPoint(t,e)));const o=new Array(i);o.fill(!1);let m=-1;for(let a=0;a<i;a++){const e=r[a];t.getXY(e).isFinite()&&((m<0||0!==this.compareVerticesMultiPoint(m,e))&&(o[e]=!0),m=e)}const l=this.m_geometry.createInstance();let u=0,c=0;for(let a=0;a<i;a++)o[a]?c=a+1:(u<c&&l.addPoints(n,u,c),u=a+1);return u<c&&l.addPoints(n,u,c),l.getImpl().setIsSimple(1,this.m_toleranceSimplify.total()),l}polylineSimplifyAsFeature(){const t=this.m_geometry.getImpl(),e=t.querySegmentIterator(),s=t.querySegmentIterator(),n=this.m_geometry.createInstance(),i=this.m_geometry,r=t.hasAttribute(1),o=r?(0,a.a3)(this.m_sr,t,!0).total():0,m=[],l=[];let u=null;r&&(u=t.getAttributeStreamRef(1));const c=new a.P,g=t.hasNonLinearSegments(),d=this.m_toleranceSimplify.total();for(;e.nextPath();){if(s.nextPath(),t.getPathSize(e.getPathIndex())<2)continue;if(g&&t.hasNonLinearSegmentsPath(e.getPathIndex())){this.removeDegenerateSegmentsFromCurvedPath(t,e.getPathIndex(),o,n);continue}s.resetToLastSegment();let a=0,_=0,p=!0,f=!0;for(;e.hasNextSegment();){this.progress_();const n=e.nextSegment(),i=s.previousSegment();if(e.getStartPointIndex()>s.getStartPointIndex())break;if(p){const s=e.getStartPointIndex();t.getXY(s).isNAN()||(p=!1,m.push(s))}if(f){const e=s.getEndPointIndex();t.getXY(e).isNAN()||(l.push(e),f=!1)}if(!p){const s=m.at(-1),i=e.getEndPointIndex();if(i-s>1){const e=new h.P;e.setSub(t.getXY(s),t.getXY(i)),a=e.length()}else a=n.calculateLength2D();if(a>d)m.push(i),a=0;else if(r){let t=u.read(s);Number.isNaN(t)&&(t=0);let e=u.read(i);Number.isNaN(e)&&(e=0),Math.abs(e-t)>o&&(m.push(i),a=0)}}if(!f){const e=l.at(-1),n=s.getStartPointIndex();if(n-e>1){const s=new h.P;s.setSub(t.getXY(e),t.getXY(n)),_=s.length()}else _=i.calculateLength2D();if(_>d)l.push(n),_=0;else if(r){let t=u.read(e);Number.isNaN(t)&&(t=0);let s=u.read(n);Number.isNaN(s)&&(s=0),Math.abs(s-t)>o&&(l.push(n),_=0)}}}if(m.length>0&&l.length>0&&(m.at(-1)<l.at(-1)?m.length>l.length?m.pop():l.pop():(m.at(-1)===l.at(-1)||l.pop(),l.pop())),l.length+m.length>=2){let t=!1;for(let e=0,s=m.length;e<s;e++)i.getPointByVal(m[e],c),t?n.lineToPoint(c):(n.startPathPoint(c),t=!0);for(let e=l.length-1;e>0;e--)i.getPointByVal(l[e],c),t?n.lineToPoint(c):(n.startPathPoint(c),t=!0);i.isClosedPath(e.getPathIndex())?n.closePathWithLine():l.length>0&&(i.getPointByVal(l[0],c),n.lineToPoint(c))}m.length=0,l.length=0}return r&&n.replaceNaNs(1,0),n.getImpl().setIsSimple(1,d),n}polygonSimplifyAsFeature(){return this.simplifyPlanar()}simplifyPlanar(){if(1===this.m_geometry.getFillRule()&&!(0,a.M)(this.m_knownSimpleResult))return Vs(this.m_geometry,this.m_toleranceSimplify,!0,!1,this.m_knownSimpleResult,this.m_progressTracker,0,!0);const t=new o.E;if(t.addGeometry(this.m_geometry),this.m_geometry.hasAttribute(1)&&t.replaceNaNs(1,0),t.removeNaNVertices(),0!==t.getTotalPointCount()){let e=null,s=0,n=0;if(t.hasCurves()){e=new ys;const r=i.Envelope2D.constructEmpty();this.m_geometry.queryEnvelope(r);const o=fs(this.m_toleranceSimplify.total(),r);s=Ps(this.m_toleranceSimplify.total()),n=xs(o,s),ds(t,o,this.m_toleranceSimplify.total(),0,e,null,this.m_progressTracker)}(0,a.M)(this.m_knownSimpleResult)||Cs(t,this.m_toleranceSimplify.add(n),this.m_progressTracker,!0,!1),this.m_geometry.getGeometryType()===r.G.enumPolygon&&Ht(t,t.getFirstGeometry(),this.m_knownSimpleResult,!1,-1,this.m_progressTracker),null!==e&&e.stitchCurves(t,t.getFirstGeometry(),s,!0)}const e=t.getGeometry(t.getFirstGeometry());return e.getGeometryType()===r.G.enumPolygon&&(e.getImpl().updateOGCFlagsProtected(),e.setFillRule(0)),e.getImpl().setIsSimple(4,this.m_toleranceSimplify.total()),e}progress_(){}static hasNanZs(t){if(t.hasAttribute(1)){const e=t.getAttributeStreamRef(1);for(let s=0,n=t.getPointCount();s<n;s++){const t=e.read(s);if(Number.isNaN(t))return!0}}return!1}compareVerticesForPlanarClustering(t,e,s){if(t===e)return 0;const n=this.m_pairs[t],i=this.m_pairs[e],r=n>>1,o=i>>1,a=this.m_xy.readPoint2D(2*r);a.y+=1&n?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const m=this.m_xy.readPoint2D(2*o);m.y+=1&i?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const l=a.compare(m);if(0===l&&s){const t=this.m_pathsForOGCTests[r]-this.m_pathsForOGCTests[o];return(0,h.e)(t)}return l}compareVerticesMultiPoint(t,e){if(t===e)return 0;const s=this.m_multiVertexGeom.getXY(t),n=this.m_multiVertexGeom.getXY(e),i=!s.isFinite(),r=!n.isFinite();if(i||r)return i<r?-1:i>r?1:0;if(s.y<n.y)return-1;if(s.y>n.y)return 1;if(s.x<n.x)return-1;if(s.x>n.x)return 1;for(let o=1;o<this.m_attributeCount;o++){const s=this.m_description.getSemantics(o),n=a.V.getComponentCount(s);for(let i=0;i<n;i++){const n=this.m_multiVertexGeom.getAttributeAsDbl(s,t,i),r=this.m_multiVertexGeom.getAttributeAsDbl(s,e,i),o=(0,h.r)(n,r);if(0!==o)return o}}return 0}edgeAngleCompare(t,e){if(t===e)return 0;const s=t.m_segment.getTangent(t.getReversed()?1:0);t.getReversed()&&s.negateThis();const n=e.m_segment.getTangent(e.getReversed()?1:0);e.getReversed()&&n.negateThis();const i=s.getQuarter(),r=n.getQuarter();if(r===i){const t=s.crossProduct(n);return t<0?1:t>0?-1:0}return i<r?-1:1}}class ln{getOperatorType(){return 10103}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}isSimpleAsFeature(t,e,s,n,i){const r=Qs(t,e,s,n,i);return(0,a.R)(t.getGeometryType(),r)}isSimplePlanarDONOTUSE(t,e,s,n,h){const m=function(t,e,s,n,h){if(n&&(n.m_reason=0,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),t.isEmpty())return 5;const m=t.getGeometryType();if(m===r.G.enumPoint)return $s(t,n);const l=(0,a.b)(e,t,!1).total();if(m===r.G.enumEnvelope){const e=t,s=new i.Envelope2D;return e.queryEnvelope(s),s.isDegenerate(l)?(n&&(n.m_reason=4,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),0):5}if((0,r.f)(m)){const i=t,r=new o.P({vd:i.getDescription()});return r.addSegment(i,!0),Qs(r,e,s,n,h)}const u=t.getImpl().getIsSimple(l,[0]);let c=s?-1:u;if((0,a.i)(c)||0===c)return c;const g=new mn(t,e,c,h,!1);return m===r.G.enumMultiPoint||m===r.G.enumPolyline||m===r.G.enumPolygon?c=g.isSimplePlanarImpl():(0,r.c)(""),t.getImpl().setIsSimple(c,l),n&&n.assign(g.m_nonSimpleResult),c}(t,e,s,n,h);return(0,a.i)(m)}executeMany(t,e,s,n){return new un(t,e,s,n)}execute(t,e,s,n){const i=new g.S([t]),o=this.executeMany(i,e,s,n).next();return o||(0,r.c)("null geometry"),o}}class un extends g.G{constructor(t,e,s,n){super(),this.m_progressTracker=n,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=t,this.m_spatialReference=e}next(){const t=this.m_inputGeometryCursor.next();return t?(this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(t)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(t){if(t||(0,r.t)(""),t.getGeometryType()===r.G.enumGeometryCollection){const e=(0,o.g)(t,-1),s=(new ln).executeMany(e,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker),n=t.createInstance();for(let t=s.next();null!=t;t=s.next())n.addGeometry(t);return n}return Ks(t,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}class cn{constructor(t,e,s,n){this.m_intersectorGeom=null,this.m_sr=null,this.m_dimensionMask=-1,this.m_progressTracker=null,this.m_intersectorGeomType=r.G.enumUnknown,this.m_geomIntersectorEmptyGeom=null,this.m_intersectorGeom=t,this.m_sr=e,this.m_dimensionMask=s,this.m_progressTracker=n,this.m_intersectorGeomType=t.getGeometryType()}intersect(t){const e=this.tryFastImplementation(t);if(null!==e)return e;const s=(0,a.g)(this.m_intersectorGeom,t),n=(0,a.a)(this.m_sr,s,!0).total(),m=i.Envelope2D.constructEmpty();this.m_intersectorGeom.queryEnvelope(m);const l=i.Envelope2D.constructEmpty();t.queryEnvelope(l),m.inflateCoords(2*n,2*n),m.intersect(l),m.inflateCoords(100*n,100*n);let c=(0,u.c)(this.m_intersectorGeom,m,0,0,this.m_progressTracker),g=(0,u.c)(t,m,0,0,this.m_progressTracker);return t.getDimension()>this.m_intersectorGeom.getDimension()&&(c=(0,h.b)(g,g=c)),function(t,e,s,n){const h=i.Envelope2D.constructEmpty();t.queryEnvelope(h);const m=i.Envelope2D.constructEmpty();e.queryEnvelope(m);const l=i.Envelope2D.constructEmpty();l.setCoords({env2D:h}),l.mergeEnvelope2D(m);const u=(0,a.a)(s,l,!0),c=new i.Envelope2D(m),g=(0,a.d)(u);if(c.inflateCoords(g,g),!h.isIntersecting(c)){if(t.getDimension()<=e.getDimension())return Us(zs(t.createInstance()),t,0,"&");if(t.getDimension()>e.getDimension())return Us(zs(e.createInstance()),t,0,"&")}const d=new Bs(n),_=new o.E,p=_.addGeometry(zs(t)),f=_.addGeometry(zs(e));let P=0,x=0,y=null;if(_.hasCurves()){y=new ys;const t=_.getEnvelope2D(n);x=Ps(u.total());const e=fs(u.total(),t);P=xs(e,x),ds(_,e,u.total(),0,y,null,n)}d.setEditShapeCrackAndCluster(_,u.add(P));const E=d.intersection(p,f);null!==y&&y.stitchCurves(_,E,x,!0);const C=Us(_.getGeometry(E),t,0,"&");return Ns(C.getGeometryType())&&(C.getImpl().setIsSimple(4,u.total()),C.getGeometryType()===r.G.enumPolygon&&C.getImpl().updateOGCFlagsProtected()),C}(g,c,this.m_sr,this.m_progressTracker)}intersectEx(t){const e=this.tryFastImplementation(t);if(null!==e){const s=[];return s.length=3,s[e.getDimension()]=e,this.prepareVector(t.getDescription(),this.m_dimensionMask,s)}const s=(0,a.g)(this.m_intersectorGeom,t),n=(0,a.a)(this.m_sr,s,!0).total(),m=i.Envelope2D.constructEmpty();this.m_intersectorGeom.queryEnvelope(m);const l=i.Envelope2D.constructEmpty();t.queryEnvelope(l),m.inflateCoords(2*n,2*n),m.intersect(l),m.inflateCoords(100*n,100*n);let c=(0,u.c)(this.m_intersectorGeom,m,0,0,this.m_progressTracker),g=(0,u.c)(t,m,0,0,this.m_progressTracker);t.getDimension()>this.m_intersectorGeom.getDimension()&&(c=(0,h.b)(g,g=c));const d=function(t,e,s,n){const h=new Array(3),m=i.Envelope2D.constructEmpty();t.queryEnvelope(m);const l=i.Envelope2D.constructEmpty();e.queryEnvelope(l);const u=i.Envelope2D.constructEmpty();u.setCoords({env2D:m}),u.mergeEnvelope2D(l);const c=(0,a.a)(s,u,!0),g=new i.Envelope2D(l),d=(0,a.d)(c);if(g.inflateCoords(d,d),!m.isIntersecting(g)){if(t.getDimension()<=e.getDimension()){const e=Us(zs(t.createInstance()),t,0,"&");return h[e.getDimension()]=e,h}if(t.getDimension()>e.getDimension()){const s=Us(zs(e.createInstance()),t,0,"&");return h[s.getDimension()]=s,h}}const _=new Bs(n),p=new o.E,f=p.addGeometry(zs(t)),P=p.addGeometry(zs(e));let x=0,y=0,E=null;if(p.hasCurves()){E=new ys;const t=p.getEnvelope2D(n);y=Ps(c.total());const e=fs(c.total(),t);x=xs(e,y),ds(p,e,c.total(),0,E,null,n)}_.setEditShapeCrackAndCluster(p,c.add(x)),p.dbgVerifyCurves();const C=_.intersectionEx(f,P);for(const i of C){null!==E&&E.stitchCurves(p,i,y,!1);const e=Us(p.getGeometry(i),t,0,"&");Ns(e.getGeometryType())&&(e.getImpl().setIsSimple(4,c.total()),e.getGeometryType()===r.G.enumPolygon&&e.getImpl().updateOGCFlagsProtected()),h[e.getDimension()]=e}return null!==E&&E.clearStitcher(p),h}(g,c,this.m_sr,this.m_progressTracker);return this.prepareVector(t.getDescription(),this.m_dimensionMask,d)}init(t,e,s){(0,r.g)(0)}static intersectPoints(t,e,s){const n=(0,a.g)(t,e);return Rs(t,e,(0,a.a)(s,n,!0))}tryFastImplementation(t){const e=t.getGeometryType();if(this.m_intersectorGeomType===r.G.enumPoint&&e===r.G.enumPoint){const e=cn.intersectPoints(t,this.m_intersectorGeom,this.m_sr);if(-1!==this.m_dimensionMask){const t=new o.M({vd:e.getDescription()});return e.isEmpty()||t.add(e),t}return e}if(e===r.G.enumEnvelope&&this.m_intersectorGeomType===r.G.enumEnvelope&&(-1===this.m_dimensionMask||4===this.m_dimensionMask)){const e=t,s=this.m_intersectorGeom,n=new a.E({copy:e});return n.intersect(s),n}const s=(0,a.g)(t,this.m_intersectorGeom),n=(0,a.a)(this.m_sr,s,!0),h=t.isEmpty(),m=this.m_intersectorGeom.isEmpty();let l=h||m;if(!l){const e=function(t,e,s){const n=new i.Envelope2D;t.queryEnvelope(n);const o=new i.Envelope2D;e.queryEnvelope(o);const a=new i.Envelope2D(o);if(a.inflate(2*s),!a.isIntersecting(n))return 4;const h=t.getGeometryType(),m=e.getGeometryType();if(h===r.G.enumEnvelope&&n.containsEnvelope(a))return 1;if(m===r.G.enumEnvelope){const t=new i.Envelope2D(n);if(t.inflate(2*s),o.containsEnvelope(t))return 2}return 0}(this.m_intersectorGeom,t,n.total());if(4===e)l=!0;else{if(2&e)return this.m_intersectorGeom;if(1&e)return t}}if(l){const s=(0,r.A)(e),n=(0,r.A)(this.m_intersectorGeomType);return s<n?cn.ReturnEmpty(t,h):s>n||0===s&&e===r.G.enumMultiPoint&&this.m_intersectorGeomType===r.G.enumPoint?this.ReturnEmptyIntersector():cn.ReturnEmpty(t,h)}if(e===r.G.enumEnvelope&&0===(0,r.A)(this.m_intersectorGeomType)||this.m_intersectorGeomType===r.G.enumEnvelope&&0===(0,r.A)(e)){const s=e===r.G.enumEnvelope?t:this.m_intersectorGeom,o=e===r.G.enumEnvelope?this.m_intersectorGeom:t,a=i.Envelope2D.constructEmpty();return s.queryEnvelope(a),(0,u.c)(o,a,n.total(),0,this.m_progressTracker)}if(0===(0,r.A)(e)&&(0,r.A)(this.m_intersectorGeomType)>0||(0,r.A)(e)>0&&0===(0,r.A)(this.m_intersectorGeomType)){if(e===r.G.enumMultiPoint)return Ys(t,this.m_intersectorGeom,n);if(e===r.G.enumPoint)return ks(t,this.m_intersectorGeom,n);if(this.m_intersectorGeomType===r.G.enumMultiPoint)return Ys(this.m_intersectorGeom,t,n);if(this.m_intersectorGeomType===r.G.enumPoint)return ks(this.m_intersectorGeom,t,n);(0,r.c)("")}return null}ReturnEmptyIntersector(){return null===this.m_geomIntersectorEmptyGeom&&(this.m_geomIntersectorEmptyGeom=this.m_intersectorGeom.createInstance()),this.m_geomIntersectorEmptyGeom}static ReturnEmpty(t,e){return e?t:t.createInstance()}prepareVector(t,e,s){let n=0;return 1&e?(s[0]||(s[0]=new o.M({vd:t})),n++):s.shift(),2&e?(s[n]||(s[n]=new o.P({vd:t})),n++):s.splice(n,1),4&e?s[n]||(s[n]=new o.a({vd:t})):s.splice(n,1),new g.S(s)}}class gn extends g.G{constructor(t,e,s,n,i){super(),this.m_smallCursor=null,this.m_progressTracker=n,this.m_geomIntersector=e.next(),this.m_intersector=new cn(this.m_geomIntersector,s,i,n),this.m_index=-1,this.m_inputGeoms=t,this.m_dimensionMask=i,-1!==this.m_dimensionMask&&(this.m_dimensionMask<=0||this.m_dimensionMask>7)&&(0,r.t)("bad dimension mask")}next(){if(!this.m_geomIntersector)return null;let t;if(null!==this.m_smallCursor){if(t=this.m_smallCursor.next(),t)return t;this.m_smallCursor=null}for(;t=this.m_inputGeoms.next();)return(0,r.d)(t),this.m_index=this.m_inputGeoms.getGeometryID(),-1===this.m_dimensionMask?this.m_intersector.intersect(t):(this.m_smallCursor=this.m_intersector.intersectEx(t),this.m_smallCursor.next());return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class dn{getOperatorType(){return 1e4}accelerateGeometry(t,e,s){if(!this.canAccelerateGeometry(t))return!1;(0,a.b)(e,t,!0);let n=0;return t.getGeometryType()!==r.G.enumPolygon&&t.getGeometryType()!==r.G.enumPolyline||!(0,o.U)(t)||0===s||(n|=t.getImpl().buildQuadTreeAccelerator(s)?1:0),!!n}canAccelerateGeometry(t){return(0,o.U)(t)}supportsCurves(){return!0}executeMany(t,e,s,n){return new gn(t,e,s,n,arguments.length>4&&void 0!==arguments[4]?arguments[4]:-1)}execute(t,e,s,n){if(t.getGeometryType()===r.G.enumPoint&&e.getGeometryType()===r.G.enumPoint)return cn.intersectPoints(t,e,s);const i=new g.S([t]),o=new g.S([e]),a=this.executeMany(i,o,s,n,-1).next();return a||(0,r.c)("null output"),a}}function _n(t,e,s){return e.m_projector.project(t,s)}function pn(t,e,s,n,i){return t.m_projector.transformInPlaceZ(e,null,s,n,null,i)}function fn(t,e,s,n){if(t&&e&&e.isPannable()||(0,r.t)("fold_into_360_range_geodetic"),t.isEmpty())return t;if(4===s)return Pn(t,e,n);let h=t;const m=h.getGeometryType();if((0,r.h)(m)){h=ki(t,e);const n=new i.Envelope2D;h.queryEnvelope(n);const r=(0,a.a)(e,n,!1).total(),o=e.getPannableExtent();let m=Math.floor((n.xmin-o.xmin)/o.width())*o.width()+o.xmin,l=h;for(;m<n.xmax;)m>n.xmin+r&&m<n.xmax-r&&(l=Yi(l,e,s,!0,m)),m+=o.width();h=l}else{if(m===r.G.enumEnvelope){const t=new o.a({vd:h.getDescription()});return t.addEnvelope(h,!1),fn(t,e,s,n)}if((0,r.f)(m)){const t=new o.P({vd:h.getDescription()});return t.addSegment(h,!0),fn(t,e,s,n)}}return Pn(h,e,n)}function Pn(t,e,s){if(t&&e&&e.isPannable()||(0,r.t)(""),t.isEmpty())return t;let n;const i=t.getGeometryType();if(i===r.G.enumEnvelope){const e=new o.a({vd:t.getDescription()});e.addEnvelope(t,!1),n=e}else if((0,r.f)(i)){const e=new o.P({vd:t.getDescription()});e.addSegment(t,!0),n=e}else n=t;const a=ki(n,e);return a.isEmpty()?a:Gi(a,e,0,a!==t,0,s)}function xn(t,e,s,n){const i=e.getXYGridRange(),r=t.hasAttribute(1),o=t.hasAttribute(2);let m=new h.E,l=new h.E;r&&(m=e.getZGridRange()),o&&(l=e.getMGridRange());let c=(new u.O).execute(t,i,s,n);if(r){const e=c.queryInterval(1,0);m.contains(e)||(t===c&&(c=c.clone()),(0,a.U)(c,m,1,0))}if(o){const e=c.queryInterval(2,0);l.contains(e)||(t===c&&(c=c.clone()),(0,a.U)(c,l,2,0))}return c}class yn{constructor(t){this.m_inputPCSHorizonClipOption=0,this.m_outputPCSHorizonClipOption=0,this.m_bDontGeonormalizePolygon=!1,this.m_bClipOutCurvedPoles=!1,this.m_bNormalizeOutputGeometry=!1,this.m_bDontHackPolesInGeogToGeog=!1,this.m_centralMeridianOfOutputGCS=0,this.m_densificationStepInput=0,t||(0,r.t)(""),this.m_projTransform=t,this.m_bClipOutCurvedPoles=!1;const e=this.m_projTransform.getExtendedParamsImpl();this.m_bNormalizeOutputGeometry=e.normalizeResultGeometry,this.m_bNormalizeOutputGeometry&&(e.legacyHorizonClipping?this.m_bNormalizeOutputGeometry=!1:this.m_projTransform.getOutputSR().isPannable()||(this.m_bNormalizeOutputGeometry=!1)),e.clipWithInputHorizon?(this.m_inputPCSHorizonClipOption=0,!e.legacyHorizonClipping&&this.m_projTransform.getInputSR().isPannable()&&(this.m_inputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_inputPCSHorizonClipOption=1,e.clipWithOutputHorizon?(this.m_outputPCSHorizonClipOption=0,!e.legacyHorizonClipping&&this.m_projTransform.getOutputSR().isPannable()&&(this.m_outputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_outputPCSHorizonClipOption=1,this.m_centralMeridianOfOutputGCS=e.centralMeridianOfOutputGCS,this.m_densificationStepInput=e.densificationStep;const s=this.m_projTransform.getExtendedParamsInternal();this.m_bDontGeonormalizePolygon=s.hasFlag(2147483648),this.m_bDontHackPolesInGeogToGeog=s.hasFlag(1073741824),this.m_bClipOutCurvedPoles=s.hasFlag(536870912)}project(t,e){if(this.m_projTransform.isIdentity()||t.isEmpty())return t;const s=t.getGeometryType();if(s===r.G.enumPoint)return this.projectPoint(t,e);const n=this.m_projTransform.getInputSR().getCoordinateSystemType(),i=this.m_projTransform.getOutputSR().getCoordinateSystemType(),o=this.m_projTransform.getInputSR(),a=this.m_projTransform.getOutputSR();if(0===n&&n===i){const e=Cn(o,a),s=t.clone();return s.applyTransformation(e),s}switch(s){case r.G.enumPolyline:case r.G.enumPolygon:return this.projectMultiPath(t,e);case r.G.enumMultiPoint:return this.projectMultiPoint(t,e);case r.G.enumEnvelope:return this.projectEnvelope(t,e);case r.G.enumGeometryCollection:return this.projectGeometryCollection(t,e);default:(0,r.c)("")}}projectPoint(t,e){const s=[t.getXY()];let n,i=null;(n=t.hasAttribute(1))&&(i=[t.getZ()]),this.transformInPlaceZ(s,i,1,s,i,null);const r=t.clone();return r.setXY(s[0]),n&&r.setZ(i[0]),r}projectMultiPoint(t,e){let s=new o.M({copy:t});const n=this.m_projTransform.getInputSR(),i=this.m_projTransform.getOutputSR(),a=n.getCoordinateSystemType(),h=i.getCoordinateSystemType();if(3===a&&(0,r.g)(0),s=zi(s,n,this.m_inputPCSHorizonClipOption,e),s.isEmpty())return s;2===a&&$i(n,0,s),rr(this.m_projTransform,s,!1);let m=0;3===h&&(0,r.g)(0);const l=2===h;return l?m=i.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(m=this.m_centralMeridianOfOutputGCS),l&&0!==this.m_outputPCSHorizonClipOption||(s=Gi(s,uo(i),m,!1,0,e)),l&&(s=Di(s,i,this.m_outputPCSHorizonClipOption,e),Qi(i,s,this.m_bNormalizeOutputGeometry),s.isEmpty()),s}projectMultiPath(t,e){const s=t.getGeometryType();return s===r.G.enumPolygon?this.projectPolygon(t,e):s===r.G.enumPolyline?this.projectPolyline(t,e):void(0,r.c)("project_multi_path_")}projectEnvelope(t,e){this.m_projTransform.getInputSR(),this.m_projTransform.getOutputSR();const s=this.m_projTransform.isVertical()&&t.hasAttribute(1);let n=h.E.constructEmpty();if(s&&(n=t.queryInterval(1,0)),n.width()>0){const s=t.clone();s.setInterval(1,0,n.vmin,n.vmin);const i=this.projectEnvelopeHelper(s,e);s.setInterval(1,0,n.vmax,n.vmax);const r=this.projectEnvelopeHelper(s,e);return i.merge(r),i}return this.projectEnvelopeHelper(t,e)}projectPolygon(t,e){(0,r.g)(t.getGeometryType()===r.G.enumPolygon),(0,r.g)(!this.m_projTransform.isIdentity()),(0,r.g)(!t.isEmpty());const s=this.m_projTransform.getInputSR(),n=this.m_projTransform.getOutputSR(),a=s.getCoordinateSystemType(),h=n.getCoordinateSystemType(),m=new o.a({copy:t});3===a&&(0,r.g)(0),3===h&&(0,r.g)(0);const l=2===a,g=2===h,d=l?s.getGCS():s,_=g?n.getGCS():n,p=!g&&!this.m_bDontHackPolesInGeogToGeog;let f=!1,P=zi(m,s,this.m_inputPCSHorizonClipOption,e);if(P.isEmpty())return P;let x=this.m_densificationStepInput;const y=!Number.isNaN(x);let E;y&&(P=(new c.O).execute(P,x,0,0,e));let C=g?n.getPCSInfo():null,S=Number.NaN;l&&(S=s.getCentralMeridian());const v=null!==n.getGCSSplitLines();if(this.m_bDontGeonormalizePolygon){const t=P;if(l&&(sr(s,S,t),y)){const t=s.getUnitsPerMillimeter();x*=s.getGCS().getUnitsPerMillimeter()/t}if(ar(this.m_projTransform,t,p),y){const t=s.getGCS().getUnitsPerMillimeter();x*=n.getGCS().getUnitsPerMillimeter()/t}E=t}else{let t=new o.P({vd:P.getDescription()});if(t.addAndExplicitlyOpenAllPaths(P,!1),l){if(sr(s,S,t),y){const t=s.getUnitsPerMillimeter();x*=s.getGCS().getUnitsPerMillimeter()/t}if(this.m_bClipOutCurvedPoles){const n=s.getPCSInfo(),r=n.getSouthPoleGeometry()===Lo.PE_POLE_LINE_CURVED,o=n.getNorthPoleGeometry()===Lo.PE_POLE_LINE_CURVED;if(r||o){const s=i.Envelope2D.constructEmpty();t.queryLooseEnvelope(s),s.inflateCoords(1,1);const n=89.9999*d.getOneDegreeGCSUnit();r&&(s.ymin=-n),o&&(s.ymax=n),t=(0,u.a)(t,s,d,0,0,e)}}}if(ar(this.m_projTransform,t,p),y){const t=uo(s).getUnitsPerMillimeter();x*=uo(n).getUnitsPerMillimeter()/t}let r=Number.NaN;g?(C=n.getPCSInfo(),r=n.getCentralMeridian()):Number.isNaN(this.m_centralMeridianOfOutputGCS)||(r=this.m_centralMeridianOfOutputGCS);let a=En(s)|En(n),h=10*_.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(a=3,h=10*_.getTolerance(0)),E=function(t,e,s,n,i,r,o,a,h){return new ni(t,null,s,e,n,i,o,a,r).geoNormalizePolygonGeometry(h)}(P,s,t,_,r,e,a,h,this.m_bNormalizeOutputGeometry),a=0}if(v&&((0,r.g)(!n.isPannable()),E=bi(E,n,e)),g){if(!f){const t=_.getPannableExtent().width();if(E.queryInterval(0,0).width()>=t-10*_.getTolerance(0)){const t=C.getNorthPoleLocation(),e=C.getSouthPoleLocation(),s=C.getNorthPoleGeometry(),n=C.getSouthPoleGeometry();let i=0;s===Lo.PE_POLE_POINT&&t!==Lo.PE_POLE_OUTSIDE_BOUNDARY&&(i=1),n===Lo.PE_POLE_POINT&&e!==Lo.PE_POLE_OUTSIDE_BOUNDARY&&(i|=2),f||(f=0!==i)}}E=Di(E,n,this.m_outputPCSHorizonClipOption,e),y&&(E=(new c.O).execute(E,x,0,0,e)),Ji(n,E,this.m_bNormalizeOutputGeometry)}return E.isEmpty()||f&&(E=(new ln).execute(E,n,!1,e)),E}projectPolyline(t,e){(0,r.g)(t.getGeometryType()===r.G.enumPolyline),(0,r.g)(!this.m_projTransform.isIdentity()),(0,r.g)(!t.isEmpty());const s=this.m_projTransform.getInputSR(),n=this.m_projTransform.getOutputSR(),i=s.getCoordinateSystemType(),a=n.getCoordinateSystemType(),h=new o.P({copy:t});3===i&&(0,r.g)(0),3===a&&(0,r.g)(0);const m=2===i,l=2===a;m&&s.getGCS();const u=l?n.getGCS():n,g=!l&&!this.m_bDontHackPolesInGeogToGeog;let d=zi(h,s,this.m_inputPCSHorizonClipOption,e);if(d.isEmpty())return d;let _=Number.NaN;m&&(_=s.getCentralMeridian());const p=null!==n.getGCSSplitLines();let f=this.m_densificationStepInput;const P=!Number.isNaN(f);let x;if(P&&(d=(new c.O).execute(d,f,0,0,e)),this.m_bDontGeonormalizePolygon){if(m&&(sr(s,_,d),P)){const t=s.getUnitsPerMillimeter();f*=s.getGCS().getUnitsPerMillimeter()/t}if(ar(this.m_projTransform,d,g),P){const t=s.getGCS().getUnitsPerMillimeter();f*=n.getGCS().getUnitsPerMillimeter()/t}x=d}else{const t=new o.P({vd:d.getDescription()});if(t.addAndExplicitlyOpenAllPaths(d,!1),m&&(sr(s,_,t),P)){const t=s.getUnitsPerMillimeter();f*=s.getGCS().getUnitsPerMillimeter()/t}if(ar(this.m_projTransform,t,g),P){const t=s.getGCS().getUnitsPerMillimeter();f*=n.getGCS().getUnitsPerMillimeter()/t}let i=Number.NaN;l?i=n.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(i=this.m_centralMeridianOfOutputGCS);let r=En(s)|En(n),a=10*u.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(r=3,a=0),x=function(t,e,s,n,i,r,o,a,h){return new ni(t,null,s,e,n,i,o,a,r).geoNormalizePolylineGeometry(h)}(d,s,t,u,i,e,r,a,this.m_bNormalizeOutputGeometry),r=0}return p&&((0,r.g)(!n.isPannable()),x=bi(x,n,e)),l&&(x=Di(x,n,this.m_outputPCSHorizonClipOption,e),P&&(x=(new c.O).execute(x,f,0,0,e)),Ji(n,x,this.m_bNormalizeOutputGeometry)),x.isEmpty(),x}projectGeometryCollection(t,e){return(0,r.g)(0),{}}projectEnvelopeHelper(t,e){const s=(t.height()+t.width())/400;if(0!==s){const n=(new c.O).execute(t,s,0,0,e),r=this.projectMultiPath(n,e),h=new a.E({vd:t.getDescription()});if(r.isEmpty()){const s=Math.min(t.height(),t.width()),r=(0,a.b)(this.m_projTransform.getInputSR(),t,!0).total();if(s>100*r){const t=i.Envelope2D.constructEmpty(),e=(0,a.a)(this.m_projTransform.getOutputSR(),t,!0).total(),n=this.m_projTransform.getInputSR().getOneMeter()/this.m_projTransform.getOutputSR().getOneMeter();if(s>100*Math.max(r,e*n))return h}const m=new o.P;m.addAndExplicitlyOpenAllPaths(n,!1),this.projectMultiPath(m,e).queryEnvelope(h);const l=new o.M({vd:t.getDescription()});l.reserve(4);const u=new a.P;for(let e=0;e<4;e++)t.queryCornerByVal(e,u),l.add(u);const c=this.projectMultiPoint(l,e),g=new a.E;return c.queryEnvelope(g),h.merge(g),h}return r.queryEnvelope(h),h}{const s=t.getCenterXY(),n=new a.P(s),i=this.projectPoint(n,e),r=new a.E({vd:t.getDescription()});if(i.isEmpty())r.setEmpty();else{t.copyTo(r);const e=i.getXY();r.setCoords(e.x,e.y,e.x,e.y)}return r}}transformInPlace(t,e,s,n){return(0,r.g)(0),0}transformInPlaceZ(t,e,s,n,i,o){if(this.m_projTransform.isIdentity())return t!==n&&(0,h.au)(n,t,s),e!==i&&(0,h.a)(i,e,0,0,s),s;const a=this.m_projTransform,m=a.getInputSR(),l=a.getOutputSR(),u=m.getCoordinateSystemType(),c=l.getCoordinateSystemType();if(0===u&&u===c)return Cn(m,l).transformPoints2D(t,s,n),a.isVertical()&&(0,r.g)(0),s;3===u&&(0,r.b)("image: transform_in_place_"),3===c&&(0,r.b)("image: transform_in_place_"),function(t,e,s,n,i){const o=n.getCoordinateSystemType();if(2===o){if(0===i)s!==t&&(0,h.au)(s,t,e),function(t,e,s){const n=t.getPCSHorizon();if(n.getGeometryType()!==r.G.enumPolygon)if(n.getGeometryType()!==r.G.enumEnvelope)(0,r.t)("");else{const t=n;for(let n=0;n<s;n++)t.contains(e[n])||e[n].setNAN()}else{const i=t.getDefaultPrecisionSR().getTolerance(0),r=n;for(let t=0;t<s;t++)1!==as(r,e[t],i)&&e[t].setNAN()}}(n,s,e);else if(s!==t&&(0,h.au)(s,t,e),n.isPannable()){const t=n.getTolerance(0);(function(t,e,s,n){for(let i=0;i<e;i++){if(t[i].y<s.ymin||t[i].y>s.ymax){t[i].setNAN();continue}const e=t[i].x;t[i].x=qi(e,s,n)}})(s,e,n.getPannableExtent(),t),Mi(s,e,n,0)}}else{(0,r.g)(1===o);const i=n.getTolerance(0),a=n.getPannableExtent();for(let n=0;n<e;n++)s[n].assign(Ui(t[n],a,i))}}(t,s,n,m,this.m_inputPCSHorizonClipOption),i!==e&&(0,h.a)(i,e,0,0,s),2===u&&nr(m,0,n,s),ur(this.m_projTransform,n,i,s,!1);let g=0;const d=2===c;if(d?g=l.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(g=this.m_centralMeridianOfOutputGCS),d&&0!==this.m_outputPCSHorizonClipOption||Mi(n,s,l.getGCS(),g),d){if(!Ai(n,s,l,this.m_outputPCSHorizonClipOption))for(let t=0;t<s;++t)n[t].setNAN();Wi(l,n,s,!1)}let _=s;for(let r=0;r<s;++r)n[r].isNAN()&&(i&&(i[r]=Number.NaN),_--);return _}}function En(t){if(2!==t.getCoordinateSystemType())return 0;let e=0;const s=t.getPCSInfo(),n=s.getNorthPoleLocation(),i=s.getSouthPoleLocation(),r=s.getNorthPoleGeometry(),o=s.getSouthPoleGeometry();return r===Lo.PE_POLE_POINT&&n!==Lo.PE_POLE_OUTSIDE_BOUNDARY&&(e=1),o===Lo.PE_POLE_POINT&&i!==Lo.PE_POLE_OUTSIDE_BOUNDARY&&(e|=2),e}function Cn(t,e){const s=t.getHorzUnitFactor(),n=e.getHorzUnitFactor();let i=1,r=1;const o=20015077/180;1===t.getUnit().getUnitType()&&(i=o),1===e.getUnit().getUnitType()&&(r=o);const a=s/n*(i!==r?i/r:1),h=new l.T;return h.setScaleCoords(a,a),h}let Sn=class{getOperatorType(){return 10300}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s){return!e||e.isIdentity()?t:new vn(t,e,s)}execute(t,e,s){return e.isIdentity()?t:_n(t,e,s)}transform(t,e,s,n){return!(arguments.length>4&&void 0!==arguments[4])||arguments[4]?function(t,e,s,n,i){t.m_projector.transformInPlaceZ(e,null,s,n,null,i);const r=n.slice(0,s).filter((t=>!t.isNAN()));for(let o=0,a=r.length;o<a;++o)n[o].assign(r[o]);return r.length}(t,e,s,n,null):pn(t,e,s,n,null)}transform3D(t,e,s,n){return(0,r.g)(0),0}foldInto360Range(t,e){return Pn(t,e,null)}foldInto360RangeGeodetic(t,e,s){return fn(t,e,s,null)}normalizeGeometryEx(t,e,s,n){return function(t,e,s,n,i){if(!e.isPannable()||t.isEmpty())return t;const m=t.getGeometryType();m===r.G.enumGeometryCollection&&(0,r.b)("not yet impl for geometry collection");const u=e.getPannableExtent();Number.isNaN(s)&&(s=u.getCenterX());const c=u.width(),g=.5*c,d=i>0,_=t.queryInterval(0,0);if(!d&&_.width()<g||!(0,r.i)(t.getGeometryType())){const e=_.getCenter();if(Math.abs(e-s)<=g)return t;{const n=new l.T,i=(0,h.av)((s-e)/c)*c;n.setShiftCoords(i,0);const r=t.clone();return r.applyTransformation(n),r}}if(m===r.G.enumPolygon){let r=new o.P({vd:t.getDescription()});r.addAndExplicitlyOpenAllPaths(t,!1),d&&(r=bn(r,e,2,i,Number.NaN,null,!0));const m=[];if(!n){{let s=t;d&&(s=new o.a,s.add(r,!1));const n=function(t,e,s){const n=$r();e.querySpheroidData(n);const i=e.getGCS()!==e?e.getSRToGCSTransform():null,r=(0,h.m)(h.P,100),o=new a.h(0,0,0),m=t.getPointCount(),l=e.getGCS().getUnit().getUnitToBaseFactor();for(let a=0,h=m;a<h;){const e=Math.min(100,h-a);t.queryCoordinates(r,e,a,a+e),i&&(new Sn).transform(i,r,e,r,!1);for(let t=0;t<e;t++){if(r[t].isNAN())continue;r[t].scale(l);const e=I(n.majorSemiAxis,n.e2,r[t]);o.addThis(e)}a+=e}const u=T(n.majorSemiAxis,n.e2,o);u.scale(1/l);const c=t;if(!new Kn(e.getGCS(),u).project(c))return 0;s.length=t.getPathCount();const g=c.calculateArea2D()<0;for(let a=0,h=t.getPathCount();a<h;a++){const t=c.calculateRingArea2D(a),e=g?t<0:t>0;s[a]=e}return g?-1:1}(t,e,m);if(n)n<0&&r.reverseAllPaths();else{const t=s.getPathCount();for(let e=0;e<t;e++)m.push(s.calculateRingArea2D(e)>0)}}n=m}return new ni(null,n,r,null,e,s,3,0,null).geoNormalizePolygonGeometry(!0)}if(m===r.G.enumPolyline){let n=new o.P({vd:t.getDescription()});return n.addAndExplicitlyOpenAllPaths(t,!1),d&&(n=bn(n,e,2,i,Number.NaN,null,!0)),new ni(null,null,n,null,e,s,3,0,null).geoNormalizePolylineGeometry(!0)}if(m===r.G.enumMultiPoint){const e=t,n=e.getAttributeStreamRef(0);let i,r=null,o=s,a=0;const m=.1*c;for(let s=0,l=e.getPointCount();s<l;s++){const e=n.read(2*s);let l=e-o;if(Math.abs(l)>g&&(l=(0,h.av)(l/c)*c,a-=l,Math.abs(a)<m&&(a=0)),0!==a){r||(i=t.clone(),r=i.getAttributeStreamRef(0));const n=e+a;r.write(2*s,n)}o=e}return r?(i.notifyModified(),i):t}(0,r.c)("")}(t,e,s,n,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}normalizeGeometry(t,e,s){return function(t,e,s){if(!e.isPannable()||t.isEmpty())return t;const n=e.getPannableExtent().width(),i=.5*n,o=t.queryInterval(0,0);if(o.width()<i||!(0,r.i)(t.getGeometryType())){if(Number.isNaN(s))return t;const e=o.getCenter();if(Math.abs(e-s)<=i)return t;{const i=new l.T,r=(0,h.av)((s-e)/n)*n;i.setShiftCoords(r,0);const o=t.clone();return o.applyTransformation(i),o}}const a=t.getGeometryType(),m=t,u=m.getAttributeStreamRef(0),c=t.clone(),g=c.getAttributeStreamRef(0);let d=0,_=0,p=0,f=(0,r.h)(a)?0:-1;const P=h.E.constructEmpty();let x=!1;for(let l=0,y=m.getPointCount();l<y;l++){const t=u.read(2*l);l===_&&((0,r.h)(a)?(0===f&&Number.isNaN(s)&&(x=!0),f>0&&Number.isNaN(s)&&(s=P.getCenter(),x=!1),_=m.getPathEnd(f),f++):_=m.getPointCount(),Number.isNaN(s)?p=t:(p=s,d=0));let e=t-p;Math.abs(e)>i&&(e=(0,h.av)(e/n)*n,d-=e,Math.abs(d)<.1*n&&(d=0));const o=t+d;g.write(2*l,o),x&&P.mergeCoordinate(o),p=t}return c.notifyModified(),c}(t,e,s)}clipToSpatialReference(t,e,s){return function(t,e,s,n){const o=e.getCoordinateSystemType();if(0===o){const n=new vo;return e.queryPrecisionDescriptor(n),xn(t,n,e,s)}let a=t;2!==n&&3!==n||!e.isPannable()||(a=Pn(a,e,s));const h=new vo;if(e.queryPrecisionDescriptor(h),a=xn(a,h,e,s),0===n||a.isEmpty())return a;if(1===o){if(1===n){const t=new i.Envelope2D;a.queryLooseEnvelope(t);const n=e.getPannableExtent(),r=.01*n.width();return n.xmin=t.xmin-r,n.xmax=t.xmax+r,(new u.O).execute(a,n,e,s)}return a}if(2===o){const t=e.getPCSHorizon();if(1===n||2===n){const n=(new dn).execute(a,t,e,s);return n===t?n.clone():n}return a}if(3===o)return a;(0,r.c)("missing implementation")}(t,e,s,arguments.length>3&&void 0!==arguments[3]?arguments[3]:0)}};class vn extends g.G{constructor(t,e,s){super(),this.m_projTrans=e,this.m_progressTracker=s,this.m_index=-1,t||(0,r.t)(""),this.m_inputGeoms=t}next(){const t=this.m_inputGeoms.next();return null!=t?((0,r.l)(t),(0,r.d)(t),this.m_index=this.m_inputGeoms.getGeometryID(),_n(t,this.m_projTrans,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}function bn(t,e,s,n,i,a){let h=arguments.length>6&&void 0!==arguments[6]&&arguments[6];t||(0,r.t)("Geometry.Geodetic_densify.densify");let m=t.getGeometryType();if((0,r.d)(t),t.isEmpty()||(0,r.e)(m))return t;const l=new An;l.m_sr=e,l.m_gcs=e.getGCS(),l.m_transform=l.m_gcs!==e?e.getSRToGCSTransform():null,l.m_progressTracker=a;const u=$r();let c,g,d;if(l.m_gcs.querySpheroidData(u),l.m_a=u.majorSemiAxis,l.m_eSquared=u.e2,l.m_rpu=l.m_gcs.getUnit().getUnitToBaseFactor(),l.m_gcsTolerance=l.m_gcs.getTolerance(0),l.m_radTolerance=l.m_gcsTolerance*l.m_rpu,l.m_maxLength=n,l.m_maxDeviation=i,l.m_curveType=s,m===r.G.enumEnvelope){const e=new o.a({vd:t.getDescription()});e.addEnvelope(t,!1),c=e,m=r.G.enumPolygon}else if((0,r.f)(m)){const e=new o.P({vd:t.getDescription()});e.addSegment(t,!0),c=e,m=r.G.enumPolyline}else c=t;if(4!==l.m_curveType){if((0,r.g)((0,r.h)(m)),g=l.replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(c),g.isEmpty())return g;g=In(l.m_rpu,g);let t=l.geodeticDensify(g);h||(t=(new Sn).foldInto360RangeGeodetic(t,l.m_gcs,l.m_curveType)),d=l.m_transform&&!l.m_transform.isIdentity()?(new Sn).execute(t,l.m_transform.getInverse(),a):t}else{let t;if((0,r.g)((0,r.h)(m)),e.isPannable())t=ki(c,e);else{const s=e.getPCSHorizon();t=(new dn).execute(c,s,e,a),t===s&&(t=s.clone())}if(g=t,g.isEmpty())return g;d=l.shapePreservingDensify(g)}return d}function In(t,e){const s=new i.Envelope2D;if(e.queryLooseEnvelope(s),s.width()*t<Math.PI)return e;let n=!1;const r=e.querySegmentIterator(),o=new h.P,m=new h.P;for(;r.nextPath();)for(;r.hasNextSegment();){const e=r.nextSegment();if(o.setCoordsPoint2D(e.getStartXY()),m.setCoordsPoint2D(e.getEndXY()),o.scale(t),m.scale(t),Math.abs(o.x-m.x)>Math.PI){if(!Dn(o,m)){n=!0;break}if(Math.abs(o.x-m.x)>2*Math.PI){n=!0;break}}}if(!n)return e;const l=e.createInstance();l.reserve(e.getPointCount());const u=e.getDescription().getAttributeCount()>1,c=new h.P,g=new h.P,d=new h.P(0,0),_=new h.P(0,0),p=new a.P;for(r.resetToFirstPath();r.nextPath();){let e=Number.NaN,s=0;for(;r.hasNextSegment();){const n=r.nextSegment();if(o.setCoordsPoint2D(n.getStartXY()),m.setCoordsPoint2D(n.getEndXY()),o.scale(t),m.scale(t),Number.isNaN(e)?(s=Bn(o.x,Number.NaN,s),d.setCoordsPoint2D(o)):d.setCoordsPoint2D(_),e=d.x,Dn(o,m)){if(m.x-o.x>2*Math.PI)for(;m.x-o.x>2*Math.PI;)m.x-=2*Math.PI;else if(m.x-o.x<2*-Math.PI)for(;m.x-o.x<2*-Math.PI;)m.x+=2*Math.PI;s=Bn(m.x,Number.NaN,s),_.setCoordsPoint2D(m)}else c.setCoordsPoint2D(m),jn(c),s=Bn(c.x,e,s),_.setCoords(s+c.x,c.y);if(Math.abs(_.x-m.x)<.5&&_.setCoordsPoint2D(m),u)n.queryCoord(0,p),g.setCoordsPoint2D(d),g.scale(1/t),p.setXY(g),r.isFirstSegmentInPath()?l.startPathPoint(p):l.lineToPoint(p),r.isLastSegmentInPath()&&!r.isPathClosed()&&(n.queryCoord(1,p),g.setCoordsPoint2D(_),g.scale(1/t),p.setXY(g),l.lineToPoint(p));else{r.isFirstSegmentInPath()&&l.insertPath2D(-1,null,0,0,!0);const e=l.getPathCount()-1;g.setCoordsPoint2D(d),g.scale(1/t),l.insertPoint2D(e,-1,g),r.isLastSegmentInPath()&&!r.isPathClosed()&&(g.setCoordsPoint2D(_),g.scale(1/t),l.insertPoint2D(e,-1,g))}}}return l}function wn(t,e,s,n,i,r,o,a,m,l,u,c){const g=new h.P,d=new h.P,_=n.compare(i)>0;Hn(_,n,i,g,d);const p=Fn(t,e,s,g,d,r,o,a,m,l,null,u,c);return _&&Rn(m,l,null,u),p}function Dn(t,e){return!(!Vo(t.y,h.l)||!Vo(e.y,h.l))||!(!Vo(t.y,-h.l)||!Vo(e.y,-h.l))}function Tn(t,e){return!(!Vo(t.y,h.l)||Vo(e.y,h.l))||!(!Vo(t.y,-h.l)||Vo(e.y,-h.l))}function Nn(t,e){return!(!Vo(e.y,h.l)||Vo(t.y,h.l))||!(!Vo(e.y,-h.l)||Vo(t.y,-h.l))}class An{constructor(){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_progressTracker=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_gcsTolerance=0,this.m_radTolerance=0,this.m_maxLength=0,this.m_maxDeviation=0,this.m_curveType=0}geodeticDensify(t){const e=t.createInstance(),s=t.querySegmentIterator(),n=[],i=[],r=new o.S,a=t.getDescription().getAttributeCount()>1;for(;s.nextPath();){const t=[0];for(;s.hasNextSegment();){const o=s.nextSegment(),m=o.getStartXY(),l=o.getEndXY();m.scale(this.m_rpu),l.scale(this.m_rpu);const u=new h.P,c=new h.P,g=m.compare(l)>0;Hn(g,m,l,u,c),n.length=0,i.length=0,this.m_maxLength>0?Fn(this.m_a,this.m_eSquared,this.m_curveType,u,c,this.m_maxLength,this.m_maxDeviation,this.m_radTolerance,null,null,a?i:null,n,t):qn(),g&&Rn(null,null,a?i:null,n),n[0].setCoordsPoint2D(o.getStartXY()),n.at(-1).setCoordsPoint2D(o.getEndXY());const d=1/this.m_rpu;for(let t=1,e=n.length-1;t<e;t++)n[t].scale(d);if(a){const t=Ln(g,o,r);Mn(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),o,t,i,n,e)}else Gn(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),n,e)}}return e}shapePreservingDensify(t){const e=t.createInstance(),s=t.querySegmentIterator(),n=[],i=[],r=new o.S,a=t.getDescription().getAttributeCount()>1;for(;s.nextPath();)for(;s.hasNextSegment();){const t=s.nextSegment(),o=t.getStartXY(),h=t.getEndXY(),m=o.compare(h)>0,l=Ln(m,t,r);n.length=0,i.length=0,kn(this.m_a,this.m_eSquared,this.m_rpu,l,this.m_sr,this.m_maxLength,this.m_maxDeviation,a?i:null,n),m&&Rn(null,null,a?i:null,n),a?Mn(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),t,l,i,n,e):Gn(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),n,e)}return e}replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(t){const e=t.hasNonLinearSegments();if((!this.m_transform||this.m_transform.isIdentity())&&(t=ki(t,this.m_gcs),!e))return t;const s=t.createInstance();s.reserveParts(t.getPointCount(),t.getPathCount());for(let n=0,i=t.getPathCount();n<i;++n){let e=new o.M;const i=t.getPathStart(n),r=t.getPathEnd(n);e.addPoints(t,i,r);const h=t.isClosedPath(n);let m=!1;if(h&&r-i==1&&t.hasNonLinearSegmentsPath(n)){const s=new a.P;t.getPointByVal(i,s),e.add(s),m=!0}if(this.m_transform&&!this.m_transform.isIdentity()){if(h&&!m){const s=new a.P;t.getPointByVal(i,s),e.add(s)}if(e=(new Sn).execute(e,this.m_transform,this.m_progressTracker),h&&e.getPointCount()>1){const t=e.getXY(0),s=e.getXY(e.getPointCount()-1);t.equals(s)&&e.removePoint(e.getPointCount()-1)}}e.getPointCount()>1&&(s.addPathMultiPoint(e,0,-1,!0),h&&s.closePathWithLine())}return s}}function Gn(t,e,s,n){t&&n.insertPath2D(-1,null,0,0,!0);const i=n.getPathCount()-1;n.insertPointsFromPoints(i,-1,s,0,s.length-1,!0),e&&n.insertPoint2D(i,-1,s.at(-1))}function Mn(t,e,s,n,i,r,o){o.reserve(o.getPointCount()+r.length-1);const h=new a.P;if(s.queryStart(h),t?o.startPathPoint(h):o.lineToPoint(h),r.length>2){const t=n.calculateLength2D();for(let e=1;e<r.length-1;e++){const s=n.lengthToT(i[e]*t);n.queryCoord(s,h),h.setXY(r[e]),o.lineToPoint(h)}}e&&(s.queryEnd(h),o.lineToPoint(h))}function Fn(t,e,s,n,i,r,o,a,l,u,c,g,d){const _={stack:[],error:void 0,hasError:!1};try{const p=(0,m.b)(_,new Yo,!1),f=(0,m.b)(_,new Yo,!1),P=(0,m.b)(_,new Yo,!1);zo.geodeticDistance(t,e,n.x,n.y,i.x,i.y,P,p,f,s);const x=P.val,y=p.val,E=f.val;let C=y,S=E;C<0&&(C+=2*Math.PI),S<0&&(S+=2*Math.PI),l&&(l[0]=C),u&&(u[0]=S);let v=Number.NaN,b=Number.NaN;if(null!==c){const s=Oo.q90(t,e),i=Oo.q(t,e,n.y);v=(s-i)/x,b=(s+i)/x}const I=Tn(n,i),w=Nn(n,i),D=I||w,T=function(t,e,s){return!(!Wn(t,e,s)||Vo(t.y,h.l)||Vo(t.y,-h.l)||Vo(e.y,h.l)||Vo(e.y,-h.l))}(n,i,a),N=(0,m.b)(_,new h.S(new Yo,new Yo),!1),A=new h.P,G=new h.P,M=new h.P;d[0]=Bn(n.x,Number.NaN,d[0]);let F=d[0];if(x<=r)return g.push(n.clone()),d[0]=Bn(i.x,Number.NaN,d[0]),null!=c&&c.push(0),D?(I&&Un(n,i,c,g),w&&zn(n,i,c,g)):T?On(n,i,y,v,b,c,g):o>0&&(G.setCoords(n.x-F,n.y),A.setCoords(i.x-d[0],i.y),F=Vn()),g.push(i.clone()),x;const q=1+Math.ceil(x/r),V=x/(q-1),Y=new h.P;g.push(n.clone()),Y.setCoordsPoint2D(n),G.setCoords(n.x-d[0],n.y),null!==c&&c.push(0);for(let r=1;r<q;r++){let h;if(r<q-1){const i=r*V;zo.geodeticCoordinate(t,e,n.x,n.y,i,y,N.at(0),N.at(1),s),A.setCoords(N.at(0).val,N.at(1).val),d[0]=Bn(A.x,Y.x,d[0]),M.setCoords(d[0]+A.x,A.y),h=r/(q-1)}else d[0]=Bn(i.x,Number.NaN,d[0]),A.setCoords(i.x-d[0],i.y),M.setCoordsPoint2D(i),h=1;D?(1===r&&I&&Un(n,M,c,g),r===q-1&&w&&zn(Y,i,c,g)):T?Wn(Y,M,a)&&(n.x<i.x?Y.x>M.x&&(d[0]+=2*Math.PI,M.setCoords(d[0]+A.x,A.y)):Y.x<M.x&&(d[0]-=2*Math.PI,M.setCoords(d[0]+A.x,A.y)),On(Y,M,y,v,b,c,g)):o>0&&Vn(),g.push(M.clone()),null!=c&&c.push(h),Y.setCoordsPoint2D(M),G.setCoordsPoint2D(A),F=d[0]}return x}catch(p){_.error=p,_.hasError=!0}finally{(0,m.c)(_)}}function qn(t,e,s,n,i,o,a,h,m,l){(0,r.g)(0)}function Vn(t,e,s,n,i,o,a,h,m,l,u,c,g,d,_){return(0,r.g)(0),0}function Yn(t,e,s,n){const i=I(t,e,s),r=I(t,e,n);return a.h.distance(i,r)}function Xn(t,e,s,n,i,o,m,l){const u=new Array,c=(0,h.m)(Array,8);let g=2,d=i.getCoord2D(o);c[0][0]=d.x,c[0][1]=d.y,d=i.getCoord2D(m),c[1][0]=d.x,c[1][1]=d.y;const _=t=>{if(null!==s){const e=Ro.projToGeog(s,t,c);(0,r.g)(e===t)}for(const e of c)e[0]*=n,e[1]*=n};_(2),u.push(I(t,e,new h.P(c[0][0],c[0][1]))),u.push(I(t,e,new h.P(c[1][0],c[1][1])));let p=a.h.distance(u[0],u[1]);if(p>l)return p;let f=0;for(g=3;g<=17;){const s=1/(g-1);let n=0;for(let t=1;t<g;++t)if(1&t){const e=(0,h.q)(o,m,t*s);i.queryCoord2D(e,d),c[n][0]=d.x,c[n][1]=d.y,n++}_(n);let P=1;for(let i=0;i<n;++i)u.splice(P,0,I(t,e,new h.P(c[i][0],c[i][1]))),P++;P=0;let x=u[P];P++;let y=0;for(;P!==u.length;++P){const t=u[P];y+=a.h.distance(x,t),x=t}if(y>l)return y;if(f=y-p,(0,r.g)(f>=0||Math.abs(f)<1e-14*y),f<0&&(f=0),p=y,y+f<=l)return y+f;g=2*g-1}return p+f}function kn(t,e,s,n,i,o,a,m,l){const u=n.isCurve(),c=function(t,e){return t*Math.sqrt(1-e)}(t,e)*Math.PI*179/180;let g=o;o>0&&!(o>c)||(g=c);const d=a,_=d>0;let p=Number.NaN;_&&(p=function(t,e,s){const n=s/(2*H(t,e)),i=n*n;return s*(1-i*(.16666666666666666-.008333333333333333*i))}(t,e,d));const f=1===i.getCoordinateSystemType();let P=null;f||(P=i.getPECoordSys());const x=i.getTolerance(0),y=n.getStartXY(),E=n.getEndXY(),C=new h.P,S=new h.P;if(f)C.setCoordsPoint2D(y),C.scale(s),S.setCoordsPoint2D(E),S.scale(s);else{const t=[y.x,y.y,E.x,E.y];Ro.projToGeog(P,2,t),C.setCoords(t[0],t[1]),C.scale(s),S.setCoords(t[2],t[3]),S.scale(s)}let v=0,b=0;const w=[],D=[],T=[];w.push(E.clone()),D.push(S.clone()),T.push(1),l.push(y.clone()),null!==m&&m.push(b);const N=i.isPannable(),G=y.clone(),M=[.5,.33333333333333337,.6666666666666666,.16666666666666669,.8333333333333333];let F=5;u||(_?(M[0]=.5,M[1]=.25,M[2]=.75,F=3):F=1),(0,r.g)(g>0);const V=t=>{if(t=t.clone(),null!==P){const e=[t.x,t.y];Ro.projToGeog(P,1,e),t.setCoords(e[0],e[1])}return t.scale(s),t};for(;D.length>0;){const o=w.at(-1).clone();S.assign(D.at(-1));const a=T.at(-1);let c=!1,d=Number.NaN;const y=Xn(t,e,P,s,n,b,a,g);let E=g>=y&&Math.abs(C.y-S.y)<.9*Math.PI;f&&E&&(E=Math.abs(C.x-S.x)<.9*Math.PI);const Y=new h.P,X=new h.P;let k=!1;if(!_&&E&&E&&(k=!0),n.calculateSubLength(b,a)<=x&&(k=!0),!k)for(let m=0;m<F;m++){const l=(0,h.q)(b,a,M[m]),g=new h.P;n.queryCoord2D(l,g);const P=V(g);if(0===m&&(d=l,Y.setCoordsPoint2D(g),X.setCoordsPoint2D(P),!E)){c=!0;break}if((0,r.g)(_),f&&Math.abs(C.x-P.x)>=Math.PI){c=!0;break}let x=new h.P,y=new h.P;u?(x=h.P.lerp(G,o,M[m]),y=V(x)):(x=g.clone(),y=P.clone());const v=A(t,e,C,S,M[m]),w=v.clone();if(f?(w.x/=s,w.y/=s):(w.x/=s,w.y/=s,pn(i.getGCSToSRTransform(),[w],1,[w],null)),w.isNAN()){const s=I(t,e,P),n=I(t,e,C),i=I(t,e,S),{first:r,second:o}=q(t,e,s,n,i,2,null);if(o>p){c=!0;break}}else{if(N){const t=i.getPannableExtent().width(),e=(0,h.q)(n.getStartX(),n.getEndX(),.5);for(;w.x<e-.5*t;)w.x+=t;for(;w.x>=e+.5*t;)w.x-=t}const s=n.getClosestCoordinateOnInterval(w,new h.E(b,a),-1);let r=n.getCoord2D(s);r=V(r);let o=Yn(t,e,r,v);if(o>p){if(o<4*p){const s=I(t,e,r),n=I(t,e,C),i=I(t,e,S),{first:a,second:h}=q(t,e,s,n,i,2,null);o=h}if(o>p){c=!0;break}}else if(u){let s=I(t,e,P);const n=I(t,e,C),i=I(t,e,S);let{second:r}=q(t,e,s,n,i,3,null);if(r<=p){s=I(t,e,y);const{first:o,second:a}=q(t,e,s,n,i,3,null);r=a}if(r>p){c=!0;break}}}}c?(w.push(Y.clone()),D.push(X.clone()),T.push(d)):(w.pop(),D.pop(),T.pop(),l.push(o.clone()),v+=y,null!==m&&m.push(v),G.setCoordsPoint2D(o),C.setCoordsPoint2D(S),b=a)}if(null!==m){const t=1/v;for(let e=0;e<m.length;e++)m[e]*=t}}function Rn(t,e,s,n){if(n.reverse(),null!==s&&s.reverse(),t){const s=t[0],n=e[0];t[0]=n,e[0]=s}}function Hn(t,e,s,n,i){t?(n.setCoordsPoint2D(s),i.setCoordsPoint2D(e)):(n.setCoordsPoint2D(e),i.setCoordsPoint2D(s))}function Ln(t,e,s){return t?(s.create(e.getGeometryType()),e.copyTo(s.get()),s.get().reverse(),s.get()):e}function Bn(t,e,s){if(Number.isNaN(e)){for(;s-t>Math.PI;)s-=2*Math.PI;for(;t-s>Math.PI;)s+=2*Math.PI;return s}return s+t-e>Math.PI?s-=2*Math.PI:e-(s+t)>Math.PI&&(s+=2*Math.PI),s}function Un(t,e,s,n){if(t.y>0){const i=new h.P;i.setCoords(e.x,h.l),Vo(t.x,i.x)||Vo(e.y,i.y)||(n.push(i),null!==s&&s.push(0))}else{const i=new h.P;i.setCoords(e.x,-h.l),Vo(t.x,i.x)||Vo(e.y,i.y)||(n.push(i),null!==s&&s.push(0))}}function zn(t,e,s,n){if(e.y>0){const i=new h.P;i.setCoords(t.x,h.l),Vo(e.x,i.x)||Vo(t.y,i.y)||(n.push(i),null!==s&&s.push(1))}else{const i=new h.P;i.setCoords(t.x,-h.l),Vo(e.x,i.x)||Vo(t.y,i.y)||(n.push(i),null!==s&&s.push(1))}}function On(t,e,s,n,i,r,o){if(function(t){return function(t,e){return 0===t||Math.abs(t)<=e}(t,qo)}(s)){if(h.l-t.y>0){const e=new h.P;e.setCoords(t.x,h.l),o.push(e),null!==r&&r.push(n)}if(h.l-e.y>0){const t=new h.P;t.setCoords(e.x,h.l),o.push(t),null!==r&&r.push(n)}}else{if(h.l+t.y>0){const e=new h.P;e.setCoords(t.x,-h.l),o.push(e),null!==r&&r.push(i)}if(h.l+e.y>0){const t=new h.P;t.setCoords(e.x,-h.l),o.push(t),null!==r&&r.push(i)}}}function Wn(t,e,s){return Math.abs(Math.abs(t.x-e.x)-Math.PI)<=s}function jn(t){if(t.x<-Math.PI)for(;t.x<-Math.PI;)t.x+=2*Math.PI;else if(t.x>Math.PI)for(;t.x>Math.PI;)t.x-=2*Math.PI}function Zn(t,e,s,n){const i={stack:[],error:void 0,hasError:!1};try{const r=[s.x],o=[s.y-n],a=[s.x],h=[s.y+n];Y(r,o),Y(a,h);const l=(0,m.b)(i,new Yo,!1),u=(0,m.b)(i,new Yo,!1);return zo.greatEllipticDistance(t,e,s.x,s.y,r[0],o[0],l,null,null),zo.greatEllipticDistance(t,e,s.x,s.y,a[0],h[0],u,null,null),Math.min(l.val,u.val)}catch(r){i.error=r,i.hasError=!0}finally{(0,m.c)(i)}}function Qn(t,e,s,n,r){const o=new i.Envelope2D;s.queryEnvelope(o);const h=(0,a.b)(null,s,!0).total();if(e.xmin-o.xmin<=h&&o.xmax-e.xmax<=h)return s;const m=e.width();let c=0;for(;e.xmin+c*m<o.xmin;)c++;for(;e.xmin+c*m>o.xmin;)c--;const g=c*m,d=new l.T;d.setShiftCoords(-g,0);const _=s;_.applyTransformation(d);const p=new i.Envelope2D;_.queryEnvelope(p);let f=null;if(p.xmax>e.xmax){let s=0;const n=new i.Envelope2D;n.setCoords({env2D:e}),n.ymin-=1,n.ymax+=1;let o=_;for(;n.xmin<p.xmax;){p.xmax>n.xmax&&(o=Yi(o,t,2,!0,n.xmax));const i=(0,a.e)(o,n),h=(0,a.a)(null,i,!0).total(),l=(0,u.c)(o,n,h,Number.NaN,r);null===f?f=l===o?l.clone():l:(d.setShiftCoords(-s*m,0),l.applyTransformation(d),f.add(l,!1)),s++,n.xmin=n.xmax,n.xmax=e.xmax+s*m}}else f=_;return f}class Kn{constructor(t,e){this.m_basisX=new a.h,this.m_basisY=new a.h,this.m_normal=new a.h,(0,r.g)(1===t.getCoordinateSystemType()),this.m_gcs=t;const s=$r();t.querySpheroidData(s),this.m_a=s.majorSemiAxis,this.m_e2=s.e2,this.m_rpu=t.getUnit().getUnitToBaseFactor(),this.m_curvCenterRad=e.mul(this.m_rpu);const n=this.m_curvCenterRad.x,i=this.m_curvCenterRad.y,o=Math.cos(n),m=Math.sin(n),l=Math.cos(i),u=Math.sin(i);this.m_cartCenter3D=function(t,e,s,n,i,r){return w(t,e,s,n,i,r,0)}(this.m_a,this.m_e2,o,m,l,u),this.m_normal.setCoordsPoint3D(this.m_cartCenter3D),this.m_d=this.m_cartCenter3D.length(),this.m_normal.divThis(this.m_d),a.h.selectRightHandedBasisFromNormal(this.m_normal,this.m_basisX,this.m_basisY),this.m_northPolePcs=this.projectPoint(h.P.construct(0,.5*Math.PI/this.m_rpu)),this.m_southPolePcs=this.projectPoint(h.P.construct(0,.5*-Math.PI/this.m_rpu))}project(t){const e=t.getGeometryType();if((0,r.i)(e)){(0,r.l)(t);const e=t;return this.projectMultiVertex(e)}(0,r.t)("Gnomonic.project")}unproject(t,e,s){const n=t.getGeometryType();if((0,r.i)(n)){(0,r.l)(t);let m=t;const l=[];if(n===r.G.enumPolygon){const t=m.getPathCount();for(let e=0;e<t;e++){const t=m.calculateRingArea2D(e);l.push(t)}}return this.unprojectMultiVertex(e,m),(0,r.h)(n)?(function(t,e,s){const n=t.getPannableExtent(),i=h.P.construct(e,0);n.centerAt(i);const r=n.width(),o=.5*r,a=new h.P;a.setNAN();let m=Number.NaN;for(let h=0;h<s.getPathCount();h++)for(let t=s.getPathStart(h);t<s.getPathEnd(h);t++){const e=s.getXY(t),i=Vo(e.y,n.ymax)||Vo(n.ymin,e.y);t===s.getPathStart(h)?(a.setNAN(),m=0):a.isNAN()||i||(m=ti(e.x,a.x,o,r,m)),e.x+=m,s.setXY(t,e),i||a.setCoordsPoint2D(e)}s.getImpl().notifyModifiedFlags(2001)}(this.m_gcs,0,m),function(t,e,s,n,m){const l=n.getGeometryType(),u=e.getPannableExtent();let c=n,g=!1,d=!1;if(l===r.G.enumPolygon){const n=new i.Envelope2D,r=h.P.construct(s,0);n.setCoords({env2D:u}),n.centerAt(r),g=function(t,e,s,n,r){const a=function(t,e){const s=new i.Envelope2D;e.queryEnvelope(s);const n=Vo(t.ymax,s.ymax),r=Vo(t.ymin,s.ymin),a=n||r;return!!a&&(function(t,e){const s=new o.a,n=new i.Envelope2D;for(let i=0;i<e.getPathCount();i++){e.queryPathEnvelope(i,n);let r=Vo(t.ymax,n.ymax),o=Vo(t.ymin,n.ymin);if(!r&&!o){s.addPath(e,i,!0);continue}s.insertPath2D(-1,null,0,0,!0);const a=e.getPathStart(i),m=e.getPathEnd(i),l=m-a;let u=-1;for(u=a;u<m;u++){const s=e.getXY(u);if(r=Vo(t.ymax,s.y),o=Vo(t.ymin,s.y),!r&&!o)break}let c=u,g=!1,d=Number.NaN;do{const n=e.getXY(c);r=Vo(t.ymax,n.y),o=Vo(t.ymin,n.y);const m=a+(c+1-a)%l;if(r||o){let r=h.P.construct(d,n.y);s.insertPoint2D(i,-1,r);const o=e.getXY(m),a=Vo(t.ymax,o.y),l=Vo(t.ymin,o.y);a||l||(r=h.P.construct(o.x,n.y),g?s.setXY(s.getPointCount()-1,r):s.insertPoint2D(i,-1,r)),g=!0}else s.insertPoint2D(i,-1,n),d=n.x,g=!1;c=m}while(c!==u)}e.setEmpty(),e.add(s,!1)}(t,e),a)}(s,n),m=function(t,e,s,n,i){const r=[],a=[],h=.5*s.width();for(let o=0;o<n.getPathCount();o++){const m=n.getXY(n.getPathStart(o)),l=n.getXY(n.getPathEnd(o)-1),u=t[o]<0;if(Math.abs(m.x-l.x)>h){const t=Jn(u,e,s,o,n,i);r.push(t),a.push(o)}else if(!u&&n.calculateRingArea2D(o)<0){const t=$n(e,s,o,n,i);r.push(t),a.push(o)}}if(0===r.length)return!1;const m=new o.a({vd:n.getDescription()});let l=0,u=a[l];for(let o=0;o<n.getPathCount();o++)o===u?(m.add(r[l],!1),l++,l<a.length&&(u=a[l])):m.addPath(n,o,!0);return n.setEmpty(),n.add(m,!1),!0}(t,e,s,n,r);return a||m}(t,e,n,c,m);const l=function(t,e,s,n){const r=new i.Envelope2D;s.queryEnvelope(r);const o=(0,a.b)(null,s,!0).total();if(e.xmin-r.xmin<=o&&r.xmax-e.xmax<=o)return s;const h=s.createInstance();let m=s.createInstance();const l=new i.Envelope2D,u=s.getPathCount();for(let i=0;i<u;i++)s.queryPathEnvelope(i,l),e.xmin-l.xmin<=o&&l.xmax-e.xmax<=o?h.addPath(s,i,!0):(m.setEmpty(),m.addPath(s,i,!0),m=Qn(t,e,m,0,n),h.add(m,!0));return h}(e,n,c,m);l!==c&&(d=!0),c=l}else c=(new Sn).foldInto360RangeGeodetic(c,e,2);l===r.G.enumPolygon&&(g||d)&&(c=(new ln).execute(c,e,!1,m)),c!==n&&(n.setEmpty(),n.add(c,!1))}(l,this.m_gcs,0,m,s)):m=Gi(m,this.m_gcs,0,!0,0,s),m}(0,r.t)("Gnomonic.unproject")}projectPoint(t){const e=t.mul(this.m_rpu),s=I(this.m_a,this.m_e2,e),n=this.m_normal.dotProduct(s);if(n<=0)return h.P.construct(Number.NaN,Number.NaN);const i=this.m_d/n,r=s.mul(i).sub(this.m_cartCenter3D),o=new h.P;return o.x=this.m_basisX.dotProduct(r),o.y=this.m_basisY.dotProduct(r),o}unprojectPoint(t){const e=this.m_cartCenter3D.add(this.m_basisX.mul(t.x).add(this.m_basisY.mul(t.y)));return T(this.m_a,this.m_e2,e).divide(this.m_rpu)}projectMultiVertex(t){const e=t.getImpl();let s=!0;const n=new h.P,i=new h.P;for(let r=0,o=e.getPointCount();r<o;r++)e.queryXY(r,n),n.y*this.m_rpu>.5*Math.PI?i.assign(this.m_northPolePcs):n.y*this.m_rpu<.5*-Math.PI?i.assign(this.m_southPolePcs):i.assign(this.projectPoint(n)),e.setXY(r,i),i.isNAN()&&(s=!1);return e.notifyModifiedFlags(2001),s}unprojectMultiVertex(t,e){const s=e.getImpl(),n=t*t,i=!this.m_northPolePcs.isNAN(),r=!this.m_southPolePcs.isNAN();for(let o=0,a=s.getPointCount();o<a;o++){const t=s.getXY(o);let e=new h.P;i&&h.P.sqrDistance(t,this.m_northPolePcs)<=n?(e.setCoords(this.m_curvCenterRad.x,.5*Math.PI),e.scale(1/this.m_rpu)):r&&h.P.sqrDistance(t,this.m_southPolePcs)<=n?(e.setCoords(this.m_curvCenterRad.x,.5*-Math.PI),e.scale(1/this.m_rpu)):e=this.unprojectPoint(t),s.setXY(o,e)}s.notifyModifiedFlags(2001)}}function Jn(t,e,s,n,r,m){const c=new o.a,g=new o.a,d=new l.T,_=r.getXY(r.getPathStart(n)),p=r.getXY(r.getPathEnd(n)-1),f=s.width(),P=.5*f,x=new i.Envelope2D;r.queryEnvelope(x);const y=Math.ceil(x.width()/f)+1;let E,C;_.x>p.x?(E=-f,C=t?s.ymin:s.ymax):(E=f,C=t?s.ymax:s.ymin),d.setShiftCoords(E,0),c.addPath(r,n,!0),g.add(c,!1);const S=new a.P;for(let i=0;i<y;i++)g.applyTransformation(d),g.getPointByVal(0,S),c.lineToPoint(S),c.addSegmentsFromPath(g,0,0,g.getSegmentCount()-1,!1);const v=c.getXY(0),b=c.getXY(c.getPointCount()-1);v.y=C,b.y=C,c.lineTo(b);const I=new h.P;for(I.setCoordsPoint2D(b),I.x-=.5*E;Math.abs(I.x-v.x)>P;)c.lineTo(I),I.x-=.5*E;c.lineTo(v);const w=s.getCenter().x,D=new i.Envelope2D;c.queryEnvelope(D);let T=0;const N=D.getCenter().x;N-w>P?T=-Math.ceil((N-w-P)/f):w-N>P&&(T=Math.ceil((w-N-P)/f)),0!==T&&(d.setShiftCoords(T*f,0),c.applyTransformation(d));const A=new o.E,G=A.addGeometry(c);Xi(A,G,e,0,2,!0,s.xmin),Xi(A,G,e,0,2,!0,s.xmax);const M=A.getGeometry(G),F=(0,a.e)(M,s);F.inflateCoords(0,1);const q=(0,a.a)(null,F,!0);return(0,u.c)(M,s,q.total(),Number.NaN,m)}function $n(t,e,s,n,r){const m=e.width(),c=.5*m,g=e.getCenter().x,d=new i.Envelope2D;n.queryPathEnvelope(s,d);let _,p=0,f=d.getCenter().x;if(f-g>c?p=-Math.ceil((f-g-c)/m):g-f>c&&(p=Math.ceil((g-f-c)/m)),0!==p){const t=new l.T;t.setShiftCoords(p*m,0),n.getImpl().applyTransformationToPath(t,s),n.queryPathEnvelope(s,d),f=d.getCenter().x}const P=new i.Envelope2D;e.containsExclusiveEnvelope(d)?(_=!1,P.setCoords({env2D:e})):(_=!0,P.setCoords({env2D:e}),P.xmin-=m,P.xmax+=m);let x=n.createInstance();x.addPathPoint2D(null,0,!0);const y=new h.P;if(y.setCoords(P.xmin,P.ymin),x.insertPoint2D(0,-1,y),y.setCoords(P.xmin,P.ymax),x.insertPoint2D(0,-1,y),y.setCoords(.5*(P.xmin+P.xmax),P.ymax),x.insertPoint2D(0,-1,y),y.setCoords(P.xmax,P.ymax),x.insertPoint2D(0,-1,y),y.setCoords(P.xmax,P.ymin),x.insertPoint2D(0,-1,y),y.setCoords(.5*(P.xmin+P.xmax),P.ymin),x.insertPoint2D(0,-1,y),_){x.addPath(n,s,!0);const i=new l.T;f<g?i.setShiftCoords(m,0):i.setShiftCoords(-m,0),n.getImpl().applyTransformationToPath(i,s),x.addPath(n,s,!0);const h=new o.E,c=h.addGeometry(x);Xi(h,c,t,0,2,!0,e.xmin),Xi(h,c,t,0,2,!0,e.xmax),x=h.getGeometry(c);const d=(0,a.e)(x,e);d.inflateCoords(0,1);const _=(0,a.a)(null,d,!0).total();x=(0,u.c)(x,e,_,Number.NaN,r)}else x.addPath(n,s,!0);return x}function ti(t,e,s,n,i){return i+t-e>s?i-=n:e-(i+t)>s&&(i+=n),i}function ei(t,e,s,n,i,r){const m=e.getAttributeStreamRef(0),l=e.getPointCount();let u=!1;const c=new h.P;for(let o=0;o<l;++o){if(m.queryPoint2D(2*o,c),1&r&&c.y>=s){u=!0;break}if(2&r&&c.y<=-s){u=!0;break}}if(!u)return!1;let g=!1;t&&(g=e.getImpl().isClosedPathInXYPlane(0));const d=new o.E,_=d.addGeometry(e),p=d.getFirstPath(_);let f=-1,P=!0;const x=new h.P,y=new a.P;let E=o.n;const C=si*i/360;for(let a=d.getFirstVertex(p);a!==o.n;a=d.getNextVertex(a)){d.queryXY(a,c);let t=1&r&&c.y>=s?1:0;if(t|=2&r&&c.y<=-s?2:0,f>0&&f!==t){if(x.x!==c.x){const t=d.getPrevVertex(a);d.queryPoint(t,y);const e=d.insertVertex(p,a,y);x.x=c.x,d.setXY(e,x)}if(g){let t=E!==o.n?d.getNextVertex(E):d.getFirstVertex(p);const e=d.getPrevVertex(a);for(;t!==e;)t=d.removeVertex(t,!1);if(E!==o.n){const t=d.getXY(E),s=d.getXY(e);if(Math.abs(t.x-s.x)>C){d.queryPoint(E,y);const n=d.insertVertex(p,e,y);t.x=(0,h.q)(t.x,s.x,.5),d.setXY(n,t)}}}E=o.n}if(t&&(c.y=(0,h.f)(n,c.y),d.setXY(a,c),!P&&f!==t))if(c.x!==x.x){d.queryPoint(a,y);const t=d.insertVertex(p,a,y);d.setXYCoords(t,x.x,c.y),E=t}else E=a;f=t,x.assign(c),P=!1}if(g){if(E!==o.n){let t=d.getNextVertex(E);for(;t!==o.n;)t=d.removeVertex(t,!1)}const t=d.getFirstVertex(p);let e=d.getLastVertex(p);const s=d.getXY(t),n=d.getXY(e);if(!s.equals(n)&&(d.queryPoint(t,y),e=d.insertVertex(p,o.n,y),Math.abs(s.x-n.x)>C)){const t=d.insertVertex(p,e,y);s.x=(0,h.q)(s.x,n.x,.5),d.setXY(t,s)}}return e.assignCopy(d.getGeometry(_)),!0}const si=210;class ni{constructor(t,e,s,n,i,o,a,h,m){this.m_bAdjustedAtPoles=0,this.m_inputPoly=s,this.m_progressTracker=m,this.m_originalGeometry=t,this.m_originalSR=n,this.m_polygonRingFlags=e,this.m_pannableSR=i,this.m_poleSnappingTolerance=h,this.m_poleFlags=a,this.m_bAdjustedAtPoles=0,this.m_pannableExtent=function(t,e){const s=t.getPannableExtent();return Number.isNaN(e)||s.centerAtCoords(e,0),s}(this.m_pannableSR,o),this.m_centralLongitude=Number.isNaN(o)?this.m_pannableExtent.getCenterX():o,this.m_width360=this.m_pannableExtent.width(),this.m_degree=this.m_width360/360,this.m_GCSLargeDelta=si*this.m_degree,(0,r.g)(null===this.m_originalGeometry&&null===this.m_originalSR||null!==this.m_originalGeometry&&null!==this.m_originalSR)}geonormalizeRing(t,e,s,n,i,m,l){let u=s;const c=new o.P({vd:this.m_inputPoly.getDescription()});c.addPath(this.m_inputPoly,t,!0),0!==this.m_poleFlags&&(this.m_bAdjustedAtPoles|=ei(!0,c,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,this.m_pannableExtent.width(),this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(u=!1));let g=-1;u&&(g=this.m_originalGeometry.getPathStart(t));const d=c.getAttributeStreamRef(0),_=c.getPointCount();let p=0,f=d.read(0),P=0;const x=3*this.m_pannableSR.getTolerance(0);let y=!1;const E=new h.P,C=new h.P;let S=!1;const v=c.hasNonLinearSegments(),b=new h.P;for(let o=1;o<_;++o){d.queryPoint2D(2*o,b);const t=b.x;let e=t+p;const s=e-f;if(b.x=e,Math.abs(s)>this.m_GCSLargeDelta){if(u){const t=g+o-1,e=g+(o+1<_?o:0),i=m.read(2*t),r=(m.read(2*e)-i)*n;Math.abs(s-r)>1*this.m_degree&&(u=!1)}u||(p-=(0,h.f)(this.m_width360,e-f),e=t+p,++P,S=0!==p,b.x=e)}else y||(0,a.L)(E,C,b,x)&&(y=!0);S&&(v&&(0,r.c)("error in geonormalize_ring_ for curves"),d.write(2*o,e)),f=e,E.setCoordsPoint2D(C),C.setCoordsPoint2D(b)}P&&c.notifyModified();const I=c.getXY(0),w=c.getXY(_-1);if(h.P.distance(I,w)<x){const t=this.finalizeGeoNormalizeClosedRing(c,y,i);l.add(t,!1)}else{e<0&&(null!==this.m_originalGeometry?((0,r.g)(null!==this.m_originalGeometry),e=this.m_originalGeometry.calculateRingArea2D(t)>0?1:0):e=1);const s=this.finalizeGeoNormalizeOpenedRing(e>0,c);l.add(s,!1)}}geoNormalizePolygonGeometry(t){(0,r.g)(this.m_originalSR&&this.m_originalGeometry||!this.m_originalGeometry&&!this.m_originalSR),(0,r.g)(this.m_pannableSR.isPannable());let e=null,s=Number.NaN;const n=!!this.m_originalSR&&this.m_originalSR.isPannable();n&&(e=this.m_originalGeometry.getAttributeStreamRef(0),s=this.m_width360/this.m_originalSR.getPannableExtent().width()),this.m_bAdjustedAtPoles=0;const a=new o.a({vd:this.m_inputPoly.getDescription()});for(let i=0,r=this.m_inputPoly.getPathCount();i<r;++i){const r=this.m_polygonRingFlags?this.m_polygonRingFlags[i]?1:0:-1;this.geonormalizeRing(i,r,n,s,t,e,a)}const h=this.m_pannableSR.getTolerance(0),m=this.m_pannableExtent.width()/180;Bi(a,this.m_pannableExtent,.1*h,!1);const l=i.Envelope2D.constructEmpty();if(l.setCoords({env2D:this.m_pannableExtent}),t){let t=!0;for(let e=0;e<2;e++){t=!0;const e=i.Envelope2D.constructEmpty();for(let s=0,n=a.getPathCount();s<n;s++)if(a.queryPathEnvelope(s,e),!(l.xmin<=e.xmin&&l.xmax>=e.xmax||e.xmin>=l.xmax||e.xmax<=l.xmin)){t=!1;break}if(t)break;l.move(.5*this.m_width360,0)}t||l.setCoords({env2D:this.m_pannableExtent})}let g=(0,u.c)(a,l,h,m,this.m_progressTracker),d=a!==g;const _=this.m_originalGeometry?this.m_originalGeometry.calculateArea2D():1,p=g.calculateArea2D();let f=0;if(p>0&&_<0)f=1;else if(p<=0&&_>0)if(0===p){if(this.m_originalSR){let t=Number.NaN;2===this.m_originalSR.getCoordinateSystemType()?t=this.m_originalSR.getPCSHorizon().calculateArea2D():1===this.m_originalSR.getCoordinateSystemType()&&(t=this.m_originalSR.getPannableExtent().getArea()),_>.99*t&&(f=-1)}}else f=-1;if(0!==f){const t=function(t,e){let s=new o.a({vd:t});s.addEnvelope(e,!1);const n=e.width()/180;return s=(new c.O).execute(s,n,0,0,null),s}(g.getDescription(),l);t.add(g,!1),d=!0,g=t}return d&&(g=(new ln).execute(g,this.m_pannableSR,!1,this.m_progressTracker)),g}geoNormalizePolylineGeometry(t){(0,r.g)(this.m_pannableSR.isPannable());let e=null;const s=this.m_originalSR&&this.m_originalSR.isPannable();let n=1;s&&((0,r.g)(this.m_originalGeometry),n=this.m_width360/this.m_originalSR.getPannableExtent().width(),e=this.m_originalGeometry.getAttributeStreamRef(0));const a=this.m_pannableExtent.width(),m=a*(0,h.N)()*4;let c=t,g=Number.NaN;const d=h.E.constructEmpty();this.m_bAdjustedAtPoles=0;let _=new o.P({vd:this.m_inputPoly.getDescription()});for(let u=0,P=this.m_inputPoly.getPathCount();u<P;++u){let t=s;const p=new o.P({vd:this.m_inputPoly.getDescription()});p.addPath(this.m_inputPoly,u,!0);const f=this.m_inputPoly.isClosedPath(u);0!==this.m_poleFlags&&(this.m_bAdjustedAtPoles|=ei(f,p,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,a,this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(t=!1));let P=-1;const x=p.getPointCount();let y=!1;t&&(P=this.m_originalGeometry.getPathStart(u),y=this.m_originalGeometry.isClosedPath(u));const E=p.getAttributeStreamRef(0);let C=0,S=E.read(0),v=0;const b=new h.P,I=new h.P;let w=!1;const D=p.hasNonLinearSegments(),T=new h.P;for(let s=1;s<x;++s){E.queryPoint2D(2*s,T);const i=T.x;let o=i+C;const a=o-S;if(T.x=o,Math.abs(a)>this.m_GCSLargeDelta){if(t){const i=P+s-1;let r=P;(!y||s+1<x)&&(r+=s);const o=e.read(2*i),h=(e.read(2*r)-o)*n;Math.abs(a-h)>1*this.m_degree&&(t=!1)}t||(C-=(0,h.f)(this.m_width360,o-S),o=i+C,++v,w=0!==C,T.x=o)}w&&(D&&(0,r.c)("error in geonormalize_ring_ for curves"),E.write(2*s,o)),S=o,b.setCoordsPoint2D(I),I.setCoordsPoint2D(T)}if(v&&p.notifyModified(),c){let t=!1;if(!p.isEmpty()){const e=i.Envelope2D.constructEmpty();if(p.queryEnvelope(e),e.width()>=a||e.ymin<=this.m_pannableExtent.ymin||e.ymax>=this.m_pannableExtent.ymax)t=!0;else{if(Number.isNaN(g)){const t=this.m_centralLongitude-.5*a;g=e.xmin,g+=Math.round((t-e.xmin)/a)*a,g>t&&(g-=a),(0,r.g)(g<=t),g<t&&(g+=a),(0,r.g)(g>=t)}let s=Math.round((g-e.xmin)/a)*a;if(e.xmin+s>g+m&&(s-=a),e.xmin+s<g-m&&(s+=a),d.mergeCoordinate(e.xmin+s),d.mergeCoordinate(e.xmax+s),t=d.width()>=a,!t){const t=new l.T;t.setShiftCoords(s,0),p.applyTransformation(t)}}}_.add(p,!1),t&&(_=(()=>{const t=new o.P({vd:_.getDescription()});for(let e=0,s=_.getPathCount();e<s;++e){const s=new o.P({vd:_.getDescription()});s.addPath(_,e,!0);const n=Gi(s,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);t.add(n,!1)}return t})(),c=!1)}else{const t=Gi(p,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);_.add(t,!1)}}if(c)return _;const p=this.m_pannableSR.getTolerance(0),f=this.m_pannableExtent.width()/180;return Bi(_,this.m_pannableExtent,.1*p,!1),(0,u.c)(_,this.m_pannableExtent,p,f,this.m_progressTracker)}finalizeGeoNormalizeOpenedRing(t,e){const s=e.getPointCount(),n=e.getXY(0),a=e.getXY(s-1);{const t=Math.abs(a.x-n.x),e=Math.round(t/this.m_width360)*this.m_width360;(0,r.g)(Math.abs(t-e)<this.m_pannableSR.getTolerance(0))}const m=(0,h.e)(a.x-n.x),u=i.Envelope2D.constructEmpty();e.queryLooseEnvelope(u);const c=this.m_pannableExtent.getCenterX();let g=0,d=c-this.m_width360,_=c+this.m_width360;if(m>=0){let t=Math.ceil((d-u.xmin)/this.m_width360);for(t*=this.m_width360;d>u.xmin+t;)t+=this.m_width360;for(;d<u.xmax+t;)t-=this.m_width360;for(g=t,u.width()>720&&(_=d+360*Math.ceil(u.width()/360));_<u.xmax;)_+=this.m_width360}else{let t=Math.ceil((_-u.xmax)/this.m_width360);for(t*=this.m_width360;_<u.xmax+t;)t-=this.m_width360;for(;_>u.xmin+t;)t+=this.m_width360;for(g=t,u.width()>720&&(d=_-360*Math.ceil(u.width()/360));d>u.xmin;)d-=this.m_width360}const p=Math.round(Math.abs(a.x-n.x)/this.m_width360)*this.m_width360,f=m*p,P=u.clone();P.move(g,0);const x=new h.P(0,0),y=new l.T;y.setShiftCoords(g,0),e.applyTransformation(y);const E=new o.P({vd:e.getDescription()});E.add(e,!1),x.assign(e.getXY(s-1));let C=0,S=E.getXY(0).x;for(;m>0?P.xmax<_:P.xmin>d;)P.move(f,0),y.xd=f,e.applyTransformation(y),S+=f,this.m_pannableExtent.xmin<=S&&this.m_pannableExtent.xmax>=S&&(C=E.getPointCount()-1),e.setXY(0,x),x.assign(e.getXY(s-1)),E.addSegmentsFromPath(e,0,0,s-1,!1);const v=new o.a({vd:E.getDescription()});v.add(E,!1);const b=E.getXY(0),I=E.getXY(E.getPointCount()-1),w=m<0?t:!t,D=v.getPointCount()-1;if(w){const t=new h.P(I.x,this.m_pannableExtent.ymax);v.lineTo(t);const e=new h.P(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymax);v.lineTo(e);const s=new h.P(b.x,this.m_pannableExtent.ymax);v.lineTo(s)}else{const t=new h.P(I.x,this.m_pannableExtent.ymin);v.lineTo(t);const e=new h.P(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymin);v.lineTo(e);const s=new h.P(b.x,this.m_pannableExtent.ymin);v.lineTo(s)}if(v.interpolateAttributesPath(0,D,0),v.getImpl().changeRingStartPoint(C),p>this.m_width360){const t=new o.a({copy:v});y.setShiftCoords(this.m_width360,0),t.applyTransformation(y),v.add(t,!1)}return v}finalizeGeoNormalizeClosedRing(t,e,s){const n=new o.a({vd:t.getDescription()});n.add(t,!1);if(n.hasNonLinearSegments()&&(()=>{const t=n.getPointCount()-2;return n.getSegmentType(t)!==r.G.enumLine})()){const t=new o.S,e=n.getPointCount()-2;n.getSegmentBuffer(e,t,!1),n.removePointFromPath(0,e+1),n.closeLastPathWithSegment(t.get())}else n.removePointFromPath(0,n.getPointCount()-1);const a=i.Envelope2D.constructEmpty();n.queryLooseEnvelope(a);let m=Math.ceil((this.m_pannableExtent.xmin-a.xmin)/this.m_width360);for(m*=this.m_width360;this.m_pannableExtent.xmin>a.xmin+m;)m+=this.m_width360;for(;this.m_pannableExtent.xmin<a.xmax+m;)m-=this.m_width360;if(m+=this.m_width360,0!==m){a.move(m,0);const t=new l.T;t.setShiftCoords(m,0),n.applyTransformation(t)}if(this.m_pannableExtent.xmin<=a.xmin&&this.m_pannableExtent.xmax>=a.xmax){if(e){const t=n.calculateArea2D(),e=(new ln).execute(n,this.m_pannableSR,!0,this.m_progressTracker);if(e!==n){const s=e.calculateArea2D();(0,h.e)(t)!==(0,h.e)(s)&&e.reverseAllPaths(),n.assignMove(e)}}let t;if(t=new o.a(s?{copy:n}:{move:n}),s)for(;a.xmin<this.m_pannableExtent.xmax;){a.move(this.m_width360,0);const e=new l.T;e.setShiftCoords(this.m_width360,0),n.applyTransformation(e),t.add(n,!1)}return t}let u=new o.a({vd:t.getDescription()});u.add(n,!1);const c=e||a.width()>this.m_width360-10*this.m_pannableSR.getTolerance(0);for(;a.xmin<this.m_pannableExtent.xmax;){a.move(this.m_width360,0);const t=new l.T;t.setShiftCoords(this.m_width360,0),n.applyTransformation(t),u.add(n,!1)}if(c){const t=u.calculateArea2D();u.setFillRule(1),u=(new ln).execute(u,this.m_pannableSR,!0,this.m_progressTracker);const e=u.calculateArea2D();(0,h.e)(t)!==(0,h.e)(e)&&u.reverseAllPaths()}return u}geonormalize_ring_(t,e,s,n,i,o,a){(0,r.g)(0)}}function ii(t){(0,r.g)(0);const e=function(t){const e=new yr({},!0);return e.m_WKID=t,e}(t),s=new oi;return s.setVertProj_(e),s}function ri(t){return!1}class oi{constructor(){this.m_hashCode=0,this.m_peVertSysVal=null,this.m_verticalUnit=new zr,this.m_verticalShift=0,this.m_userVerticalWKID=0,this.m_bIsDepth=!1}getType(){return(0,r.g)(0),0}getID(){return(0,r.g)(0),0}getLatestID(){return this.m_peVertSysVal?this.m_peVertSysVal.getLatestID():0}getOldID(){return this.m_peVertSysVal?this.m_peVertSysVal.getOldID():0}getText(){return(0,r.g)(0),""}getTextExtended(t){return(0,r.g)(0),""}getText2(t){return(0,r.g)(0),""}getUnit(){return(0,r.g)(0),{}}equals(t){return(0,r.g)(0),!1}equalForProjection(t){return(0,r.g)(0),!1}getPeVertcsCopy(){return(0,r.g)(0),{}}getOneMeter(){return 1/this.m_verticalUnit.getUnitToBaseFactor()}getUnitToBaseFactor(){return(0,r.g)(0),0}isDepth(){return(0,r.g)(0),!1}getVerticalShift(){return(0,r.g)(0),0}isCustomWkid(){return!!this.m_peVertSysVal&&this.m_peVertSysVal.isCustomWkid()}getHashCode(){return this.m_hashCode}setVertProj_(t){this.m_peVertSysVal=t}getPEVerticalCoordSys(){return this.m_peVertSysVal?this.m_peVertSysVal.m_peVertcs:null}}function ai(t,e,s,n,i){if(t.equals(e))return!1;if(n){let s=1,r=0,o=1,a=1,h=0,m=1;Number.isNaN(t.m_heightMetersPerUnit)||(s=t.m_heightMetersPerUnit,r=t.m_heightZ0,o=t.m_heightSign,a=e.m_heightMetersPerUnit,h=e.m_heightZ0,m=e.m_heightSign);const l=o*m*s/a;for(let t=0;t<i;t++)n[t]=(n[t]-r)*l+h}let r=1,a=0;if(Number.isNaN(t.m_XYToRadians)||(r=t.m_XYToRadians/e.m_XYToRadians,a=t.m_PrimeMeridianDegrees-e.m_PrimeMeridianDegrees,0!==a&&(a=(0,o.b)(a),a/=e.m_XYToRadians)),Array.isArray(s)){const t=s;for(let e=0;e<i;e++)t[e][0]=t[e][0]*r+a,t[e][1]=t[e][1]*r}else{const t=s;for(let e=0;e<i;e++){const s=e<<1;t[s]=t[s]*r+a,t[s+1]=t[s+1]*r}}return!0}function hi(){return{m_heightMetersPerUnit:0,m_heightSign:0,m_heightZ0:0,m_XYToRadians:0,m_PrimeMeridianDegrees:0,assign(t){this.m_heightMetersPerUnit=t.m_heightMetersPerUnit,this.m_heightSign=t.m_heightSign,this.m_heightZ0=t.m_heightZ0,this.m_XYToRadians=t.m_XYToRadians,this.m_PrimeMeridianDegrees=t.m_PrimeMeridianDegrees},equals(t){return(0,h.a3)(this.m_heightSign,t.m_heightSign)&&(0,h.a3)(this.m_heightMetersPerUnit,t.m_heightMetersPerUnit)&&(0,h.a3)(this.m_heightZ0,t.m_heightZ0)&&(0,h.a3)(this.m_XYToRadians,t.m_XYToRadians)&&(0,h.a3)(this.m_PrimeMeridianDegrees,t.m_PrimeMeridianDegrees)},initFromGcsAndVcsPe(t,e){this.m_heightSign=1,this.m_heightMetersPerUnit=Number.NaN,this.m_heightZ0=0,this.m_XYToRadians=Number.NaN,this.m_PrimeMeridianDegrees=Number.NaN,e&&(0,r.g)(0),t&&(this.m_XYToRadians=t.getUnit().getUnitFactor(),this.m_PrimeMeridianDegrees=t.getPrimem().getLongitude())},initFromGcsAndVcs(t,e){const s=t?t.getPECoordSys():null,n=e?e.getPEVerticalCoordSys():null;this.initFromGcsAndVcsPe(s,n)},processUnitParams(t){Number.isNaN(this.m_heightMetersPerUnit)&&(this.m_heightMetersPerUnit=t.m_heightMetersPerUnit,this.m_heightSign=t.m_heightSign,this.m_heightZ0=t.m_heightZ0),Number.isNaN(this.m_XYToRadians)&&(this.m_XYToRadians=t.m_XYToRadians,this.m_PrimeMeridianDegrees=t.m_PrimeMeridianDegrees)}}}class mi{constructor(t){this.m_constantsLoaded=-1,this.m_isUsable=-1,this.m_inputSR=null,this.m_outputSR=null,this.m_inputSRHorz=null,this.m_outputSRHorz=null,this.m_inputVCS=null,this.m_outputVCS=null,this.m_hashCode=0,this.m_areaOfUse=new a.E,this.m_inputUnitParams=hi(),this.m_outputUnitParams=hi(),(0,r.g)(t),this.m_geogTran=t,this.m_vertTran=null,this.m_latestID=Xo.getCode(this.m_geogTran),this.m_latestID<0&&(this.m_latestID=0);const e=this.m_geogTran.getGeogcs1();Xo.getCode(e);const s=this.m_geogTran.getGeogcs2();Xo.getCode(s),this.initUnitParams()}getLatestId(){return this.m_latestID}getText(){return this.m_geogTran?this.m_geogTran.toString():((0,r.g)(0),"")}getGeogtran(){return this.m_geogTran}getVerttran(){return null}loadConstants(t){let e=this.m_constantsLoaded;if(-1===e){if(!t){this.m_geogTran||(0,r.c)("vcs not impl");const e=this.m_geogTran.getParameters();null!==e[ko.PE_PARM_ND]&&(t=0===e[ko.PE_PARM_ND].getValue())}e=this.m_geogTran.loadConstants()?1:0,this.m_constantsLoaded=e}return 0!==e}isUsable(){let t=this.m_isUsable;return-1===t&&(this.m_geogTran?this.m_isUsable=t=this.m_geogTran?1:0:this.m_isUsable=t=this.m_vertTran?1:0),1===t}getInputSr(t){return this.updateSrs(),t?this.m_inputSR:this.m_inputSRHorz}getOutputSr(t){return this.updateSrs(),t?this.m_outputSR:this.m_outputSRHorz}getHashCode(){let t=this.m_hashCode;return 0===t&&(t=this.m_latestID>0?(0,h.ar)(this.m_latestID):(0,h.aw)(this.getText()),0===t&&(t=345),this.m_hashCode=t),t}isGeogtran(){return null!==this.m_geogTran}prepareOrThrow(){}getName(){return this.isGeogtran()?this.getGeogtran().getName():((0,r.b)("vcs not impl"),"")}updateSrs(){if(this.m_inputSR||this.m_inputVCS)return;let t,e,s,n,i,o;if(this.m_geogTran){const r=this.m_geogTran.getGeogcs1(),a=Fr(r),h=this.m_geogTran.getGeogcs2(),m=Fr(h);let l=-1,u=-1;l=a.getVcsCode(),u=m.getVcsCode(),s=oo(r,null,null,1),n=oo(h,null,null,1),l>0&&u>0?(i=ii(l),o=ii(u),t={},e={}):(t=s,e=n)}else(0,r.g)(0);this.m_inputSR||this.m_inputVCS||(this.m_inputSR=t,this.m_outputSR=e,this.m_inputSRHorz=s,this.m_outputSRHorz=n,this.m_inputVCS=i,this.m_outputVCS=o)}initUnitParams(){if(this.m_inputUnitParams.m_heightSign=1,this.m_inputUnitParams.m_heightMetersPerUnit=Number.NaN,this.m_inputUnitParams.m_heightZ0=0,this.m_outputUnitParams.m_heightSign=1,this.m_outputUnitParams.m_heightMetersPerUnit=Number.NaN,this.m_outputUnitParams.m_heightZ0=0,this.m_inputUnitParams.m_XYToRadians=Number.NaN,this.m_inputUnitParams.m_PrimeMeridianDegrees=Number.NaN,this.m_outputUnitParams.m_XYToRadians=Number.NaN,this.m_outputUnitParams.m_PrimeMeridianDegrees=Number.NaN,this.m_vertTran)(0,r.g)(0);else if(this.m_geogTran){const t=this.m_geogTran;let e=t.getGeogcs1();this.m_inputUnitParams.m_XYToRadians=e.getUnit().getUnitFactor(),this.m_inputUnitParams.m_PrimeMeridianDegrees=e.getPrimem().getLongitude(),e=t.getGeogcs2(),this.m_outputUnitParams.m_XYToRadians=e.getUnit().getUnitFactor(),this.m_outputUnitParams.m_PrimeMeridianDegrees=e.getPrimem().getLongitude()}}}function li(t,e,s,n,i,r,o){let a=null;e&&(a=e.getPEVerticalCoordSys());let h=null;t&&(h=t.getPECoordSys());let m=null;n&&(m=n.getPEVerticalCoordSys());let l=null;if(s&&(l=s.getPECoordSys()),!(h||a||l||m))return!1;const u=hi();u.initFromGcsAndVcsPe(h,a);const c=hi();return c.initFromGcsAndVcsPe(l,m),ai(u,c,i,r,o)}function ui(t,e,s,n,i,r,o,a){const h=e,m=t,l=hi();l.initFromGcsAndVcsPe(m,h),a.assign(n?s.m_outputUnitParams:s.m_inputUnitParams),a.processUnitParams(l),l.processUnitParams(a),o>0&&ai(l,a,i,r,o)}function ci(t,e,s,n,i,r,o,a,h){const m=hi(),l=hi();m.assign(s?e.m_inputUnitParams:e.m_outputUnitParams),l.assign(i?n.m_outputUnitParams:n.m_inputUnitParams),m.processUnitParams(t),l.processUnitParams(m),m.processUnitParams(l),a>0&&ai(m,l,r,o,a),h.assign(l)}function gi(t,e,s,n,i,r,o){const a=e.getVerttran(),h=e.getGeogtran();if(o.assign(s?e.m_inputUnitParams:e.m_outputUnitParams),o.processUnitParams(t),r>0){e.prepareOrThrow();const t=s?ko.PE_TRANSFORM_2_TO_1:ko.PE_TRANSFORM_1_TO_2;a?mr():lr(h,r,n,i,t)}}class di{supportsCurves(){return!0}accelerateGeometry(t,e,s){return _i(t,e,s)}canAccelerateGeometry(t){return pi(t)}}function _i(t,e,s){if(!pi(t))return!1;(0,a.W)(e,t,!1);let n=0;const i=t.getGeometryType();return(0,r.h)(i)&&(0,o.U)(t)&&0!==s&&(n|=t.getImpl().buildQuadTreeAccelerator(s)?1:0),(0,r.h)(i)&&(0,o.V)(t)&&0!==s&&(n|=t.getImpl().buildQuadTreeForPathsAccelerator(s)?1:0),n>0}function pi(t){return(0,o.U)(t)||(0,o.V)(t)}class fi extends di{getOperatorType(){return 8}execute(t,e,s,n){return oe(t,e,s,1,n)}}function Pi(t,e,s,n){if(t.isEmpty()||e.isEmpty())return t;const m=t.getDimension(),l=e.getDimension();if(m>l)return t;const c=t.getGeometryType(),g=e.getGeometryType(),d=new i.Envelope2D,_=new i.Envelope2D,p=new i.Envelope2D;t.queryEnvelope(d),e.queryEnvelope(_),p.setCoords({env2D:d}),p.mergeEnvelope2D(_);const f=(0,a.a)(s,p,!0),P=(0,a.d)(f),x=new i.Envelope2D;if(x.setCoords({env2D:d}),x.inflateCoords(P,P),!x.isIntersecting(_))return t;if(1===m&&2===l){const h=function(t,e,s,n,h){const m=new a.E;t.queryEnvelope(m);const l=new i.Envelope2D;e.queryEnvelope(l),m.merge(l);const u=.1*m.width(),c=.1*m.height();m.inflateCoords(u,c);const g=new o.a;g.addEnvelope(m,!1);const d=g.getImpl();if(s===r.G.enumPolygon){const t=e.getImpl();d.add(t,!0)}else d.addEnvelope(e,!0);return new cn(g,n,-1,h).tryFastImplementation(t)}(t,e,g,s,n);if(h)return h}if(c===r.G.enumPoint){let s;switch((0,r.f)(g)?(s=new o.P({vd:e.getDescription()}),s.addSegment(e,!0)):s=e,g){case r.G.enumPolygon:return function(t,e,s){return 0===os(e,t,s.total())?t:t.createInstance()}(t,s,f);case r.G.enumPolyline:return function(t,e,s){const n=t.getXY(),r=e.querySegmentIterator(),o=(0,a.d)(s),m=o*o;for(;r.nextPath();)for(;r.hasNextSegment();){const e=r.nextSegment(),a=new i.Envelope2D;if(e.queryEnvelope(a),a.inflateCoords(o,o),!a.contains(n))continue;if(e.isIntersectingPoint(n,s.total()))return t.createInstance();let l=e.getStartXY();if(h.P.sqrDistance(n,l)<=m)return t.createInstance();if(l=e.getEndXY(),h.P.sqrDistance(n,l)<=m)return t.createInstance()}return t}(t,s,f);case r.G.enumMultiPoint:return function(t,e,s){const n=e.getImpl().getAttributeStreamRef(0),i=e.getPointCount(),r=t.getXY(),o=(0,a.d)(s),m=o*o,l=new h.P;for(let a=0;a<i;a++)if(n.queryPoint2D(2*a,l),h.P.sqrDistance(l,r)<=m)return t.createInstance();return t}(t,s,f);case r.G.enumEnvelope:return function(t,e,s){const n=new i.Envelope2D;e.queryEnvelope(n),n.inflate(s.total());const r=t.getXY();return n.contains(r)?t.createInstance():t}(t,s,f);case r.G.enumPoint:return function(t,e,s){const n=(0,a.d)(s),i=n*n,r=t.getXY(),o=e.getXY();return h.P.sqrDistance(r,o)<=i?t.createInstance():t}(t,s,f);default:(0,r.t)("invalid shape type")}}else if(c===r.G.enumMultiPoint)switch(g){case r.G.enumPolygon:return function(t,e,s){const n=new i.Envelope2D;e.queryEnvelope(n),n.inflate(s.total());const r=t.getPointCount();let o=!1;const a=(0,h.d)(r,!1),m=new h.P;for(let i=0;i<r;i++)t.queryXY(i,m),n.contains(m)&&0!==as(e,m,s.total())&&(o=!0,a[i]=!0);if(!o)return t;const l=t.createInstance();for(let i=0;i<r;i++)a[i]||l.addPoints(t,i,i+1);return l}(t,e,f);case r.G.enumEnvelope:return function(t,e,s){const n=new i.Envelope2D;e.queryEnvelope(n),n.inflate(s.total());const r=t.getPointCount();let o=!1;const a=(0,h.d)(r,!1),m=new h.P;for(let i=0;i<r;i++)t.queryXY(i,m),n.contains(m)&&(o=!0,a[i]=!0);if(!o)return t;const l=t.createInstance();for(let i=0;i<r;i++)a[i]||l.addPoints(t,i,i+1);return l}(t,e,f);case r.G.enumPoint:return function(t,e,s){const n=t.getImpl().getAttributeStreamRef(0),i=t.getPointCount(),r=e.getXY();let o=!1;const m=(0,h.d)(i,!1),l=(0,a.d)(s),u=l*l,c=new h.P;for(let a=0;a<i;a++)n.queryPoint2D(2*a,c),h.P.sqrDistance(c,r)<=u&&(o=!0,m[a]=!0);if(!o)return t;const g=t.createInstance();for(let a=0;a<i;a++)m[a]||g.addPoints(t,a,a+1);return g}(t,e,f)}const y=new i.Envelope2D(d);return y.inflate(100*f.total()),function(t,e,s,n){if(t.isEmpty()||e.isEmpty()||t.getDimension()>e.getDimension())return Us(zs(t),t,0,"-");const h=new i.Envelope2D;t.queryEnvelope(h);const m=new i.Envelope2D;e.queryEnvelope(m);const l=new i.Envelope2D;l.setCoords({env2D:h}),l.mergeEnvelope2D(m);const u=(0,a.a)(s,l,!0),c=m.clone(),g=(0,a.d)(u);if(c.inflateCoords(g,g),!h.isIntersecting(c))return Us(zs(t),t,0,"-");const d=new Bs(n),_=new o.E,p=_.addGeometry(zs(t)),f=_.addGeometry(zs(e));let P=0,x=0,y=null;if(_.hasCurves()){y=new ys;const t=_.getEnvelope2D(n);x=Ps(u.total());const e=fs(u.total(),t);P=xs(e,x),ds(_,e,u.total(),0,y,null,n)}d.setEditShapeCrackAndCluster(_,u.add(P));const E=d.difference(p,f);null!==y&&y.stitchCurves(_,E,x,!0);const C=Us(_.getGeometry(E),t,0,"-");return Ns(C.getGeometryType())&&(C.getImpl().setIsSimple(4,u.total()),C.getGeometryType()===r.G.enumPolygon&&C.getImpl().updateOGCFlagsProtected()),C}(t,(0,u.c)(e,y,0,0,n),s,n)}class xi{getOperatorType(){return 10002}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,n){return new yi(t,e,s,n)}execute(t,e,s,n){return this.executeMany(new g.S([t]),new g.S([e]),s,n).next()}}class yi extends g.G{constructor(t,e,s,n){super(),this.m_progressTracker=n,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=s;const i=e.next();this.m_geomSubtractor=i||new o.a}next(){const t=this.m_inputGeoms.next();return t?((0,r.d)(t),(0,r.B)(t),this.m_index=this.m_inputGeoms.getGeometryID(),Pi(t,this.m_geomSubtractor,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class Ei{getOperatorType(){return 10001}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s){return new Si(t,e,s,arguments.length>3&&void 0!==arguments[3]?arguments[3]:0)}execute(t,e,s,n){const i=new g.S([t,e]),o=new Si(i,s,n,0).next();return o||(0,r.c)("null output"),o}}class Ci{constructor(){this.binVertexCount=0,this.geometries=[]}addPair(t){this.binVertexCount+=t.vertexCount,this.geometries.push(t)}sort(){this.geometries.sort(((t,e)=>function(t,e){return h.P.compareZorder(t.location,e.location)?-1:t.location.equals(e.location)?0:1}(t,e)))}geomCount(){return this.geometries.length}geomPairs(){return this.geometries}clear(){this.binVertexCount=0,this.geometries.length=0}getBinVertexCount(){return this.binVertexCount}}class Si extends g.G{constructor(t,e,s,n){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];super(),this.m_index=-1,this.m_currentDim=-1,this.m_bDone=!1,this.m_unionBins=[],this.m_readyGeoms=(0,h.as)(4),this.m_dimGeomCounts=(0,h.d)(4,0),this.m_addedGeoms=0,this.m_maxDimension=-1,this.m_bHadGeometry=(0,h.d)(4,!1),this.m_complexUnionGeoms=(0,h.as)(4),this.m_totalNonEmptyGeomCounters=(0,h.d)(4,0),this.m_progressTracker=s,this.m_bUnionAllDimensions=!!(4&n),this.m_bPreserveAllPathEnds=!!(8&n),this.m_inputGeoms=t,this.m_spatialReference=e,this.m_options=n,this.m_bIs3D=i}next(){if(this.m_bDone&&this.m_currentDim===this.m_maxDimension)return null;for(;!this.step_(););if(-1===this.m_maxDimension)return null;if(this.m_bUnionAllDimensions){if(-1===this.m_currentDim)for(let t=0;t<=this.m_maxDimension;t++)if(this.m_bHadGeometry[t]){this.m_complexUnionGeoms[t]=this.getResultGeometry(t);for(let e=t+1;e<=this.m_maxDimension;e++)this.m_complexUnionGeoms[e]=this.getResultGeometry(e),this.m_bHadGeometry[e]&&!this.m_complexUnionGeoms[e].isEmpty()&&(this.m_bIs3D?(0,r.g)(0):this.m_complexUnionGeoms[t]=(new xi).execute(this.m_complexUnionGeoms[t],this.m_complexUnionGeoms[e],this.m_spatialReference,this.m_progressTracker))}for(;this.m_currentDim++,(this.m_currentDim>this.m_maxDimension||this.m_currentDim<0)&&(0,r.c)(""),!this.m_bHadGeometry[this.m_currentDim];);if(this.m_index++,0===this.m_currentDim&&this.m_complexUnionGeoms[this.m_currentDim].getGeometryType()===r.G.enumPoint){const t=new o.M({vd:this.m_complexUnionGeoms[this.m_currentDim].getDescription()});return this.m_complexUnionGeoms[this.m_currentDim].isEmpty()||t.add(this.m_complexUnionGeoms[this.m_currentDim]),t}return this.m_complexUnionGeoms[this.m_currentDim]}return this.m_index=0,this.m_currentDim=this.m_maxDimension,this.getResultGeometry(this.m_maxDimension)}getGeometryID(){return this.m_index}getRank(){return 1}tock(){return this.step_()}getResultGeometry(t){return this.m_readyGeoms[t]}finishDim(t,e,s){let n=e;if(!s)return 16&this.m_options?(n=Hs([n],1,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D),n):n;if(1&this.m_options)return n;if(1===t)if(8&this.m_options||!(16&this.m_options||this.m_totalNonEmptyGeomCounters[t]>1))1===this.m_totalNonEmptyGeomCounters[t]&&(this.m_bIs3D?(0,r.g)(0):n=(new ln).execute(n,this.m_spatialReference,!1,this.m_progressTracker));else{n=Hs([n],1,this.m_spatialReference,this.m_progressTracker,16|this.m_options,this.m_bIs3D);const t=[0],e=n.getImpl().getIsSimple(0,t);(0,r.g)(this.m_bIs3D||(0,a.i)(e))}else this.m_bIs3D?(0,r.g)(0):n=(new ln).execute(n,this.m_spatialReference,!1,this.m_progressTracker);if(0===t&&n.getGeometryType()===r.G.enumPoint){const t=new o.M({vd:n.getDescription()});n.isEmpty()||t.add(n),n=t}return n}static getLevel(t){const e=(0,r.v)(t);let s=e>0?(Math.log(e)-Math.log(32))/Math.log(4):0;return s<0&&(s=0),Math.floor(s)}step_(){if(this.m_bDone)return!0;let t;if(this.m_inputGeoms?(t=this.m_inputGeoms.next(),null===t?(this.m_bDone=!0,this.m_inputGeoms=null):(this.checkAndThrow(t),t.isEmpty()||this.m_totalNonEmptyGeomCounters[t.getDimension()]++)):t=null,null!==t){const e=t.getDimension();this.m_bHadGeometry[e]=!0,(e>=this.m_maxDimension||this.m_bUnionAllDimensions)&&(this.addGeom(e,!1,t),e>this.m_maxDimension&&!this.m_bUnionAllDimensions&&this.removeAllBinsWithLowerDimension(e))}if(this.m_addedGeoms>0)for(let e=0;e<=this.m_maxDimension;e++){for(;this.m_dimGeomCounts[e]>1;){const t=this.collectGeometriesToUnion(e);if(null===t)break;{let s;s=1&this.m_options?Hs(t,t.length,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D):Ls(t,t.length,this.m_spatialReference,this.m_progressTracker,8|this.m_options,this.m_bIs3D),this.addGeom(e,!0,s)}}if(this.m_bDone&&((0,r.g)(this.m_dimGeomCounts[e]<=1),0!==this.m_dimGeomCounts[e])){const t=this.m_unionBins[e].entries().next().value,s=t[1].geomPairs()[0].geom,n=t[1].geomPairs()[0].bUnioned;this.m_unionBins[e].clear(),this.m_readyGeoms[e]=this.finishDim(e,s,n)}}return this.m_bDone}addGeom(t,e,s){const n={geom:null,vertexCount:-1,bUnioned:!1,location:new h.P};n.geom=s;const o=(0,r.v)(s);n.vertexCount=o;const a=i.Envelope2D.constructEmpty();s.queryEnvelope(a),n.location=o>0?a.getCenter():new h.P(0,0);const m=Si.getLevel(s);if(t+1>this.m_unionBins.length)for(;this.m_unionBins.length<Math.max(2,t+1);)this.m_unionBins.push(new Map);let l=null;const u=this.m_unionBins[t].get(m);u&&(l=u),null===l&&(l=new Ci,this.m_unionBins[t].set(m,l)),n.bUnioned=e,l.addPair(n),this.m_dimGeomCounts[t]++,this.m_addedGeoms++,this.m_maxDimension=Math.max(this.m_maxDimension,t)}removeAllBinsWithLowerDimension(t){for(let e=0;e<t;e++)this.m_unionBins[e].clear(),this.m_addedGeoms-=this.m_dimGeomCounts[e],this.m_dimGeomCounts[e]=0}collectGeometriesToUnion(t){if(1&this.m_options&&!this.m_bDone)return null;let e=null;const s=[];for(const n of this.m_unionBins[t].keys())s.push(n);(0,h.v)(s);for(let n=0;n<s.length;n++){if(-1===s[n])continue;const i=this.m_unionBins[t].get(s[n]);{const r=5e3,o=4,a=i.getBinVertexCount()>r&&i.geomCount()>=o;if(this.m_bDone||a){for(let i=0;i<n;i++){if(-1===s[i])continue;const n=this.m_unionBins[t].get(s[i]);n.sort(),this.m_dimGeomCounts[t]-=n.geomCount(),this.m_addedGeoms-=n.geomCount();for(const t of n.geomPairs())e||(e=new Array),e.push(t.geom);n.clear(),this.m_unionBins[t].delete(s[i]),s[i]=-1}i.sort(),this.m_dimGeomCounts[t]-=i.geomCount(),this.m_addedGeoms-=i.geomCount();for(const t of i.geomPairs())e||(e=new Array),e.push(t.geom);if(i.clear(),this.m_unionBins[t].delete(s[n]),s[n]=-1,!this.m_bDone)break}}}return e}checkAndThrow(t){this.m_bIs3D&&(t.getDimension()>1&&(0,r.x)(),t.hasAttribute(1)||(0,r.t)("Geometry must have Zs")),(0,r.d)(t)}}class vi extends di{getOperatorType(){return 3}execute(t,e,s){return oe(t,e,s,4,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}}function bi(t,e,s){const n=e.getGCSSplitLines();if(null===n)return t;const m=e.getGCS(),u=m.getPannableExtent().width(),c=i.Envelope2D.constructEmpty();t.queryLooseEnvelope(c);const g=h.E.constructEmpty();c.queryIntervalX(g);const d=n.querySegmentIterator();let _=null;const p=new l.T;for(;d.nextPath();)for(;d.hasNextSegment();){const t=d.nextSegment(),e=t.queryInterval(0,0),s=h.E.constructEmpty();s.setCoordsFromEnvelope(e);let n=0;for(;s.vmax>g.vmin;)s.move(-u),n--;for(;s.vmin<=g.vmax;){if(s.isIntersecting(g)){null===_&&(_=new o.P);const e=new o.L({start:t.getStartXY(),end:t.getEndXY()});0!==n&&(p.setShiftCoords(n*u,0),e.applyTransformation(p)),_.addSegment(e,!0)}s.move(u),++n}}if(null!==_){const e=(0,a.b)(m,_,!0);return function(t,e,s,n){const i=e.getGeometryType();if((0,r.h)(i))return new Gt(n).crackAWithBMultiPath_(t,e,s);(0,r.b)("crack_A_with_B")}(t,_,(0,a.d)(e),s)}return t}function Ii(t,e,s){let n=t.getName();return xo(n)||(s||e>0?(n=t.toString(ko.PE_STR_NAME_CANON|ko.PE_STR_AUTH_NONE),n=function(t){return t.toLocaleUpperCase("en-US")}(n)):n=t.toString(ko.PE_STR_AUTH_TOP)),n}function wi(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;if((e>1||e<-1)&&(0,r.t)("verbosity"),-1===e)return t.toString();{const s=0===e?ko.PE_STR_AUTH_TOP:ko.PE_STR_AUTH_ALL;return t.toString(s)}}function Di(t,e,s,n){if(t.isEmpty()||1===s)return t;const o=t.getGeometryType();if(o===r.G.enumPoint){const n=t,i=n.getXY();return 0===Ai([i],1,e,s)||i.isNAN()?n.setEmpty():n.setXY(i),t}if(o===r.G.enumMultiPoint){const n=t,i=t.createInstance(),r=n.getPointCount();i.reserve(r);const o=n.getAttributeStreamRef(0),h=n.getDescription().getAttributeCount()>1,m=new a.P,l=Float64Array.from(o.getArray());if(Ai(l,r,e,s)>0)for(let t=0,e=2*r;t<e;t+=2)Number.isNaN(l[t])||(h?(n.getPointByVal(t>>1,m),m.setXYCoords(l[t],l[t+1]),i.add(m)):i.addXY(l[t],l[t+1]));return i}let h=t;const m=e.getOneDegreeGCSUnit(),c=90*m,g=180*m,d=360*m,_=e.getCentralMeridian(),p=.5*m,f=i.Envelope2D.constructEmpty();h.queryEnvelope(f);const P=e.getGCSHorizon(),x=e.getGCSHorisonIsInclusive(),y=P.getGeometryType()===r.G.enumEnvelope,E=i.Envelope2D.constructEmpty();P.queryEnvelope(E);const C=e.getGCS();if(2!==s&&4!==s||(E.xmin=_-g,E.xmax=E.xmin+d),4===s){if(!(f.width()>d-m)){const t=i.Envelope2D.constructEmpty();t.setCoords({xmin:f.xmin-m,ymin:E.ymin,xmax:f.xmax+m,ymax:E.ymax}),h=(new u.O).execute(h,t,C,n);let e=Math.floor((_-f.getCenterX())/d);for(f.move(e*d,0);f.xmin>E.xmax;)e-=1,f.move(-d,0);for(;f.xmin<E.xmin;)e+=1,f.move(d,0);if(0!==e){const t=new l.T;t.setShiftCoords(e*d,0),h.applyTransformation(t)}return h}s=2}if(2===s&&(E.xmin=_-g,E.xmax=E.xmin+d),f.ymin<-c||f.ymax>c){const t=i.Envelope2D.constructEmpty();if(t.setCoords({xmin:f.xmin-m,ymin:-c,xmax:f.xmax+m,ymax:c}),h=(new u.O).execute(h,t,C,n),h.isEmpty())return h;h.queryEnvelope(f)}if(x&&(E.ymax<f.ymin||E.ymin>f.ymax))return h.createInstance();f.width()>d&&(h=Hi(h,_-g,d,C,!0,0,!0,n),h.queryEnvelope(f));let S=function(t,e,s,n,i){return t>=s&&e<=n?0:Ri(.5*(e+t),s,n,i)}(f.xmin,f.xmax,E.xmin,E.xmax,d);if(0!==S&&f.move(S,0),f.xmax>E.xmax||f.xmin<E.xmin){if(f.xmax>E.xmax)for(;f.xmin>=E.xmax;)f.move(-d,0),S-=d;for(;f.xmin<E.xmax-d;)f.move(d,0),S+=d}const v=(0,a.W)(C,P,!1);if(0!==S){const t=new l.T;t.setShiftCoords(S,0),h.applyTransformation(t),S=0}if(x){if(y&&E.containsEnvelope(f))return h;const t=new Array(2);for(let e=0;e<2;e++){let s;if(y?s=(0,r.h)(o)?(0,u.c)(h,E,v,p,n):(0,u.c)(h,E,v,0,n):(s=(new dn).execute(h,P,C,n),s===P&&(s=s.clone())),E.xmin<=f.xmin&&E.xmax>=f.xmax)return s;if(E.xmin>=f.xmin&&E.xmax<=f.xmax)return s;if(t[e]=s,0===e){f.move(-d,0);const t=new l.T;t.setShiftCoords(-d,0),h.applyTransformation(t)}}return(0,r.h)(o)?t[0].add(t[1],!1):(0,r.c)("intersect_with_GCS_horizon: unexpected geometry type"),t[0]}{if(E.ymax<f.ymin||E.ymin>f.ymax)return h;let t=0;for(;!h.isEmpty()&&f.xmax>E.xmin;){if(0!==t){const e=new l.T;e.setShiftCoords(t,0),h.applyTransformation(e)}if((new vi).execute(h,P,C,n)||(h=(new xi).execute(h,P,C,n),P===h&&(h=h.clone())),0!==t){const e=new l.T;e.setShiftCoords(-t,0),h.applyTransformation(e)}t-=d,f.move(-d,0)}return h}}function Ti(t,e,s,n,i,r){const l={stack:[],error:void 0,hasError:!1};try{if(2===r)return function(t,e,s,n,i){if(Math.abs(s.x-n.x)>Math.PI)return Number.NaN;if(Math.abs(s.y)>h.l||Math.abs(n.y)>h.l)return Number.NaN;if((Math.abs(s.y)===h.l||Math.abs(n.y)===h.l)&&s.x!==n.x)return Number.NaN;const{first:r,second:m}=(0,h.aC)(s.x,n.x);let l=i;if(l=b(l,r,m),!h.E.construct(s.x,n.x).containsCoordinate(l))return Number.NaN;const u=o.W.constructPoint2D(s),c=o.W.constructPoint2D(n),g=D(1,e,u),d=D(1,e,c),_=g.crossProductVector(d);if(_.z.isZero())return s.y;const p=_.x.divE(_.z.negate()),f=_.y.divE(_.z.negate()),P=p.mulE(p).addE(f.mulE(f)).sqrt();if(P.isZero()||p.isZero()&&f.isZero())return s.y;const x=Math.atan2(f.value(),p.value());let y=Math.atan2(P.value()*Math.cos(x-l),1-e);const E=I(1,e,h.P.construct(l,y)),C=a.h.construct(E.x,E.y,-E.z),S=_.value().dotProduct(E),v=_.value().dotProduct(C);return Math.abs(v)<Math.abs(S)&&(y=-y),y}(0,e,s,n,i);if(Math.abs(s.x-n.x)>=Math.PI||!_r(s.x,n.x,i))return Number.NaN;s.x>n.x&&(n=(0,h.b)(s,s=n));const u=(0,m.b)(l,new Yo,!1),c=(0,m.b)(l,new Yo,!1),g=(0,m.b)(l,new Yo,!1),d=s.clone();zo.geodeticDistance(t,e,s.x,s.y,n.x,n.y,c,u,null,r);const _=c.val;let p=0,f=1;for(;_*(f-p)>1e-12*t;){const o=.5*(p+f);if(zo.geodeticCoordinate(t,e,s.x,s.y,_*o,u.val,c,g,r),d.x=c.val,d.y=g.val,d.x===i)return d.y;if(_r(s.x,d.x,i))f=o;else{if(!_r(n.x,d.x,i))return Number.NaN;p=o}}return d.y}catch(u){l.error=u,l.hasError=!0}finally{(0,m.c)(l)}}function Ni(t,e,s,n){for(let i=0,r=0;i<n;i++,r+=2)e[s+i].x=t[r],e[s+i].y=t[r+1]}function Ai(t,e,s,n){if(0===e||1===n)return e;const o=function(t,e){let s;if(Array.isArray(t)){const n=t;s=new Float64Array(2*e);for(let t=0,i=0;t<e;t++,i+=2)s[i]=n[t].x,s[i+1]=n[t].y}else s=t;return s}(t,e);if(2===n){const n=s.getPannableExtentInGCS();let i=e;for(let t=0,s=2*e;t<s;t+=2)(o[t+1]>n.ymax||o[t+1]<n.ymin)&&(o[t]=Number.NaN,i--);return i?(Li(o,e,n.xmin,n.width(),!0),t!==o&&Ni(o,t,0,e),i):0}const m=s.getOneDegreeGCSUnit(),l=90*m,u=180*m,c=360*m;let g=e;for(let i=0,r=2*e;i<r;i+=2)(o[i+1]>l||o[i+1]<-l)&&(o[i]=Number.NaN,g--);if(!g)return 0;const d=i.Envelope2D.constructEmpty();d.setFromPoints(o,e);const _=s.getGCSHorizon(),p=s.getGCSHorisonIsInclusive(),f=_.getGeometryType()===r.G.enumEnvelope,P=i.Envelope2D.constructEmpty();if(_.queryEnvelope(P),p&&(P.ymax<d.ymin||P.ymin>d.ymax))return 0;if(p)if(Li(o,e,P.getCenterX()-u,c,!0),g=e,f)for(let i=0,r=2*e;i<r;i+=2)P.containsCoords(o[i],o[i+1])||(o[i]=Number.NaN,g--);else{const t=(0,a.W)(s.getGCS(),_,!1),n=new h.P;for(let s=0,i=2*e;s<i;s+=2)n.setCoords(o[s],o[s+1]),0!==as(_,n,t)||(o[s]=Number.NaN,g--)}else{Li(o,e,-u,c,!0),g=e;const t=(0,a.W)(s.getGCS(),_,!1),n=new h.P;for(let s=0,i=2*e;s<i;s+=2){n.setCoords(o[s],o[s+1]),n.isNAN()&&g--;const e=Ri(n.x,P.xmin,P.xmax,c);n.x+=e,0!==as(_,n,t)&&(o[s]=Number.NaN,g--)}}return g>0&&Array.isArray(t)&&Ni(o,t,0,e),g}function Gi(t,e,s,n,i,o){if(e.isPannable()||(0,r.t)("fold_into_360_degree_range"),t.isEmpty())return t;let a,h;if(2===e.getCoordinateSystemType()){const t=e.getPannableExtent();h=t.xmin,a=t.width()}else{const t=e.getOneDegreeGCSUnit();a=360*t,h=s-180*t}return Hi(t,h,a,e,n,i,!0,o)}function Mi(t,e,s,n){let i,r;if(2===s.getCoordinateSystemType()){const t=s.getPannableExtent();i=t.xmin,r=t.width()}else{const t=s.getOneDegreeGCSUnit();r=360*t,i=n-180*t}Li(t,e,i,r)}function Fi(t,e){const s=e.width();let n=(0,h.o)(t-e.vmin,s);return n<0&&(n+=s),e.snapClip(n+e.vmin)}function qi(t,e,s){return t>e.xmax&&t-e.xmax<s?e.xmax:t<e.xmin&&e.xmin-t<s?e.xmin:t}function Vi(t,e,s){if(t[0]<e.vmin||t[0]>e.vmax||s&&t[0]===e.vmax){const s=e.width();return t[0]+=Math.ceil((e.vmin-t[0])/s)*s,t[0]=e.snapClip(t[0]),!0}return!1}function Yi(t,e,s,n,i){const r=new o.E,h=r.addGeometry(t);return Xi(r,h,e,(0,a.W)(e,t,!1),s,n,i),r.getGeometry(h)}function Xi(t,e,s,n,i,a,l){const u={stack:[],error:void 0,hasError:!1};try{(0,r.g)(eo()),s.isPannable()||(0,r.m)("insert_geodetic_points");const c=s.getPannableExtent(),g=s.getGCS(),d=$r();g.querySpheroidData(d);const _=g.getUnit().getUnitToBaseFactor(),p=d.majorSemiAxis,f=d.e2;let P=0;const x=new h.E;c.queryIntervalX(x);let y=null;const E=(0,h.d)(4,Number.NaN);2===s.getCoordinateSystemType()?(y=s.getPECoordSys(),a?(E[0]=Fi(l,x),E[1]=c.getCenterY(),Ro.projToGeog(y,1,E),P=E[0]*_):(E[0]=c.getCenterX(),E[1]=l,Ro.projToGeog(y,1,E),P=E[1]*_)):P=l*_,a||0===P||2===i||(0,r.m)("insert_geodetic_points: 1");const C=(0,m.b)(u,new Yo,!1),S=new h.P,v=new h.P,b=new h.P,I=new h.P,w=new h.P,D=new h.P;for(let r=t.getFirstPath(e);r!==o.n;r=t.getNextPath(r)){const e=t.getFirstVertex(r);t.queryXY(e,b);let m=!1;const u=t.getNextVertex(e);for(let r=u;r!==o.n;r=t.getNextVertex(r)){if(r===u){if(m)break;m=!0}if(t.queryXY(r,I),a&&(n<l-b.x&&I.x-l>n||n<l-I.x&&b.x-l>n)||!a&&(0!==l||n<-b.y&&I.y>n||n<-I.y&&b.y>n))do{if(Math.abs(b.x-I.x)>=.5*x.width())break;2===s.getCoordinateSystemType()?(E[0]=Fi(b.x,x),E[1]=b.y,E[2]=Fi(I.x,x),E[3]=I.y,er(y,2,E,0),w.x=E[0]*_,w.y=E[1]*_,D.y=E[3]*_):(w.x=b.x*_,w.y=b.y*_,D.y=I.y*_),D.x=(I.x-b.x)*Math.PI*2/x.width()+w.x;let e=0;const n=(0,h.m)(h.P,2);if(a){if(v.x=P,v.y=Ti(p,f,w,D,P,i),Number.isNaN(v.y))break;n[0]=v,e=1}else if(2===i){const t=[0,0];if(e=V(0,f,w,D,P,t),!e)break;n[0].x=t[0],n[0].y=P,2===e&&(n[1].x=t[1],n[1].y=P)}else{if(v.x=pr(p,f,w,D,i),Number.isNaN(v.x))break;v.y=0,n[0]=v,e=1}let o=-1;for(let m=0;m<e;m++){zo.geodeticDistance(p,f,w.x,w.y,D.x,D.y,C,null,null,i);const e=C.val;zo.geodeticDistance(p,f,w.x,w.y,n[m].x,n[m].y,C,null,null,i);const u=C.val;2===s.getCoordinateSystemType()?(E[0]=n[m].x/_,E[1]=n[m].y/_,Ro.geogToProj(y,1,E),a?(S.y=E[1],S.x=l):(S.x=fr(E[0],b.x,I.x,x),S.y=l)):a?(S.x=l,S.y=n[m].y/_):(S.x=fr(n[m].x/_,b.x,I.x,x),S.y=l);const c=e>0?(0,h.c)(u/e,0,1):.5;if(0===c||1===c)continue;if(o>c)continue;const g=t.getPrevVertex(r);t.splitSegment(g,[c],1);const d=t.getNextVertex(g);t.setXYCoords(d,S.x,S.y),o=c}}while(0);b.setCoordsPoint2D(I)}}}catch(c){u.error=c,u.hasError=!0}finally{(0,m.c)(u)}}function ki(t,e){(0,r.g)(e.isPannable());const s=e.getPannableExtent();if(t.getGeometryType()===r.G.enumPoint){const e=t.getY();return s.ymin<=e&&e<=s.ymax?t:t.createInstance()}const n=i.Envelope2D.constructEmpty();t.queryEnvelope(n);const o=i.Envelope2D.constructEmpty();o.setCoords({env2D:s}),o.xmin=n.xmin,o.xmax=n.xmax,o.inflateCoords(.01*o.height(),0);const h=(0,a.c)(e,n,!1);let m;return m=o.containsEnvelope(n)?t:(0,u.c)(t,o,h,0,null),m}function Ri(t,e,s,n){return(0,h.av)((.5*(s+e)-t)/n)*n}function Hi(t,e,s,n,a,m,c,g){const d=t.getGeometryType(),_=h.E.constructEmpty();_.setCoords(e,e+s);const p=[0];if(d===r.G.enumPoint){const e=t;if(p[0]=e.getX(),Vi(p,_,c)){const e=a?t:t.clone();return e.setX(p[0]),e}return t}const f=i.Envelope2D.constructEmpty();if(t.queryEnvelope(f),f.isEmpty())return t;if(d===r.G.enumMultiPoint){const e=a?t:t.clone(),s=e.getImpl(),n=s.getAttributeStreamRef(0),i=2*s.getPointCount();let r=!1;for(let t=0;t<i;t+=2)p[0]=n.read(t),Vi(p,_,c)&&(n.write(t,p[0]),r=!0);return r&&s.notifyModifiedFlags(2001),e}const P=h.E.constructEmpty();if(f.queryIntervalX(P),_.contains(P))return _.vmax,P.vmax,t;const x=i.Envelope2D.constructEmpty();if(x.setCoords({env2D:f}),0===P.width()){let e=P.vmin;e+=Math.ceil((_.vmin-e)/s)*s,e=_.snapClip(e);const n=a?t:t.clone();return n.setAttributeBasic(0,0,e),n}if(d===r.G.enumEnvelope){const e=a?t:t.clone();return f.intersect(x),e.setEnvelope(f),e}const y=.1*Math.max(f.height(),f.width())*1;x.inflateCoords(0,y);let E=t;const C=n.getTolerance(0),S=new l.T;for(;;){const t=Math.floor((P.vmin-e)/s),i=Math.ceil((P.vmax-e)/s);if(!(i-t>3))break;{const o=Math.floor(.5*(i+t));x.xmin=f.xmin-y,x.xmax=e+s*o;const a=(0,u.c)(E,x,C,m,g);x.xmin=x.xmax,x.xmax=f.xmax+y;const h=(0,u.c)(E,x,C,m,g);S.setShiftCoords((o-i)*s,0),h.applyTransformation(S),d===r.G.enumPolygon?E=(new Ei).execute(a,h,n,g):(E=a,E.add(h,!1)),E.queryEnvelope(f),f.queryIntervalX(P)}}x.xmin=e,x.xmax=e+s;const v=i.Envelope2D.constructEmpty();v.setCoords({env2D:x}),v.inflateCoords(C,0);const b=Math.floor((f.xmin-x.xmin)/s)*s;let I;b?(x.move(b,0),S.setShiftCoords(-b,0)):S.setIdentity(),I=d===r.G.enumPolyline?new o.P({vd:E.getDescription()}):new o.a({vd:E.getDescription()});const w=i.Envelope2D.constructEmpty(),D=i.Envelope2D.constructEmpty();for(;f.xmax>x.xmin;){const t=(0,u.c)(E,x,C,0,g);t.queryEnvelope(D);let e=!1;e=d===r.G.enumPolyline?!t.isEmpty()&&(D.width()>C||D.height()>C):!t.isEmpty()&&(d!==r.G.enumPolygon||D.width()>C),e&&(t.applyTransformation(S),t.queryEnvelope(D),I.queryEnvelope(w),w.inflateCoords(C,C),w.isIntersecting(D)&&d===r.G.enumPolygon?I=(new Ei).execute(I,t,n,g):I.add(t,!1)),x.move(s,0),S.shiftCoords(-s,0)}return I}function Li(t,e,s,n){let i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const r=new h.E;r.setCoords(s,s+n);const o=[0];if(Array.isArray(t)){const s=t;for(let t=0;t<e;t++)r.containsRightExclusive(s[t].x)||(o[0]=s[t].x,Vi(o,r,i),s[t].x=o[0])}else{const s=t;for(let t=0;t<e;t++){const e=t<<1;r.containsRightExclusive(s[e])||(o[0]=s[e],Vi(o,r,i),s[e]=o[0])}}}function Bi(t,e,s){let n=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];if(t.isEmpty())return;const o=t.getGeometryType();if(!n||o!==r.G.enumPolygon)if((0,r.i)(o)){let n=!1;if((0,r.h)(o)&&t.hasNonLinearSegments()){const i=t.getImpl(),o=i.getAttributeStreamRef(0),a=i.getSegmentFlagsStreamRef();(0,r.g)(null!==a);for(let t=0,r=i.getPathCount();t<r;t++){let r=!0;const h=i.isClosedPath(t),m=i.getPathEnd(t);h&&i.getPathSize(t)>0&&(r=1===(31&a.read(m-1)));for(let l=i.getPathStart(t);l<m;l++)if(1===(31&a.read(l))){if(r){const t=o.read(2*l),i=qi(t,e,s);i!==t&&(n=!0,o.write(2*l,i))}r=!0}else r=!1}}else{const i=t.getImpl(),r=i.getAttributeStreamRef(0);for(let t=0,o=i.getPointCount();t<o;t++){const i=r.read(2*t),o=qi(i,e,s);o!==i&&(n=!0,r.write(2*t,o))}}n&&t.getImpl().notifyModifiedFlags(2001)}else if(o===r.G.enumEnvelope){const n=t,r=i.Envelope2D.constructEmpty();n.queryEnvelope(r),r.xmin=qi(r.xmin,e,s),r.xmax=qi(r.xmax,e,s),n.setEnvelope(r)}else if(o===r.G.enumPoint){const n=t;n.setX(qi(n.getX(),e,s))}else(0,r.c)("")}function Ui(t,e,s){const n=new h.P;return n.x=qi(t.x,e,s),n.y=t.y,n}function zi(t,e,s,n){const o=t.getGeometryType();(0,r.g)(o===r.G.enumPolygon||o===r.G.enumPolyline||o===r.G.enumMultiPoint);const m=e.getCoordinateSystemType();if(2===m){let m=t;if(0===s){const s=function(t,e){if(e.isEmpty())return 0;const s=t.getPECoordSys();if(s.getProjection().getCode()===ko.PE_PRJ_AZIMUTHAL_EQUIDISTANT){const n=$r();t.querySpheroidData(n);const r=s.getParameters();if(null===r[ko.PE_PARM_LAM0])return 0;if(null===r[ko.PE_PARM_PHI0])return 0;const o=[r[ko.PE_PARM_LAM0].getValue(),r[ko.PE_PARM_PHI0].getValue()];Ro.geogToProj(s,1,o);const a=new h.P(o[0],o[1]),m=i.Envelope2D.constructEmpty();e.queryEnvelope(m);const l=(0,h.m)(h.P,4);m.queryCorners(l);let u=0;const c=t.getOneMeter();let g=Math.max(n.majorSemiAxis,n.minorSemiAxis)*Math.PI,d=Math.min(n.majorSemiAxis,n.minorSemiAxis)*Math.PI;d-=g/180,g*=c,d*=c;for(let t=0;t<4;t++){const e=h.P.distance(l[t],a);if(e>g)u++;else if(e>d)return-1}if(0===u)return 1;if(4===u){const t=i.Envelope2D.constructEmpty();return t.setCoords({center:a,width:g,height:g}),m.isIntersectingNe(t)?-1:0}return-1}return-1}(e,t);if(0===s)return t.createInstance();if(1===s)return t;const o=e.getPCSHorizon(),l=o.getGeometryType(),c=e.getDefaultPrecisionSR();if(l===r.G.enumEnvelope){const s=i.Envelope2D.constructEmpty();o.queryEnvelope(s);const r=(0,a.c)(c,s,!1);m=(0,u.c)(t,s,r,5e4*e.getOneMeterPCSUnit(),n)}else(new fi).execute(o,t,c,n)||(m=(new dn).execute(m,o,c,n),m===o&&(m=m.clone()))}else if(e.isPannable()){const t=i.Envelope2D.constructEmpty();m.queryEnvelope(t);const a=e.getPannableExtent();a.containsEnvelope(t)||(Bi(m,a,e.getTolerance(0)),2!==s&&4!==s||(m=ki(m,e)),4!==s?m=Gi(m,e,0,!0,1e5*e.getOneMeterPCSUnit(),n):o===r.G.enumPolygon&&t.width()>2*a.width()&&(m=Hi(m,-2*a.width(),2*a.width(),e,!0,0,!0,n)))}return m}if((0,r.g)(1===m),o===r.G.enumMultiPoint)return Bi(t,e.getPannableExtent(),e.getTolerance(0)),t;{const s=i.Envelope2D.constructEmpty();t.queryEnvelope(s);let a=t;const h=e.getPannableExtent();if(s.ymin<h.ymin||s.ymax>h.ymax){const t=Math.max(1,s.calculateToleranceFromEnvelope()),r=new i.Envelope2D(s.xmin-t,h.ymin,s.xmax+t,h.ymax);if(a=(new u.O).execute(a,r,e,n),a.isEmpty())return a}return o===r.G.enumPolygon&&s.width()>2*h.width()&&(a=Hi(a,-2*h.width(),2*h.width(),e,!0,0,!0,n)),a}}function Oi(t,e){const s=e.getPointCount();if(!s)return;const n=e.getImpl(),i=n.getAttributeStreamRef(0),r=t;Ro.geogToProj(r,s,i.getArray()),n.notifyModifiedFlags(2001)}function Wi(t,e,s,n){if(!s)return;const i=t.getPECoordSys();if(1===s){const s=[e[0].x,e[0].y];if(Ro.geogToProj(i,1,s),n){const{first:n,second:i}=t.m_peCoordSysVal.getGeogToProjFactors();s[0]=n*(e[0].x-t.getCentralMeridian())+i}return void e[0].setCoords(s[0],s[1])}const r=t.isPannable(),o=r?t.getPannableExtent().width():0,a=179*o/360;let m=0;r&&(m=t.getCentralMeridian());const l=new Float64Array(512);for(let u=0;u<s;){for(let t=u;t<s&&e[t].isNAN();++t)u++;let c=Math.min(256,s-u);if(c>0){for(let t=1,s=u+1;t<c;++t,++s)if(e[s].isNAN()){c=t;break}for(let t=0;t<c;++t){const s=t<<1;l[s]=e[u+t].x,l[s+1]=e[u+t].y}if(Ro.geogToProj(i,c,l),n){const{first:s,second:n}=t.m_peCoordSysVal.getGeogToProjFactors();for(let t=0;t<c;++t)l[t<<1]=s*(e[u+t].x-m)+n}if(r)for(let t=0,s=u;t<c;t++,s++){const n=t<<1,i=l[n],r=(0,h.e)(i),u=e[s].x-m;r*(0,h.e)(u)<0&&Math.abs(i)>a&&(l[n]-=r*o)}Ni(l,e,u,c),u+=c}}}function ji(t,e,s,n){const i=t.getSRToGCSTransform();return(new Sn).transform(i,e,s,n,!1)}function Zi(t,e,s,n){const r=new o.M({vd:e.getDescription()});let a;r.addPoints(e,0,-1),a=(new Sn).execute(r,t,n);const h=e.getPointCount();if(s.setEmpty(),t.getInputSR().isPannable()){if(h!==a.getPointCount())return!1;const n=new i.Envelope2D;e.queryEnvelope(n);const r=new i.Envelope2D;a.queryEnvelope(r);const o=n.width(),m=r.width();if(0!==o&&0!==m){const e=m/o,s=t.getOutputSR().getPannableExtent().width()/t.getInputSR().getPannableExtent().width();if(Math.abs(e/s-1)>1e-10)return!1}else if(0!==o||0!==m)return!1;s.add(e,!1);for(let t=0;t<h;t++){const e=a.getXY(t);s.setXY(t,e)}return!0}return!1}function Qi(t,e,s){(0,r.g)(!s||t.isPannable());const n=e.getPointCount();if(!n)return;const i=e.getImpl(),o=i.getAttributeStreamRef(0),a=t.getPECoordSys();let m=0;const l=o.readRange(0,2*n);let u=()=>{Ro.geogToProj(a,n,l)};const c=t.isPannable()&&!s,g=c?t.getPannableExtent().width():0,d=179*g/360;if(t.isPannable()&&(m=t.getCentralMeridian(),s)){const e=t.m_peCoordSysVal.getGeogToProjFactors(),s=e.first,i=e.second;u=()=>{Ro.geogToProj(a,n,l);for(let t=0;t<n;t++){const e=t<<1,n=o.read(e),r=s*(n-m)+i;l[e]=r}}}if(u(),c)for(let r=0;r<n;r++){const t=r<<1,e=l[t],s=(0,h.e)(e),n=o.read(t)-m;s*(0,h.e)(n)<0&&Math.abs(e)>d&&(l[t]+=-s*g)}o.writeRangeFromArray(0,2*n,l,!0,1),i.notifyModifiedFlags(2001)}function Ki(t,e,s){switch(e.getGeometryType()){case r.G.enumLine:return void function(t,e,s){const n=[e.getStartXY(),e.getEndXY()];Wi(t,n,2,s),e.setStartXY(n[0]),e.setEndXY(n[1]),e.normalizeAfterEndpointChange()}(t,e,s);case r.G.enumBezier:return void function(t,e,s){const n=(0,h.m)(h.P,4);e.queryControlPoints(n),cr(t,n,4,s),e.setControlPoints(n)}(t,e,s);case r.G.enumEllipticArc:return void function(t,e,s){if(0===e.projectionBehavior())!function(t,e,s){dr(!0,t,0,e,s)}(t,e,s);else{const n=e.isClosed()&&e.isMajor(),i=[e.getStartXY(),n?e.getCenter():e.getEndXY()],r=[i[0].clone(),i[1].clone()];cr(t,r,2,s);const o=new l.T;o.initializeFromTwoPointsArray(i,r),e.applyTransformation(o);const a=n?0:1;e.setCoordsForIntersector(r[0],r[a],!1)}}(t,e,s);case r.G.enumBezier2:case r.G.enumRationalBezier2:return void(0,r.g)(0);default:(0,r.c)("")}}function Ji(t,e,s){if(!e.hasNonLinearSegments())return void Qi(t,e,s);if((0,r.g)(!s||t.isPannable()),e.isEmpty())return;const n=t.getPECoordSys(),i=t.isPannable(),m=i?t.getPannableExtent().width():0,l=179*m/360;let u=0;i&&(u=t.getCentralMeridian());const c=e.createInstance();c.reserveParts(e.getPointCount(),e.getPathCount());const g=e.getImpl(),d=new o.S;for(let r=0,o=e.getPathCount();r<o;++r)if(g.hasNonLinearSegmentsPath(r)){let e=!0,n=-1;const i=g.getPathStart(r),o=i+g.getSegmentCountPath(r);g.isClosedPath(r)&&(n=o-1);const m=new h.P;for(let r=i;r<o;++r){if(g.getSegmentBuffer(r,d,!1),Ki(t,d.get(),s),e||d.get().getStartXY().equals(m)||d.get().moveTo(m),r!==n)c.addSegment(d.get(),e);else{if(e){const t=new a.P;d.get().queryStart(t),c.startPathPoint(t)}c.closeLastPathWithSegment(d.get())}m.assign(d.get().getEndXY()),e=!1}}else{const t=1024;let s,o=g.getPathSize(r),a=Math.min(o,t);c.insertPath(-1,e,r,!0);const d=g.getAttributeStreamRef(0),_=c.getAttributeStreamRef(0);for(let e=g.getPathStart(r),c=g.getPathEnd(r);e<c;){if(s=d.readRange(e,a),Ro.geogToProj(n,a,s),i)for(let t=0;t<a;t++){const e=t<<1,n=s[e],i=(0,h.e)(n),r=d.read(2*(0+t))-u;i*(0,h.e)(r)<0&&Math.abs(n)>l&&(s[e]+=-i*m)}_.writeRangeFromArray(e,a,s,!0,1),e+=a,o-=a,a=Math.min(o,t)}}e.assignMove(c)}function $i(t,e,s){let n=s.getPointCount();if(!n)return;const i=s.getImpl(),r=i.getAttributeStreamRef(0);let o=Math.min(n,1e3),a=0;const m=t.getPECoordSys();Number.isNaN(e)&&(e=0);const l=t.isPannable(),u=t.getOneDegreeGCSUnit(),c=360*u,g=179*u;let d;for(;n;){if(d=r.readRange(2*a,2*o),er(m,o,d,e),l)for(let t=0;t<o;t++){const s=t<<1,n=d[s]-e,i=(0,h.e)(n),o=r.read(2*(a+t));i*(0,h.e)(o)<0&&Math.abs(n)>g&&(d[s]+=-i*c)}r.writeRangeFromArray(2*a,2*o,d,!0,1),a+=o,n-=o,o=Math.min(n,1e3)}i.notifyModifiedFlags(2001)}function tr(t,e,s){switch(s.getGeometryType()){case r.G.enumLine:return void function(t,e,s){const n=[s.getStartXY(),s.getEndXY()];nr(t,e,n,2),s.setStartXY(n[0]),s.setEndXY(n[1]),s.normalizeAfterEndpointChange()}(t,e,s);case r.G.enumBezier:return void function(t,e,s){const n=(0,h.m)(h.P,4);s.queryControlPoints(n),gr(t,e,n,4),s.setControlPoints(n)}(t,e,s);case r.G.enumEllipticArc:return void function(t,e,s){if(0===s.projectionBehavior())!function(t,e,s){dr(!1,t,e,s,!1)}(t,e,s);else{const n=s.isClosed()&&s.isMajor(),i=[s.getStartXY(),n?s.getCenter():s.getEndXY()],r=[i[0].clone(),i[1].clone()];gr(t,e,r,2);const o=new l.T;o.initializeFromTwoPointsArray(i,r),s.applyTransformation(o);const a=n?0:1;s.setCoordsForIntersector(r[0],r[a],!1)}}(t,e,s);case r.G.enumBezier2:case r.G.enumRationalBezier2:return void(0,r.g)(0);default:(0,r.c)("")}}function er(t,e,s,n){const i=Ro.projToGeogCenter(t,e,s,n);for(let o=0;o<e;++o){const t=o<<1;(0,r.g)(Number.isFinite(s[t]+s[t+1]))}return i}function sr(t,e,s){if(!s.hasNonLinearSegments())return void $i(t,e,s);if(s.isEmpty())return;const n=t.getPECoordSys();Number.isNaN(e)&&(e=0);const i=t.isPannable(),r=t.getOneDegreeGCSUnit(),m=360*r,l=179*r,u=s.createInstance();u.reserveParts(s.getPointCount(),s.getPathCount());const c=s.getImpl(),g=new o.S;for(let o=0,d=s.getPathCount();o<d;++o)if(c.hasNonLinearSegmentsPath(o)){let s=!0,n=-1;const i=c.getPathStart(o),r=i+c.getSegmentCountPath(o);c.isClosedPath(o)&&(n=r-1);const m=new h.P;for(let o=i;o<r;++o){if(c.getSegmentBuffer(o,g,!1),tr(t,e,g.get()),s||g.get().getStartXY().equals(m)||g.get().moveTo(m),o!==n)u.addSegment(g.get(),s);else{if(s){const t=new a.P;g.get().queryStart(t),u.startPathPoint(t)}u.closeLastPathWithSegment(g.get())}m.assign(g.get().getEndXY()),s=!1}}else{const t=1e3;let r,a=c.getPathSize(o),g=Math.min(a,t);u.insertPath(-1,s,o,!0);const d=c.getAttributeStreamRef(0),_=u.getAttributeStreamRef(0);for(let s=c.getPathStart(o),u=c.getPathEnd(o);s<u;){if(r=d.readRange(2*s,2*g),er(n,g,r,e),i)for(let t=0;t<g;t++){const n=t<<1,i=r[n]-e,o=(0,h.e)(i),a=d.read(2*s);o*(0,h.e)(a)<0&&Math.abs(i)>l&&(r[n]+=-o*m)}_.writeRangeFromArray(2*s,2*g,r,!0,1),s+=g,a-=g,g=Math.min(a,t)}}s.assignMove(u)}function nr(t,e,s,n){const i=t.getPECoordSys();Number.isNaN(e)&&(e=0);const r=t.isPannable(),o=t.getOneDegreeGCSUnit(),a=360*o,m=179*o,l=new Float64Array(512);for(let u=0;u<n;){for(let e=u;e<n&&s[e].isNAN();++e)u++;let t=Math.min(256,n-u);if(t>0){for(let e=1,n=u+1;e<t;++e,++n)if(s[n].isNAN()){t=e;break}for(let e=0;e<t;e++){const t=e<<1;l[t]=s[u+e].x,l[t+1]=s[u+e].y}if(er(i,t,l,e),r)for(let n=0,i=u;n<t;++n,++i){const t=n<<1,r=s[i].x,o=l[t]-e,u=(0,h.e)(o);u*(0,h.e)(r)<0&&Math.abs(o)>m&&(l[t]-=u*a)}for(let e=0;e<t;e++){const t=e<<1;s[u+e].x=l[t],s[u+e].y=l[t+1]}u+=t}}}function ir(t,e,s,n){(0,r.g)(0)}function rr(t,e,s){let n=e.getPointCount();if(!n)return!1;const i=e.getImpl(),r=i.getAttributeStreamRef(0);let o=null;const a=t.getInputSR(),m=t.getOutputSR();a.getVCS(),m.getVCS();const l=a.getOneDegreeGCSUnit(),u=m.getOneDegreeGCSUnit(),c=t.isVertical();c&&e.hasAttribute(1)&&(o=i.getAttributeStreamRef(1));const g=t.getDatumTransformation(),d=!!g&&1===g.getType();if(d||null===o||(ir(o.getArray()),o=null),!g||0===g.count()){const t=a.getGcsUnitFactor()/m.getGcsUnitFactor(),e=(a.getPrimeMeridian()-m.getPrimeMeridian())*u,s=-90*l,o=90*l;let c=0;const g=r.getArray(),d=[0];for(let i=1,r=2*n;i<r;)d[0]=g[i],c|=(0,h.ax)(d,s,o)?1:0,g[i]=d[0],i+=2;if(0!==e||1!==t){c=1;const s=r.getArray();for(let i=0,r=2*n;i<r;){let n=s[i];n*=t,n+=e,s[i]=n,s[i+1]*=t,i+=2}}return 0!==c&&i.notifyModifiedFlags(2001),!!c}let _=Math.min(n,1e3);const p=(0,h.d)(_,Number.NaN),f=(0,h.d)(_,Number.NaN);let P=null;null!==o&&(P=new Float64Array(_));let x=0,y=Number.NaN,E=Number.NaN;const C=360*u,S=u/l;s&&(E=90*u,y=89.9*l,f.fill(0));let v=!0,b=0;for(;n;){let t=!1;const e=r.readRange(2*x,2*_);for(let s=0;s<_;s++)p[s]=e[s<<1];if(s)for(let s=0;s<_;s++){const n=1+(s<<1),i=Math.abs(e[n])-y;if(i>0){const r=e[n];e[n]=(0,h.f)(y,r),f[s]=(0,h.f)(i,r),t=!0}}const i=e[0];if(d){const t=g;P&&o.queryRange(x,_,P,!0,1),t.transform(!1,e,P,_),P&&o.writeRangeFromArray(x,_,P,!0,1)}else g.transform(!1,e,_);v&&(b=e[0]-S*i,v=!1);for(let s=0;s<_;s++){const t=s<<1,n=e[t]-p[s]*S-b;Math.abs(n)>200&&(e[t]+=n>0?-C:C)}if(t){for(let t=0;t<_;t++)if(f[t]){const s=1+(t<<1);e[s]+=S*f[t],e[s]>E?e[s]=E:e[s]<-E&&(e[s]=-E)}f.fill(0)}r.writeRangeFromArray(2*x,2*_,e,!0,1),c&&o&&o.writeRangeFromArray(x,_,P,!0,1),x+=_,n-=_,_=Math.min(n,1e3)}return i.notifyModifiedFlags(2001),!0}function or(t,e,s){switch(e.getGeometryType()){case r.G.enumLine:return function(t,e,s){const n=[e.getStartXY(),e.getEndXY()],i=[0,0];let r=null;e.hasAttribute(1)&&(r=i,r[0]=e.getAttributeAsDbl(0,1,0),r[1]=e.getAttributeAsDbl(1,1,0));const o=ur(t,n,r,2,s);return e.setStartXY(n[0]),e.setEndXY(n[1]),r&&(e.setStartAttribute(1,0,r[0]),e.setEndAttribute(1,0,r[1])),e.normalizeAfterEndpointChange(),o}(t,e,s);case r.G.enumBezier:return function(t,e,s){const n=(0,h.m)(h.P,4);e.queryControlPoints(n);const i=[0,0,0,0];let r=null;e.hasAttribute(1)&&(r=i,r[0]=e.getAttributeAsDbl(0,1,0),r[3]=e.getAttributeAsDbl(1,1,0),r[1]=(0,h.q)(r[0],r[3],.5),r[2]=r[1]);const o=ur(t,n,r||null,n.length,s);return e.setControlPoints(n),r&&(e.setStartAttribute(1,0,r[0]),e.setEndAttribute(1,0,r[3])),e.normalizeAfterEndpointChange(),o}(t,e,s);case r.G.enumEllipticArc:return function(t,e,s){if(0===e.projectionBehavior())return function(t,e,s){const n=[e.getStartXY(),e.getEndXY(),e.getInteriorPoint(),e.getCenter()];let i=4;e.isDegenerateToLine()&&(i=2);const r=[0,0,0,0];let o=null;if(e.hasAttribute(1)){o=r,o[0]=e.getAttributeAsDbl(0,1,0),o[1]=e.getAttributeAsDbl(1,1,0);const t=(0,h.q)(o[0],o[1],.5);o[2]=t,o[3]=t}const a=e.getStartXY().equals(e.getEndXY())&&!e.isDegenerateToLine(),m=ur(t,n,o,i,s);return a?e.constructCircleCenterAndPoint(n[3],n[0],!e.isClockwise()):e.isDegenerateToLine()?e.constructLineCircularArc(n[0],n[1]):e.constructCircularArcThreePoint(n[0],n[1],n[2]),o&&(e.setStartAttribute(1,0,o[0]),e.setEndAttribute(1,0,o[1])),m}(t,e,s);const n=e.getStartXY().equals(e.getEndXY()),i=(0,h.m)(h.P,3),r=(0,h.m)(h.P,3),o=[0,0,0];let a=null;i[0].assign(e.getStartXY()),i[1].assign(n?e.getCenter():e.getEndXY());let m=!1;e.hasAttribute(1)&&(a=o,a[0]=e.getAttributeAsDbl(0,1,0),a[1]=e.getAttributeAsDbl(1,1,0),a[2]=(0,h.q)(a[0],a[1],.5),n&&(a[1]=a[2])),r[0].setCoordsPoint2D(i[0]),r[1].setCoordsPoint2D(i[1]);const u=new l.T;if(n||e.isDegenerateToLine())m=ur(t,r,a,2,s),u.initializeFromTwoPoints(i[0],i[1],r[0],r[1]);else{const n=new h.P;e.queryCoord2D(.5,n),i[2].setCoordsPoint2D(n),r[2].setCoordsPoint2D(n),m=ur(t,r,a,3,s),u.setFromTwoTriangles(i,r)}return u.isIdentity()||(e.applyTransformation(u),e.setStartXY(r[0]),e.setEndXY(n?r[0]:r[1]),e.normalizeAfterEndpointChange()),a&&(e.setStartAttribute(1,0,a[0]),e.setEndAttribute(1,0,n?a[0]:a[1])),m}(t,e,s);case r.G.enumBezier2:case r.G.enumRationalBezier2:return(0,r.g)(0),!1;default:(0,r.c)("")}}function ar(t,e,s){if(!e.hasNonLinearSegments())return rr(t,e,s);if(e.isEmpty())return!1;const n=e.createInstance();n.reserveParts(e.getPointCount(),e.getPathCount());const i=e.getImpl(),r=new o.S;for(let o=0,m=e.getPathCount();o<m;++o){let e=!0,m=-1;const l=i.getPathStart(o),u=l+i.getSegmentCountPath(o);i.isClosedPath(o)&&(m=u-1);const c=new h.P;for(let o=l;o<u;++o){if(i.getSegmentBuffer(o,r,!1),or(t,r.get(),s),e||r.get().getStartXY().equals(c)||r.get().moveTo(c),o!==m)n.addSegment(r.get(),e);else{if(e){const t=new a.P;r.get().queryStart(t),n.startPathPoint(t)}n.closeLastPathWithSegment(r.get())}c.assign(r.get().getEndXY()),e=!1}}return e.assignMove(n),!0}function hr(t,e,s,n,i,r){if(t.isIdentityGeogToGeog()){const s=90*t.getInputSR().getOneDegreeGCSUnit();let i=0;const r=[0];for(let t=0;t<n;t++)r[0]=e[t].y,i|=(0,h.ax)(r,-s,s)?1:0,e[t].y=r[0];return i}const o=t.getInputSR(),a=t.getOutputSR(),m=o.getVCS(),l=a.getVCS(),u=o.getOneDegreeGCSUnit(),c=90*u,g=a.getOneDegreeGCSUnit(),d=t.isVertical(),_=t.getDatumTransformation(),p=!!_&&1===_.getType();if(d||(s=null),!_||0===_.count()){let t=0;const i=[0];for(let s=0;s<n;s++)i[0]=e[s].y,t|=(0,h.ax)(i,-c,c)?1:0,e[s].y=i[0];return t|=li(o.getGCS(),m,a.getGCS(),l,e,s,n)?1:0,t}p||null===s||ir();let f=Math.min(n,1024);const P=(0,h.d)(f,Number.NaN),x=(0,h.d)(f,Number.NaN);let y=0,E=Number.NaN,C=Number.NaN;const S=360*g,v=g/u;i&&(C=90*g,E=89.9*u);let b=!0,I=0,w=n;for(;w;){let t=!1;for(let s=0;s<f;s++)P[s]=e[s+y].x;if(i)for(let s=0;s<f;s++){const n=Math.abs(e[s+y].y)-E;if(n>0){const i=e[s+y].y;e[s+y].y=(0,h.f)(E,i),x[s]=(0,h.f)(n,i),t=!0}}const n=e[0].x;p?_.transform(!1,e,s,f):_.transform(!1,e,f),b&&(I=e[0].x-v*n,b=!1);for(let s=0;s<f;s++){const t=e[y+s].x-P[s]*v-I;Math.abs(t)>200&&(t>0?e[y+s].x-=S:e[y+s].x+=S)}if(t){for(let t=0;t<f;t++)x[t]&&(e[y+t].y+=v*x[t],e[y+t].y>C?e[y+t].y=C:e[y+t].y<-C&&(e[y+t].y=-C));x.fill(0,0,f)}y+=f,w-=f,f=Math.min(w,1024)}return 1}function mr(t,e,s,n,i){return(0,r.g)(0),0}function lr(t,e,s,n,i){(0,r.g)(null===n),(0,r.g)(e<2147483647);const o=Array.isArray(s);let a;a=o?(0,h.ay)(s):s;const m=Ho.geogToGeog(t,e,a,null,i);return o&&(0,h.az)(a,s),m}function ur(t,e,s,n,i,r){let o=0,a=!0,h=0;for(let m=0;m<n;++m)e[m].isNAN()?a||(o|=hr(t,e.slice(h,m-h),s?s.slice(h,m-h):null,m-h,i),h=m,a=!0):a&&(h=m,a=!1);return a||(o|=hr(t,0===h?e:e.slice(h),s?0===h?s:s.slice(h):null,n-h,i)),0!==o}function cr(t,e,s,n){Wi(t,e,s,n)}function gr(t,e,s,n){nr(t,e,s,n);const r=new i.Envelope2D;r.setFromPoints(s,n);const o=t.getOneDegreeGCSUnit(),a=360*o,h=180*o;if(r.width()>h){for(let t=0;t<n;t++)for(;s[t].x<e;)s[t].x+=a;if(r.setFromPoints(s,n),r.xmax>h+e)for(let t=0;t<n;t++)s[t].x-=a}}function dr(t,e,s,n,i){const r=(0,h.m)(h.P,3);let o=0,a=!1,m=!1;const l=n.isDegenerateToLine();l?(r[0].assign(n.getStartXY()),r[1].assign(n.getEndXY()),r[2].setCoords(0,0),o=2):n.isClosed()&&n.isMajor()?(a=!0,m=!n.isClockwise(),r[0].assign(n.getStartXY()),r[1].assign(n.getCenter()),r[2].setCoords(0,0),o=2):(r[0].assign(n.getStartXY()),r[1].assign(n.getEndXY()),r[2].assign(n.getInteriorPoint()),o=3),t?cr(e,r,o,i):gr(e,s,r,o),l?n.constructLineCircularArc(r[0],r[1]):a?n.constructCircleCenterAndPoint(r[1],r[0],m):n.constructCircularArcThreePoint(r[0],r[1],r[2])}function _r(t,e,s){const n=(0,o.a3)(t),i=(0,o.a3)(e),r=(0,o.$)(n,i),a=(0,o.$)(n,(0,o.a3)(s));return 0===a||r>0&&a>0&&a<=r||r<0&&a<0&&a>=r}function pr(t,e,s,n,i){const o={stack:[],error:void 0,hasError:!1};try{const a=s.clone(),l=n.clone();if(2===i){const t=[0,0];return V(0,e,a,l,0,t),t[0]}if(a.y>l.y){const t=new h.P;t.assign(a),a.assign(l),l.assign(t)}const u=(0,m.b)(o,new Yo,!1),c=(0,m.b)(o,new Yo,!1),g=(0,m.b)(o,new Yo,!1),d=new h.E;if(d.setCoords(a.y,l.y),!d.containsCoordinate(0)||Math.abs(a.x-l.x)>=Math.PI)return Number.NaN;if(a.x===l.x)return a.x;zo.geodeticDistance(t,e,a.x,a.y,l.x,l.y,c,u,null,i);const _=c.val;let p=0,f=1;const P=a.clone();for(;_*(f-p)>1e-12*t;){const s=.5*(p+f);if(zo.geodeticCoordinate(t,e,a.x,a.y,_*s,u.val,c,g,i),P.x=c.val,P.y=g.val,d.setCoords(a.y,P.y),0===P.y)return P.x;if(d.containsCoordinate(0))f=s;else{if(d.setCoords(l.y,P.y),!d.containsCoordinate(0))return(0,r.g)(!1),Number.NaN;p=s}}return P.x}catch(a){o.error=a,o.hasError=!0}finally{(0,m.c)(o)}}function fr(t,e,s,n){const i=new h.E;i.setCoords(e,s);const r=n.width();let o=Math.floor((t-e)/r)*r+t;const a=i.getCenter();for(;Math.abs(o-a)>Math.abs(o+r-a);)o+=r;return o}class Pr extends g.G{constructor(){super(),this.m_geometryDeque=[],this.m_index=-1}next(){if(this.m_geometryDeque.length>0){this.m_index++;const t=this.m_geometryDeque[0];return this.m_geometryDeque.shift(),t}return null}getGeometryID(){return this.m_index}tick(t){this.m_geometryDeque.push(t)}tock(){return!0}getRank(){return 1}}class xr{constructor(t){this.m_PCSHorizon=null,this.m_GCSHorizon=null,this.m_GCSSplitLines=null,this.m_bGCSHorisonIsInclusive=!1,this.m_oneMeterPCS=0,this.m_oneDegreeGCS=0,this.m_gcsUnitFactor=0,this.m_northPole=h.P.getNAN(),this.m_southPole=h.P.getNAN(),this.m_polesUpdated=0,this.m_domain=i.Envelope2D.constructEmpty(),this.m_primeMeridian=Number.NaN,this.m_geogToProjFactor=1,this.m_geogToProjOffset=0,this.m_geogToProjFactorsUpdated=0,this.m_oneMillimeter=0,this.m_centralMeridian=0,this.m_pPCSInfoNoDomain=null,this.m_oldWKID=-1973,this.m_vcsWKID=-1,this.m_bIsPannable=!1,this.m_bCached=!1,this.m_pannableExtent=i.Envelope2D.constructEmpty(),this.m_pannableExtentGCS=i.Envelope2D.constructEmpty(),this.m_areaOfUse=null,this.m_canonicalWkt="",this.m_peCoordSys=t,this.m_WKID=Xo.getCode(t),this.m_WKID<=0?(this.m_WKID=0,this.m_canonicalWkt=Ii(t,0,!0),this.m_hashCode=(0,h.aw)(this.m_canonicalWkt)):this.m_hashCode=(0,h.A)(this.m_WKID);const e=this.m_peCoordSys.getType();this.m_csType=e===ko.PE_TYPE_PROJCS?2:1,(0,r.g)(e===ko.PE_TYPE_PROJCS||e===ko.PE_TYPE_GEOGCS),e===ko.PE_TYPE_PROJCS&&(t.loadConstants()||(0,r.t)("PeProjcs.loadConstants failed"));const s=e===ko.PE_TYPE_GEOGCS?this.m_peCoordSys:this.m_peCoordSys.getGeogcs();e!==ko.PE_TYPE_GEOGCS&&Xo.getCode(s),this.m_unit=y(t),this.m_primeMeridian=s.getPrimem().getLongitude();{const t=s.getUnit().getUnitFactor();this.m_gcsUnitFactor=t;let e=Math.PI/(180*t);Math.abs(e-1)<1e-10&&(e=1),this.m_oneDegreeGCS=e}if(e===ko.PE_TYPE_PROJCS){const t=this.m_peCoordSys,e=t.getUnit().getUnitFactor();this.m_oneMeterPCS=1/e,this.m_oneMillimeter=.001/e,this.m_pPCSInfoNoDomain=Lo.generate(t,Lo.PE_PCSINFO_OPTION_NONE),this.m_pPCSInfoNoDomain||(0,r.c)("cannot create pcs info"),this.m_bIsPannable=this.m_pPCSInfoNoDomain.isPannableRectangle(),this.m_centralMeridian=this.m_pPCSInfoNoDomain.getCentralMeridian()}else{this.m_bIsPannable=!0,this.m_polesUpdated=1,this.m_oneMeterPCS=0;const t=1/s.getUnit().getUnitFactor(),e=s.getDatum().getSpheroid().getAxis();this.m_oneMillimeter=.001/e*t,this.m_centralMeridian=0}this.m_bIsPannable&&(this.updateGCSHorizon(),this.updatePCSHorizon(),this.updatePoles(),this.updateDomain(),this.updatePannableExtent(),this.updatePannableExtentGCS())}[Symbol.dispose](){}getHashCode(){return this.m_hashCode}getPCSHorizonPannable(){return this.m_PCSHorizon}getGCSHorizonPannable(){return this.m_GCSHorizon}getPCSInfo(){return(0,r.g)(this.m_pPCSInfoNoDomain),this.m_pPCSInfoNoDomain}getCentralMeridian(){return this.m_centralMeridian}updateGCSHorizon(){if(this.m_peCoordSys.getType()!==ko.PE_TYPE_PROJCS)return;let t=!0;const e=this.m_peCoordSys,s=e.getGeogcs(),n=e.horizonGcsGenerate();if(!n)return;(0,r.g)(n.length>0);const m=n[0].getNump(),c=n[0].getKind();let g,d;t=n[0].getInclusive()>0;const _=this.getOneDegreeGCSUnit(),p=90*_,f=360*_,P=370*_,x=180*_*ko.PE_HORIZON_DELTA/Math.PI,y=i.Envelope2D.constructEmpty();let E=null;if(m>1)for(let i=1;i<m;i++)if(n[i].getKind()===ko.PE_HORIZON_LINE){E||(E=new o.P);const t=n[i].getCoord();E.startPathCoords(t[0][0],t[0][1]),E.lineToCoords(t[1][0],t[1][1])}if(c===ko.PE_HORIZON_RECT){const e=n[0].getCoord();if(y.setFromPoints([new h.P(e[0][0],e[0][1]),new h.P(e[1][0],e[1][1])],2),Math.abs(y.ymax-p)<1e-7*x&&(y.ymax=p),Math.abs(y.ymin+p)<1e-7*x&&(y.ymin=-p),y.width()>P){const t=-400*_,e=t+5*f;y.setCoords({xmin:t,ymin:y.ymin,xmax:e,ymax:y.ymax})}const s=new a.E({env2D:y});this.m_GCSHorizon||(this.m_GCSHorizon=s,this.m_bGCSHorisonIsInclusive=t)}else{let e=this.getPCSInfo().isGcsHorizonMultiOverlap();const a=oo(s,null,null,1),c=[],P=new h.E;for(let t=0;t<m;t++){if(n[t].getKind()!==ko.PE_HORIZON_POLY)continue;g=n[t].getSize();const e=n[t].getCoord(),s=i.Envelope2D.constructEmpty();s.setFromPoints((0,h.aB)(e),g),c.push(new h.E(s.xmin,s.xmax)),s.width(),P.merge(c.at(-1))}let x=!1;const y=new h.E;P.width()>f&&c.length>1?(y.vmin=this.getCentralMeridian()-f,y.vmax=y.vmin+2*f,x=!0,e=!0):(y.vmin=P.vmin,y.vmax=y.vmin+f);const C=t=>{let e=0;for(;c[t].vmin+e<y.vmin;)e+=f;for(;c[t].vmax+e-f>y.vmin;)e-=f;return e};let S=new o.a;if(e){const t=new Pr,e=(new Ei).executeMany(t,a,null);for(let s=0;s<m;s++){if(n[s].getKind()!==ko.PE_HORIZON_POLY)continue;g=n[s].getSize();const i=n[s].getCoord();d=n[s].getInclusive()>0;const r=new o.a;if(r.addPathPoint2D((0,h.aB)(i),g-1,!0),x){const e=C(s),n=c[s].clone();n.move(e);let i=e;const o=new l.T;do{o.setShiftCoords(i,0);const e=r.clone();e.applyTransformation(o),t.tick(e),t.tock(),i+=f,n.move(f)}while(n.vmin<y.vmax)}else t.tick(r),e.tock()}S=e.next()}else{S=new o.a;for(let e=0;e<m;e++){if(n[e].getKind()!==ko.PE_HORIZON_POLY)continue;g=n[e].getSize();const s=n[e].getCoord();if(d=n[e].getInclusive()>0,(0,r.g)(d===t),x){const t=new o.a;t.addPathPoint2D((0,h.aB)(s),g-1,!0);const n=C(e),i=c[e].clone();i.move(n);let r=n;const a=new l.T;do{if(0!==r){a.setShiftCoords(r,0);const e=new o.a({copy:t});e.applyTransformation(a),S.addPath(e,0,!0)}else S.addPath(t,0,!0);r+=f,i.move(f)}while(i.vmin<y.vmax)}else S.addPathPoint2D((0,h.aB)(s),g-1,!0)}}x&&(S=(new u.O).execute(S,new i.Envelope2D(y.vmin,-p-_,y.vmax,p+_),a,null)),t?(new dn).accelerateGeometry(S,a,1):(new xi).accelerateGeometry(S,a,1),(new vi).accelerateGeometry(S,a,1),null===this.m_GCSHorizon&&(this.m_GCSHorizon=S,this.m_bGCSHorisonIsInclusive=t,this.m_GCSSplitLines=E)}}updateAreaOfUse(){return null}updatePCSHorizon(){if(this.m_peCoordSys.getType()!==ko.PE_TYPE_PROJCS)return;const t=this.m_peCoordSys.horizonPcsGenerate();if(!t)return;let e;this.getPCSInfo();const s=t[0].getKind();t[0].getInclusive();const n=i.Envelope2D.constructEmpty(),m=t[0].getNump();let l=!1;if(s===ko.PE_HORIZON_RECT){const s=t[0].getCoord();n.setFromPoints((0,h.aB)(s),2),e=new a.E({env2D:n})}else{let s=-1;for(let e=0;e<m;e++)t[e].getKind()===ko.PE_HORIZON_POLY&&(s=e);(0,r.g)(s>=0);const n=t[s].getSize()-1,i=t[s].getCoord(),a=new o.a;e=a,a.addPathPoint2D((0,h.aB)(i),n,!0),l=!0}if(this.getPCSInfo().isDensificationNeeded()){(0,r.g)(s!==ko.PE_HORIZON_RECT);const t=1e5*this.getOneMeterPCSUnit();e=(new c.O).execute(e,t,0,0,null)}if(l){{const t=new a.E;e.queryEnvelope(t),e.calculateArea2D(),e.calculateLength2D(),e.getExteriorRingCount()}(new dn).accelerateGeometry(e,null,1)}null===this.m_PCSHorizon&&(this.m_PCSHorizon=e)}updatePannableExtent(){const t=this.m_peCoordSys.getType();if(t===ko.PE_TYPE_PROJCS){const t=this.m_peCoordSys,e=this.getPCSInfo().getCentralMeridian(),s=t.getGeogcs();s||(0,r.c)("");const n=[e+1/s.getUnit().getUnitFactor()*Math.PI,0];Ro.geogToProj(t,1,n);const o=n[0],a=t.getParameters()[ko.PE_PARM_X0].getValue(),h=this.getPCSHorizon(),m=i.Envelope2D.constructEmpty();h.queryEnvelope(m);const l=Math.abs(o-a),u=l+a,c=-1*l+a,g=m.ymax,d=m.ymin;this.m_pannableExtent.setCoords({xmin:c,ymin:d,xmax:u,ymax:g})}else if(t===ko.PE_TYPE_GEOGCS){const t=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtent.setCoords({xmin:-t,ymin:-t/2,xmax:t,ymax:t/2})}else(0,r.c)("")}updatePannableExtentGCS(){const t=this.m_peCoordSys.getType();if(t===ko.PE_TYPE_PROJCS){const t=this.m_peCoordSys,e=this.m_centralMeridian,s=t.getGeogcs();s||(0,r.c)("");const n=1/s.getUnit().getUnitFactor()*Math.PI,o=this.getGCSHorizon(),a=i.Envelope2D.constructEmpty();o.queryEnvelope(a),this.m_pannableExtentGCS.setCoords({xmin:e-n,ymin:a.ymin,xmax:e+n,ymax:a.ymax})}else if(t===ko.PE_TYPE_GEOGCS){const t=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtentGCS.setCoords({xmin:-t,ymin:-t/2,xmax:t,ymax:t/2})}else(0,r.c)("")}updateDomain(){if(1===this.m_csType){const t=400*this.getOneDegreeGCSUnit();this.m_domain=i.Envelope2D.construct(-t,-t,t,t)}else{(0,r.g)(2===this.m_csType);const t=Lo.generate(this.m_peCoordSys,Lo.PE_PCSINFO_OPTION_DOMAIN);t||(0,r.c)("generate pcs info failed");const e=new i.Envelope2D(t.getDomainMinx(),t.getDomainMiny(),t.getDomainMaxx(),t.getDomainMaxy());this.m_domain.isEmpty()&&this.m_domain.setCoords({env2D:e})}}updatePoles(){if(this.m_peCoordSys.getType()===ko.PE_TYPE_PROJCS){const t=90*this.getOneDegreeGCSUnit(),e=[[0,t],[0,-t]];Ro.geogToProj(this.m_peCoordSys,2,e);const s=this.getPCSInfo().getNorthPoleLocation()!==Lo.PE_POLE_OUTSIDE_BOUNDARY,n=this.getPCSInfo().getSouthPoleLocation()!==Lo.PE_POLE_OUTSIDE_BOUNDARY;this.m_polesUpdated||(s&&this.m_northPole.setCoords(e[0][0],e[0][1]),n&&this.m_southPole.setCoords(e[1][0],e[1][1]),this.m_polesUpdated=1)}else this.m_polesUpdated=1}updateGeogToProjFactors(){if(this.m_peCoordSys.getType()===ko.PE_TYPE_PROJCS){const t=this.getOneDegreeGCSUnit(),e=this.m_pPCSInfoNoDomain.getCentralMeridian(),s=[0,0,0,0];s[0]=e,s[1]=0,s[2]=e+t,s[3]=0;const n=Ro.geogToProj(this.m_peCoordSys,2,s);(0,r.g)(2===n);const i=(s[2]-s[0])/t,o=s[0];0===this.m_geogToProjFactorsUpdated&&(this.m_geogToProjFactor=i,this.m_geogToProjOffset=o,this.m_geogToProjFactorsUpdated=1)}else this.m_geogToProjFactorsUpdated=1}getOneMeterPCSUnit(){return this.m_oneMeterPCS}getOneDegreeGCSUnit(){return this.m_oneDegreeGCS}getGcsUnitFactor(){return this.m_gcsUnitFactor}getUnitsPerMillimeter(){return this.m_oneMillimeter}getGCSSplitLines(){return this.m_bIsPannable?null:(this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSSplitLines)}getGCSHorizon(){return this.m_bIsPannable?this.getGCSHorizonPannable():(null!==this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSHorizon)}getGCSHorisonIsInclusive(){return this.m_bIsPannable||this.getGCSHorizon(),this.m_bGCSHorisonIsInclusive}getPCSHorizon(){return this.m_bIsPannable?this.getPCSHorizonPannable():(null!==this.m_PCSHorizon||this.updatePCSHorizon(),this.m_PCSHorizon)}getPole(t){return this.m_bIsPannable||0!==this.m_polesUpdated||this.updatePoles(),t?this.m_southPole:this.m_northPole}getGeogToProjFactors(){return 0===this.m_geogToProjFactorsUpdated&&this.updateGeogToProjFactors(),(0,h.n)(this.m_geogToProjFactor,this.m_geogToProjOffset)}getDomainXY(){if(this.m_bIsPannable)return this.m_domain.clone();let t=!1;return t=this.m_domain.isEmpty(),t&&this.updateDomain(),this.m_domain.clone()}getPrimeMeridian(){return this.m_primeMeridian}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;if(t<0){if(t=0,this.m_WKID>0){const e=[0],s=[0];(function(t,e,s,n){return e<=0?(s[0]=0,n[0]=0,!1):(s[0]=e,n[0]=e,!0)})(this.m_peCoordSys.getType(),this.m_WKID,e,s)||(0,r.c)("query_code_change"),t=e[0]}this.m_oldWKID=t}return t}isCustomWkid(){return!1}isPannable(){return this.m_bIsPannable}getPannableExtent(){return this.m_pannableExtent.clone()}getPannableExtentGCS(){return this.m_pannableExtentGCS.clone()}getAreaOfUse(){return null!==this.m_areaOfUse?this.m_areaOfUse:this.updateAreaOfUse()}getVcsCode(){return 0}saveMemory(){}getCSType(){return this.m_csType}getUnit(){return this.m_unit}setCached(){this.m_bCached=!0}getCached(){return this.m_bCached}static equal(t,e){return!1}static equal_for_projection(t,e){return!1}}class yr{constructor(t){this.m_oneMeter=0,this.m_WKID=-1,this.m_oldWKID=-1,this.m_canonicalWkt="not yet implemented",this.m_model=0,this.m_unit=new zr,this.m_cached=!1}setCached(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.m_cached=t}getCached(){return this.m_cached}getOneMeterUnit(){return 0}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;return t<0&&(t=0,this.m_WKID>0&&(t=this.m_WKID),this.m_oldWKID=t),t}getModel(){return 0}isCustomWkid(){return!1}getVerticalUnit(){return this.m_unit}static equal(t,e){return!1}static equal_for_projection(t,e){return!1}}function Er(t,e,s,n){return function(t,e,s,n,o){return eo()||(0,r.r)("cannot create projection transformation"),e.hasVCS()&&s.hasVCS()?function(){return(0,r.g)(0),{}}():function(t,e,s,n){t&&e||(0,r.t)("!inputSR || !outputSR");const o=t.getLatestID(),a=e.getLatestID();if(3857===o&&4326===a){if(t.m_bDefaultDescriptor&&e.m_bDefaultDescriptor)return Rr()}else if(4326===o&&3857===a&&t.m_bDefaultDescriptor&&e.m_bDefaultDescriptor)return Xr||(Xr=Rr().getInverse()),Xr;const h=i.Envelope2D.constructEmpty();h.setCoords({env2D:s});const m=t.getCoordinateSystemType(),l=e.getCoordinateSystemType();if(0===m||0===l)return Ir(t,e);if(n){const s=n.find(0,t.getGCS(),e.getGCS());if(s)return Ir(t,e,s)}const u=t.getGCS().getLatestID(),c=e.getGCS().getLatestID();if(u>0&&u===c)return Ir(t,e);const g=new qr(t,e,s);{const t=function(t){if(Vr.has(t.getHashCode()))return Vr.get(t.getHashCode())}(g);if(t)return t}const d=vr(0,t,e,h,1,!0);return function(t,e){return Vr.set(t.getHashCode(),e),e}(g,Ir(t,e,d.length?d[0]:void 0))}(e,s,n,o)}(0,t,e,s,n)}function Cr(t,e,s,n){return Sr(!0,t,e,s,n)}function Sr(t,e,s,n,i,o){return eo()||(0,r.r)("cannot create projection transformation"),new Nr(t?2:1,e,s,n,i,o)}function vr(t,e,s,n,i){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e&&s||(0,r.t)(""),eo()||(0,r.r)("cannot obtain geotransformation list"),1===t&&e.hasVCS()&&s.hasVCS())return(0,r.b)("hv xform not impl"),[];{const t=na(e,s,n,i,o),r=[];for(const e of t)r.push(e);return r}}function br(){return{centralMeridianOfOutputGCS:Number.NaN,densificationStep:Number.NaN,clipWithInputHorizon:!0,clipWithOutputHorizon:!0,legacyHorizonClipping:!1,normalizeResultGeometry:!1,equals(t){return(0,h.a3)(this.centralMeridianOfOutputGCS,t.centralMeridianOfOutputGCS)&&(0,h.a3)(this.densificationStep,t.densificationStep)&&this.clipWithInputHorizon===t.clipWithInputHorizon&&this.clipWithOutputHorizon===t.clipWithOutputHorizon&&this.legacyHorizonClipping===t.legacyHorizonClipping&&this.normalizeResultGeometry===t.normalizeResultGeometry}}}function Ir(t,e,s,n,i){return new Nr(1,t,e,s,n,i)}function wr(){return{flagsMask:0,setFlag(t,e){e?this.flagsMask|=t:this.flagsMask&=~t},hasFlag(t){return!!(this.flagsMask&t)}}}function Dr(){return{m_extendedParams:br(),m_extendedParamsInternal:wr()}}function Tr(){return Dr()}let Nr=class t{constructor(t,e,s,n,i,o){let a,h;this.m_datumTran=null,this.m_bIdentity=!0,this.m_bIdentityGeogToGeog=!0,this.m_bVertical=!1,this.m_bNormalize=!1,e&&s||(0,r.t)("!inputSR || !outputSR"),n&&0===n.getType()&&(n.m_bReadOnly=!0),this.m_bNormalize=!1,1!==t&&(a=e.getVCS(),h=s.getVCS(),this.m_bVertical=null!=a&&null!=h),this.m_inputSR=e,this.m_outputSR=s,this.m_bIdentity=!1,this.m_bIdentityGeogToGeog=!1,(0,r.g)(!this.m_params),i&&(this.m_params=Dr(),this.m_params.m_extendedParams=i),o&&(this.m_params||(this.m_params=Dr()),this.m_params.m_extendedParamsInternal=o);let m=!1;const l=null!=n,u=e.getCoordinateSystemType(),c=s.getCoordinateSystemType();if(s.isPannable()&&0!==u&&i){const t=i.centralMeridianOfOutputGCS;if(!Number.isNaN(t)&&s.isPannable()){const e=s.getPannableExtent(),n=e.getCenterX();if(n!==t){const s=Math.ceil(e.width());t+s!==n+s&&(m=!0)}}}const g=i&&i.normalizeResultGeometry;if(e.equals(s))return this.m_bIdentity=!m,this.m_bIdentityGeogToGeog=!0,void this.updateProjector();const d=!l&&e.equalForProjection(s,this.m_bVertical);this.m_bIdentity=d&&!m,this.m_bIdentity?this.m_bIdentityGeogToGeog=!0:0!==u&&0!==c&&(g&&this.m_outputSR.isPannable()&&(this.m_bNormalize=g),this.m_datumTran=n||null,this.m_bIdentityGeogToGeog=(!this.m_datumTran||0===this.m_datumTran.count())&&this.m_inputSR.getGCS().equalForProjection(this.m_outputSR.getGCS(),this.m_bVertical)),this.updateProjector()}getInputSR(){return this.m_inputSR}getOutputSR(){return this.m_outputSR}getDatumTransformation(){return this.m_datumTran}getInverse(){var e;const s=new t(1,this.m_outputSR,this.m_inputSR,null===(e=this.m_datumTran)||void 0===e?void 0:e.createInverse());return s.m_bIdentity=this.m_bIdentity,s.m_bVertical=this.m_bVertical,s.m_bIdentityGeogToGeog=this.m_bIdentityGeogToGeog,s.updateProjector(),s}isIdentity(){return this.m_bIdentity}getExtendedParams(){return this.m_params?this.m_params.m_extendedParams:Tr().m_extendedParams}equals(t){return(0,r.g)(0),!1}isVertical(){return this.m_bVertical}isMatchingTransformation(t,e){return(0,r.g)(0),!1}getGeographicTransformations(){return this.m_datumTran}getExtendedParamsImpl(){return this.m_params?this.m_params.m_extendedParams:Tr().m_extendedParams}getExtendedParamsInternal(){return this.m_params?this.m_params.m_extendedParamsInternal:Tr().m_extendedParamsInternal}isIdentityGeogToGeog(){return this.m_bIdentityGeogToGeog}normalizeOutput(){return this.m_bNormalize}updateProjector(){this.m_projector=new yn(this)}};const Ar=new Map,Gr=new Map,Mr=new Map;function Fr(t){let e=t.getCode();if(e>0){return Ur(e)||Br(Xo.coordsys(e))}const s=t.getName();if(Gr.has(s)){const e=Gr.get(s);if(e&&e.deref()){const s=e.deref();if(s.m_peCoordSys.isEqual(t))return s}}return e=Xo.getCode(t),Br(e>0?Xo.coordsys(e):t)}class qr{constructor(t,e,s){this.m_hashCode=-1,t&&(this.m_inputSR=t,this.m_outputSR=e,this.m_env=s.clone(),this.m_hashCode=this.m_inputSR.getHashCode(),this.m_hashCode=(0,h.aq)(this.m_hashCode,this.m_outputSR.getHashCode()),this.m_env.isEmpty()||(this.m_hashCode=(0,h.aq)(this.m_hashCode,(0,h.at)(this.m_env.xmin)),this.m_hashCode=(0,h.aq)(this.m_hashCode,(0,h.at)(this.m_env.xmax)),this.m_hashCode=(0,h.aq)(this.m_hashCode,(0,h.at)(this.m_env.ymin)),this.m_hashCode=(0,h.aq)(this.m_hashCode,(0,h.at)(this.m_env.ymax))))}getHashCode(){return this.m_hashCode}equals(t){return!(this.m_inputSR&&!t.m_inputSR||!this.m_inputSR&&t.m_inputSR)&&this.m_env.equals(t.m_env)&&this.m_inputSR.equals(t.m_inputSR)&&this.m_outputSR.equals(t.m_outputSR)}clear(){this.m_inputSR=void 0,this.m_outputSR=void 0,this.m_hashCode=-1,this.m_env=void 0}}const Vr=new Map;let Yr,Xr,kr;function Rr(){return Yr||(Yr=Cr(bo(),wo())),Yr}const Hr=new Map;function Lr(t){if(Hr.has(t))return Hr.get(t);{const e=function(t){return null!==jo(Xo.coordsys(t)).get()}(t);return Hr.set(t,e),e}}function Br(t){const e=jo(t),s=t.getCode();if(s>0){const t=Ur(s);if(t)return t}const n=t.getName();let i=Gr.get(n);if(i){const e=i.deref();if(e&&e.m_peCoordSys.isEqual(t))return e}const r=new xr(e.release());if(s>0)return r.setCached(),Ar.set(s,new WeakRef(r)),Gr.set(n,new WeakRef(r)),r;const o=Ii(t,0,!1);if(i=Mr.get(o),i){const t=i.deref();if(t)return t}return r.setCached(),Mr.set(o,new WeakRef(r)),r}function Ur(t){const e=Ar.get(t);if(e)return e.deref()}class zr extends _{constructor(t){return void 0===t?(super(),this.m_wkid=9001,void(this.m_peUnit=null)):"number"==typeof t?(super(),this.m_factor=t,void(this.m_wkid=0)):(super(t),void(t||(this.m_factor=1,this.m_wkid=9001,this.m_peUnit=(kr||(kr=Xo.unit(9001)),kr))))}getUnitType(){return 0}convertFromMeters(t){return t/this.getUnitToBaseFactor()}convertToMeters(t){return t*this.getUnitToBaseFactor()}}const Or=["0","1","2","3","4","5","6","7","8","9","b","c","d","e","f","g","h","j","k","m","n","p","q","r","s","t","u","v","w","x","y","z"];function Wr(t,e,s,n,i){(0,r.g)(n>>5<i.length);let o=e,a=s;for(let r=n;r>=0;r-=2){const e=31&r,s=.5*(a+o);t>=s?(i[r>>5]|=1<<e,o=s):a=s}}let jr=new Set;const Zr=2147483645n,Qr=9007199254740990n,Kr="operation is not supported for unknown coordinate systems";var Jr;function $r(){return{majorSemiAxis:0,e2:0,minorSemiAxis:0,flattening:0,isSphere(){return 0===this.e2}}}function to(t){!function(t){Zo=t,(0,r.g)(Zo)}(t)}function eo(){return!!Xo}function so(){return!!Zo}function no(){return!!Xo||!!Zo}function io(t,e,s){return(0,r.g)(no()),Go(t,void 0===e?0:e,null,!1)}function ro(t,e){(0,r.g)(no());const s=new So;let n;return eo()?(n=function(t){const e=jo(Xo.fromString(ko.PE_TYPE_COORDSYS,t));return e.get()||(0,r.z)(t),Fr(e.release())}(t),s.setHorzProj_(n),s.m_vertcs=null,s.m_userWKID=n.getLatestID()):(n=Qo(t),s.m_unit=n.isPCS?new zr(n.metersOrRadiansPerUnit):new P(n.metersOrRadiansPerUnit)),To(s.m_precisionDescriptor,n,null,1),s.m_bDefaultDescriptor=!0,s.m_userWKT=t,s.calculateHashCode(),s.initDbgName(),s}function oo(t,e,s,n){let i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=null;return e&&((0,r.g)(0),o={}),function(t,e,s,n,i){t||(0,r.t)("!PE_coord_sys");const o=new So;let a;return a=i?Fr(t):new xr(t,!1),To(o.m_precisionDescriptor,a,e,n),o.m_bDefaultDescriptor=!0,o.setHorzProj_(a),o.m_vertcs=e,o.m_userWKID=a.getLatestID(),o.calculateHashCode(),o.initDbgName(),o}(t,o,0,n,i)}function ao(t,e){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];3===t.getCoordinateSystemType()&&(0,r.t)("image spatial reference cannot be altered");const n=new So,i=t;return n.m_peCoordSysVal=i.m_peCoordSysVal,n.m_vertcs=i.m_vertcs,n.m_unit=i.m_unit,n.m_precisionDescriptor.assign(e),n.m_localZToXYFactor=i.m_localZToXYFactor,(Number.isNaN(n.m_precisionDescriptor.m_falseX)||Number.isNaN(n.m_precisionDescriptor.m_falseY))&&(n.m_precisionDescriptor.m_falseX=i.m_precisionDescriptor.m_falseX,n.m_precisionDescriptor.m_falseY=i.m_precisionDescriptor.m_falseY),n.m_precisionDescriptor.snapPrecision(),n.m_precisionDescriptor.fixTolerance(),n.m_userWKID=i.m_userWKID,n.m_precisionDescriptor.equals(i.m_precisionDescriptor)?n.m_bDefaultDescriptor=i.m_bDefaultDescriptor:n.m_bDefaultDescriptor=!1,s&&(n.m_bDefaultDescriptor=!0),n.calculateHashCode(),n.initDbgName(),n}function ho(t,e,s){return{}}function mo(t,e,s){void 0===e&&(e=1),(e<=0||!Number.isFinite(e))&&(0,r.t)(""),t||1===e||(0,r.t)("null Unit has to have z_to_xy_factor equal to 1");const n=new So;n.m_unit=t;const i=t||new zr(9001);return Ao(n.m_precisionDescriptor,i,null,1),n.m_bDefaultDescriptor=!0,Number.isNaN(n.m_precisionDescriptor.m_falseX)&&(0,r.t)("NAN false X/Y are not allowed here"),n.m_localZToXYFactor=e,n.calculateHashCode(),n.initDbgName(),n}function lo(t,e){return t.snapGeometry(e)}function uo(t){const e=t.getCoordinateSystemType();return 1===e?t:(3===e&&(0,r.g)(0),t.getGCS())}function co(t){return(0,r.g)(no()),so()?function(t){return(0,r.g)(so()),!!Zo(t).isPCS||function(t){return Xo&&(0,r.m)("pe has been loaded. no-pe methods should not be used at this point."),Fo||Jo(),Fo.has(t)}(t)}(t):Lr(t)}function go(t){if(eo())return null!==jo(Xo.fromString(ko.PE_TYPE_COORDSYS,t)).get();try{return Qo(t),!0}catch(e){}return!1}let _o;function po(){return _o||(_o=(()=>{const t=Math.trunc(Math.random()*(0,h.i)()),e=Date.now();return"|abba_000|".concat(t.toString(16),"|").concat(e.toString(16),"|")})()),_o}!function(t){t[t.utmDefault=0]="utmDefault",t[t.utmNorthSouth=1]="utmNorthSouth"}(Jr||(Jr={}));let fo=0;function Po(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",e="".concat(po()).concat(fo++);return""!==t&&(e+="|".concat(t)),e}function xo(t){return t.startsWith(po())}let yo,Eo,Co,So=class t{destroy(){(function(t){Gr.delete(t.m_peCoordSys.getName()),Mr.delete(Ii(t.m_peCoordSys,0,!1))})(this.m_peCoordSysVal),1===this.getCoordinateSystemType()||2===this.getCoordinateSystemType()?this.getPECoordSys().destroy():(0,r.c)("SpatialReference.destroy")}constructor(){this.m_vertcs=null,this.m_peCoordSysVal=null,this.m_userWKID=0,this.m_userWKT=null,this.m_geogSpatialReference=null,this.m_srToGcs=null,this.m_gcsToSr=null,this.m_defaultPrecisionSR=null,this.m_localZToXYFactor=-1,this.m_precisionDescriptor=new vo,this.m_hashCode=0,this.m_bDefaultDescriptor=!1,Do(this.m_precisionDescriptor),jr&&jr.add(new WeakRef(this))}attachToPe(){(this.m_userWKID>0?io(this.m_userWKID):ro(this.m_userWKT)).copyTo(this,!1)}copyTo(t){(!(arguments.length>1&&void 0!==arguments[1])||arguments[1]||t.m_bDefaultDescriptor)&&(t.m_bDefaultDescriptor=this.m_bDefaultDescriptor,t.m_precisionDescriptor.assign(this.m_precisionDescriptor)),t.m_defaultPrecisionSR=null,t.m_gcsToSr=this.m_gcsToSr,t.m_geogSpatialReference=this.m_geogSpatialReference,t.m_hashCode=this.m_hashCode,t.m_localZToXYFactor=this.m_localZToXYFactor,t.m_peCoordSysVal=this.m_peCoordSysVal,t.m_srToGcs=this.m_srToGcs,t.m_userWKID=this.m_userWKID,t.m_userWKT=this.m_userWKT,t.m_vertcs=this.m_vertcs,t.m_unit=this.m_unit}getHashCode(){return this.m_hashCode}getHashCodeHorizontal(){let t=0;return t=this.m_peCoordSysVal?this.m_peCoordSysVal.getHashCode():this.m_unit?this.m_unit.getHashCode():305419891,t}updateTransform(t){if(1===this.getCoordinateSystemType())return Cr(this,this,null);let e=t?this.m_srToGcs:this.m_gcsToSr;if(e)return e;const s=this.getGCS();e=t?Cr(this,s,null):Cr(s,this,null);const n=e;return(t?this.m_srToGcs:this.m_gcsToSr)||(t?this.m_srToGcs=n:this.m_gcsToSr=n,e)}getHashCodeVertical(){return this.m_vertcs?this.m_vertcs.getHashCode():0}calculateHashCode(){let t=this.getHashCodeHorizontal();const e=this.getHashCodeVertical(),s=this.m_precisionDescriptor.getHashCode();t=(0,h.aq)(t,e),this.m_hashCode=(0,h.aq)(t,s)}initDbgName(){}setHorzProj_(t){this.m_peCoordSysVal=t,this.m_unit=this.m_peCoordSysVal.getUnit()}getTolerance(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.m_precisionDescriptor.getTolerance(t)}getResolution(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.m_precisionDescriptor.getResolution(t)}getPECoordSys(){return this.m_peCoordSysVal?this.m_peCoordSysVal.m_peCoordSys:null}getPCSInfo(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSInfo()}getCentralMeridian(){return this.throwIfNotGCSOrPCS(),1===this.getCoordinateSystemType()?0:this.getPCSInfo().getCentralMeridian()}getCoordinateSystemType(){const t=this.getPECoordSys();if(t)switch(t.getType()){case ko.PE_TYPE_GEOGCS:return 1;case ko.PE_TYPE_PROJCS:return 2;default:return 0}else{if((this.m_userWKID>0||this.m_userWKT)&&this.m_unit instanceof zr)return 2;if(this.m_unit instanceof P)return 1}return 0}getID(){return this.m_userWKID}getLatestID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getLatestID():this.m_userWKID}getOldID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getOldID():this.m_userWKID}getVerticalID(){return(0,r.b)("vcs not implemented"),0}getLatestVerticalID(){return this.m_vertcs?this.m_vertcs.getLatestID():0}getOldVerticalID(){return(0,r.b)("vcs not implemented"),0}getPEVerticalCoordSys(){return null}getPole(t){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPole(t)}getText(){var t;const e=this.getPECoordSys();return e?wi(e):null!==(t=this.m_userWKT)&&void 0!==t?t:""}getTextExtended(t){var e;const s=this.getPECoordSys();return s?this.getPEVerticalCoordSys()?(this.getPEVerticalCoordSys(),(0,r.g)(0),""):wi(s,t):null!==(e=this.m_userWKT)&&void 0!==e?e:""}getText2(){var t;let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;const s=this.getPECoordSys();return s?function(t,e){(e>1||e<-1)&&(0,r.t)("verbosity");let s=ko.PE_STR_FMT_WKT2;return-1!==e&&(s|=0===e?ko.PE_STR_AUTH_TOP:ko.PE_STR_AUTH_ALL),t.toString(s)}(s,e):null!==(t=this.m_userWKT)&&void 0!==t?t:""}getUnit(){return this.m_unit}getUnitsPerMillimeter(){var t;return this.m_peCoordSysVal?this.m_peCoordSysVal.getUnitsPerMillimeter():this.m_unit instanceof zr?.001/this.m_unit.getUnitToBaseFactor():this.m_unit instanceof P?.001/(Qo(null!==(t=this.m_userWKT)&&void 0!==t?t:this.m_userWKID).semiMajor*this.m_unit.getUnitToBaseFactor()):((0,r.m)("sr object not in valid state"),0)}getAuthorityName(){return this.getPECoordSys()?((0,r.g)(0),""):""}getVerticalUnit(){return(0,r.b)("vcs not implemented"),{}}getVCS(){return this.m_vertcs}hasVCS(){return!1}getGCSHorisonIsInclusive(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorisonIsInclusive()}getGCSHorizon(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorizon()}getGCS(){const t=this.getCoordinateSystemType();if(0===t)(0,r.m)(Kr);else{if(1===t)return this;3===t&&(0,r.m)("image cs not supported")}if(this.m_geogSpatialReference)return this.m_geogSpatialReference;let e;if(this===bo()||this===Io())e=wo();else{(0,r.g)(this.m_peCoordSysVal);const t=this.m_peCoordSysVal.m_peCoordSys.getGeogcs();t||(0,r.c)(""),e=oo(t,this.m_vertcs,null,this.m_precisionDescriptor.getPrecision(),this.m_peCoordSysVal.getCached())}return this.m_geogSpatialReference?e=this.m_geogSpatialReference:this.m_geogSpatialReference=e,e}getGCSSplitLines(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSSplitLines()}toGCS(t,e){if(0===t.length)return 0;t.length>e.length&&(0,r.t)("coordsSrc.size() > coordsDst.size()");const s=this.getCoordinateSystemType();if(0===s&&(0,r.m)(Kr),1===s)return(0,h.au)(e,t,t.length),t.length;(0,r.g)(this.m_peCoordSysVal);const n=this.getSRToGCSTransform();return(new Sn).transform(n,t,t.length,e)}toGeohash(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8;const s=t.clone();s.scale(9102===this.getGCS().getUnit().getID()?1:this.getGCS().getUnit().getUnitToBaseFactor()/Math.PI*180),s.x<-180?(s.x=(0,h.o)(s.x,360),s.x<-180&&(s.x+=360)):s.x>180&&(s.x=(0,h.o)(s.x,360),s.x>180&&(s.x-=360)),s.y>90&&(s.y=90),s.y<-90&&(s.y=-90);const n=5*e,i=new Uint32Array(4);return Wr(s.x,-180,180,n-1,i),Wr(s.y,-90,90,n-2,i),function(t,e,s){const n=(0,h.d)(e,"R");let i=0,r=0;for(let o=0;o<e;o++){let s=t[i]>>r&31;if(r+=5,r>31){const e=37-r;s&=(1<<e)-1,r-=32,i++,s|=(t[i]&(1<<r)-1)<<e}const a=Or[s];n[e-1-o]=a}return s>e?n.push(..."0".repeat(s-e)):s<e&&(n.length=s),n.join("")}(i,e,e)}isPannable(){const t=this.getCoordinateSystemType();return 0!==t&&3!==t&&((0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.isPannable())}getPannableExtent(){return this.isPannable()||(0,r.t)("!is_pannable"),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtent()}getPannableExtentInGCS(){return this.isPannable()||(0,r.t)("!is_pannable"),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtentGCS()}throwIfNotGCSOrPCS(){const t=this.getCoordinateSystemType();1!==t&&2!==t&&(0,r.t)("Not a GCS or PCS")}getDomainXY(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getDomainXY()}getFullWorldExtent(){return this.throwIfNotGCSOrPCS(),this.isPannable()?this.getPannableExtent():this.getDomainXY()}queryPrecisionDescriptor(t){if(t.assign(this.m_precisionDescriptor),Number.isNaN(t.m_falseX))if(eo()||(0,r.r)("cannot query precision descriptor"),(0,r.g)(null!==this.m_peCoordSysVal),2!==this.m_precisionDescriptor.m_precision){const e=this.m_peCoordSysVal.getDomainXY();t.m_falseX=e.xmin,t.m_falseY=e.ymin}else t.m_falseX=-Number.MAX_VALUE,t.m_falseY=-Number.MAX_VALUE}queryPrecisionDescriptorWithoutFalseXY(t){t.assign(this.m_precisionDescriptor),t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}queryDefaultPrecisionDescriptorWithoutFalseXY(t){if(this.m_bDefaultDescriptor)t.assign(this.m_precisionDescriptor);else{const e=this.getCoordinateSystemType();0===e?Ao(t,this.m_unit,this.m_vertcs,this.m_precisionDescriptor.getPrecision()):3===e?(0,r.b)("image cs"):To(t,this.m_peCoordSysVal,this.m_vertcs,this.m_precisionDescriptor.getPrecision())}t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}horizontalEqual(t){return function(t,e){return t===e||null!==t&&null!==e&&t.m_csType===e.m_csType&&(0===t.m_WKID&&0===e.m_WKID?t.m_hashCode===e.m_hashCode&&t.m_canonicalWkt===e.m_canonicalWkt:t.m_WKID===e.m_WKID)}(this.m_peCoordSysVal,t.m_peCoordSysVal)}verticalEqual(t){return null!==this.m_vertcs==(null!==t.m_vertcs)&&(!this.m_vertcs||this.m_vertcs.equals(t.m_vertcs))}equals(t){const e=t;if(this===e)return!0;if(!this.horizontalEqual(e)||!this.verticalEqual(e))return!1;if(!e.m_peCoordSysVal){if((0,r.g)(!this.m_peCoordSysVal),null!==this.m_unit!=(null!==e.m_unit))return!1;if(this.m_unit&&!this.m_unit.equals(e.m_unit))return!1;if(this.m_localZToXYFactor!==e.m_localZToXYFactor)return!1}if(!this.m_bDefaultDescriptor||!e.m_bDefaultDescriptor){if(this.m_peCoordSysVal){if(!this.m_precisionDescriptor.equalsWithoutFalseXY(e.m_precisionDescriptor))return!1;(0,r.g)(e.m_peCoordSysVal);let t=this.m_precisionDescriptor.m_falseX,s=this.m_precisionDescriptor.m_falseY;if(Number.isNaN(t)){const e=this.m_peCoordSysVal.getDomainXY();t=e.xmin,s=e.ymin}let n=e.m_precisionDescriptor.m_falseX,i=e.m_precisionDescriptor.m_falseY;if(Number.isNaN(n)){const t=e.m_peCoordSysVal.getDomainXY();n=t.xmin,i=t.ymin}return t===n&&s===i}return this.m_precisionDescriptor.equals(e.m_precisionDescriptor)}return!0}equalForProjection(t,e){if(this===t)return!0;const s=this.getCoordinateSystemType(),n=t.getCoordinateSystemType();if(0===s||0===n)return 0===s&&0===n?(!e||this.getZToXYFactor()===t.getZToXYFactor())&&(!this.getUnit()||!t.getUnit()||this.getUnit().equals(t.getUnit())):3!==s&&3!==n&&(null===this.getUnit()||null===t.getUnit()||(!e||this.getZToXYFactor()===t.getZToXYFactor())&&this.getUnit().equals(t.getUnit()));if(s!==n)return!1;if(3===s)return this.equals(t);if(function(t,e){return t===e||null!==t&&null!==e&&t.m_csType===e.m_csType&&(0===t.m_WKID&&0===e.m_WKID?1===t.m_csType?t.m_peCoordSys.isEqual(e.m_peCoordSys):t.m_peCoordSys===e.m_peCoordSys:t.m_WKID===e.m_WKID)}(this.m_peCoordSysVal,t.m_peCoordSysVal)){if(!e)return!0;if(null!==this.m_vertcs==(null!==t.m_vertcs))return!this.m_vertcs||this.m_vertcs.equalForProjection(t.m_vertcs)}return!1}equalHorizontal(t){return this.horizontalEqual(t)}equalVertical(t){return(0,r.g)(0),!1}equalVerticalVCS(t){return(0,r.g)(0),!1}convergenceAngle(t){return(0,r.g)(0),0}getPeCoordsysCopy(){if(this.m_peCoordSysVal){const t=this.m_peCoordSysVal.m_peCoordSys;return t||(0,r.c)("cannot clone coord sys"),t}return null}getPeVertcsCopy(){return(0,r.g)(0),0}throwIfLocal(){0===this.getCoordinateSystemType()&&(0,r.t)(Kr)}getPrimeMeridian(){return this.throwIfLocal(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPrimeMeridian()}getSRToGCSTransform(){return this.updateTransform(!0)}getGCSToSRTransform(){return this.updateTransform(!1)}getOneMeter(){return 1e3*this.getUnitsPerMillimeter()}getOneMeterPCSUnit(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneMeterPCSUnit()}getDefaultPrecisionSR(){if(this.m_bDefaultDescriptor)return this;if(null===this.m_defaultPrecisionSR){const t=new vo;this.queryDefaultPrecisionDescriptorWithoutFalseXY(t),this.m_defaultPrecisionSR=ao(this,t,!0)}return this.m_defaultPrecisionSR}getPCSHorizon(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSHorizon()}getHorzUnitFactor(){return this.m_unit?this.m_unit.getUnitToBaseFactor():1}querySpheroidData(t){this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal);const e=this.getGCS().getPECoordSys().getDatum().getSpheroid(),s=e.getFlattening();!function(t,e,s){t.majorSemiAxis=e,t.minorSemiAxis=e*(1-s),t.e2=s*(2-s),t.flattening=s}(t,e.getAxis(),s)}getAreaOfUse(){0===this.getCoordinateSystemType()&&(0,r.m)(""),(0,r.g)(this.m_peCoordSysVal);const t=this.m_peCoordSysVal.getAreaOfUse();return null===t?new d:new d({geom:t.clone(),sr:io(4326)})}getZToXYFactor(){return 1}isCustomWkid(){return!1}getOneDegreeGCSUnit(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneDegreeGCSUnit()}getGcsUnitFactor(){return this.throwIfNotGCSOrPCS(),(0,r.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getGcsUnitFactor()}snapGeometry(t){if(t.isEmpty())return!1;if(2===this.m_precisionDescriptor.getPrecision())return!1;const e=t.getGeometryType();if((0,r.i)(e))return this.snapMultiVertex_(t);if(e===r.G.enumPoint)return this.snapPoint_(t);if(e===r.G.enumEnvelope)return this.snapEnvelope_(t);if((0,r.f)(e))return this.snapSegment_(t);if(e===r.G.enumGeometryCollection){const e=t;let s=!1;for(let t=0,n=e.getGeometryCount();t<n;++t)s=this.snapGeometry(e.getGeometry(t))||s;return s}(0,r.c)("what else?")}snapMultiVertex_(t){if((0,r.g)(!t.isEmpty()),(0,r.g)(2!==this.m_precisionDescriptor.getPrecision()),(0,r.h)(t.getGeometryType())){const e=t;if(e.hasNonLinearSegments())return this.snapGeometryWithCurves_(e)}const e=t.getImpl(),s=e.getDescription();let n=!1;for(let i=0,r=s.getAttributeCount();i<r;i++){const t=s.getSemantics(i),r=e.getAttributeStreamRef(t);n=this.snapAttributes(t,r,0,e.getPointCount())||n}return n&&e.notifyModifiedFlags(2001),n}snapPoint_(t){return!1}snapEnvelope_(t){return!1}snapSegment_(t){(0,r.g)(!t.isEmpty()),(0,r.g)(2!==this.m_precisionDescriptor.getPrecision());const e=new vo;this.queryPrecisionDescriptor(e);const s=t.getStartXY(),n=new h.P;n.x=Mo(s.x,e.getFalseX(),e.getGridUnitsXY()),n.y=Mo(s.y,e.getFalseY(),e.getGridUnitsXY());let i=!n.equals(s);const o=t.getEndXY(),a=new h.P;a.x=Mo(o.x,e.getFalseX(),e.getGridUnitsXY()),a.y=Mo(o.y,e.getFalseY(),e.getGridUnitsXY()),i||(i=!a.equals(o)),i&&t.changeEndPoints2D(n,a);const m=(e,s,n)=>{let i=!1;{const r=t.getStartAttributeAsDbl(e,0),o=Mo(r,s,n),a=!(0,h.a3)(o,r);i||(i=a),a&&t.setStartAttribute(e,0,o)}{const r=t.getEndAttributeAsDbl(e,0),o=Mo(r,s,n),a=!(0,h.a3)(o,r);i||(i=a),a&&t.setEndAttribute(e,0,o)}return i};let l=i?1:0;return t.hasAttribute(1)&&(l|=m(1,e.getFalseZ(),e.getGridUnitsZ())?1:0),t.hasAttribute(2)&&(l|=m(2,e.getFalseM(),e.getGridUnitsM())?1:0),!!l}snapGeometryWithCurves_(t){(0,r.g)(!t.isEmpty()),(0,r.g)(2!==this.m_precisionDescriptor.getPrecision());const e=t.createInstance(),s=new o.S;let n=0;for(let i=0,r=t.getPathCount();i<r;++i){const r=t.getSegmentCountPath(i);if(0===r){if(e.addPath(t,i,!0),1===e.getPathSize(i)){const t=new a.P;e.getPointByVal(e.getPointCount()-1,t),n|=this.snapGeometry(t)?1:0,e.setPointByVal(e.getPointCount()-1,t)}continue}const o=t.isClosedPath(i);for(let a=0,h=o?r-1:r;a<h;++a)t.getSegmentFromPath(i,a,s,!1),n|=this.snapGeometry(s.get())?1:0,e.addSegment(s.get(),0===a);o&&(t.getSegmentFromPath(i,r-1,s,!1),n|=this.snapGeometry(s.get())?1:0,1===r?e.addPathFromClosedSegment(s.get(),!1):e.closeLastPathWithSegment(s.get()))}return n&&e.copyTo(t),!!n}snapAttributes(e,s,n,i){let r=!1;const o=new vo;if(this.queryPrecisionDescriptor(o),0===e){const e=s;for(let s=n;s<i;s++){const n=e.read(2*s),i=t.s_SnapValue(n,o.getFalseX(),o.getGridUnitsXY()),a=e.read(2*s+1),h=t.s_SnapValue(a,o.getFalseY(),o.getGridUnitsXY());r=r||i!==n||h!==a,r&&(e.write(2*s,i),e.write(2*s+1,h))}}else if(1===e){const e=s;for(let s=n;s<i;s++){const n=e.read(s),i=t.s_SnapValue(n,o.getFalseZ(),o.getGridUnitsZ());r=r||!(0,h.a3)(i,n),r&&e.write(s,i)}}else if(2===e){const e=s;for(let s=n;s<i;s++){const n=e.read(s),i=t.s_SnapValue(n,o.getFalseM(),o.getGridUnitsM());r=r||!(0,h.a3)(i,n),r&&e.write(s,i)}}return r}static s_SnapValue(t,e,s){return(0,h.av)((t-e)*s)/s+e}};class vo{constructor(){const t=Qr,e=1e-4,s=.001,n=e*Number(t)*.5;this.m_precision=1,this.m_falseX=-n,this.m_falseY=-n,this.m_unitsXY=Number(t)/(2*n),this.m_falseM=-1e5,this.m_unitsM=1/e,this.m_falseZ=-1e5,this.m_unitsZ=1/e,this.m_toleranceXY=s,this.m_toleranceM=s,this.m_toleranceZ=s}getHashCode(){let t=7777,e=7777;return e=(0,h.aq)(e,this.m_falseM),e=(0,h.aq)(e,this.m_unitsM),t=(0,h.aq)(t,this.m_unitsXY),e=(0,h.aq)(e,this.m_toleranceXY),t=(0,h.aq)(t,this.m_falseZ),e=(0,h.aq)(e,this.m_toleranceZ),t=(0,h.aq)(t,this.m_unitsZ),e=(0,h.aq)(e,this.m_toleranceM),t=(0,h.aq)(t,this.m_precision),(0,h.aq)(t,e)}clone(){const t=new vo;return t.m_falseX=this.m_falseX,t.m_falseY=this.m_falseY,t.m_unitsXY=this.m_unitsXY,t.m_falseZ=this.m_falseZ,t.m_unitsZ=this.m_unitsZ,t.m_falseM=this.m_falseM,t.m_unitsM=this.m_unitsM,t.m_toleranceXY=this.m_toleranceXY,t.m_toleranceZ=this.m_toleranceZ,t.m_toleranceM=this.m_toleranceM,t.m_precision=this.m_precision,t}assign(t){return this.m_falseX=t.m_falseX,this.m_falseY=t.m_falseY,this.m_unitsXY=t.m_unitsXY,this.m_falseZ=t.m_falseZ,this.m_unitsZ=t.m_unitsZ,this.m_falseM=t.m_falseM,this.m_unitsM=t.m_unitsM,this.m_toleranceXY=t.m_toleranceXY,this.m_toleranceZ=t.m_toleranceZ,this.m_toleranceM=t.m_toleranceM,this.m_precision=t.m_precision,this}initialize2D(t,e){}getTolerance(t){switch(t){case 0:return this.m_toleranceXY;case 1:return this.m_toleranceZ;case 2:return this.m_toleranceM;default:return 0}}getResolution(t){if(2===this.m_precision)return 0;switch(t){case 0:return 1/this.m_unitsXY;case 1:return 1/this.m_unitsZ;case 2:return 1/this.m_unitsM;default:return 0}}getFalseX(){return this.m_falseX}getFalseY(){return this.m_falseY}getFalseZ(){return this.m_falseZ}getFalseM(){return this.m_falseM}getGridUnitsXY(){return this.m_unitsXY}getGridUnitsZ(){return this.m_unitsZ}getGridUnitsM(){return this.m_unitsM}getPrecision(){return this.m_precision}static getLimit32(){return 2147483645}static getLimit64(){return 9007199254740990n}static getLimitFloat(){return 0}getXYGridRange(){const t=new i.Envelope2D;switch(this.m_precision){case 0:{const e=vo.getLimit32()/this.getGridUnitsXY();t.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+e,ymax:this.getFalseY()+e})}break;case 1:{const e=Number(vo.getLimit64())/this.getGridUnitsXY();t.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+e,ymax:this.getFalseY()+e})}break;case 2:t.setCoords({xmin:-Number.MAX_VALUE,ymin:-Number.MAX_VALUE,xmax:Number.MAX_VALUE,ymax:Number.MAX_VALUE});break;default:t.setEmpty(),(0,r.c)("")}return t}getZGridRange(){const t=new h.E;switch(this.m_precision){case 0:{const e=vo.getLimit32()/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+e)}break;case 1:{const e=Number(vo.getLimit64())/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+e)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),(0,r.c)("")}return t}getMGridRange(){const t=new h.E;switch(this.m_precision){case 0:{const e=vo.getLimit32()/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+e)}break;case 1:{const e=Number(vo.getLimit64())/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+e)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),(0,r.c)("")}return t}setTolerance(t,e){switch(e<0&&(0,r.t)("tol < 0"),Number.isFinite(e)||(0,r.t)("tol is not finite"),t){case 0:this.m_toleranceXY=e;break;case 1:this.m_toleranceZ=e;break;case 2:this.m_toleranceM=e;break;default:(0,r.t)("cannot set tolerance for this attribute")}}setGridParams(t,e,s){Number.isFinite(t)&&Number.isFinite(e)&&Number.isFinite(s)||(0,r.t)("grid params are not finite"),s<1&&(0,r.t)("grid units cannot be smaller than 1.0"),this.m_falseX=t,this.m_falseY=e,this.m_unitsXY=s}setZParams(t,e){Number.isFinite(t)&&Number.isFinite(e)||(0,r.t)("grid params are not finite"),e<1&&(0,r.t)("grid units cannot be smaller than 1.0"),this.m_falseZ=t,this.m_unitsZ=e}setMParams(t,e){Number.isFinite(t)&&Number.isFinite(e)||(0,r.t)("grid params are not finite"),e<1&&(0,r.t)("grid units cannot be smaller than 1.0"),this.m_falseM=t,this.m_unitsM=e}setPrecision(t){}equals(t){return this===t||(0,h.a3)(this.m_falseX,t.m_falseX)&&(0,h.a3)(this.m_falseY,t.m_falseY)&&this.equalsWithoutFalseXY(t)}snapPrecision(){if(2===this.m_precision)return;const t=(t,e,s,n)=>{if(!Number.isFinite(e)||!Number.isFinite(s))return s;if(s<1)return 1;if(!n)return s;const i=Number(t)/s;return Math.trunc((e+i-e)*s)>t&&(s=t/(e+i-e)),Math.max(1,s)},e=Number(0===this.m_precision?Zr:Qr);this.m_unitsXY=t(e,this.m_falseX,this.m_unitsXY,!0),this.m_unitsXY=t(e,this.m_falseY,this.m_unitsXY,!0),this.m_unitsZ=t(e,this.m_falseZ,this.m_unitsZ,!1),this.m_unitsM=t(e,this.m_falseM,this.m_unitsM,!1)}verifyPrecision(){if(2===this.m_precision)return!0;const t=(t,e,s,n)=>{if(s<1)return!1;if(!Number.isFinite(e)||!Number.isFinite(s))return!1;if(!n)return!0;const i=Number(t)/s;return!(BigInt((e+i-e)*s)>t)},e=0===this.m_precision?Zr:Qr;return!!t(e,this.m_falseX,this.m_unitsXY,!0)&&!!t(e,this.m_falseY,this.m_unitsXY,!0)&&!!t(e,this.m_falseZ,this.m_unitsZ,!1)&&!!t(e,this.m_falseM,this.m_unitsM,!1)}fixTolerance(){2!==this.m_precision&&(this.m_toleranceXY=Math.max(2/this.m_unitsXY,this.m_toleranceXY),this.m_toleranceZ=Math.max(2/this.m_unitsZ,this.m_toleranceZ),this.m_toleranceM=Math.max(2/this.m_unitsM,this.m_toleranceM),(Number.isNaN(this.m_falseX)||Number.isNaN(this.m_falseY))&&(this.m_falseX=this.m_falseY=Number.NaN))}equalsWithoutFalseXY(t){return this===t||this.m_unitsXY===t.m_unitsXY&&this.m_falseZ===t.m_falseZ&&this.m_unitsZ===t.m_unitsZ&&this.m_falseM===t.m_falseM&&this.m_unitsM===t.m_unitsM&&this.m_toleranceXY===t.m_toleranceXY&&this.m_toleranceZ===t.m_toleranceZ&&this.m_toleranceM===t.m_toleranceM&&this.m_precision===t.m_precision}setBestXyDomainFromEnvelope(t,e){}setBestZDomainFromZRange(t,e,s){}setBestMDomainFromMRange(t,e,s){}}function bo(){return(!yo||eo()&&null===yo.getPECoordSys())&&(yo=Go(3857,0,null,!0)),yo}function Io(){return(!Eo||eo()&&null===Eo.getPECoordSys())&&(Eo=Go(102100,0,null,!0)),Eo}function wo(){return(!Co||eo()&&null===Co.getPECoordSys())&&(Co=Go(4326,0,null,!0)),Co}function Do(t){t.m_falseX=0,t.m_falseY=0,t.m_unitsXY=1,t.m_falseZ=0,t.m_unitsZ=1,t.m_falseM=0,t.m_unitsM=1,t.m_toleranceXY=100*(0,h.N)(),t.m_toleranceZ=100*(0,h.N)(),t.m_toleranceM=100*(0,h.N)(),t.m_precision=2}function To(t,e,s,n){const i=e instanceof xr;Do(t),t.m_precision=n,t.m_falseX=Number.NaN,t.m_falseY=Number.NaN;const o=1e-4,a=.001,h=i?e.m_csType:e.isPCS?2:1;if(1===h){const s=(0===n?1/18e5:1e-9)*(i?e.getOneDegreeGCSUnit():Math.PI/e.metersOrRadiansPerUnit/180);t.m_unitsXY=1/s}else if(2===h){const s=(0===n?a:o)*(i?e.getOneMeterPCSUnit():1/e.metersOrRadiansPerUnit);t.m_unitsXY=1/s}else(0,r.t)("unrecognized cs type");t.m_falseM=-1e5,t.m_unitsM=1/(0===n?a:o),t.m_unitsM=Math.max(1,t.m_unitsM),t.m_unitsXY=Math.max(1,t.m_unitsXY);let m=0,l=0;0!==n&&1!==n||(m=2/t.m_unitsXY,l=2/t.m_unitsM),t.m_toleranceXY=Math.max(m,i?e.getUnitsPerMillimeter():2===h?.001/e.metersOrRadiansPerUnit:.001/(e.semiMajor*e.metersOrRadiansPerUnit)),t.m_toleranceM=Math.max(a,l),No(t,s)}function No(t,e){const s=1e-4,n=.001;if(t.m_falseZ=-1e5,e){const i=(0===t.m_precision?n:s)*e.getOneMeter();t.m_unitsZ=1/i}else t.m_unitsZ=1/(0===t.m_precision?n:s);t.m_unitsZ=Math.max(1,t.m_unitsZ);let i=0;0!==t.m_precision&&1!==t.m_precision||(i=2/t.m_unitsZ),t.m_toleranceZ=Math.max(e?e.getOneMeter()*n:n,i)}function Ao(t,e,s,n){Do(t),t.m_precision=n;const i=0===n?Zr:Qr,r=1e-4,o=.001;let a=1,h=1,m=.001;e&&(h=e.getUnitToBaseFactor()),e&&1===e.getUnitType()?(a=400*Math.PI/180,m=8.983152841195215e-9*Math.PI/180/h):(a=(0===n?o:r)*Number(i)*.5,m=o/h),a/=h,t.m_falseX=-a,t.m_falseY=-a,t.m_unitsXY=Number(i)/(2*a),t.m_falseM=-1e5,t.m_unitsM=1/(0===n?o:r),t.m_unitsM=Math.max(1,t.m_unitsM),t.snapPrecision();let l=0,u=0;0!==t.m_precision&&1!==t.m_precision||(u=2/t.m_unitsM,l=2/t.m_unitsXY),t.m_toleranceXY=Math.max(l,m),t.m_toleranceM=Math.max(o,u),No(t,s)}function Go(t,e,s,n){if(!n&&e<=0){if(3857===t)return bo();if(102100===t)return Io();if(4326===t)return wo()}const i=new So;let o,a=null;return eo()?(o=function(t){t<=0&&(0,r.y)(t);{const e=Ur(t);if(e)return e}const e=jo(Xo.coordsys(t));e.get()||(0,r.y)(t);const s=Br(e.release());return s.getLatestID()!==t&&Ar.set(t,new WeakRef(s)),s}(t),e>0?a=null:e=0,i.setHorzProj_(o),i.m_vertcs=a):(o=Qo(t),i.m_unit=o.isPCS?new zr(o.metersOrRadiansPerUnit):new P(o.metersOrRadiansPerUnit)),To(i.m_precisionDescriptor,o,a,1),i.m_bDefaultDescriptor=!0,i.m_userWKID=t,i.calculateHashCode(),i.initDbgName(),i}function Mo(t,e,s){return(0,h.av)((t-e)*s)/s+e}let Fo=null;const qo=3552713678800501e-30;function Vo(t,e){return function(t,e,s){return t===e||Math.abs(t-e)<=s*(1+(Math.abs(t)+Math.abs(e))/2)}(t,e,qo)}let Yo,Xo,ko,Ro,Ho,Lo,Bo,Uo,zo,Oo,Wo;function jo(t){return{_this:t,get(){return this._this},reset(t){this._this=t},release(){const t=this._this;return this._this=null,t}}}let Zo=null;function Qo(t){(0,r.g)(Zo);const e=Zo(t);return e.semiMajor=e.isPCS?Number.NaN:function(t){if(Xo&&(0,r.m)("pe has been loaded. no-pe methods should not be used at this point."),"string"==typeof t){const e=t.match(Ko);e&&2===e.length||(0,r.t)("bad gcs wkt");const s=Number.parseFloat(e[1]);return Number.isFinite(s)||(0,r.t)("bad gcs wkt"),s}return Fo||Jo(),Fo.has(t)||(0,r.m)("gcs wkid not found"),Fo.get(t)}(t),e}const Ko=/(?:ELLIPSOID|SPHEROID)\["(?:\w|[-()])+",(\d+\.\d+)/;function Jo(){Fo=new Map;for(const t in f){const e=Number.parseFloat(t),s=f[t];if(Array.isArray(s))for(const t of s)Fo.set(t,e);else Fo.set(s,e)}!function(){for(const t in f)delete f[t]}()}function $o(t,e){return new sa(t,e)}const ta=(0,h.ar)(0),ea=(0,h.ar)(1);let sa=class t{constructor(e,s){if(e instanceof t)return this.m_geogTranWrapper=e.m_geogTranWrapper,this.m_bInverted=s?!e.m_bInverted:e.m_bInverted,void(this.m_hashCode=(0,h.aq)(this.m_geogTranWrapper.getHashCode(),this.m_bInverted?ea:ta));this.m_geogTranWrapper=new mi(e),this.m_bInverted=s,this.m_hashCode=(0,h.aq)(this.m_geogTranWrapper.getHashCode(),this.m_bInverted?ea:ta)}getID(){return this.m_geogTranWrapper.getLatestId()}getLatestID(){return this.m_geogTranWrapper.getLatestId()}getText(){return this.m_geogTranWrapper.getText()}getTextExtended(t){if(!this.m_geogTranWrapper.getGeogtran())return"";if(-1===t)return this.m_geogTranWrapper.getGeogtran().toString();{const e=0===t?ko.PE_STR_AUTH_TOP:ko.PE_STR_AUTH_ALL;return this.m_geogTranWrapper.getGeogtran().toString(e)}}getText2(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,e=ko.PE_STR_FMT_WKT2;return-1!==t&&(e|=0===t?ko.PE_STR_AUTH_TOP:ko.PE_STR_AUTH_ALL),this.m_geogTranWrapper.getGeogtran().toString(e)}getName(){return this.m_geogTranWrapper&&this.m_geogTranWrapper.getGeogtran()?this.m_geogTranWrapper.getGeogtran().getName():""}getInputSpatialReference(){return this.m_bInverted?this.m_geogTranWrapper.getOutputSr(!1):this.m_geogTranWrapper.getInputSr(!1)}getOutputSpatialReference(){return this.m_bInverted?this.m_geogTranWrapper.getInputSr(!1):this.m_geogTranWrapper.getOutputSr(!1)}getInverse(){return new t(this,!0)}isInverted(){return this.m_bInverted}getHashCode(){return this.m_hashCode}GetPeGeogtran(){return this.m_geogTranWrapper.getGeogtran()}equals(t){const e=t;return e===this||this.m_bInverted===e.m_bInverted&&(this.GetPeGeogtran()===e.GetPeGeogtran()||this.getID()===e.getID()&&!(0===this.getID()&&!this.GetPeGeogtran().isEqual(e.GetPeGeogtran())))}referencesMissingData(){return!!this.m_geogTranWrapper&&!this.m_geogTranWrapper.isUsable()}getWrapper(){return this.m_geogTranWrapper}};function na(t,e,s,n,i){const o=t.getGCS(),m=e.getGCS(),l=o.getPECoordSys(),u=m.getPECoordSys();let c=null;if(!s.isEmpty()){const e=s.clone();if(!e.isEmpty()&&2===t.getCoordinateSystemType()){let s=new a.E({env2D:e});const n=Cr(t,o,null);s=(new Sn).execute(s,n,null),s.queryEnvelope(e)}if(!e.isEmpty()){const t=l.getPrimem().getLongitude(),s=l.getUnit().getUnitFactor();c=new Wo(e.xmin,e.ymin,e.xmax,e.ymax,t,s)}}let g=n;g>=(0,h.i)()&&(g=0);const d=[];let _=Bo.PE_GTLIST_OPTS_COMMON;i||(_&=~Bo.PE_GTLIST_OPTS_USABLE);for(let a=0;a<2;a++){d.length=0;const t=g,e=Bo.getGTlist(l,u,2,_,c,t);let s=!1;if(e&&e.length>0)for(let o=0,a=e.length;o<a;o++){const t=ia([e[o]]);if((0,r.g)(t),i&&t.referencesMissingData())s=!0;else if(d.push(t),n>0&&d.length===n)break}if(!s)break;0===g||(g=0)}return c&&c.destroy(),d}function ia(t){(0,r.g)(null!==t);const e=new oa,s=t[0].getSteps();if(s){const n=t[0].getEntries();for(let t=0;t<s;t++){const s=0!==n[t].getDirection(),i=$o(n[t].getGeogtran(),s);e.add(i)}return e.create()}return null}let ra=class{constructor(t,e,s,n){this.m_bReadOnly=!0,this.m_name="",this.m_fastTrack=-1,this.m_bNameIsSet=!1,this.m_transforms=t,e&&(this.m_name=e,this.m_bNameIsSet=!0),this.m_inputSr=s,this.m_outputSr=n}getType(){return 0}getName(){if(this.m_bNameIsSet)return this.m_name;if(0===this.m_transforms.length)return"";let t="";for(const e of this.m_transforms)t.length>0&&(t+=" + "),e.isInverted()&&(t+="~"),t+=e.getName();return t}count(){return this.m_transforms.length}createInverse(){return this.getInverse()}getHashCode(){let t=1973;for(let e=0;e<this.m_transforms.length;e++)t=(0,h.aq)(t,this.m_transforms[e].getHashCode());return t}equals(t){return(0,r.g)(0),!1}referencesMissingData(){if(0===this.m_transforms.length)return!1;for(const t of this.m_transforms)if(t.referencesMissingData())return!0;return!1}isMatchingTransformation(t,e){return(0,r.g)(0),!1}validateTransformation(t,e){return(0,r.g)(0),!1}nameIsSet(){return(0,r.g)(0),!1}getInputSpatialReference(){return this.m_inputSr}getOutputSpatialReference(){return this.m_outputSr}getStep(t){return(t<0||t>this.count())&&(0,r.n)(""),this.m_transforms[t]}getInverse(){const t=new oa;return t.addSteps(this,!0),t.setInputSpatialReference(this.m_outputSr),t.setOutputSpatialReference(this.m_inputSr),t.create()}transform(t,e,s){if(0===this.count())return;let n=this.m_inputSr,i=this.m_outputSr;if(t&&(i=(0,h.b)(n,n=i)),0===this.m_transforms.length)return void li(n,null,i,null,e,null,s);let r=this.m_fastTrack;if(1===r)return void(0,o.I)(t,this.m_transforms,(n=>{!function(t,e,s,n,i){const r=t.getVerttran(),o=t.getGeogtran();if(i>0){t.prepareOrThrow();const a=e?ko.PE_TRANSFORM_2_TO_1:ko.PE_TRANSFORM_1_TO_2;r?mr():lr(o,i,s,n,a)}}(n.getWrapper(),t!==n.isInverted(),e,null,s)}));const a=hi();-1===r&&a.initFromGcsAndVcs(n,null);const m=hi();let l=t?this.m_transforms.length-1:0;const u=t?-1:1;for(let o=0,h=this.m_transforms.length;o<h;o++,l+=u){if(0===o){const i=this.m_transforms[l];ui(n.getPECoordSys(),null,i.getWrapper(),t!==i.isInverted(),e,null,s,m),-1===r&&(a.equals(m)||(r=0)),a.assign(m)}else{const n=this.m_transforms[l-u],i=this.m_transforms[l];ci(a,n.getWrapper(),t!==n.isInverted(),i.getWrapper(),t!==i.isInverted(),e,null,s,m),-1===r&&(a.equals(m)||(r=0)),a.assign(m)}const i=this.m_transforms[l];gi(a,i.getWrapper(),t!==i.isInverted(),e,null,s,m),a.assign(m)}const c=this.m_transforms[l-u];(function(t,e,s,n,i,r,o,a){const h=hi();h.assign(s?e.m_inputUnitParams:e.m_outputUnitParams),h.processUnitParams(t);let m=null;n&&(m=n.getPECoordSys());const l=hi();l.initFromGcsAndVcsPe(m,null),l.processUnitParams(h),h.processUnitParams(l),a>0&&ai(h,l,r,o,a)})(a,c.getWrapper(),t!==c.isInverted(),i,0,e,null,s),-1===r&&(m.initFromGcsAndVcs(i,null),a.equals(m)||(r=0)),this.m_fastTrack=0===r?0:1}};class oa{constructor(){this.m_transforms=[],this.m_inputGCS=null,this.m_outputGCS=null,this.m_name="",this.m_bNameIsSet=!1}getInputSpatialReference(){return null!==this.m_inputGCS?this.m_inputGCS:this.count()>0?this.m_transforms[0].getInputSpatialReference():null}setInputSpatialReference(t){this.m_inputGCS=t?t.getGCS():null}getOutputSpatialReference(){return null!==this.m_outputGCS?this.m_outputGCS:this.count()>0?this.m_transforms.at(-1).getOutputSpatialReference():null}setOutputSpatialReference(t){this.m_outputGCS=t?t.getGCS():null}getName(){if(this.m_bNameIsSet)return this.m_name;if(0===this.m_transforms.length)return"";let t="";for(const e of this.m_transforms)t.length>0&&(t+=" + "),e.isInverted()&&(t+="~"),t+=e.getName();return t}count(){return this.m_transforms.length}getStep(t){return(t<0||t>this.count())&&(0,r.n)(""),this.m_transforms[t]}setStep(t,e){(0,r.g)(0)}add(t){this.m_transforms.push(t)}addSteps(t,e){if(e)for(let s=t.count()-1;s>=0;--s)this.add(t.getStep(s).getInverse());else for(let s=0;s<t.count();++s)this.add(t.getStep(s))}clear(){this.m_transforms=[],this.m_name="",this.m_bNameIsSet=!1,this.m_inputGCS=null,this.m_outputGCS=null}remove(t){(0,r.g)(0)}create(){const t=this.getInputSpatialReference(),e=this.getOutputSpatialReference(),s=new ra(this.m_transforms,this.m_bNameIsSet?this.m_name:null,t,e);return s.m_bReadOnly=!0,this.clear(),s}}const aa=Object.freeze(Object.defineProperty({__proto__:null,SpatialReference:So,SpatialReferencePrecisionDescriptor:vo,create:io,createFromWKT:ro,createImplFromPe:oo,createLocal:mo,createWithNewPrecision:ao,createWithNewVCS:ho,getGCS:uo,getTempName:Po,hasNoPe:so,hasPe:eo,injectNoPe:to,injectPe:function(t){if(Xo)return;!function(t){const e=t;Xo=e.PeFactory,(0,r.g)(Xo),Wo=e.PeGCSExtent,(0,r.g)(Wo),zo=e.PeLineType,(0,r.g)(zo),Oo=e.PeMath,(0,r.g)(Oo),Yo=e.PeDouble,(0,r.g)(Yo),ko=e.PeDefs,(0,r.g)(ko),Ro=e.PeCSTransformations,(0,r.g)(Ro),Ho=e.PeGTTransformations,(0,r.g)(Ho),Lo=e.PePCSInfo,(0,r.g)(Lo),Bo=e.PeGTlistExtended,(0,r.g)(Bo),Xo.initialize(),Uo=e.PeGTlistExtendedEntry,(0,r.g)(Uo),ko.PE_TYPE_ANGUNIT=512,ko.PE_STR_AUTH_ALL=2,Lo.PE_POLE_LINE_STRAIGHT=2,Lo.PE_POLE_LINE_CURVED=3,ko.PE_PARM_LAM0=2,ko.PE_PARM_PHI0=6,ko.PE_PRJ_AZIMUTHAL_EQUIDISTANT=43032,ko.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA=43033,ko.PE_PRJ_ALBERS=43007,ko.PE_PRJ_CYLINDRICAL_EQAREA=43034,ko.PE_TYPE_VERTCS=8,ko.PE_LINETYPE_GEODESIC=0,ko.PE_LINETYPE_LOXODROME=1,ko.PE_LINETYPE_GREAT_ELLIPTIC=2,ko.PE_LINETYPE_NORMAL_SECTION=3,Bo.PE_GTLIST_OPTS_USABLE=1,Zo=null}(t);const e=jr;jr=null,e.forEach((t=>{const e=t.deref();e&&e.attachToPe()}))},isInitialized:no,isTempName:xo,isValidWkid:co,isValidWkt:go,makeSpheroidData:$r,snapGeometry:lo,webMercator:bo,webMercator102100:Io,wgs84:wo},Symbol.toStringTag,{value:"Module"})),ha=Object.freeze(Object.defineProperty({__proto__:null,OperatorProject:Sn},Symbol.toStringTag,{value:"Module"})),ma=Object.freeze(Object.defineProperty({__proto__:null,CompositeGeographicTransformation:ra,CompositeGeographicTransformationEditor:oa,createImpl:ia,queryGtListImpl:na},Symbol.toStringTag,{value:"Module"})),la=Object.freeze(Object.defineProperty({__proto__:null,GeographicTransformation:sa,create:function(t,e){const s=Xo.geogtran(t);return s||(0,r.y)(t),new sa(s,e)},createFromPe:$o,createFromWKT:function(t,e){const s=Xo.fromString(ko.PE_TYPE_GEOGTRAN,t);return s||(0,r.z)(t),new sa(s,e)}},Symbol.toStringTag,{value:"Module"})),ua=Object.freeze(Object.defineProperty({__proto__:null,ProjectionTransformation:Nr,create:function(t,e,s){return Er(t,e,i.Envelope2D.constructEmpty(),s)},createEx:Cr,createFromAoi:Er,createImplEx:Sr,makeExtendedParams:br,makeExtendedParamsInternal:wr,queryTransformationList:vr},Symbol.toStringTag,{value:"Module"}))},88689:(t,e,s)=>{s.d(e,{O:()=>g,a:()=>u,c:()=>m});var n=s(68707),i=s(97799),r=s(91523),o=s(21557),a=s(79186),h=s(26871);function m(t,e,s,n,i){return l(t,e,null,s,n,i)}function l(t,e,s,n,a,h){const l=t.getGeometryType();if(l===i.G.enumPoint){const s=t.getXY();return e.contains(s)?t:t.createInstance()}if(l===i.G.enumEnvelope){const s=o.Envelope2D.constructEmpty();if(t.queryEnvelope(s),s.intersect(e)){const e=t.clone();return e.setEnvelope(s),e}return t.createInstance()}if(t.isEmpty())return t;if(e.isEmpty())return t.createInstance();const u=e.clone();{const e=new o.Envelope2D;if(t.queryLooseEnvelope(e),u.containsEnvelope(e))return t;if(!u.isIntersecting(e))return t.createInstance();0===a&&(e.intersect(u),e.inflate(Math.max(.1*e.maxDimension(),1)),e.intersect(u),u.assign(e))}let g=n;if((null!==s||Number.isNaN(g))&&(g=(0,r.a)(s,u,!1).total()),l===i.G.enumGeometryCollection){const e=t,s=t.createInstance();for(let t=0,n=e.getGeometryCount();t<n;t++){const n=e.getGeometry(t);if(n.isEmpty())continue;const i=m(n,u,g,a,h);i.isEmpty()||(i===n?s.addGeometry(i.clone()):s.addGeometry(i))}return s}(0,i.i)(l)||(0,i.t)("Clip: geometry not supported");const d=t.getImpl().getAccelerators();if(null!==d){const t=d.getRasterizedGeometry();(0,i.g)(null===t)}switch(l){case i.G.enumMultiPoint:{const e=t;let s;const n=e.getPointCount(),r=e.getImpl().getAttributeStreamRef(0);let o=0;for(let t=0;t<n;t++){const n=r.readPoint2D(2*t);u.contains(n)||(0===o&&(s=e.createInstance()),o<t&&s.addPoints(e,o,t),o=t+1)}return o>0&&s.addPoints(e,o,n),0===o?e:((0,i.g)(null!==s),s)}case i.G.enumPolygon:case i.G.enumPolyline:return function(t,e,s,n,i){return new c(e,i).clipMultiPath2(t,s,n)}(t,u,g,a,h);default:(0,i.c)("")}}function u(t,e,s,n,i,r){const a=new c(e,r),h=new o.Envelope2D;return t.queryLooseEnvelope(h),e.containsEnvelope(h)?t:e.isIntersecting(h)?a.clipPolesOut(t,i):t.createInstance()}class c{constructor(t,e){this.m_shape=new a.E,this.m_geometry=a.n,this.m_verticesOnExtentIndex=-1,this.m_verticesOnExtent=[],this.m_progressCounter=0,this.m_extent=new o.Envelope2D(t),this.m_progressTracker=e}progress_(){}clipMultiPath2(t,e,s){return t.getGeometryType()===i.G.enumPolygon?this.clipPolygonOrProjectedPolyline2(t,s):this.clipPolyline(t,e)}clipPolygonOrProjectedPolyline2(t,e){const s=t.getGeometryType()===i.G.enumPolyline;if(0===this.m_extent.width()||0===this.m_extent.height())return t.createInstance();const n=o.Envelope2D.constructEmpty();t.queryLooseEnvelope(n),this.m_geometry=s?this.m_shape.addGeometry(t):this.m_shape.addGeometry(t,this.m_extent);const r=o.Envelope2D.constructEmpty(),m=o.Envelope2D.constructEmpty(),l=new h.P,u=new h.P,g=(0,h.d)(9,Number.NaN),d=(0,h.d)(9,Number.NaN),_=(0,h.m)(h.P,9);let p=null;const f=new a.L,P=[];let x=!1;for(let o=0;!x&&o<4;o++){let t=!1;const e=!!(1&o);let h=0;switch(o){case 0:h=this.m_extent.xmin,t=n.xmin<=h&&n.xmax>=h;break;case 1:h=this.m_extent.ymin,t=n.ymin<=h&&n.ymax>=h;break;case 2:h=this.m_extent.xmax,t=n.xmin<=h&&n.xmax>=h;break;case 3:h=this.m_extent.ymax,t=n.ymin<=h&&n.ymax>=h}if(t){x=!0;for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==a.n;){let n=!0,y=-1,E=-1;const C=this.m_shape.getFirstVertex(t);let S=C;do{this.progress_(),p=this.m_shape.getSegment(S);let t=p;if(null===t){const e=this.m_shape.getNextVertex(S);if(e===a.n){(0,i.g)(s),0===y&&P.push(S);break}this.m_shape.queryXY(S,l),f.setStartXY(l),this.m_shape.queryXY(e,u),f.setEndXY(u),t=f}t.queryLooseEnvelope(r);let C=c.checkSegmentIntersection(r,o,h);t.isCurve()&&0===C&&t.isCurve()&&(f.setStartXY(t.getStartXY()),f.setEndXY(t.getEndXY()),this.m_shape.replaceCurveWithLine(S),t=f,f.queryEnvelope(r),C=c.checkSegmentIntersection(r,o,h));let v=0,b=a.n;if(-1===C){const s=t.intersectionWithAxis2D(e,h,g,d);if(s>0){let n=null;if(t.isCurve()){n=_,(0,i.g)(s<=9);for(let t=0;t<s;t++)e?_[t].setCoords(g[t],h):_[t].setCoords(h,g[t]);v=this.m_shape.splitSegmentAxisAware(S,d,s,n,e?1:0)}else v=this.m_shape.splitSegmentAxisAware(S,d,s,null,-1)}else v=0;v+=1;let r=S,a=this.m_shape.getNextVertex(r);t=null;for(let t=0;t<v;t++){this.m_shape.queryXY(r,l),this.m_shape.queryXY(a,u),p=this.m_shape.getSegment(r);let t=p;null===t&&(f.setStartXY(l),f.setEndXY(u),t=f),t.queryEnvelope(m);let s=c.checkSegmentIntersection(m,o,h);t.isCurve()&&0===s&&(this.m_shape.replaceCurveWithLine(r),f.setStartXY(l),f.setEndXY(u),t=f,t.queryEnvelope(m),s=c.checkSegmentIntersection(m,o,h)),-1===s&&(e?Math.abs(l.y-h)<Math.abs(u.y-h)?(l.y=h,this.m_shape.setXY(r,l)):(u.y=h,this.m_shape.setXY(a,u)):Math.abs(l.x-h)<Math.abs(u.x-h)?(l.x=h,this.m_shape.setXY(r,l)):(u.x=h,this.m_shape.setXY(a,u)),p=this.m_shape.getSegment(r),t=p,null===t&&(f.setStartXY(l),f.setEndXY(u),t=f),t.queryEnvelope(m),s=c.checkSegmentIntersection(m,o,h),-1===s&&(s=c.checkSegmentIntersectionLoose(m,o,h)));const i=y;y=s,-1===E&&(E=y),0===i&&1===y||1===i&&0===y||0===i&&0===y&&P.push(r),1===y&&(x=!1,n=!1),r=a,b=r,a=this.m_shape.getNextVertex(a)}}if(0===v){const t=y;y=C,-1===E&&(E=y),0===t&&y>=1||t>=1&&0===y||0===t&&0===y&&P.push(S),1===y&&(x=!1,n=!1),b=this.m_shape.getNextVertex(S)}if(S=b,P.length>=256){for(let t=1,e=P.length-1;t<e;t++){const e=P[t];s?this.m_shape.snapVertexForPoleClipping(e,h):this.m_shape.removeVertex(e,!1)}P[1]=P.at(-1),P.length=2}}while(S!==C);if(!n){0!==E||!s&&0!==y&&2!==y||P.push(C);for(let t=0,e=P.length;t<e;t++){const e=P[t];s?this.m_shape.snapVertexForPoleClipping(e,h):this.m_shape.removeVertex(e,!1)}}P.length=0,t=n||0===this.m_shape.getPathSize(t)?this.m_shape.removePath(t):this.m_shape.getNextPath(t)}}}if(x)return t.createInstance();p=null,s?this.removeSpikesAlongPoles():this.resolveBoundaryOverlaps(),e>0&&this.densifyAlongClipExtent(e);const y=this.m_shape.getGeometry(this.m_geometry);return y.getGeometryType()===i.G.enumPolygon&&y.setFillRule(t.getFillRule()),y}clipPolyline(t,e){const s=o.Envelope2D.constructEmpty(),n=o.Envelope2D.constructEmpty(),i=(0,h.d)(9,Number.NaN),r=(0,h.d)(9,Number.NaN),m=new a.S;let l=t;const u=o.Envelope2D.constructEmpty();t.queryLooseEnvelope(u);for(let o=0;o<4;o++){let e=!1;const a=!!(1&o);let g=0;switch(o){case 0:g=this.m_extent.xmin,e=u.xmin<=g&&u.xmax>=g;break;case 1:g=this.m_extent.ymin,e=u.ymin<=g&&u.ymax>=g;break;case 2:g=this.m_extent.xmax,e=u.xmin<=g&&u.xmax>=g;break;case 3:g=this.m_extent.ymax,e=u.ymin<=g&&u.ymax>=g}if(!e)continue;const d=l;l=t.createInstance();const _=d.getImpl().querySegmentIterator();_.resetToFirstPath();const p=new h.P,f=new h.P;for(;_.nextPath();){let t=-1,e=!0;for(;_.hasNextSegment();){this.progress_();const h=_.nextSegment(),u=h.isDegenerate(0);h.queryLooseEnvelope(s);const d=c.checkSegmentIntersection(s,o,g);if(-1===d){const s=h.intersectionWithAxis2D(a,g,i,r);let d=0;p.assign(h.getStartXY());for(let _=0;_<=s;_++){const P=_<s?r[_]:1;if(d===P)continue;h.queryCut(d,P,m,!1);const x=m.get();let y=!1;if(x.getStartXY().equals(p)||(x.setStartXY(p),y=!0),_<s&&(a?(f.x=i[_],f.y=g):(f.x=g,f.y=i[_]),x.getEndXY().equals(f)||(x.setEndXY(f),y=!0)),y&&x.normalizeAfterEndpointChange(),!u&&x.isDegenerate(0))continue;x.queryEnvelope(n);let E=c.checkSegmentIntersection(n,o,g);if(-1===E){const t=x.getStartXY(),e=x.getEndXY();y=!1,a?Math.abs(t.y-g)<Math.abs(e.y-g)?(t.y=g,x.setStartXY(t),t.equals(x.getStartXY())||(x.setStartXY(t),y=!0)):(e.y=g,e.equals(x.getEndXY())||(x.setEndXY(e),y=!0)):Math.abs(t.x-g)<Math.abs(e.x-g)?(t.x=g,t.equals(x.getStartXY())||(x.setStartXY(t),y=!0)):(e.x=g,e.equals(x.getEndXY())||(x.setEndXY(e),y=!0)),y&&x.normalizeAfterEndpointChange(),x.queryEnvelope(n),E=c.checkSegmentIntersection(n,o,g),-1===E&&(E=c.checkSegmentIntersectionLoose(n,o,g))}p.assign(x.getEndXY()),d=P,t=E,t>=1?(l.addSegment(x,e),e=!1):e=!0}}else t=d,t>=1?(l.addSegment(h,e),e=!1):e=!0}}}return l}static checkSegmentIntersection(t,e,s){switch(e){case 0:return t.xmin<s&&t.xmax<=s?0:t.xmin>=s?t.xmax===s?2:1:-1;case 1:return t.ymin<s&&t.ymax<=s?0:t.ymin>=s?t.ymax===s?2:1:-1;case 2:return t.xmin>=s&&t.xmax>s?0:t.xmax<=s?t.xmin===s?2:1:-1;case 3:return t.ymin>=s&&t.ymax>s?0:t.ymax<=s?t.ymin===s?2:1:-1}return(0,i.c)(""),0}static checkSegmentIntersectionLoose(t,e,s){switch(e){case 0:{const e=Math.abs(t.xmin-s),n=Math.abs(t.xmax-s);return t.xmin<s?e>n?0:1:((0,i.c)(""),1)}case 1:{const e=Math.abs(t.ymin-s),n=Math.abs(t.ymax-s);return t.ymin<s?e>n?0:1:((0,i.c)(""),1)}case 2:{const e=Math.abs(t.xmin-s),n=Math.abs(t.xmax-s);return t.xmax>s?e<n?0:1:((0,i.c)(""),1)}case 3:{const e=Math.abs(t.ymin-s),n=Math.abs(t.ymax-s);return t.ymax>s?e<n?0:1:((0,i.c)(""),1)}}return(0,i.c)(""),0}resolveBoundaryOverlaps(){this.m_verticesOnExtentIndex=-1,this.splitSegments(!1,this.m_extent.xmin),this.splitSegments(!1,this.m_extent.xmax),this.splitSegments(!0,this.m_extent.ymin),this.splitSegments(!0,this.m_extent.ymax),this.m_verticesOnExtent.length=0,this.m_verticesOnExtentIndex=this.m_shape.createUserIndex();const t=new h.P;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==a.n;e=this.m_shape.getNextPath(e)){let s=this.m_shape.getFirstVertex(e);for(let n=0,i=this.m_shape.getPathSize(e);n<i;n++,s=this.m_shape.getNextVertex(s))this.progress_(),this.m_shape.queryXY(s,t),this.m_extent.xmin!==t.x&&this.m_extent.xmax!==t.x&&this.m_extent.ymin!==t.y&&this.m_extent.ymax!==t.y||(this.m_shape.setUserIndex(s,this.m_verticesOnExtentIndex,this.m_verticesOnExtent.length),this.m_verticesOnExtent.push(s))}this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmin),this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmax),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymin),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymax),this.fixPaths()}densifyAlongClipExtent(t){const e=new h.P(0,0),s=new h.P(0,0),n=(0,h.d)(2048,Number.NaN);for(let r=this.m_shape.getFirstPath(this.m_geometry);r!==a.n;r=this.m_shape.getNextPath(r)){const o=this.m_shape.getFirstVertex(r);let a=o;do{const r=this.m_shape.getNextVertex(a);this.m_shape.queryXY(a,e);let o=-1;if(e.x===this.m_extent.xmin?(this.m_shape.queryXY(r,s),s.x===this.m_extent.xmin&&(o=1)):e.x===this.m_extent.xmax&&(this.m_shape.queryXY(r,s),s.x===this.m_extent.xmax&&(o=1)),e.y===this.m_extent.ymin?(this.m_shape.queryXY(r,s),s.y===this.m_extent.ymin&&(o=0)):e.y===this.m_extent.ymax&&(this.m_shape.queryXY(r,s),s.y===this.m_extent.ymax&&(o=0)),-1===o){a=r;continue}if(this.isCurve(a)){a=r;continue}const m=e.clone(),l=new h.P(0,0);if(o){const n=e.y-this.m_extent.ymin;l.y=(0,h.e)(s.y-e.y),m.y=t*(0,h.f)(Math.floor(Math.abs(n)/t),n)+this.m_extent.ymin,l.y<0&&(m.y+=t)}else{const n=e.x-this.m_extent.xmin;l.x=(0,h.e)(s.x-e.x),m.x=t*(0,h.f)(Math.floor(Math.abs(n)/t),n)+this.m_extent.xmin,l.x<0&&(m.x+=t)}const u=o?s.y-e.y:s.x-e.x,c=Math.abs(u);if(c/t>65536&&(0,i.c)(""),c>0){const s=Math.trunc(c/t)+2;n.length<s&&(n.length=s);let r=0;for(let a=0;;a++){const s=m.add(l.mul(a*t)),h=(o?s.y-e.y:s.x-e.x)/u;if(h>=1)break;h<=0||((0,i.g)(r<=n.length),n[r]=h,r++)}0!==r&&this.m_shape.splitSegment(a,n,r)}a=r}while(a!==o)}}splitSegments(t,e){let s=-1;const n=new h.P,i=[];for(let h=this.m_shape.getFirstPath(this.m_geometry);h!==a.n;h=this.m_shape.getNextPath(h)){let r=this.m_shape.getFirstVertex(h),o=a.n;for(let a=0,m=this.m_shape.getPathSize(h);a<m;a++,r=o)if(this.progress_(),o=this.m_shape.getNextVertex(r),this.m_shape.queryXY(r,n),(t?n.y===e:n.x===e)&&(this.m_shape.queryXY(o,n),t?n.y===e:n.x===e)){if(this.isCurve(r))continue;-1===s&&(s=this.m_shape.createUserIndex()),1!==this.m_shape.getUserIndex(r,s)&&(i.push(r),this.m_shape.setUserIndex(r,s,1)),1!==this.m_shape.getUserIndex(o,s)&&(i.push(o),this.m_shape.setUserIndex(o,s,1))}}if(-1!==s&&this.m_shape.removeUserIndex(s),i.length<3)return;i.sort(((t,e)=>this.compareVertices(t,e)));const r=new h.P,o=new h.P,m=new h.P;o.setNAN();let l=-1,u=[],c=[];const g=this.m_shape.createUserIndex(),d=this.m_shape.createUserIndex();for(let a=0,_=i.length;a<_;a++){const s=i[a];if(this.m_shape.queryXY(s,n),!n.isEqualPoint2D(o)){if(-1===l){l=a,o.setCoordsPoint2D(n);continue}for(let n=l;n<a;n++){const s=i[n],a=this.m_shape.getNextVertex(s),h=this.m_shape.getPrevVertex(s);let m=!1;this.m_shape.queryXY(a,r),o.compare(r)<0&&(t?r.y===e:r.x===e)&&(this.isCurve(s)||(u.push(s),m=!0,this.m_shape.setUserIndex(s,d,1))),this.m_shape.queryXY(h,r),o.compare(r)<0&&(t?r.y===e:r.x===e)&&(this.isCurve(h)||(m||u.push(s),this.m_shape.setUserIndex(s,g,1)))}for(let t=0,e=u.length;t<e;t++){const e=u[t],s=this.m_shape.getUserIndex(e,g),i=this.m_shape.getUserIndex(e,d);if(1===s){const t=this.m_shape.getPrevVertex(e);this.m_shape.queryXY(t,m);let s=0;if(!m.isEqualPoint2D(n)){const i=h.P.distance(o,m);s=h.P.distance(m,n)/i,0===s?s=Number.EPSILON:1===s&&(s=1-Number.EPSILON),this.m_shape.splitSegment(t,[s],1);const r=this.m_shape.getPrevVertex(e);this.m_shape.setXY(r,n),c.push(r),this.m_shape.setUserIndex(r,g,1),this.m_shape.setUserIndex(r,d,-1)}}if(1===i){const t=this.m_shape.getNextVertex(e);this.m_shape.queryXY(t,m);let s=0;if(!m.isEqualPoint2D(n)){const t=h.P.distance(o,m);s=h.P.distance(o,n)/t,0===s?s=Number.EPSILON:1===s&&(s=1-Number.EPSILON),this.m_shape.splitSegment(e,[s],1);const i=this.m_shape.getNextVertex(e);this.m_shape.setXY(i,n),c.push(i),this.m_shape.setUserIndex(i,g,-1),this.m_shape.setUserIndex(i,d,1)}}}const s=u;u=c,c=s,c.length=0,l=a,o.setCoordsPoint2D(n)}}this.m_shape.removeUserIndex(g),this.m_shape.removeUserIndex(d)}resolveOverlaps(t,e){const s=new h.P,n=[];let r=-1;for(let i=0,h=this.m_verticesOnExtent.length;i<h;i++){this.progress_();const o=this.m_verticesOnExtent[i];if(o===a.n)continue;const h=this.m_shape.getNextVertex(o);if(this.m_shape.queryXY(o,s),(t?s.y===e:s.x===e)&&(this.m_shape.queryXY(h,s),t?s.y===e:s.x===e)){if(this.isCurve(o))continue;-1===r&&(r=this.m_shape.createUserIndex()),-2!==this.m_shape.getUserIndex(o,r)&&(n.push(o),this.m_shape.setUserIndex(o,r,-2)),-2!==this.m_shape.getUserIndex(h,r)&&(n.push(h),this.m_shape.setUserIndex(h,r,-2))}}if(0===n.length)return void(-1!==r&&this.m_shape.removeUserIndex(r));(0,i.g)(-1!==r),n.sort(((t,e)=>this.compareVertices(t,e)));for(let i=0,a=n.length;i<a;i++){const t=n[i];this.m_shape.setUserIndex(t,r,i)}const o=new h.P,m=new h.P;m.setNAN();let l=-1;for(let i=0,h=n.length;i<h;i++){this.progress_();const h=n[i];if(h!==a.n&&(this.m_shape.queryXY(h,s),!s.isEqualPoint2D(m))){if(-1!==l)for(;;){let s=!1;const h=i;for(let u=l;u<h;u++){const h=n[u];if(h===a.n)continue;let l=a.n;const c=this.m_shape.getNextVertex(h);this.m_shape.queryXY(c,o),m.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(h)||(l=c));let g=a.n;const d=this.m_shape.getPrevVertex(h);if(this.m_shape.queryXY(d,o),m.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(d)||(g=d)),l===a.n||g===a.n){if(l!==a.n||g!==a.n){for(let c=u+1;c<i;c++){const i=n[c];if(i===a.n)continue;const u=this.m_shape.getNextVertex(i);let d=a.n;this.m_shape.queryXY(u,o),m.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(i)||(d=u));const _=this.m_shape.getPrevVertex(i);let p=a.n;if(this.m_shape.queryXY(_,o),m.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(_)||(p=_)),d!==a.n&&p!==a.n){this.beforeRemoveVertex(i,n,r),this.m_shape.removeVertex(i,!1),this.beforeRemoveVertex(d,n,r),this.m_shape.removeVertex(d,!1),s=!0;break}if(l!==a.n&&p!==a.n){this.removeOverlap(n,h,l,i,p,r),s=!0;break}if(g!==a.n&&d!==a.n){this.removeOverlap(n,i,d,h,g,r),s=!0;break}}if(s)break}}else this.beforeRemoveVertex(h,n,r),this.m_shape.removeVertex(h,!1),this.beforeRemoveVertex(l,n,r),this.m_shape.removeVertex(l,!1),s=!0}if(!s)break}l=i,m.setCoordsPoint2D(s)}}this.m_shape.removeUserIndex(r)}beforeRemoveVertex(t,e,s){let n=this.m_shape.getUserIndex(t,s);(0,i.g)(n>=0),e[n]=a.n,n=this.m_shape.getUserIndex(t,this.m_verticesOnExtentIndex),(0,i.g)(n>=0),this.m_verticesOnExtent[n]=a.n;const r=this.m_shape.getPathFromVertex(t);r!==a.n&&this.m_shape.getFirstVertex(r)===t&&(this.m_shape.setFirstVertex(r,a.n),this.m_shape.setLastVertex(r,a.n))}removeOverlap(t,e,s,n,i,r){this.m_shape.setNextVertex(e,n),this.m_shape.setPrevVertex(n,e),this.m_shape.setPrevVertex(s,i),this.m_shape.setNextVertex(i,s),this.beforeRemoveVertex(n,t,r),this.m_shape.removeVertexInternal(n,!1),this.beforeRemoveVertex(i,t,r),this.m_shape.removeVertexInternal(i,!0)}removeSpikesAlongPoles(){this.removeSpikesOnPole(this.m_extent.ymin),this.removeSpikesOnPole(this.m_extent.ymax)}removeSpikesOnPole(t){for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==a.n;e=this.m_shape.getNextPath(e)){const s=this.m_shape.getPathSize(e);if(s<3)continue;let n=this.m_shape.getFirstVertex(e);const i=new h.P;this.m_shape.queryXY(n,i);let r=i.y===t&&!this.isCurve(n);n=this.m_shape.getNextVertex(n);const o=new h.P;this.m_shape.queryXY(n,o);let a=o.y===t&&!this.isCurve(n);n=this.m_shape.getNextVertex(n);const m=new h.P;for(let e=0,h=s-2;e<h;e++,n=this.m_shape.getNextVertex(n)){this.progress_(),this.m_shape.queryXY(n,m);const e=m.y===t;a&&r&&e&&(o.x-i.x)*(m.x-o.x)<=0?(this.m_shape.removeVertex(this.m_shape.getPrevVertex(n),!1),o.setCoordsPoint2D(m),a=e&&!this.isCurve(n)):(i.setCoordsPoint2D(o),r=a,o.setCoordsPoint2D(m),a=e&&!this.isCurve(n))}}}fixPaths(){for(let i=0,r=this.m_verticesOnExtent.length;i<r;i++){const t=this.m_verticesOnExtent[i];t!==a.n&&this.m_shape.setPathToVertex(t,a.n)}const t=this.m_shape.hasCurves();let e=0,s=0;for(let i=this.m_shape.getFirstPath(this.m_geometry);i!==a.n;){const t=this.m_shape.getFirstVertex(i);if(t===a.n||i!==this.m_shape.getPathFromVertex(t)){const t=i;i=this.m_shape.getNextPath(i),this.m_shape.setFirstVertex(t,a.n),this.m_shape.removePathOnly(t);continue}let n=t,r=0;do{this.m_shape.setPathToVertex(n,i),r++,n=this.m_shape.getNextVertex(n)}while(n!==t);this.m_shape.setRingAreaValid(i,!1),this.m_shape.setLastVertex(i,this.m_shape.getPrevVertex(t)),this.m_shape.setPathSize(i,r),s+=r,e++,i=this.m_shape.getNextPath(i)}for(let r=0,o=this.m_verticesOnExtent.length;r<o;r++){let n=this.m_verticesOnExtent[r];if(n===a.n)continue;let o=this.m_shape.getPathFromVertex(n);if(o!==a.n)continue;o=this.m_shape.insertPath(this.m_geometry,a.n);let h=!1,m=0;const l=n;do{this.m_shape.setPathToVertex(n,o),m++,t&&m<=2&&(h||(h=this.isCurve(n))),n=this.m_shape.getNextVertex(n)}while(n!==l);if(h?0===m:m<=2){let t=this.m_shape.getUserIndex(l,this.m_verticesOnExtentIndex);(0,i.g)(t>=0),this.m_verticesOnExtent[t]=a.n;const e=this.m_shape.removeVertex(l,!1);2===m&&(t=this.m_shape.getUserIndex(e,this.m_verticesOnExtentIndex),t>=0&&(this.m_verticesOnExtent[t]=a.n),this.m_shape.removeVertex(e,!1));const s=o;o=this.m_shape.getNextPath(o),this.m_shape.setFirstVertex(s,a.n),this.m_shape.removePathOnly(s)}else this.m_shape.setClosedPath(o,!0),this.m_shape.setPathSize(o,m),this.m_shape.setFirstVertex(o,l),this.m_shape.setLastVertex(o,this.m_shape.getPrevVertex(l)),this.m_shape.setRingAreaValid(o,!1),s+=m,e++}this.m_shape.setGeometryPathCount(this.m_geometry,e),this.m_shape.setGeometryVertexCount(this.m_geometry,s);let n=0;for(let i=this.m_shape.getFirstGeometry();i!==a.n;i=this.m_shape.getNextGeometry(i))n+=this.m_shape.getPointCount(i);this.m_shape.setTotalPointCount(n)}dbgCheckPathFirst(){}isCurve(t){return null!==this.m_shape.getSegment(t)}compareVertices(t,e){const s=new h.P;this.m_shape.queryXY(t,s);const n=new h.P;return this.m_shape.queryXY(e,n),s.compare(n)}clipPolesOut(t,e){return this.clipPolygonOrProjectedPolyline2(t,e)}}class g{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,n){return new d(t,e,s,n)}execute(t,e,s,n){return function(t,e,s,n){return l(t,e,s,Number.NaN,0,n)}(t,e,s,n)}}class d extends n.G{constructor(t,e,s,n){super(),this.m_progressTracker=n,this.m_index=-1,t||(0,i.t)(""),this.m_envelope=e,this.m_inputGeometryCursor=t,this.m_spatialRefImpl=s,this.m_tolerance=(0,r.a)(s,e,!1).total()}next(){let t;return(t=this.m_inputGeometryCursor.next())?((0,i.d)(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),m(t,this.m_envelope,this.m_tolerance,0,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}}}]);
//# sourceMappingURL=82103.5af3874e.chunk.js.map