"use strict";(self.webpackChunksc_depot=self.webpackChunksc_depot||[]).push([[66486],{8141:(t,e,i)=>{i.d(e,{z:()=>s});class s{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.minValue=t,this.maxValue=e,this.noDataValue=i}}},66486:(t,e,i)=>{i.r(e),i.d(e,{default:()=>f});var s,l=i(35143),n=i(50076),h=i(42553),r=i(53084),o=i(76460),a=i(46053),p=i(21403),u=i(85842),c=i(8141),d=i(52297);let g=s=class extends h.A{static createEmptyBand(t,e){return new(s.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];const e=t[0].length,i=new Uint8Array(e).fill(255);for(let s=0;s<t.length;s++){const l=t[s];for(let t=0;t<e;t++)l[t]||(i[t]=0)}return i}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){var t;return null===(t=this.pixels)||void 0===t?void 0:t.length}addData(t){var e;if(!t.pixels||t.pixels.length!==this.width*this.height)throw new n.default("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(null!==(e=t.statistics)&&void 0!==e?e:new c.z)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map((t=>function(t,e){let i=1/0,s=-1/0;const l=t.length;let n,h=0;if(null!=e)for(n=0;n<l;n++)e[n]&&(h=t[n],i=h<i?h:i,s=h>s?h:s);else for(n=0;n<l;n++)h=t[n],i=h<i?h:i,s=h>s?h:s;return new c.z(i,s)}(t,this.mask)));const t=this.mask;let e=0;if(null!=t)for(let i=0;i<t.length;i++)t[i]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||"f64"===t||"f32"===t||!this.pixels)return;const[e,i]=(0,d.hP)(t),l=this.pixels,n=this.width*this.height,h=l.length;let r,o,a;const p=[];for(let u=0;u<h;u++){a=s.createEmptyBand(t,n),r=l[u];for(let t=0;t<n;t++)o=r[t],a[t]=o>i?i:o<e?e:o;p.push(a)}this.pixels=p,this.pixelType=t}extractBands(t){var e;const{pixels:i,statistics:l}=this;if(null==t||0===t.length||!i||0===i.length)return this;const n=i.length,h=t.some((t=>t>=i.length)),r=n===t.length&&!t.some(((t,e)=>t!==e));if(h||r)return this;const o=(null===(e=this.bandMasks)||void 0===e?void 0:e.length)===n?t.map((t=>this.bandMasks[t])):void 0;let{mask:a,validPixelCount:p}=this;const{width:u,height:c}=this;return null!==o&&void 0!==o&&o.length&&(a=s.combineBandMasks(o),p=a.filter((t=>!!t)).length),new s({pixelType:this.pixelType,width:u,height:c,mask:a,bandMasks:o,validPixelCount:p,maskIsAlpha:this.maskIsAlpha,pixels:t.map((t=>i[t])),statistics:l&&t.map((t=>l[t]))})}clone(){const t=new s({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let e;null!=this.mask&&(t.mask=new Uint8Array(this.mask)),this.bandMasks&&(t.bandMasks=this.bandMasks.map((t=>new Uint8Array(t))));const i=s.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const s=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=s?this.pixels[e].slice():new i(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=(0,r.clone)(this.statistics[e]);return t.premultiplyAlpha=this.premultiplyAlpha,t}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:i,premultiplyAlpha:s,pixels:l}=this;if(!t||null===l||void 0===l||!l.length)return void o.A.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let n,h,r,a;n=h=r=l[0],l.length>=3?(h=l[1],r=l[2]):2===l.length&&(h=l[1]);const p=new Uint32Array(t),u=this.width*this.height;if(n.length===u)if(null!=e&&e.length===u)if(i)for(a=0;a<u;a++){const t=e[a];if(t){const e=t/255;p[a]=s?t<<24|r[a]*e<<16|h[a]*e<<8|n[a]*e:t<<24|r[a]<<16|h[a]<<8|n[a]}}else for(a=0;a<u;a++)e[a]&&(p[a]=255<<24|r[a]<<16|h[a]<<8|n[a]);else for(a=0;a<u;a++)p[a]=255<<24|r[a]<<16|h[a]<<8|n[a];else o.A.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:i,statistics:s}=this;if(!t||null===e||void 0===e||!e.length)return void o.A.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const l=this.pixelType;let n=1,h=0,r=1;if(s&&s.length>0){for(const t of s)if(null!=t.minValue&&(h=Math.min(h,t.minValue)),null!=t.maxValue&&null!=t.minValue){const e=t.maxValue-t.minValue;r=Math.max(r,e)}n=255/r}else{let t=255;"s8"===l?(h=-128,t=127):"u16"===l?t=65535:"s16"===l?(h=-32768,t=32767):"u32"===l?t=4294967295:"s32"===l?(h=-2147483648,t=2147483647):"f32"===l?(h=-34e38,t=34e38):"f64"===l&&(h=-Number.MAX_VALUE,t=Number.MAX_VALUE),n=255/(t-h)}const a=new Uint32Array(t),p=this.width*this.height;let u,c,d,g,f;if(u=c=d=e[0],u.length!==p)return o.A.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(c=e[1],e.length>=3&&(d=e[2]),null!=i&&i.length===p)for(g=0;g<p;g++)i[g]&&(a[g]=255<<24|(d[g]-h)*n<<16|(c[g]-h)*n<<8|(u[g]-h)*n);else for(g=0;g<p;g++)a[g]=255<<24|(d[g]-h)*n<<16|(c[g]-h)*n<<8|(u[g]-h)*n;else if(null!=i&&i.length===p)for(g=0;g<p;g++)f=(u[g]-h)*n,i[g]&&(a[g]=255<<24|f<<16|f<<8|f);else for(g=0;g<p;g++)f=(u[g]-h)*n,a[g]=255<<24|f<<16|f<<8|f}_fillFrom32Bit(t){const{pixels:e,mask:i}=this;if(!t||null===e||void 0===e||!e.length)return o.A.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let s,l,n,h;s=l=n=e[0],e.length>=3?(l=e[1],n=e[2]):2===e.length&&(l=e[1]);const r=this.width*this.height;if(s.length!==r)return o.A.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let a=0;if(null!=i&&i.length===r)for(h=0;h<r;h++)t[a++]=s[h],t[a++]=l[h],t[a++]=n[h],t[a++]=1&i[h];else for(h=0;h<r;h++)t[a++]=s[h],t[a++]=l[h],t[a++]=n[h],t[a++]=1}};(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"width",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"height",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"pixelType",void 0),(0,l._)([(0,p.w)("pixelType")],g.prototype,"castPixelType",null),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"validPixelCount",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"mask",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"maskIsAlpha",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"pixels",void 0),(0,l._)([(0,a.MZ)()],g.prototype,"premultiplyAlpha",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"statistics",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"depthCount",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"noDataValues",void 0),(0,l._)([(0,a.MZ)({json:{write:!0}})],g.prototype,"bandMasks",void 0),g=s=(0,l._)([(0,u.$)("esri.layers.support.PixelBlock")],g);const f=g}}]);
//# sourceMappingURL=66486.e0fbfa72.chunk.js.map