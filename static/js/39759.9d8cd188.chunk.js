"use strict";(self.webpackChunksc_depot=self.webpackChunksc_depot||[]).push([[1509,39759,58067,68707],{15079:(t,e,s)=>{s.d(e,{O:()=>u});var r=s(68707),n=s(79186),i=s(97799),o=s(21557),a=s(91523),l=s(82103);class u{getOperatorType(){return 10700}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s){return new m(t,e,s,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1)}}class m extends r.G{constructor(t,e,s,r){super(),this.m_progressTracker=s,this.m_inputGeoms=t,this.m_spatialReference=e,this.m_currentGeometry=null,this.m_singlePartIndex=-1,this.m_singlePartCount=-1,this.m_polygonStart=-1,this.m_index=-1,this.m_options=r}tock(){return!0}getRank(){return 1}next(){if(this.m_singlePartIndex===this.m_singlePartCount){const t=this.m_inputGeoms.next();if(null===t)return null;if((0,i.d)(t),t.getGeometryType()===i.G.enumPolygon)if(1===this.m_options)this.m_currentGeometry=(new l.g).execute(t,this.m_spatialReference,!1,this.m_progressTracker);else if(2===this.m_options)if(t.getPathCount()<2)this.m_currentGeometry=t;else{const e=[0],s=t.getImpl().getIsSimple(0,e);if((0,a.i)(s))this.m_currentGeometry=t;else{const e=new n.E,s=e.addGeometry(t);let r=null;if(e.hasCurves()){r=new l.C;const s=new o.Envelope2D;t.queryEnvelope(s);const n=(0,a.b)(null,t,!0),i=(0,l.k)(n.total(),s);(0,l.n)(e,i,n.total(),12e3,null,r,null,this.m_progressTracker)}const u=e.createPathUserIndex();{let t=0;for(let r=e.getFirstPath(s);r!==n.n;r=e.getNextPath(r))e.setPathUserIndex(r,u,t++)}const m=(0,l.o)(e,s,this.m_progressTracker);(0,i.g)(m>=0);const c=[];for(let t=e.getFirstPath(s);t!==n.n;t=e.getNextPath(t))c.push(t);c.sort(((t,s)=>Math.abs(e.getPathUserIndex(t,m))-Math.abs(e.getPathUserIndex(s,m))));const h=t,p=new n.a({vd:t.getDescription()});p.reserveParts(h.getPointCount(),h.getPathCount());for(let t=0,n=c.length;t<n;t++){const s=c[t],r=e.getPathUserIndex(s,u),n=h.calculateRingArea2D(r)>0,i=e.getPathUserIndex(s,m)>=0;p.addPath(h,r,n===i)}this.m_currentGeometry=p}}else(0,i.t)("");else this.m_currentGeometry=t;this.m_singlePartCount=function(t){return t.isEmpty()?1:(0,l.q)(t)}(this.m_currentGeometry),this.m_singlePartIndex=0,this.m_polygonStart=0,this.m_index=this.m_inputGeoms.getGeometryID()}const t=this.getSingleGeometry(this.m_singlePartIndex,this.m_singlePartCount,this.m_polygonStart,this.m_currentGeometry);return t.getGeometryType()===i.G.enumPolygon&&(this.m_polygonStart+=t.getPathCount()),this.m_singlePartIndex++,t}getGeometryID(){return this.m_index}getSingleGeometry(t,e,s,r){let n=null;switch(r.getGeometryType()){case i.G.enumMultiPoint:n=new a.P({vd:r.getDescription()}),r.isEmpty()||r.getPointByVal(t,n);break;case i.G.enumPolyline:if(1===e)n=r;else{n=r.createInstance(),n.getImpl().addPath(r.getImpl(),t,!0);const e=[0],s=r.getImpl().getIsSimple(0,e);n.getImpl().setIsSimple(s,e[0],!0)}break;case i.G.enumPolygon:if(1===e)n=r;else{n=r.createInstance();const t=n.getImpl(),e=r.getImpl(),i=e.getPathFlagsStreamRef();let o=s;const a=e.getPathCount();do{t.addPath(e,o,!0),o++}while(o<a&&!(8&i.read(o)));t.getPathFlagsStreamRef().setBits(0,8);const l=[0],u=e.getIsSimple(0,l);t.setIsSimple(u,l[0],!0)}break;default:n=r}return n}}},39759:(t,e,s)=>{s.r(e),s.d(e,{findSlicesByArea:()=>R,recursiveSliceEqualArea:()=>M,sliceIntoStrips:()=>V,supportsCurves:()=>Y});var r=s(31633),n=s(89379),i=s(68707),o=s(97799),a=s(21557),l=s(16364),u=s(79186),m=s(26871),c=s(91523),h=s(88689),p=s(15079),g=s(50847);function _(t,e,s,r,n){return new k(n).findSlicesByArea(t,e,s,r)}function y(t,e,s,r,n){return new k(n).sliceIntoStrips(t,e,s,r)}function d(t,e,s,r){return new k(r).recursiveSliceEqualArea(t,e,s)}function f(t){this.currentX=this.calcX(t)}function x(t){if(null===this.curve){const e=(t-this.y0)/(this.y1-this.y0);return(0,m.q)(this.x0,this.x1,e)}return this.curve.intersectionOfYMonotonicWithAxisX(t,this.x0)}function E(){return{x0:Number.NaN,y0:Number.NaN,x1:Number.NaN,y1:Number.NaN,currentX:Number.NaN,nextAET:null,prevAET:null,startNodeNext:null,nextInChain:null,curve:null,advance:f,calcX:x}}function v(t,e){const s=E();return s.x0=t.getStartX(),s.y0=t.getStartY(),s.x1=t.getEndX(),s.y1=t.getEndY(),e&&(s.y0=(0,m.b)(s.x0,s.x0=s.y0),s.y1=(0,m.b)(s.x1,s.x1=s.y1)),s.y1<s.y0&&(s.y1=(0,m.b)(s.y0,s.y0=s.y1),s.x1=(0,m.b)(s.x0,s.x0=s.x1)),s.currentX=Number.NaN,s.nextAET=null,s.prevAET=null,s.startNodeNext=null,s.nextInChain=null,s.curve=null,s}function T(t){const e=E();return e.x0=t.getStartX(),e.y0=t.getStartY(),e.x1=t.getEndX(),e.y1=t.getEndY(),e.curve=t,e.y1<e.y0&&(e.y1=(0,m.b)(e.y0,e.y0=e.y1),e.x1=(0,m.b)(e.x0,e.x0=e.x1)),e.currentX=Number.NaN,e.nextAET=null,e.prevAET=null,e.startNodeNext=null,e.nextInChain=null,e}function A(t){if(this.x===t.x&&this.y===t.y){const e=null!==this.endEdge,s=null!==t.startEdge;return e&&s?-1:1}return this.y!==t.y?this.y-t.y:this.x-t.x}function C(){return{x:Number.NaN,y:Number.NaN,startEdge:null,endEdge:null,compare:A}}function P(t,e){return{y:t,startingEdges:e}}class w{constructor(t,e,s,r,n,i){this.m_parent=t,this.m_y0=e,this.m_y1=s,this.m_t0=r,this.m_area=i}getMaxDerivative(){return 1}getValue(t,e){return 1===t?0:this.getArea(e)-this.m_area}getError(t){return(0,o.g)(0),0}getArea(t){const e=.5*(this.m_parent.m_sumBase-this.m_parent.m_sumA),s=this.m_y1-this.m_y0;let r=(this.m_parent.m_sumBase-e*(t+this.m_t0))*s*(t-this.m_t0),n=!1;for(let i=this.m_parent.m_AETHead;null!==i;i=i.nextAET)if(n=!n,n&&(null!==i.curve||null!==i.nextAET.curve)){const e=this.m_y0+s*this.m_t0,n=this.m_y0+s*t;i.curve&&(r+=G(i.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),i.nextAET.curve&&(r-=G(i.nextAET.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),r+=(n-e)*(i.nextAET.calcX(e)-i.calcX(e)+(i.nextAET.calcX(n)-i.calcX(n)))*.5}return r}}function S(t,e,s){return{polygon:t,from:e,to:s}}function G(t,e,s){const r=[0,0],n=t.intersectionWithAxis2D(!0,e,null,r);(0,o.g)(1===n);const i=r[0],a=t.intersectionWithAxis2D(!0,s,null,r);(0,o.g)(1===a);const l=r[0],c=(0,m.m)(m.P,4);(0,u.w)(t,c,!0);const h=c[3],p=c[2],g=c[1],_=t.getCoordX(i)-t.getStartX(),y=t.getCoordY(i)-t.getStartY(),d=t=>{const e=t*t;return e*t*(10*(p.x*g.y-p.y*g.x)-15*t*(h.y*g.x-h.x*g.y)+6*e*(p.y*h.x-h.y*p.x))/60},f=t=>(-t*(g.y+t*(p.y+h.y*t))*_+t*(g.x+t*(p.x+h.x*t))*y)/2;return d(l)-d(i)-(f(l)-f(i))}class N extends i.G{constructor(t){super(),this.m_geoms=[],this.m_index=-1,this.m_id=-1,this.m_geoms=t}tock(){return!0}getRank(){return 1}next(){return this.m_index++,this.m_index>=this.m_geoms.length?null:(this.m_id=this.m_geoms[this.m_index].second,this.m_geoms[this.m_index].first)}getGeometryID(){return this.m_id}}class k{constructor(t){this.m_edges=[],this.m_curves=[],this.m_sortedNodes=[],this.m_sortHelper=[],this.m_cuts=[],this.m_cutAreas=[],this.m_totalAreaOfTraps=new m.K(0),this.m_areaTracking=0,this.m_splitArea=0,this.m_sumBase=0,this.m_sumA=0,this.m_numberOfCuts=0,this.m_currentScan=0,this.m_progressCounter=0,this.m_AETHead=null,this.m_bHorizontalSweep=!1,this.m_bPolygonHasCurves=!1,this.m_progressTracker=t}findSlicesByArea(t,e,s,r){r<0&&(0,o.t)("remainingArea");let n=t,i=null;n.hasNonLinearSegments()&&(this.m_bPolygonHasCurves=!0,i=(0,u.p)(t,1e-16,!0),function(t){t.getImpl().ensureXYMonotoneSegments()}(i),n=i);const a=Math.abs(n.calculateArea2D());return 0===a||0===s||r>=a||1===s&&0===r?[]:(this.m_splitArea=(a-r)/s,this.m_numberOfCuts=s-1,r>0&&this.m_numberOfCuts++,this.m_edges.length=0,this.m_sortedNodes.length=0,this.m_cuts.length=0,this.m_areaTracking=0,this.m_totalAreaOfTraps.reset(),this.m_curves.length=0,this.buildEdges(n),this.buildScanNodes(),this.trapezoidation(),this.m_cuts)}sliceIntoStrips(t,e,s,r){if(0===r)return new i.S([t]);const n=new a.Envelope2D;t.queryLooseEnvelope(n);const o=n.width()+n.height();return new N(this.splitPolygon(t,e,n.xmin-o-1+1,n.xmax+o+1,s,r))}recursiveSliceEqualArea(t,e,s){if(s<=1||t.isEmpty())return new i.S([t]);{const r=[],n=[];n.push((0,m.n)(t.clone(),s));let i=0,u=0;for(;n.length>0;){(0,o.g)(u++<2*s);const t=n.at(-1);if(n.pop(),1===t.second){r.push((0,m.n)(t.first,i++));continue}const c=new a.Envelope2D;t.first.queryEnvelope(c);const h=c.width()+c.height(),p=new l.T;p.setIdentity(),c.width()>c.height()&&(p.setRotateCcw90(),t.first.applyTransformation(p),p.transformEnvInPlace(c));const g=t.first.calculateArea2D(),_=g/t.second,y=g-Math.trunc(t.second/2)*_,d=new k(this.m_progressTracker).findSlicesByArea(t.first,e,1,y),f=new k(this.m_progressTracker).splitPolygon(t.first,e,c.xmin-h-1+1,c.xmax+h+1,d,1),x=f.length;if((0,o.g)(x>0&&x<=2),!p.isIdentity()){const t=new l.T;t.setRotateCw90(),f[0].first.applyTransformation(t),2===x&&f[1].first.applyTransformation(t)}2===x?(n.push((0,m.n)(f[1].first,t.second-Math.trunc(t.second/2))),n.push((0,m.n)(f[0].first,Math.trunc(t.second/2)))):n.push((0,m.n)(f[0].first,t.second))}return new N(r)}}recursiveSliceEqualAreaImpl(t,e,s,r){return(0,o.g)(0),{}}processTraps(t,e,s){s?this.processTrapsCurves(t,e):this.processTrapsLinear(t,e)}processTrapsLinear(t,e){let s=0,r=1;const n=.5*(this.m_sumBase-this.m_sumA),i=e-t,o=(this.m_sumBase-n*(r+s))*i*(r-s);if(o+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(o),void(this.m_areaTracking+=o);const a=new m.K(o),l=new m.E(0,1);let c=!1;for(;s<1;){const e=this.m_splitArea-this.m_areaTracking,m=[Number.NaN,Number.NaN];if(!((0,u.q)(-n*i,this.m_sumBase*i,(n*s-this.m_sumBase)*i*s-e,l,!1,m)>0)){c?this.m_areaTracking=a.getResult():this.m_areaTracking+=o;break}{c=!0,r=m[0],this.m_areaTracking=0,s=r,a.me(e);const n=r*i+t;if(this.m_cuts.push(n),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+o-a.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(o-a.getResult())}}this.m_totalAreaOfTraps.pe(o)}processTrapsCurves(t,e){let s=0,r=1;const n=new w(this,t,e,0,1,0).getArea(1);if(n+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(n),void(this.m_areaTracking+=n);const i=e-t,o=new m.K(n);let a=!1;for(;s<1;){const l=this.m_splitArea-this.m_areaTracking,c=new w(this,t,e,s,1,l),h=[0],p=new m.E(s,1);if(!((0,u.t)(c,p,1,h)>0)){a?this.m_areaTracking=o.getResult():this.m_areaTracking+=n;break}{a=!0,r=h[0],this.m_areaTracking=0,s=r,o.me(l);const e=r*i+t;if(this.m_cuts.push(e),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+n-o.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(n-o.getResult())}}this.m_totalAreaOfTraps.pe(n)}advanceAET(){const t=this.m_sortedNodes[this.m_currentScan-1].y,e=this.m_sortedNodes[this.m_currentScan];let s=!1,r=!1;const n=new m.K(0);for(let a=this.m_AETHead;null!==a;a=a.nextAET){const t=a.prevAET;s=!s,null!==a.nextAET&&s&&(this.m_bPolygonHasCurves&&(a.curve||a.nextAET.curve)||n.pe(a.nextAET.currentX-a.currentX)),a.advance(e.y),null!==t&&a.currentX<t.currentX&&(r=!0)}this.m_sumBase=n.getResult(),r&&this.sortAET();const i=new m.K(0);s=!1;let o=!1;for(let a=this.m_AETHead;null!==a;a=a.nextAET)o=o||null!==a.curve,s=!s,null!==a.prevAET&&(s||this.m_bPolygonHasCurves&&(a.curve||a.prevAET.curve)||i.pe(a.currentX-a.prevAET.currentX));this.m_sumA=i.getResult(),this.processTraps(t,e.y,o);for(let a=this.m_AETHead;null!=a;){const t=a.prevAET,s=a.nextAET;if(e.y===a.y1)if(a.prevAET=null,a.nextAET=null,null!==a.nextInChain){const e=a.currentX;a=a.nextInChain,a.currentX=e,a.prevAET=t,t?t.nextAET=a:this.m_AETHead=a,a.nextAET=s,s&&(s.prevAET=a)}else t?t.nextAET=s:this.m_AETHead=s,s&&(s.prevAET=t);a=s}}mergeNewEdgesToAET(){for(let r=this.m_sortedNodes[this.m_currentScan].startingEdges;null!==r;r=r.startNodeNext)Number.isNaN(r.currentX)&&(this.m_sortHelper.push(r),r.currentX=r.x0);if(!this.m_sortHelper.length)return;this.sortHelper();let t=this.m_AETHead,e=0,s=t;for(;null!==t&&e<this.m_sortHelper.length;)t.currentX>this.m_sortHelper[e].currentX?(this.m_sortHelper[e].prevAET=t.prevAET,t.prevAET?t.prevAET.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=t,t.prevAET=this.m_sortHelper[e],e++):(s=t,t=t.nextAET);for(;e<this.m_sortHelper.length;)this.m_sortHelper[e].prevAET=s,null!==s?s.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=null,s=this.m_sortHelper[e],e++;this.m_sortHelper.length=0}sortAET(){for(let e=this.m_AETHead;null!==e;e=e.nextAET)this.m_sortHelper.push(e);this.sortHelper(),this.m_AETHead=null;let t=null;for(const e of this.m_sortHelper)e.prevAET=t,t?t.nextAET=e:this.m_AETHead=e,e.nextAET=null,t=e;this.m_sortHelper.length=0}sortHelper(){this.m_sortHelper.sort(((t,e)=>t.currentX-e.currentX))}trapezoidation(){for(this.m_currentScan=0,this.mergeNewEdgesToAET(),this.m_currentScan++;this.m_currentScan<this.m_sortedNodes.length&&(this.progress(),this.advanceAET(),this.m_cuts.length!==this.m_numberOfCuts);)this.mergeNewEdgesToAET(),this.m_currentScan++}buildEdges(t){const e=t.querySegmentIterator();for(e.stripAttributes();e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(t.isCurve()){const e=t;if((0,u.u)(e),this.m_bHorizontalSweep){const t=(0,m.m)(m.P,4);e.queryControlPoints(t);for(const e of t)e.y=(0,m.b)(e.x,e.x=e.y);e.constructPoints(t)}const s=e.getStartY(),r=e.getEndY();if(r===s)continue;r<s&&e.reverse(),this.m_curves.push(e.clone()),this.m_edges.push(T(this.m_curves.at(-1)))}else{const e=this.m_bHorizontalSweep?t.getStartX():t.getStartY();if((this.m_bHorizontalSweep?t.getEndX():t.getEndY())===e)continue;this.m_edges.push(v(t,this.m_bHorizontalSweep))}}this.m_edges.sort(((t,e)=>t.y0===e.y0?t.x0-e.x0:t.y0-e.y0))}buildScanNodes(){const t=[];for(const n of this.m_edges){const e=C();e.x=n.x0,e.y=n.y0,e.startEdge=n,e.endEdge=null,t.push(e);const s=C();s.x=n.x1,s.y=n.y1,s.startEdge=null,s.endEdge=n,t.push(s)}t.sort(((t,e)=>t.compare(e)));let e=0,s=t[e].y;this.m_sortedNodes.push(P(s,t[e].startEdge));let r=e;for(e++;e!==t.length;++e){t[e].y!==s&&(this.m_sortedNodes.push(P(t[e].y,null)),s=t[e].y);const n=t[e].startEdge;if(n){const t=this.m_sortedNodes.at(-1);n.startNodeNext=t.startingEdges,t.startingEdges=n}if(t[r].x!==t[e].x||t[r].y!==t[e].y){if(e-r==2){let e=r;e++,null!==t[r].endEdge&&null!==t[e].startEdge&&(t[r].endEdge.nextInChain=t[e].startEdge)}r=e}}}progress(){}splitPolygonLinear(t,e,s,r,n,l){const c=[];c.push([t,0,l]);const h=[],_=new u.P;for(_.startPathCoords(s,0),_.lineToCoords(r,0);c.length>0;){const u=c.at(-1);c.pop();const y=u[0],d=u[1],f=u[2],x=(new p.O).executeMany(new i.S([y]),e,this.m_progressTracker);for(let i=x.next();null!==i;i=x.next()){const u=i,p=new a.Envelope2D;u.queryLooseEnvelope(p);let y=d,x=f;for(let t=d,e=f-1;t<f;++t,--e)p.ymin>=n[t]&&(y=t+1),p.ymax<=n[e]&&(x=e);if(y!==f)if(x!==d)if(y!==x)if(this.isYMonotone(u))this.splitYMonotone(h,u,e,n,y,x);else{const i=Math.trunc((y+x)/2);_.setXYCoords(0,s,n[i]),_.setXYCoords(1,r,n[i]);const d=(new g.O).execute(!1,u,_,null,this.m_progressTracker),f=d.next(),E=d.next(),v=d.next();if(null!==f){if(f.isEmpty()||(i===x-1?(h.push((0,m.n)(f,i)),(0,o.g)(b(h.at(-1).first,e,t,h.at(-1).second,n,l))):c.push([f,i+1,x])),E.isEmpty()||(i===y?(h.push((0,m.n)(E,i-1)),(0,o.g)(b(h.at(-1).first,e,t,h.at(-1).second,n,l))):c.push([E,y,i])),null!==v&&!v.isEmpty()){const t=new a.Envelope2D;v.queryLooseEnvelope(t),t.ymin>=n[i]?c.push([v,i+1,x]):t.ymax<=n[i]?c.push([v,y,i]):c.push([v,y,x])}}else i+1===x?(n[i]-p.ymin<p.ymax-n[i]?h.push((0,m.n)(u,i)):h.push((0,m.n)(u,i+1)),(0,o.g)(b(h.at(-1).first,e,t,h.at(-1).second,n,l))):c.push([u,i+1,x])}else h.push((0,m.n)(i,y-1));else h.push((0,m.n)(i,d-1));else h.push((0,m.n)(i,f-1))}}return h}splitPolygon(t,e,s,r,i,o){const l=new a.Envelope2D;t.queryLooseEnvelope(l),l.inflateCoords(0,Math.max(l.width(),l.height()));const c=[],p=[];for(p.push(S(t,0,o));p.length;){const o=(0,n.A)({},p.at(-1));if(p.pop(),o.polygon.hasNonLinearSegments()){const t=Math.trunc((o.to+o.from)/2),n=i[t],u=new a.Envelope2D(s,l.ymin,r,n),g=(new h.O).execute(o.polygon,u,e,this.m_progressTracker);g.isEmpty()||(t-o.from==0?c.push((0,m.n)(g,t-1)):p.push(S(g,o.from,t)));const _=new a.Envelope2D(s,n,r,l.ymax),y=(new h.O).execute(o.polygon,_,e,this.m_progressTracker);y.isEmpty()||(o.to-t==1?c.push((0,m.n)(y,t)):p.push(S(y,t+1,o.to)))}else{const n=this.splitPolygonLinear(t,e,s,r,i.slice(o.from),o.to-o.from);c.push(...n)}}c.sort(((t,e)=>t.second-e.second));const g=[];return(0,u.v)(c,((t,e)=>t.second===e.second),((t,e)=>{const s=new u.a;for(let r=t;r!==e;++r)s.add(c[r].first,!1);g.push((0,m.n)(s,c[t].second))})),g}isYMonotone(t){if(1!==t.getPathCount())return!1;const e=t.getXY(0);let s=0,r=0;const n=new m.P;for(let i=1,o=t.getPointCount();i<=o;i++){t.queryXY(i===o?0:i,n);const a=n.y>e.y?1:n.y<e.y?-1:0;if(e.setCoordsPoint2D(n),s!==a&&0!==a){if(0!==s&&(r++,r>2))return!1;s=a}}return!0}splitYMonotone(t,e,s,r,n,i){const a=new u.E;a.addGeometry(e);const l=a.getFirstPath(a.getFirstGeometry()),c=a.getFirstVertex(l),h=new m.P,p=new m.P;let g=c,_=c;{const t=a.getXY(c);h.setCoordsPoint2D(t),p.setCoordsPoint2D(t)}let y=a.getNextVertex(c);const d=new m.P;for(let o=0,u=a.getPathSize(l);o<u;o++,y=a.getNextVertex(y))a.queryXY(y,d),d.compare(h)<0?(g=y,h.setCoordsPoint2D(d)):d.compare(p)>0&&(_=y,p.setCoordsPoint2D(d));let f=g,x=g,E=f,v=x,T=!1,A=!1,C=n,P=h.y,w=h.y,S=!1;for(;C<i;)if(r[C]<=h.y)C++;else{if(r[C]>=p.y)break;if(!T){const t=a.getNextVertex(f),e=a.getY(t);if(e<P)break;const s=r[C];P<=s&&e>=s?T=!0:(P=e,f=t)}if(!A){const t=a.getPrevVertex(x),e=a.getY(t);if(e<w)break;const s=r[C];w<=s&&e>=s?A=!0:(w=e,x=t)}if(T&&A){S=!0;let e=a.getXY(f);const s=a.getNextVertex(f);let n=a.getXY(s),i=u.n;if(n.y===e.y)i=n.x<e.x?f:s;else{const t=(r[C]-e.y)/(n.y-e.y);if(0===t)i=f;else if(1===t)i=s;else{const e=a.splitSegmentAxisAware(f,[t],1,null,-1);(0,o.g)(1===e),i=a.getNextVertex(f),a.getY(i)!==r[C]&&a.setXYCoords(i,a.getX(i),r[C])}}const l=a.getPrevVertex(x);e=a.getXY(l),n=a.getXY(x);let c=u.n;if(n.y===e.y)c=n.x<e.x?x:l;else{const t=(r[C]-e.y)/(n.y-e.y);if(0===t)c=l;else if(1===t)c=x;else{const e=a.splitSegmentAxisAware(l,[t],1,null,-1);(0,o.g)(1===e),c=a.getNextVertex(l),a.getY(c)!==r[C]&&a.setXYCoords(c,a.getX(c),r[C])}}t.push((0,m.n)(this.extractTrapezoid(a,E,i,v,c),C-1)),E=i,v=c,f=i,x=c,P=w=r[C],T=!1,A=!1,C++}}S?t.push((0,m.n)(this.extractTrapezoid(a,E,_,v,_),C-1)):t.push((0,m.n)(e,C))}extractTrapezoid(t,e,s,r,n){const i=new u.a({vd:t.getVertexDescription()}),o=new c.P;let a=!0;for(let l=e;;l=t.getNextVertex(l)){const e=t.getSegment(l);if(e?i.addSegment(e,a):(t.queryPoint(l,o),a?i.startPathPoint(o):i.lineToPoint(o)),a=!1,l===s)break}s!==n&&(t.queryPoint(n,o),i.lineToPoint(o)),a=!0;for(let l=n;;l=t.getNextVertex(l)){const s=t.getSegment(l);if(s?i.addSegment(s,a):a||l===e||(t.queryPoint(l,o),i.lineToPoint(o)),a=!1,l===r)break}return i}}function b(t,e,s,r,n,i){const o=new a.Envelope2D;t.queryEnvelope(o);const l=4*(0,c.b)(e,s,!0).total();return(!(r>=0)||o.ymin+l>=n[r])&&!(r+1<i&&o.ymax>n[r+1]+l)}class I extends i.G{constructor(t,e,s,r,n,i,o){var a,l;super(),this.m_resultCursor=null,this.m_method=t,this.m_polygon=e,this.m_sr=s,this.m_ySplits=null!==(a=null===r||void 0===r?void 0:r.slice())&&void 0!==a?a:null,this.m_transform=n,this.m_bReversePaths=null!==(l=null===n||void 0===n?void 0:n.isReflective())&&void 0!==l&&l,this.m_inverseTransform=n?n.clone().invertThis():null,this.m_partCount=i,this.m_tracker=o}tock(){return!0}getRank(){return 1}next(){this.m_resultCursor||(this.m_method?this.recursiveSliceEqualArea():this.sliceIntoStrips());const t=this.m_resultCursor.next();return t?(this.m_inverseTransform&&!this.m_inverseTransform.isIdentity()&&(t.applyTransformation(this.m_inverseTransform),this.m_bReversePaths&&t.reverseAllPaths()),t):t}getGeometryID(){return this.m_resultCursor?this.m_resultCursor.getGeometryID():-1}sliceIntoStrips(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=y(this.m_polygon,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=y(t,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker)}}recursiveSliceEqualArea(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=d(this.m_polygon,this.m_sr,this.m_partCount,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=d(t,this.m_sr,this.m_partCount,this.m_tracker)}}}const X=new class{getOperatorType(){return 10011}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}sliceIntoStrips(t,e,s,r,n,i){return new I(0,t,e,s,n,0,i)}findSlicesByArea(t,e,s,r,n,i){if(!n||n.isIdentity())return _(t,e,s,r,i);{const o=t.clone();return o.applyTransformation(n),_(o,e,s,r,i)}}recursiveSliceEqualArea(t,e,s,r,n){return new I(1,t,e,null,r,s,n)}};var H=s(58067);function R(t,e,s){var n;let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{transform:o,unit:a}=i,l=(0,H.getSpatialReference)(t);if(s&&a){if(l.isGeographic)throw new Error("Unable to convert from an angular area unit to a linear area unit.");const t=(0,r.B5)(l);t!==a&&(t?s=(0,r.oU)(s,a,t):(s=(0,r.oU)(s,a,"square-meters"),s=Math.sqrt(s),s/=(0,r.GA)(l),s**=2))}return function(t,e,s,r,n){return X.findSlicesByArea(t,e,s,r,n,null)}((0,H.fromPolygon)(t),(0,H.fromSpatialReference)(l),e,s,null!==(n=null===o||void 0===o?void 0:o.transform)&&void 0!==n?n:null)}function M(t,e){var s;let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{transform:n}=r,i=(0,H.getSpatialReference)(t);return function(t,e,s,r){const n=X.recursiveSliceEqualArea(t,e,s,r,null);return Array.from(n)}((0,H.fromPolygon)(t),(0,H.fromSpatialReference)(i),e,null!==(s=null===n||void 0===n?void 0:n.transform)&&void 0!==s?s:null).map((t=>(0,H.toPolygon)(t,i)))}function V(t,e){var s;let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{transform:n}=r,i=(0,H.getSpatialReference)(t);return function(t,e,s,r){const n=X.sliceIntoStrips(t,e,s,0,r,null);return Array.from(n)}((0,H.fromPolygon)(t),(0,H.fromSpatialReference)(i),e,null!==(s=null===n||void 0===n?void 0:n.transform)&&void 0!==s?s:null).map((t=>(0,H.toPolygon)(t,i)))}const Y=X.supportsCurves()},50847:(t,e,s)=>{s.d(e,{O:()=>m});var r=s(68707),n=s(97799),i=s(79186),o=s(91523),a=s(82103),l=a.C;function u(t,e){return{m_geometry:t,m_side:e}}class m{getOperatorType(){return 10005}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}execute(t,e,s,r,n){return new c(t,e,s,r,n)}}class c extends r.G{constructor(t,e,s,r,n){super(),this.m_cutIndex=-1,this.m_cuts=[],this.m_progressTracker=n,this.m_cuttee=e.clone(),this.m_cutter=new i.P({copy:s}),this.m_bConsiderTouch=t;const a=(0,o.g)(e,s);this.m_tolerance=(0,o.a)(r,a,!0)}next(){return-1===this.m_cutIndex&&this.generateCuts(),++this.m_cutIndex<this.m_cuts.length?this.m_cuts[this.m_cutIndex]:null}getGeometryID(){return this.m_cutIndex}tock(){return!0}getRank(){return 1}generateCuts(){switch(this.m_cuttee.getGeometryType()){case n.G.enumPolyline:this.generatePolylineCuts();break;case n.G.enumPolygon:this.generatePolygonCuts()}}generatePolylineCuts(){const t=new i.P,e=new i.P,s=new i.P;this.m_cuts.length=0,this.m_cuts.push(t),this.m_cuts.push(e);const r=[];!function(t,e,s,r,n,o){if(e.isEmpty()){const t=u(e,0);return void n.push(t)}if(s.isEmpty()){const t=u(e,0);return void n.push(t)}const m=[],c=new i.E;{const i=c.createGeometryUserIndex(),h=c.addGeometry(e),p=c.addGeometry(s),g=new a.T(o);let _=0,y=null;if(c.hasCurves()){y=new l;const t=c.getEnvelope2D(o);_=(0,a.s)(r.total());const e=(0,a.k)(r.total(),t);(0,a.l)(c,e,r.total(),12e3,y,null,o)}c.dbgVerifyCurves(),g.setEditShapeCrackAndCluster(c,r),g.cut(t,i,h,p,m);for(const t of m){null!==y&&y.stitchCurves(c,t,_,!1);const e=u(c.getGeometry(t),(0,a.m)(c.getGeometryUserIndex(t,i)));n.push(e)}null!==y&&y.clearStitcher(c)}}(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,r,this.m_progressTracker);for(let i=0;i<r.length;i++){const o=r[i];1===o.m_side?t.add(o.m_geometry,!1):2===o.m_side||4===o.m_side?e.add(o.m_geometry,!1):3===o.m_side?this.m_cuts.push(o.m_geometry):0===o.m_side?s.add(o.m_geometry,!1):(0,n.c)("")}s.isEmpty()||t.isEmpty()&&e.isEmpty()&&!(this.m_cuts.length>=3)||this.m_cuts.push(s),t.isEmpty()&&e.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}generatePolygonCuts(){const t=new i.a,e=new i.a,s=new i.a;this.m_cuts.length=0,this.m_cuts.push(t),this.m_cuts.push(e);const r=[];!function(t,e,s,r,n,o){if(e.isEmpty()){const t=u(e,0);return void n.push(t)}if(s.isEmpty()){const t=u(e,0);return void n.push(t)}const m=[],c=new i.E;{const t=c.createGeometryUserIndex(),h=c.addGeometry(e),p=c.addGeometry(s),g=new a.T(o);let _=0,y=null;if(c.hasCurves()){y=new l;const t=c.getEnvelope2D(o);_=(0,a.s)(r.total());const e=(0,a.k)(r.total(),t);(0,a.l)(c,e,r.total(),12e3,y,null,o)}c.dbgVerifyCurves(),g.setEditShapeCrackAndCluster(c,r),g.cut(!1,t,h,p,m),null!==y&&y.stitchCurves(c,i.n,_,!0);let d=c.getGeometry(h);const f=new i.a,x=new i.a,E=[];for(let e=0;e<m.length;e++){let s=null;{const n=new i.E,l=n.addGeometry(d),u=n.addGeometry(c.getGeometry(m[e]));if(n.hasCurves()){const t=n.getEnvelope2D(o);_=(0,a.s)(r.total());const e=(0,a.k)(r.total(),t);(0,a.l)(n,e,r.total(),12e3,y,null,o)}g.setEditShapeCrackAndCluster(n,r);const h=g.intersection(l,u);if(null!==y&&y.stitchCurves(n,i.n,_,!0),s=n.getGeometry(h),s.isEmpty())continue;const p=c.getGeometryUserIndex(m[e],t);2===p?f.add(s,!1):1===p?x.add(s,!1):E.push(s)}{const t=new i.E,s=t.addGeometry(d),n=t.addGeometry(c.getGeometry(m[e]));if(t.hasCurves()){const e=t.getEnvelope2D(o);_=(0,a.s)(r.total());const s=(0,a.k)(r.total(),e);(0,a.l)(t,s,r.total(),12e3,y,null,o)}g.setEditShapeCrackAndCluster(t,r);const l=g.difference(s,n);null!==y&&y.stitchCurves(t,i.n,_,!0),d=t.getGeometry(l)}}if(!d.isEmpty()&&m.length>0&&E.push(d),f.isEmpty()&&x.isEmpty())return;if(!f.isEmpty()){const t=u(f,1);n.push(t)}if(!x.isEmpty()){const t=u(x,2);n.push(t)}for(let e=0,s=E.length;e<s;++e){const t=u(E[e],3);n.push(t)}}}(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,r,this.m_progressTracker);for(let i=0;i<r.length;i++){const o=r[i];1===o.m_side?t.add(o.m_geometry,!1):2===o.m_side?e.add(o.m_geometry,!1):3===o.m_side?this.m_cuts.push(o.m_geometry):0===o.m_side?s.add(o.m_geometry,!1):(0,n.c)("")}(0,n.g)(s.isEmpty()||1===r.length),t.isEmpty()&&e.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}}},58067:(t,e,s)=>{s.r(e),s.d(e,{fromExtent:()=>E,fromGeometry:()=>x,fromMultipoint:()=>v,fromPoint:()=>T,fromPolygon:()=>A,fromPolyline:()=>C,fromSpatialReference:()=>P,getSpatialReference:()=>f,toExtent:()=>S,toGeometry:()=>w,toMultipoint:()=>G,toPoint:()=>N,toPolygon:()=>k,toPolyline:()=>b});var r=s(89379),n=s(26871),i=(s(21557),s(97799)),o=s(91523),a=s(79186),l=s(82103),u=s(76797),m=s(66388),c=s(19247),h=s(65215),p=s(23701),g=(s(59739),s(48045));const _="_gxVersion",y=2,d=1;function f(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function x(t){switch(t.type){case"point":return T(t);case"multipoint":return v(t);case"polyline":return C(t);case"polygon":return A(t);case"extent":return E(t);default:throw new Error("Unsupported geometry type: ".concat(t.type))}}function E(t){if(!t.getCacheValue(_)){const e=new o.E;e.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&e.setInterval(y,0,t.mmin,t.mmax),t.hasZ&&e.setInterval(d,0,t.zmin,t.zmax),t.setCacheValue(_,e)}return t.getCacheValue(_)}function v(t){if(!t.getCacheValue(_)){const r=new a.M,n=new o.P,i=t.points,l=t.hasM,u=t.hasZ,m=u?3:2;for(let t=0,o=i.length;t<o;t++){var e,s;const o=i[t];n.setXYCoords(o[0],o[1]),u&&n.setZ(null!==(e=o[2])&&void 0!==e?e:0),l&&n.setM(null!==(s=o[m])&&void 0!==s?s:NaN),r.add(n)}t.setCacheValue(_,r)}return t.getCacheValue(_)}function T(t){if(!t.getCacheValue(_)){const e=new o.P;e.setXYCoords(t.x,t.y),t.hasM&&e.setM(t.m),t.hasZ&&e.setZ(t.z),t.setCacheValue(_,e)}return t.getCacheValue(_)}function A(t){if(!t.getCacheValue(_)){const{curveRings:e,hasM:s,hasZ:r,rings:n}=t,i=(0,g.fromGeometryToGXGeometry)({curveRings:e,hasM:s,hasZ:r,rings:n});t.setCacheValue(_,i)}return t.getCacheValue(_)}function C(t){if(!t.getCacheValue(_)){const{curvePaths:e,hasM:s,hasZ:r,paths:n}=t,i=(0,g.fromGeometryToGXGeometry)({curvePaths:e,hasM:s,hasZ:r,paths:n});t.setCacheValue(_,i)}return t.getCacheValue(_)}function P(t){if(t.wkid)return(0,l.c)(t.wkid);const e=t.wkt2||t.wkt;return e?(0,l.b)(e):null}function w(t,e){if(t)switch(t.getGeometryType()){case i.G.enumPoint:return N(t,e);case i.G.enumEnvelope:return S(t,e);case i.G.enumMultiPoint:return G(t,e);case i.G.enumPolyline:return b(t,e);case i.G.enumPolygon:return k(t,e)}return null}function S(t,e){if(t.isEmpty())return null;const s=new u.default({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:e}),r=t.getDescription();if(r.hasM()){const e=t.queryInterval(y,0);s.mmin=e.vmin,s.mmax=e.vmax}if(r.hasZ()){const e=t.queryInterval(d,0);s.zmin=e.vmin,s.zmax=e.vmax}return s.setCacheValue(_,t),s}function G(t,e){if(t.isEmpty())return null;const s=t.getDescription(),r=s.hasM(),n=s.hasZ(),i=[],a=new o.P;for(let o=0,u=t.getPointCount();o<u;o++){t.getPointByVal(o,a);const e=[a.getX(),a.getY()];n&&e.push(a.getZ()),r&&e.push(a.getM()),i.push(e)}const l=new m.default({hasM:r,hasZ:n,points:i,spatialReference:e});return l.setCacheValue(_,t),l}function N(t,e){if(t instanceof n.P)return new c.default({x:t.x,y:t.y,spatialReference:e});if(t.isEmpty())return null;const s=new c.default({x:t.getX(),y:t.getY(),spatialReference:e}),r=t.getDescription();return r.hasM()&&(s.m=t.getM()),r.hasZ()&&(s.z=t.getZ()),s.setCacheValue(_,t),s}function k(t,e){if(t.isEmpty())return null;const s=h.default.fromJSON((0,r.A)({spatialReference:e},(0,g.toGeometry)(t,null)));return s.setCacheValue(_,t),s}function b(t,e){if(t.isEmpty())return null;const s=p.default.fromJSON((0,r.A)({spatialReference:e},(0,g.toGeometry)(t,null)));return s.setCacheValue(_,t),s}},68707:(t,e,s)=>{s.d(e,{G:()=>r,O:()=>n,S:()=>i});class r{*[Symbol.iterator](){let t=this.next();for(;t;)yield t,t=this.next()}}class n extends r{}class i extends r{constructor(t){super(),this.m_iGeom=-1,this.m_aGeoms=t?t.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const t=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,t}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}}}]);
//# sourceMappingURL=39759.9d8cd188.chunk.js.map