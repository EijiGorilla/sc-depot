"use strict";(self.webpackChunksc_depot=self.webpackChunksc_depot||[]).push([[1509,19115,58067,68707],{19115:(e,t,n)=>{n.r(t),n.d(t,{executeMany:()=>h,supportsCurves:()=>p});var r=n(26871),s=n(68707),o=n(97799),i=n(91523),u=n(79186);class a{constructor(e,t,n,r){this.m_interval=n,this.m_progressTracker=r,this.m_attribute=e,this.m_ord=t,(i.V.getComponentCount(this.m_attribute)<=t||t<0)&&(0,o.t)("LocateBetween: ordinate"),2===i.V.getInterpolation(this.m_attribute)&&(0,o.t)("LocateBetween: angular interpolation")}processGeometry(e){const t=e.getGeometryType();if(t===o.G.enumGeometryCollection)return this.processGeometryCollection(e);if((0,o.p)(t)&&(0,o.t)("LocateBetween does not support Polygons and Envelopes."),e.isEmpty()||!e.hasAttribute(this.m_attribute))return new i.P({vd:e.getDescription()});if((0,o.f)(t))return this.processSegment(e);switch(t){case o.G.enumPoint:return this.processPoint(e);case o.G.enumMultiPoint:return this.processMultiPoint(e);case o.G.enumPolyline:return this.processPolyline(e);default:(0,o.c)("LocateBetween")}}processPoint(e){const t=e.getAttributeAsDbl(this.m_attribute,this.m_ord);return this.m_interval.containsCoordinate(t)?new u.M({point:e}):new i.P({vd:e.getDescription()})}processMultiPoint(e){let t=null,n=-1;const r=e.getAttributeStreamRef(this.m_attribute),s=i.V.getComponentCount(this.m_attribute);for(let o=0,i=0,a=e.getPointCount();o<a;++o,i+=s){const s=r.readAsDbl(i);this.m_interval.containsCoordinate(s)?-1===n&&(n=o):n>=0&&(t||(t=new u.M({vd:e.getDescription()})),t.addPoints(e,n,o),n=-1)}return n>=0&&(t||(t=new u.M({vd:e.getDescription()})),t.addPoints(e,n,-1)),t||new i.P({vd:e.getDescription()})}processPolyline(e){const t=e.queryInterval(this.m_attribute,this.m_ord);if(this.m_interval.contains(t))return e;if(!this.m_interval.isIntersecting(t))return new i.P({vd:e.getDescription()});let n=null,r=null;const s=e.querySegmentIterator(),a=new u.S,l=new i.P,c=new i.P,m=new i.P;let h=!0,p=!1;for(;s.nextPath();)for(h=!0,p=!1;s.hasNextSegment();){const e=s.nextSegment(),t=[null],i=this.processSegmentHelper(e,a,t,l);if(i!==o.G.enumUnknown)if(i===o.G.enumPoint){if(!h&&(r.getPointByVal(r.getPointCount()-1,c),c.equals(l)))continue;if(h=!0,p&&(e.queryStart(c),l.equals(c)))continue;e.queryEnd(c),p=l.equals(c),n?n.add(l):n=new u.M({point:l})}else i===o.G.enumLine&&(p=!1,r||(r=new u.P),h&&(null===n||n.isEmpty()||(n.getPointByVal(n.getPointCount()-1,c),t[0].queryStart(l),c.equals(l)&&n.removePoint(n.getPointCount()-1))),r.addSegment(t[0],h),e.queryEnd(c),t[0].queryEnd(m),h=!c.equals(m));else h=!0,p=!1}if(null!==n&&n.isEmpty()&&(n=null),null!==n&&null!==r){const e=new u.G;return e.addGeometry(r),e.addGeometry(n),e}return null!==n?n:null!==r?r:new i.P({vd:e.getDescription()})}processSegment(e){const t=e.getAttributeAsDbl(0,this.m_attribute,this.m_ord),n=e.getAttributeAsDbl(1,this.m_attribute,this.m_ord),s=Number.isNaN(t)?n:t,o=Number.isNaN(n)?t:n,u=new r.E;u.setCoords(s,o);const a=u.clone();if(a.intersect(this.m_interval),a.isEmpty())return new i.P({vd:e.getDescription()});if(u.equals(a))return e;const l=o-s,c=e.calculateLength2D();if(0===a.width()){const t=new i.P({vd:e.getDescription()}),n=(a.vmin-s)/l,r=e.lengthToT(n*c);return e.queryCoord(r,t),t}let m=(a.vmin-s)/l,h=(a.vmax-s)/l;return m>h&&(h=(0,r.b)(m,m=h)),m=e.lengthToT(m*c),h=e.lengthToT(h*c),e.cut(m,h)}processGeometryCollection(e){if(e.isEmpty()||!e.hasAttribute(this.m_attribute))return new i.P({vd:e.getDescription()});const t=(0,u.g)(e),n=new u.G;for(let r=t.next();null!==r;r=t.next()){const e=this.processGeometry(r);e.isEmpty()||n.addGeometry(e)}return n.isEmpty()?new i.P({vd:e.getDescription()}):n}processSegmentHelper(e,t,n,s){const i=e.getAttributeAsDbl(0,this.m_attribute,this.m_ord),u=e.getAttributeAsDbl(1,this.m_attribute,this.m_ord),a=Number.isNaN(i)?u:i,l=Number.isNaN(u)?i:u,c=new r.E;c.setCoords(a,l);const m=c.clone();if(m.intersect(this.m_interval),m.isEmpty())return o.G.enumUnknown;if(c.equals(m))return n[0]=e,o.G.enumLine;const h=l-a,p=e.calculateLength2D();if(0===m.width()){const t=(m.vmin-a)/h,n=1===t?1:e.lengthToT(t*p);return e.queryCoord(n,s),o.G.enumPoint}let g=(m.vmin-a)/h,f=(m.vmax-a)/h;return g>f&&(f=(0,r.b)(g,g=f)),g=1===g?1:e.lengthToT(g*p),f=1===f?1:e.lengthToT(f*p),e.queryCut(g,f,t),n[0]=t.get(),o.G.enumLine}}class l extends s.G{constructor(e,t,n){super(),this.m_collectionCursor=null,this.m_interval=t,this.m_progressTracker=n,this.m_inputGeoms=e,this.m_index=-1}tock(){return!0}getRank(){return 1}next(){if(this.m_collectionCursor){const e=this.m_collectionCursor.next();if(e)return e;this.m_collectionCursor=null}const e=this.m_inputGeoms.next();if(null===e)return null;(0,o.d)(e),this.m_index=this.m_inputGeoms.getGeometryID();const t=function(e,t,n,r,s){return new a(t,n,r,s).processGeometry(e)}(e,2,0,this.m_interval,this.m_progressTracker);return t.getGeometryType()===o.G.enumGeometryCollection?(this.m_collectionCursor=(0,u.g)(t),this.m_collectionCursor.next()):t}getGeometryID(){return this.m_index}}const c=new class{getOperatorType(){return 10801}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t,n){return new l(e,t,n)}};var m=n(58067);function h(e,t,n){const o=e.map(m.fromGeometry),i=(0,m.getSpatialReference)(e);return function(e,t){const n=c.executeMany(new s.S(e),t,null);return Array.from(n)}(o,new r.E(t,n)).map((e=>(0,m.toGeometry)(e,i)))}const p=c.supportsCurves()},58067:(e,t,n)=>{n.r(t),n.d(t,{fromExtent:()=>w,fromGeometry:()=>_,fromMultipoint:()=>C,fromPoint:()=>P,fromPolygon:()=>v,fromPolyline:()=>x,fromSpatialReference:()=>b,getSpatialReference:()=>G,toExtent:()=>V,toGeometry:()=>M,toMultipoint:()=>D,toPoint:()=>E,toPolygon:()=>T,toPolyline:()=>A});var r=n(89379),s=n(26871),o=(n(21557),n(97799)),i=n(91523),u=n(79186),a=n(82103),l=n(76797),c=n(66388),m=n(19247),h=n(65215),p=n(23701),g=(n(59739),n(48045));const f="_gxVersion",y=2,d=1;function G(e){return Array.isArray(e)?e[0].spatialReference:e.spatialReference}function _(e){switch(e.type){case"point":return P(e);case"multipoint":return C(e);case"polyline":return x(e);case"polygon":return v(e);case"extent":return w(e);default:throw new Error("Unsupported geometry type: ".concat(e.type))}}function w(e){if(!e.getCacheValue(f)){const t=new i.E;t.setCoords(e.xmin,e.ymin,e.xmax,e.ymax),e.hasM&&t.setInterval(y,0,e.mmin,e.mmax),e.hasZ&&t.setInterval(d,0,e.zmin,e.zmax),e.setCacheValue(f,t)}return e.getCacheValue(f)}function C(e){if(!e.getCacheValue(f)){const r=new u.M,s=new i.P,o=e.points,a=e.hasM,l=e.hasZ,c=l?3:2;for(let e=0,i=o.length;e<i;e++){var t,n;const i=o[e];s.setXYCoords(i[0],i[1]),l&&s.setZ(null!==(t=i[2])&&void 0!==t?t:0),a&&s.setM(null!==(n=i[c])&&void 0!==n?n:NaN),r.add(s)}e.setCacheValue(f,r)}return e.getCacheValue(f)}function P(e){if(!e.getCacheValue(f)){const t=new i.P;t.setXYCoords(e.x,e.y),e.hasM&&t.setM(e.m),e.hasZ&&t.setZ(e.z),e.setCacheValue(f,t)}return e.getCacheValue(f)}function v(e){if(!e.getCacheValue(f)){const{curveRings:t,hasM:n,hasZ:r,rings:s}=e,o=(0,g.fromGeometryToGXGeometry)({curveRings:t,hasM:n,hasZ:r,rings:s});e.setCacheValue(f,o)}return e.getCacheValue(f)}function x(e){if(!e.getCacheValue(f)){const{curvePaths:t,hasM:n,hasZ:r,paths:s}=e,o=(0,g.fromGeometryToGXGeometry)({curvePaths:t,hasM:n,hasZ:r,paths:s});e.setCacheValue(f,o)}return e.getCacheValue(f)}function b(e){if(e.wkid)return(0,a.c)(e.wkid);const t=e.wkt2||e.wkt;return t?(0,a.b)(t):null}function M(e,t){if(e)switch(e.getGeometryType()){case o.G.enumPoint:return E(e,t);case o.G.enumEnvelope:return V(e,t);case o.G.enumMultiPoint:return D(e,t);case o.G.enumPolyline:return A(e,t);case o.G.enumPolygon:return T(e,t)}return null}function V(e,t){if(e.isEmpty())return null;const n=new l.default({xmin:e.getXMin(),ymin:e.getYMin(),xmax:e.getXMax(),ymax:e.getYMax(),spatialReference:t}),r=e.getDescription();if(r.hasM()){const t=e.queryInterval(y,0);n.mmin=t.vmin,n.mmax=t.vmax}if(r.hasZ()){const t=e.queryInterval(d,0);n.zmin=t.vmin,n.zmax=t.vmax}return n.setCacheValue(f,e),n}function D(e,t){if(e.isEmpty())return null;const n=e.getDescription(),r=n.hasM(),s=n.hasZ(),o=[],u=new i.P;for(let i=0,l=e.getPointCount();i<l;i++){e.getPointByVal(i,u);const t=[u.getX(),u.getY()];s&&t.push(u.getZ()),r&&t.push(u.getM()),o.push(t)}const a=new c.default({hasM:r,hasZ:s,points:o,spatialReference:t});return a.setCacheValue(f,e),a}function E(e,t){if(e instanceof s.P)return new m.default({x:e.x,y:e.y,spatialReference:t});if(e.isEmpty())return null;const n=new m.default({x:e.getX(),y:e.getY(),spatialReference:t}),r=e.getDescription();return r.hasM()&&(n.m=e.getM()),r.hasZ()&&(n.z=e.getZ()),n.setCacheValue(f,e),n}function T(e,t){if(e.isEmpty())return null;const n=h.default.fromJSON((0,r.A)({spatialReference:t},(0,g.toGeometry)(e,null)));return n.setCacheValue(f,e),n}function A(e,t){if(e.isEmpty())return null;const n=p.default.fromJSON((0,r.A)({spatialReference:t},(0,g.toGeometry)(e,null)));return n.setCacheValue(f,e),n}},68707:(e,t,n)=>{n.d(t,{G:()=>r,O:()=>s,S:()=>o});class r{*[Symbol.iterator](){let e=this.next();for(;e;)yield e,e=this.next()}}class s extends r{}class o extends r{constructor(e){super(),this.m_iGeom=-1,this.m_aGeoms=e?e.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const e=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,e}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}}}]);
//# sourceMappingURL=19115.2d2b5650.chunk.js.map