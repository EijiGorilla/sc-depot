"use strict";(self.webpackChunksc_depot=self.webpackChunksc_depot||[]).push([[1509,41202,58067,68707],{41202:(t,e,i)=>{i.r(e),i.d(e,{execute:()=>C,executeMany:()=>b,supportsCurves:()=>T});var n=i(89379),s=i(68707),o=i(97799),r=i(26871),h=i(79186);function g(t,e,i,n,s,o){const g=n-e;if(g<=o)return(0,h.h)(t,e,i,n,s),i;const a=function(t,e,i,n,s){const o=[];!function(t,e,i){const n=Math.trunc(e/2);let s=BigInt(n);const o=BigInt(e);for(let r=0;r<i;++r)t.push(Number(s%o)),s=6364136223846793005n*s+1442695040888963407n&0x7fffffffffffffffn,s=BigInt.asUintN(64,s);(0,r.v)(t);const h=(0,r.u)(t,((t,e)=>t===e));t.length=h}(o,i-e,s);const h=[];for(let a=0,d=o.length;a<d;a++){const i=o[a];h.push((0,r.n)(t[e+i],i))}const g=Math.trunc(h.length/2);return h.sort(((t,e)=>n(t.first,e.first)?-1:1)),e+h[g].second}(t,e,n,s,Math.min(Math.max(g>>1,3),100)),d=t[a];t[e]=(0,r.b)(t[a],t[a]=t[e]);let c=e+1,l=!1;for(let h=e+1;h!==n;++h)s(t[h],d)&&(t[c]=(0,r.b)(t[h],t[h]=t[c]),++c,l=!0);if(!l)for(let h=e+1;h<i;++h)s(d,t[h])||(h!==c&&(t[c]=(0,r.b)(t[h],t[h]=t[c])),++c);return--c,t[c]=(0,r.b)(t[e],t[e]=t[c]),c}function a(){return{p:new r.P,userData:Number.NaN,edge:null}}class d{constructor(){this.info=0,this.mask=!1,this.p=null,this.a=[null,null],this.twin=null}nextFreeEdge(){return this.twin}setIndex(t){this.info=t,this.mask=!1}getIndex(){return this.info}setMask(){this.mask=!0}getMask(){return this.mask}}function c(t,e){return{first:t,second:e}}function l(t,e){t.first=e.first,t.second=e.second}function u(){return this.i1-this.i0}function m(){return{i0:Number.NaN,i1:Number.NaN,nextFreeEdgeIndex:[-1],box:[c(null,null),c(null,null)],size:u}}function f(){return{p:[new r.P,new r.P],points:[null,null]}}class p{constructor(){this.m_nextFreePairEdge=c(null,null),this.m_points=[],this.m_pointZero=null,this.m_edges=[],this.m_voronoiToEdge=[],this.m_nextFreeEdge=0}clear(){this.m_nextFreePairEdge=c(null,null),this.m_points.length=0,this.m_pointZero=null,this.m_edges.length=0,this.m_voronoiToEdge.length=0,this.m_nextFreeEdge=0}reservePoints(t){(0,o.g)(t>1)}prepare(t){{const e=a();e.p.x=Number.POSITIVE_INFINITY,e.p.y=Number.POSITIVE_INFINITY,e.userData=t,this.m_points.push(e)}}addVertex(t,e){const i=a();i.p.assign(t),i.userData=e,i.edge=null,this.m_points.push(i)}removeDuplicates(){const t=this.m_points.shift();this.m_points.sort(((t,e)=>t.p.compareX(e.p)));const e=(0,r.u)(this.m_points,((t,e)=>t.p.equals(e.p))),i=e!==this.m_points.length;return this.m_points.length=e,this.m_points.unshift(t),i}boundVoronoiCells(t,e){const i=this.m_points.length;if(i<2)return!1;const n=[this.m_points[1].p.clone(),this.m_points[1].p.clone()];for(let r=2;r<i;r++){const t=this.m_points[r].p;t.x<n[0].x&&(n[0].x=t.x),n[1].x<t.x&&(n[1].x=t.x),t.y<n[0].y&&(n[0].y=t.y),n[1].y<t.y&&(n[1].y=t.y)}const s=new r.P;s.x=.5*(n[0].x+n[1].x),s.y=.5*(n[0].y+n[1].y);let o=0;for(let a=1;a<i;a++){const t=this.m_points[a].p,e=r.P.sqrDistanceCoords(t.x,t.y,s.x,s.y);o<e&&(o=e)}const h=Math.sqrt(o),g=Math.max(h+2*t,1.5*h);{const t=.8660254037844386,i=.5;let n=1,o=0;for(let h=0;h<12;h++){const h=new r.P;h.x=s.x+g*n,h.y=s.y+g*o,this.addVertex(h,e);const a=n*i+o*t;n=n*t-o*i,o=a}}return!0}construct(){const t=m();return!!this.constructTask(t)&&(this.solveTask(t),!0)}constructTask(t){if(this.m_pointZero=this.createZeroHandle(),(0,o.g)(void 0!==this.m_pointZero),this.m_points.length<3)return!1;const e=6*(this.m_points.length-2);this.m_edges=(0,r.m)(d,e);for(let i=0;i<e;i++)this.m_edges[i].setIndex(i);return t.i0=1,t.i1=this.m_points.length,t.nextFreeEdgeIndex[0]=0,!0}splitTask(t,e,i,n){const s=t,o=e,r=i,h=n;s.k=this.findMaxSide(h.i0,h.i1);let a=h.i0+h.i1>>1;a=0===s.k?g(this.m_points,h.i0,a,h.i1,((t,e)=>t.p[0]!==e.p[0]?t.p[0]<e.p[0]:t.p[1]<e.p[1]),1250):g(this.m_points,h.i0,a,h.i1,((t,e)=>t.p[1]!==e.p[1]?t.p[1]<e.p[1]:t.p[0]<e.p[0]),1250),o.i0=h.i0,o.i1=a,o.nextFreeEdgeIndex[0]=h.nextFreeEdgeIndex[0],h.nextFreeEdgeIndex[0]+=6*(o.i1-o.i0-1)+2,r.i0=a,r.i1=h.i1,r.nextFreeEdgeIndex[0]=h.nextFreeEdgeIndex[0],h.nextFreeEdgeIndex[0]+=6*(r.i1-r.i0-1)+2,s.pTask=h,s.pTask0=o,s.pTask1=r}solveMergeTask(t){const e=this.newPairEdgeEx(t.pTask.nextFreeEdgeIndex,!1);if(t.pTask.box[t.k]=c(t.pTask0.box[t.k].first,t.pTask1.box[t.k].second),t.pTask.box[1-t.k]=c(x(this.getPointXYFromEdge(t.pTask0.box[1-t.k].first),this.getPointXYFromEdge(t.pTask1.box[1-t.k].first),1-t.k)?t.pTask0.box[1-t.k].first:t.pTask1.box[1-t.k].first,x(this.getPointXYFromEdge(t.pTask0.box[1-t.k].second),this.getPointXYFromEdge(t.pTask1.box[1-t.k].second),1-t.k)?t.pTask1.box[1-t.k].second:t.pTask0.box[1-t.k].second),t.pTask.i0+2===t.pTask.i1){const i=t.pTask0.box[t.k].second,n=i.twin,s=t.pTask1.box[t.k].first,o=s.twin;return this.joinEdges2(n,o),this.joinEdges2(o,n),void this.join(i,s,0,1,e)}const i=[new Array(2),new Array(2)];i[0][0]=i[1][0]=c(t.pTask0.box[t.k].second,t.pTask0.box[t.k].second.twin),i[0][1]=i[1][1]=c(t.pTask1.box[t.k].first,t.pTask1.box[t.k].first.twin);const n=[!1,!1];if(t.pTask0.i0+1===t.pTask0.i1?(this.findEdgeSide(i[0],n,1,0),this.findEdgeSide(i[1],n,1,1)):(this.findEdge(i[0],n,0),this.findEdge(i[1],n,1)),n[0]||n[1]){if(n[0]){const e=this.newPairEdgeEx(t.pTask0.nextFreeEdgeIndex,!1);this.insertEdge(i[0][0].first,e.first,0),this.insertEdge(i[0][0].second,e.second,1)}if(n[1]){const e=this.newPairEdgeEx(t.pTask1.nextFreeEdgeIndex,!1);this.insertEdge(i[0][1].first,e.first,1),this.insertEdge(i[0][1].second,e.second,0)}}else this.getNextDEdge(i[0][0].first,0)!==i[0][0].first&&(i[1][0]=this.newPairEdgeEx(t.pTask0.nextFreeEdgeIndex,!1),this.insertEdge(i[0][0].first,i[1][0].first,0),this.insertEdge(i[0][0].second,i[1][0].second,1)),this.getNextDEdge(i[0][1].first,0)!==i[0][1].first&&(i[1][1]=this.newPairEdgeEx(t.pTask1.nextFreeEdgeIndex,!1),this.insertEdge(i[0][1].first,i[1][1].first,1),this.insertEdge(i[0][1].second,i[1][1].second,0));this.merge(i[1][0],i[0][0],i[0][1],i[1][1],e)}solveTask(t){const e=t;switch(e.i1-e.i0){case 1:{this.insertPoint(e.i0,e.nextFreeEdgeIndex);const t=this.m_points[e.i0].edge;e.box[0]=e.box[1]=(0,r.n)(t,t)}break;case 2:{const t=e.i0,i=t+1;this.insertPoint(t,e.nextFreeEdgeIndex),this.insertPoint(i,e.nextFreeEdgeIndex);const n=this.m_points[t],s=this.m_points[i],o=n.edge,r=s.edge,h=o.twin,g=r.twin;this.joinEdges2(h,g),this.joinEdges2(g,h);const a=this.newPairEdgeEx(e.nextFreeEdgeIndex,!1);this.join(o,r,0,1,a);for(let d=0;d<2;d++)e.box[d]=x(this.getPointXY(n),this.getPointXY(s),d)?c(o,r):c(r,o)}break;case 3:{const t=[e.i0,e.i0+1,e.i0+2];this.insertPoint(t[0],e.nextFreeEdgeIndex),this.insertPoint(t[1],e.nextFreeEdgeIndex),this.insertPoint(t[2],e.nextFreeEdgeIndex);const i=[this.m_points[t[0]],this.m_points[t[1]],this.m_points[t[2]]],n=this.caseFromCompare(i[0].p,i[1].p,i[2].p),s=[i[0].edge,i[1].edge,i[2].edge],o=p.c_aTableDelaunayTriangulationSolution[n],h=P(19*P(1+(7&o))),g=P(19*P(1+(o>>5)));let a=P(o<<3)>>6;const d=3&h,l=h>>6,u=3&g,m=g>>6;e.box[0]=c(s[d],s[l]),e.box[1]=c(s[u],s[m]);const f=[s[0].twin,s[1].twin,s[2].twin],E=[this.newPairEdgeEx(e.nextFreeEdgeIndex,!1),this.newPairEdgeEx(e.nextFreeEdgeIndex,!1),this.newPairEdgeEx(e.nextFreeEdgeIndex,!1)];switch(3===a&&(a=this.orientation(i[0].p,i[1].p,i[2].p)+1),a){case 0:this.joinEdges2(f[0],f[2]),this.joinEdges2(f[2],f[1]),this.joinEdges2(f[1],f[0]),this.join(s[0],s[2],0,1,E[0]),this.join(s[2],s[1],0,1,E[1]),this.join(s[1],s[0],0,1,E[2]);break;case 1:{const t=[0,1,2];t[3-(d+l)]=(0,r.b)(t[1],t[1]=t[3-(d+l)]),this.joinEdges2(f[t[0]],f[t[1]]),this.joinEdges2(f[t[1]],f[t[2]]),this.joinEdges2(f[t[2]],f[t[0]]),this.join(s[t[0]],s[t[1]],0,1,E[0]),this.join(s[t[1]],s[t[2]],0,1,E[1]),this.join(E[1].first,f[t[2]],0,1,E[2])}break;case 2:this.joinEdges2(f[0],f[1]),this.joinEdges2(f[1],f[2]),this.joinEdges2(f[2],f[0]),this.join(s[0],s[1],0,1,E[0]),this.join(s[1],s[2],0,1,E[1]),this.join(s[2],s[0],0,1,E[2])}}break;default:{const e={k:0,pTask:null,pTask0:null,pTask1:null},i=m(),n=m();this.splitTask(e,i,n,t),this.solveTask(i),this.solveTask(n),this.solveMergeTask(e)}}}getOutsideHull(){const t=[],e=this.m_points[0].edge;let i=e;do{t.push(this.getPointFromEdge(this.getTwinEdge(i))),i=this.getNextDEdge(i,0)}while(i!==e);return t}getConvexHull(){const t=[],e=this.m_points[0].edge;let i=e;do{const e=this.getPointFromEdge(this.getTwinEdge(i));t.length<2||!this.insideLine(this.getPointXY(t.at(-2)),this.getPointXY(t.at(-1)),this.getPointXY(e))?t.push(e):t[t.length-1]=e,i=this.getNextDEdge(i,0)}while(i!==e);return 2<t.length&&this.insideLine(this.getPointXY(t[0]),this.getPointXY(t.at(-1)),this.getPointXY(t.at(-2)))&&t.pop(),2<t.length&&this.insideLine(this.getPointXY(t[1]),this.getPointXY(t[0]),this.getPointXY(t.at(-1)))&&(t[0]=t.at(-1),t.pop()),t}getVoronoiPolygon(t,e){t.length=0;const i=this.getEdgeFromPoint(e);let n=i;for(;;){const e=this.calculateCircleCenter(n);t.push(e);const s=this.getNextDEdge(n,1);if(s===i)break;n=s}}getNearestPoint(t){this.isInfinitePointFromPoint(t)&&(0,o.t)("Not supported for the infinite point");const e=this.getPointXY(t);let i=this.m_pointZero,n=Number.MAX_VALUE;const s=this.getEdgeFromPoint(t);let h=s;do{const t=this.getPointFromEdge(this.getTwinEdge(h));if(!this.isInfinitePointFromPoint(t)){const s=r.P.sqrDistance(e,this.getPointXY(t));s<n&&(i=t,n=s)}h=this.getCounterClockwiseEdge(h)}while(h!==s);return i}addConstraint(t,e){const i=[null],n=[null];if(!this.constraintFindFirstEdge(i,n,t,e))return c(n[0],i[0]);i[0]=this.getTwinEdge(i[0]);const s=this.getPointXY(t),r=this.getPointXY(e),h=[new Array(0),new Array(0)],g=i[0];for(;;){const t=this.getClockwiseEdge(n[0]);t.getMask()&&(0,o.t)("add_constraint");const g=c(t,this.getTwinEdge(t));this.deleteTwinEdges(g,!0);const a=this.getCounterClockwiseEdge(this.getTwinEdge(i[0])),d=this.getTwinEdge(this.getClockwiseEdge(n[0])),l=this.getPointFromEdge(d);if(l===e){h[0].push(i[0]),i[0]=a,h[1].push(n[0]),n[0]=d;break}const u=this.orientation(s,r,this.getPointXY(l));0===u&&(0,o.t)("add_constraint - point on constraint"),0<u?(h[0].push(i[0]),i[0]=a):(h[1].push(n[0]),n[0]=d)}h[0].push(i[0]),h[1].push(n[0]);const a=this.newPairEdge();a.first.setMask(),a.second.setMask(),this.join(n[0],g,1,1,a),this.triangulateConstraint(h[0],1,h[0].length-1,a),h[1].reverse();const d=c(a.second,a.first);return this.triangulateConstraint(h[1],1,h[1].length-1,d),d}verify(){for(let t=0,e=this.m_edges.length;t<e;t++){const e=this.m_edges[t];if(!e.getMask()&&!this.testEdge(e))return!1}return!0}getDelaunayTriangleCount(){return this.m_points.length-2<<1}getVoronoiSegments(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Number.MAX_VALUE;const e=[];for(let i=0,n=this.m_edges.length;i<n;i+=2){const n=c(null,null);if(n.first=this.m_edges[i],n.second=n.first.twin,this.isInfinitePointFromEdge(n.first)&&(n.second=(0,r.b)(n.first,n.first=n.second)),this.isInfinitePointFromEdge(n.second)){const i=(0,r.m)(r.P,3);i[0]=this.calculateCircleCenter(this.getNextDEdge(n.first,0).twin,1),i[2]=this.calculateCircleCenter(this.getNextDEdge(n.first,1),1);const s=(0,r.m)(r.P,2);s[0].assign(i[0]),s[1].assign(i[2]),s[0].rightPerpendicularThis(),s[1].leftPerpendicularThis(),i[1]=i[0].add(s[0]).add(i[2].add(s[1])),i[1].normalize();for(const e of i)e.mulThis(t);const o=f();o.points[0]=n.first.p,o.points[1]=n.second.p;for(let t=0;t<i.length-1;t++){for(let e=0;e<2;e++)o.p[e]=i[t+e];o.p[0].equals(o.p[1])||e.push(o)}}else if(this.isInfinitePointFromEdge(this.getNextDEdge(n.first,0).twin)&&this.isInfinitePointFromEdge(this.getNextDEdge(n.first,1).twin)){const t=(0,r.m)(r.P,3);t[0]=this.calculateCircleCenter(n.first),t[1]=this.getPointXY(this.getPointFromEdge(n.first)).add(this.getPointXY(this.getPointFromEdge(n.second))).mul(.5),t[2]=this.calculateCircleCenter(n.second);const i=f();i.points[0]=n.first.p,i.points[1]=n.second.p;for(let n=0;n<t.length-1;n++){for(let e=0;e<2;e++)i.p[e]=t[n+e];i.p[0].equals(i.p[1])||e.push(i)}}else{const t=f();t.p[0]=this.calculateCircleCenter(n.first),t.p[1]=this.calculateCircleCenter(n.second),t.points[0]=n.first.p,t.points[1]=n.second.p,t.p[0].equals(t.p[1])||e.push(t)}}return e}startDelaunayTriangles(){return-1}nextDelaunayTriangle(t,e){for(;;){if(++e[0],e[0]===this.m_edges.length)return!1;const i=this.m_edges[e[0]];if(t.p[0]=this.getPointFromEdge(i),this.isInfinitePointFromPoint(t.p[0]))continue;const n=this.getTwinEdge(i);if(t.p[1]=this.getPointFromEdge(n),this.isInfinitePointFromPoint(t.p[1]))continue;if(this.getPointXY(t.p[1]).lt(this.getPointXY(t.p[0])))continue;const s=this.getTwinEdge(this.getNextDEdge(i,1));if(t.p[2]=this.getPointFromEdge(s),!this.isInfinitePointFromPoint(t.p[2])&&!this.getPointXY(t.p[2]).lt(this.getPointXY(t.p[0])))return!0}}getPointCount(){return this.m_points.length-1}getPoint(t){return this.m_points[t+1]}getInfinitePoint(){return this.m_pointZero}isInfinitePointFromPoint(t){return t===this.m_pointZero}getPointXY(t){return t.p}getPointIndex(t){return t.userData}setPointIndex(t,e){t.userData=e}getEdgeFromPoint(t){return t.edge}isInfinitePointFromEdge(t){return t.p===this.m_pointZero}getEdgeCount(){return this.m_edges.length}getEdge(t){return this.m_edges[t]}getEdgeIndex(t){return t.getIndex()}getPointFromEdge(t){return t.p}getPointXYFromEdge(t){return t.p.p}getCounterClockwiseEdge(t){return t.a[0]}getClockwiseEdge(t){return t.a[1]}getTwinEdge(t){return t.twin}getPreviousEdge(t){return this.getTwinEdge(this.getCounterClockwiseEdge(t))}getNextEdge(t){return this.getClockwiseEdge(this.getTwinEdge(t))}getNextDEdge(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return t.a[e]}newPairEdge(){const t=c(this.m_nextFreePairEdge.first,this.m_nextFreePairEdge.second);return this.m_nextFreePairEdge.first=this.m_nextFreePairEdge.first.nextFreeEdge(),this.m_nextFreePairEdge.second=this.m_nextFreePairEdge.second.nextFreeEdge(),t.first.twin=t.second,t.second.twin=t.first,t}newPairEdgeEx(t,e){let i;if(e&&null!==this.m_nextFreePairEdge.first)i=c(this.m_nextFreePairEdge.first,this.m_nextFreePairEdge.second),this.m_nextFreePairEdge.first=this.m_nextFreePairEdge.first.nextFreeEdge(),this.m_nextFreePairEdge.second=this.m_nextFreePairEdge.second.nextFreeEdge();else{const e=t[0]++,n=t[0]++;i=c(this.m_edges[e],this.m_edges[n])}return i.first.twin=i.second,i.second.twin=i.first,i}insertEdge(t,e,i){e.p=t.p;const n=t.a[i],s=e.a;s[i]=n,s[1-i]=t,t.a[i]=e,n.a[1-i]=e}insertPoint(t,e){const i=this.m_points[t],n=this.newPairEdgeEx(e,!1),s=n.first,o=n.second;i.edge=n.first,s.p=this.m_points[t],s.a[0]=n.first,s.a[1]=n.first,o.p=this.m_pointZero,o.a[0]=n.second,o.a[1]=n.second,null===this.m_points[0].edge&&(this.m_points[0].edge=n.second)}deleteTwinEdges(t,e){this.deleteEdge(t.first),this.deleteEdge(t.second),e&&(t.first.twin=this.m_nextFreePairEdge.first,t.second.twin=this.m_nextFreePairEdge.second,this.m_nextFreePairEdge=t)}join(t,e,i,n,s){this.insertEdge(t,s.first,i),this.insertEdge(e,s.second,n)}joinEdges2(t,e){t.a[1]=e,e.a[0]=t}checkEdge(t,e,i,n,s){for(;;){const o=c(null,null);if(o.first=this.getNextDEdge(t.first,n),o.second=o.first.twin,this.isInfinitePointFromEdge(o.second))return t;const r=this.getPointXYFromEdge(t.second),h=this.getPointXYFromEdge(o.second);if(this.inCircle(e,i,r,h)<=0)return t;if(this.deleteTwinEdges(t,s),!s){const e=this.getNextDEdge(t.second,n).twin;this.join(o.second,e,n,n,t)}t=o}}calculateCircleCenter(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE;const i=this.getPointXYFromEdge(t),n=this.getPointXYFromEdge(t.twin),s=this.getNextDEdge(t,0);if(this.isInfinitePointFromEdge(s.twin)){const t=new r.P;if(Number.isNaN(e))t.setNAN();else{const s=n.sub(i);s.leftPerpendicularThis(),t.assign(s),t.divThis(Math.max(Math.abs(t.x),Math.abs(t.y))),t.normalize(),t.mulThis(e)}return t}const o=this.getPointXYFromEdge(s.twin);return this.calculateCircleCenterFromThreePoints(i,n,o)}createZeroHandle(){return this.m_points[0]}deleteEdge(t){const e=t,i=e.p;i.edge===t&&(i.edge=e.a[0]),e.a[0].a[1]=e.a[1],e.a[1].a[0]=e.a[0]}testEdge(t){if(this.isInfinitePointFromEdge(t))return!0;const e=t.twin;if(this.isInfinitePointFromEdge(e))return!0;const i=this.getNextDEdge(t,0).twin,n=this.getNextDEdge(e,0).twin;if(this.isInfinitePointFromEdge(i)||this.isInfinitePointFromEdge(n))return!0;const s=this.getPointXYFromEdge(t),o=this.getPointXYFromEdge(e),r=this.getPointXYFromEdge(i),h=this.getPointXYFromEdge(n);return!(this.orientation(s,o,r)<=0)&&!(0<=this.orientation(s,o,h))&&this.inCircle(s,o,r,h)<=0}findMaxSide(t,e){const i=[this.m_points[t].p.clone(),this.m_points[t].p.clone()];for(t++;t!==e;t++){const e=this.m_points[t].p;e.x<i[0].x&&(i[0].x=e.x),i[1].x<e.x&&(i[1].x=e.x),e.y<i[0].y&&(i[0].y=e.y),i[1].y<e.y&&(i[1].y=e.y)}return i[1].x-i[0].x<i[1].y-i[0].y?1:0}findEdge(t,e,i){let n=!1,s=0;for(;;){const o=c(null,null);if(o.second=this.getNextDEdge(t[s].second,i^s),o.first=o.second.twin,0===i&&this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(o.first))<0||1===i&&0<this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(o.first)))t[s]=o,e[s]=!0,n=!1;else{if(n)return;s^=1,n=!0}}}findEdgeSide(t,e,i,n){for(;;){const s=c(null,null);if(s.second=this.getNextDEdge(t[i].second,n^i),s.first=s.second.twin,!(0===n&&this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(s.first))<0||1===n&&0<this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(s.first))))return;t[i]=s,e[i]=!0}}merge(t,e,i,s,o){const r=(0,n.A)({},t),h=(0,n.A)({},s),g=(0,n.A)({},o);let a=(0,n.A)({},e),d=(0,n.A)({},i);const u=a.second,m=d.second;for(;;){if(this.join(a.first,d.first,0,1,g),a.first=this.getNextDEdge(g.first,0),d.first=this.getNextDEdge(g.second,1),a.first===r.first&&d.first===h.first){this.joinEdges2(u,m),this.joinEdges2(h.second,r.second);break}a.second=a.first.twin,d.second=d.first.twin;const t=this.getPointXYFromEdge(g.first),e=this.getPointXYFromEdge(g.second);if(a.first===r.first){let i=c(null,null);i.first=this.getNextDEdge(d.first,1),i.second=i.first.twin,i=this.checkEdge(i,t,e,1,!1),l(a,g),l(g,d),d=c(i.second,i.first)}else if(d.first===h.first){let i=c(null,null);i.first=this.getNextDEdge(a.first,0),i.second=i.first.twin,i=this.checkEdge(i,t,e,0,!1),d=c(g.second,g.first),l(g,a),a=c(i.second,i.first)}else{let i=c(null,null);i.first=this.getNextDEdge(a.first,0),i.second=i.first.twin,i=this.checkEdge(i,t,e,0,!1);let n=c(null,null);n.first=this.getNextDEdge(d.first,1),n.second=n.first.twin,n=this.checkEdge(n,t,e,1,!1);const s=this.getPointXYFromEdge(i.second),o=this.getPointXYFromEdge(n.second);let r=this.inCircle(t,e,s,o);0===r&&(r=this.orientation(t,e,o)),0<r?(l(a,g),l(g,d),d=c(n.second,n.first)):(d=c(g.second,g.first),l(g,a),a=c(i.second,i.first))}this.deleteTwinEdges(g,!1)}}findEdgeClockwise(t,e,i,n,s,o){for(t[0]=n;;){e[0]=t[0],++e[0]===i.length&&(e[0]=0);const n=this.orientation(s,o,this.getPointXYFromEdge(i[e[0]]));if(n<=0)return n<0;t[0]=e[0]}}findEdgeCounterClockwise(t,e,i,n,s,o){for(e[0]=n;;){t[0]=0!==e[0]?e[0]:i.length,t[0]--;const n=this.orientation(s,o,this.getPointXYFromEdge(i[t[0]]));if(0<=n)return 0<n;e[0]=t[0]}}constraintFindFirstEdge(t,e,i,n){const s=[];{const o=this.getEdgeFromPoint(i);let r=o;do{const i=this.getTwinEdge(r);if(this.getPointFromEdge(i)===n)return t[0]=i,e[0]=r,t[0].setMask(),e[0].setMask(),!1;s.push(i),r=this.getClockwiseEdge(r)}while(r!==o)}s.length<3&&(0,o.t)("add_constraint");let r=-1;for(let h=0,l=s.length;h<l;h++)this.isInfinitePointFromEdge(s[h])&&(-1!==r&&(0,o.t)("add_constraint"),r=h);const g=this.getPointXY(i),a=this.getPointXY(n);let d,c;if(-1!==r)for((0,h.r)(s,0,r+1,s.length),s.pop(),0===this.orientation(g,a,this.getPointXYFromEdge(s[0]))&&(0,o.t)("add_constraint - point on constraint"),0===this.orientation(g,a,this.getPointXYFromEdge(s.at(-1)))&&(0,o.t)("add_constraint - point on constraint"),d=0,c=s.length-1;d+1!==c;){const t=d+c>>1,e=this.orientation(g,a,this.getPointXYFromEdge(s[t]));0===e&&(0,o.t)("add_constraint - point on constraint"),0<e?d=t:c=t}else{let t=0,e=this.orientation(g,a,this.getPointXYFromEdge(s[t]));if(0!==e)if(0<e){const e=[0],i=[0];this.findEdgeClockwise(e,i,s,t,g,a)||(0,o.t)("add_constraint"),d=e[0],c=i[0]}else{const e=[0],i=[0];this.findEdgeCounterClockwise(e,i,s,t,g,a)||(0,o.t)("add_constraint"),d=e[0],c=i[0]}else{t++,e=this.orientation(g,a,this.getPointXYFromEdge(s[t])),e<=0&&(0,o.t)("add_constraint");const i=[0],n=[0];this.findEdgeClockwise(i,n,s,t,g,a)||(0,o.t)("add_constraint"),d=i[0],c=n[0]}}return t[0]=s[d],e[0]=s[c],!0}triangulateConstraint(t,e,i,n){if(e===i)return;let s=i;for(let o=e;o!==i;++o)this.inCircle(this.getPointXYFromEdge(n.first),this.getPointXYFromEdge(n.second),this.getPointXYFromEdge(t[s]),this.getPointXYFromEdge(t[o]))<0&&(s=o);if(s!==i){const e=this.newPairEdge();this.join(n.first,t[s],1,1,e),t[s]=e.second,this.triangulateConstraint(t,s+1,i,e)}if(s!==e){const i=this.newPairEdge();this.join(t[s],n.second,1,0,i),this.triangulateConstraint(t,e,s-1,i)}}insideLine(t,e,i){return 0===this.orientation(t,e,i)&&(e.x<t.x!=e.x<i.x||e.y<t.y!=e.y<i.y)}orientation(t,e,i){return r.P.orientationRobust(t,e,i)}inCircle(t,e,i,n){return r.P.inCircleRobust(t,e,i,n)}calculateCircleCenterFromThreePoints(t,e,i){return e.lt(t)&&(e=(0,r.b)(t,t=e)),i.lt(e)&&(i=(0,r.b)(e,e=i)),e.lt(t)&&(e=(0,r.b)(t,t=e)),r.P.calculateCircleCenterFromThreePoints(t,e,i)}compare(t,e){return 3*((E(t[0]<e[0])<<1)+E(t[0]>e[0]))+(E(t[1]<e[1])<<1)+E(t[1]>e[1])-1}caseFromCompare(t,e,i){return(this.compare(t,e)<<6)+(this.compare(t,i)<<3)+this.compare(e,i)}}function E(t){return t?1:0}function x(t,e,i){return t[i]!==e[i]?t[i]<e[i]:t[1-i]<e[1-i]}function P(t){return 255&t}p.c_aTableDelaunayTriangulationSolution=Uint8Array.from([41,74,0,0,0,0,0,0,0,206,0,0,0,0,0,0,0,0,0,0,65,0,0,0,0,0,33,33,65,0,0,0,0,0,0,0,193,0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,86,54,86,0,0,0,0,0,0,0,214,173,0,0,0,0,0,0,0,107,239,0,0,0,0,0,0,0,0,0,181,0,0,0,0,0,0,0,181,0,0,0,0,0,0,117,117,245,0,0,0,0,0,0,0,0,0,103,0,0,0,0,0,0,0,167,0,0,0,0,0,0,231,103,231,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,198,0,0,41,0,0,74,0,0,49,0,0,49,0,0,50,0,0,194,0,0,193,0,0,194,0,0,0,0,0,206,0,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,0,198,0,0,0,0,0,82,50,82,0,0,0,0,0,0,0,198,0,66,0,0,65,0,0,66,49,66,33,57,65,82,50,90,0,194,0,0,193,0,0,194,0,0,0,0,0,0,0,214,0,0,0,0,0,86,54,86,0,0,0,0,0,0,0,222,0,0,0,0,0,0,178,0,0,0,0,0,0,230,102,230,177,0,0,177,0,0,178,0,177,0,0,177,0,0,178,0,113,226,113,113,249,226,122,226,0,0,0,0,0,0,102,0,0,0,0,0,0,0,190,0,0,0,0,0,0,230,102,230,0,0,0,165,0,0,0,0,0,0,0,0,243,0,0,0,0,0,173,0,0,0,0,0,0,0,0,165,0,0,0,0,0,0,0,0,245,0,0,0,0,0,107,0,0,239,0,0,163,0,0,163,0,0,167,0,0,247,0,0,243,0,0,247,0,0,37,37,69,0,0,0,0,0,0,0,211,0,0,0,0,0,0,0,69,0,0,0,0,0,37,37,69,0,0,0,0,0,0,0,221,0,0,0,0,215,0,0,211,0,0,215,35,87,35,35,91,87,63,87,0,215,0,0,211,0,0,215,0,0,0,165,0,0,0,0,0,0,115,115,243,0,0,0,0,0,0,181,0,0,0,0,0,0,0,189,0,0,0,0,0,0,117,117,245,0,0,0,99,0,0,99,0,0,103,0,163,0,0,163,0,0,167,0,99,247,115,123,243,231,103,255]);class _{constructor(t){this.m_numberOfSets=t,this.m_elements=Array.from({length:t},((t,e)=>e)),this.m_sizes=(0,r.d)(t,1)}getNumberOfSets(){return this.m_numberOfSets}connected(t,e){return this.findRoot(t)===this.findRoot(e)}connect(t,e){const i=this.findRoot(t),n=this.findRoot(e);return i!==n&&(this.m_sizes[i]<this.m_sizes[n]?(this.m_sizes[n]+=this.m_sizes[i],this.m_elements[i]=n):(this.m_sizes[i]+=this.m_sizes[n],this.m_elements[n]=i),--this.m_numberOfSets,!0)}connectRange(t,e,i){if(e!==i)for(let n=e;n<i;++n)this.connect(t[e],t[n])}size(){return this.m_elements.length}size1(t){return(0,o.g)(0),0}findRoot(t){let e=t;if(this.m_elements[e]!==e)do{this.m_elements[e]=this.m_elements[this.m_elements[e]],e=this.m_elements[e]}while(this.m_elements[e]!==e);return e}}class F extends s.G{alphaShapeConstruct(t,e){const i=t.getEdgeCount(),n=new h.a({vd:this.m_vertexDescription});if(!n)throw new Error("alphaShapeConstruct");for(let s=0;s<i;++s){if(2!==e[s])continue;const i=c(null,null);if(i.first=t.getEdge(s),i.second=t.getTwinEdge(i.first),1!==e[t.getEdgeIndex(i.second)])continue;t.getPointXYFromEdge(i.first),n.startPath(t.getPointXYFromEdge(i.first));let o=s,r=i.second;for(;;){for(e[o]=3,r=t.getCounterClockwiseEdge(r);1===e[t.getEdgeIndex(r)];)r=t.getCounterClockwiseEdge(r);if(r===i.first)break;n.lineTo(t.getPointXYFromEdge(r)),o=t.getEdgeIndex(r),r=t.getTwinEdge(r)}}return n}alphaShape(t,e){const i=t.getEdgeCount(),n=new Uint8Array(i);for(let s=0;s<i;++s){if(0!==n[s])continue;const i={p:[null,null,null]},o=t.getEdge(s);i.p[0]=t.getPointFromEdge(o);const h=t.getClockwiseEdge(t.getTwinEdge(o));i.p[1]=t.getPointFromEdge(h);const g=t.getEdgeIndex(h),a=t.getClockwiseEdge(t.getTwinEdge(h));i.p[2]=t.getPointFromEdge(a);const d=t.getEdgeIndex(a);let c=1;for(let e=0;e<3;++e)if(t.isInfinitePointFromPoint(i.p[e])){c=2;break}if(1===c){const n=(0,r.m)(r.P,3);for(let e=0;e<3;++e)n[e]=t.getPointXY(i.p[e]);const s=r.P.sqrDistance(n[0],n[1]),o=r.P.sqrDistance(n[1],n[2]),h=r.P.sqrDistance(n[2],n[0]),g=2*n[1].sub(n[0]).crossProduct(n[2].sub(n[0]));e<s*o*h/(g*g)&&(c=2)}n[s]=n[g]=n[d]=c}return this.alphaShapeConstruct(t,n)}alphaShapeAlphaOut(t,e){const i=t.getEdgeCount(),n=new Uint8Array(i),s=[],o=new _(t.getPointCount());for(let g=0;g<i;++g){if(0!==n[g])continue;const e={p:[null,null,null]},i=t.getEdge(g);e.p[0]=t.getPointFromEdge(i);const o=t.getClockwiseEdge(t.getTwinEdge(i));e.p[1]=t.getPointFromEdge(o);const h=t.getEdgeIndex(o),a=t.getClockwiseEdge(t.getTwinEdge(o));e.p[2]=t.getPointFromEdge(a);const d=t.getEdgeIndex(a);let c=1;for(let n=0;n<3;++n)if(t.isInfinitePointFromPoint(e.p[n])){c=2;break}if(1===c){const i=new Array(3);for(let s=0;s<3;++s)i[s]=t.getPointXY(e.p[s]);const n=r.P.sqrDistance(i[0],i[1]),o=r.P.sqrDistance(i[1],i[2]),a=r.P.sqrDistance(i[2],i[0]),l=i[1].sub(i[0]).crossProduct(i[2].sub(i[0])),u=(0,r.n)(Number.NaN,(0,r.n)([0,0,0],[0,0,0]));u.first=n*o*a/(l*l),u.second.first[0]=g,u.second.first[1]=h,u.second.first[2]=d,u.second.second[0]=t.getPointIndex(e.p[0]),u.second.second[1]=t.getPointIndex(e.p[1]),u.second.second[2]=t.getPointIndex(e.p[2]),s.push(u),c=2}n[g]=n[h]=n[d]=c}s.sort(((t,e)=>function(t,e){if(t.first!==e.first)return t.first-e.first;let i=t.second.first,n=e.second.first;for(let s=0;s<3;++s)if(i[s]!==n[s])return i[s]-n[s];i=t.second.second,n=e.second.second;for(let s=0;s<3;++s)if(i[s]!==n[s])return i[s]-n[s];return 0}(t,e)));let h=0;for(const r of s){if(1===o.getNumberOfSets()&&r.first!==h)break;n[r.second.first[0]]=n[r.second.first[1]]=n[r.second.first[2]]=1;const t=[r.second.second[0],r.second.second[1],r.second.second[2]];o.connectRange(t,0,3),h=r.first}return e&&(e[0]=.25*h),this.alphaShapeConstruct(t,n)}constructor(t,e,i,n){super(),this.m_multiPointForAttributes=null,this.m_inputGeometryCursor=null,this.m_index=-1,this.m_nDelaunayPoints=0,this.m_cDelaunay=new p,this.m_vertexDescription=null,this.m_progressTracker=n,this.m_alpha=Number.isNaN(e)||!Number.isFinite(e)||e<0?-1:e<Number.MIN_VALUE?0:e,this.m_bMerge=i,this.m_bDone=!1,this.m_inputGeometryCursor=t,this.prepareDelaunay()}prepareDelaunay(){this.m_nDelaunayPoints=0,this.m_cDelaunay.clear(),0!==this.m_alpha&&this.m_cDelaunay.prepare((0,r.i)())}next(){if(this.m_bMerge){if(!this.m_bDone){const t=this.calculateAlphaShapeMerging(this.m_inputGeometryCursor,this.m_progressTracker);return this.m_bDone=!0,t}return null}if(!this.m_bDone){const t=this.m_inputGeometryCursor.next();if(null!==t)return(0,o.l)(t),(0,o.d)(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.calculateAlphaShape(t,this.m_progressTracker);this.m_bDone=!0}return null}tock(){return!0}getRank(){return 1}getGeometryID(){return this.m_index}calculateAlphaShapeMerging(t,e){let i;for(;i=t.next();)(0,o.l)(i),(0,o.d)(i),this.addGeometry(i);return this.buildAlphaShape()}calculateAlphaShape(t,e){return t.isEmpty()?new h.a({vd:t.getDescription()}):(this.prepareDelaunay(),this.addGeometry(t),this.buildAlphaShape())}buildAlphaShape(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(t&&(t[0]=this.m_alpha),0===this.m_alpha)return this.m_vertexDescription?new h.a({vd:this.m_vertexDescription}):new h.a;if(this.m_cDelaunay.removeDuplicates())for(let e=0,i=this.m_cDelaunay.getPointCount();e<i;++e)this.m_cDelaunay.setPointIndex(this.m_cDelaunay.getPoint(e),e);return this.m_cDelaunay.construct()?this.m_alpha<0?this.alphaShapeAlphaOut(this.m_cDelaunay,t):this.alphaShape(this.m_cDelaunay,this.m_alpha):this.m_vertexDescription?new h.a({vd:this.m_vertexDescription}):new h.a}addGeometry(t){if((0,o.l)(t),(0,o.d)(t),0===this.m_alpha)return;if(this.m_vertexDescription&&this.m_bMerge||(this.m_vertexDescription=t.getDescription(),this.m_vertexDescription.getAttributeCount()>1?this.m_multiPointForAttributes=new h.M({vd:this.m_vertexDescription}):this.m_multiPointForAttributes=null),t.isEmpty())return;const e=t.getGeometryType();if((0,o.i)(e)){const e=t,i=new r.P;for(let t=0,n=e.getPointCount();t<n;t++)e.queryXY(t,i),this.m_cDelaunay.addVertex(i,this.m_nDelaunayPoints++);this.m_multiPointForAttributes&&this.m_multiPointForAttributes.addPoints(e,0,-1)}else if(e===o.G.enumPoint){const e=t,i=e.getXY();this.m_cDelaunay.addVertex(i,this.m_nDelaunayPoints++),this.m_multiPointForAttributes&&this.m_multiPointForAttributes.add(e)}else(0,o.t)("bad geometry type")}}const w=new class{getOperatorType(){return 10112}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!1}executeMany(t,e,i,n){return new F(t,e,i,n)}execute(t,e,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const s=new F(null,e,!1,i);return s.addGeometry(t),s.buildAlphaShape(n)}};function y(t,e,i){return w.execute(t,e,null,i)}var k=i(58067);function C(t,e){const i=(0,k.getSpatialReference)(t),n=[0];return{alphaShape:(0,k.toPolygon)(y((0,k.fromGeometry)(t),e,n),i),calculatedAlpha:n[0]}}function b(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{merge:n=!1}=i,o=t.map(k.fromGeometry),r=(0,k.getSpatialReference)(t);return function(t,e,i){const n=w.executeMany(new s.S(t),e,i,null);return Array.from(n)}(o,e,n).map((t=>(0,k.toPolygon)(t,r)))}const T=w.supportsCurves()},58067:(t,e,i)=>{i.r(e),i.d(e,{fromExtent:()=>_,fromGeometry:()=>P,fromMultipoint:()=>F,fromPoint:()=>w,fromPolygon:()=>y,fromPolyline:()=>k,fromSpatialReference:()=>C,getSpatialReference:()=>x,toExtent:()=>T,toGeometry:()=>b,toMultipoint:()=>D,toPoint:()=>X,toPolygon:()=>I,toPolyline:()=>Y});var n=i(89379),s=i(26871),o=(i(21557),i(97799)),r=i(91523),h=i(79186),g=i(82103),a=i(76797),d=i(66388),c=i(19247),l=i(65215),u=i(23701),m=(i(59739),i(48045));const f="_gxVersion",p=2,E=1;function x(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function P(t){switch(t.type){case"point":return w(t);case"multipoint":return F(t);case"polyline":return k(t);case"polygon":return y(t);case"extent":return _(t);default:throw new Error("Unsupported geometry type: ".concat(t.type))}}function _(t){if(!t.getCacheValue(f)){const e=new r.E;e.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&e.setInterval(p,0,t.mmin,t.mmax),t.hasZ&&e.setInterval(E,0,t.zmin,t.zmax),t.setCacheValue(f,e)}return t.getCacheValue(f)}function F(t){if(!t.getCacheValue(f)){const n=new h.M,s=new r.P,o=t.points,g=t.hasM,a=t.hasZ,d=a?3:2;for(let t=0,r=o.length;t<r;t++){var e,i;const r=o[t];s.setXYCoords(r[0],r[1]),a&&s.setZ(null!==(e=r[2])&&void 0!==e?e:0),g&&s.setM(null!==(i=r[d])&&void 0!==i?i:NaN),n.add(s)}t.setCacheValue(f,n)}return t.getCacheValue(f)}function w(t){if(!t.getCacheValue(f)){const e=new r.P;e.setXYCoords(t.x,t.y),t.hasM&&e.setM(t.m),t.hasZ&&e.setZ(t.z),t.setCacheValue(f,e)}return t.getCacheValue(f)}function y(t){if(!t.getCacheValue(f)){const{curveRings:e,hasM:i,hasZ:n,rings:s}=t,o=(0,m.fromGeometryToGXGeometry)({curveRings:e,hasM:i,hasZ:n,rings:s});t.setCacheValue(f,o)}return t.getCacheValue(f)}function k(t){if(!t.getCacheValue(f)){const{curvePaths:e,hasM:i,hasZ:n,paths:s}=t,o=(0,m.fromGeometryToGXGeometry)({curvePaths:e,hasM:i,hasZ:n,paths:s});t.setCacheValue(f,o)}return t.getCacheValue(f)}function C(t){if(t.wkid)return(0,g.c)(t.wkid);const e=t.wkt2||t.wkt;return e?(0,g.b)(e):null}function b(t,e){if(t)switch(t.getGeometryType()){case o.G.enumPoint:return X(t,e);case o.G.enumEnvelope:return T(t,e);case o.G.enumMultiPoint:return D(t,e);case o.G.enumPolyline:return Y(t,e);case o.G.enumPolygon:return I(t,e)}return null}function T(t,e){if(t.isEmpty())return null;const i=new a.default({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:e}),n=t.getDescription();if(n.hasM()){const e=t.queryInterval(p,0);i.mmin=e.vmin,i.mmax=e.vmax}if(n.hasZ()){const e=t.queryInterval(E,0);i.zmin=e.vmin,i.zmax=e.vmax}return i.setCacheValue(f,t),i}function D(t,e){if(t.isEmpty())return null;const i=t.getDescription(),n=i.hasM(),s=i.hasZ(),o=[],h=new r.P;for(let r=0,a=t.getPointCount();r<a;r++){t.getPointByVal(r,h);const e=[h.getX(),h.getY()];s&&e.push(h.getZ()),n&&e.push(h.getM()),o.push(e)}const g=new d.default({hasM:n,hasZ:s,points:o,spatialReference:e});return g.setCacheValue(f,t),g}function X(t,e){if(t instanceof s.P)return new c.default({x:t.x,y:t.y,spatialReference:e});if(t.isEmpty())return null;const i=new c.default({x:t.getX(),y:t.getY(),spatialReference:e}),n=t.getDescription();return n.hasM()&&(i.m=t.getM()),n.hasZ()&&(i.z=t.getZ()),i.setCacheValue(f,t),i}function I(t,e){if(t.isEmpty())return null;const i=l.default.fromJSON((0,n.A)({spatialReference:e},(0,m.toGeometry)(t,null)));return i.setCacheValue(f,t),i}function Y(t,e){if(t.isEmpty())return null;const i=u.default.fromJSON((0,n.A)({spatialReference:e},(0,m.toGeometry)(t,null)));return i.setCacheValue(f,t),i}},68707:(t,e,i)=>{i.d(e,{G:()=>n,O:()=>s,S:()=>o});class n{*[Symbol.iterator](){let t=this.next();for(;t;)yield t,t=this.next()}}class s extends n{}class o extends n{constructor(t){super(),this.m_iGeom=-1,this.m_aGeoms=t?t.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const t=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,t}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}}}]);
//# sourceMappingURL=41202.967cc6d4.chunk.js.map