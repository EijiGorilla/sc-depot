"use strict";(self.webpackChunksc_depot=self.webpackChunksc_depot||[]).push([[73265,89646],{73265:(e,t,i)=>{i.r(t),i.d(t,{default:()=>v});var n=i(35143),r=i(91967),l=i(46053),o=(i(81806),i(76460),i(47249),i(85842));let a=class extends r.default{constructor(e){super(e),this.length=null,this.verticalLength=null,this.area=null}};(0,n._)([(0,l.MZ)()],a.prototype,"length",void 0),(0,n._)([(0,l.MZ)()],a.prototype,"verticalLength",void 0),(0,n._)([(0,l.MZ)()],a.prototype,"area",void 0),a=(0,n._)([(0,o.$)("esri.views.interactive.sketch.Units")],a);const s=a;var c=i(89646);let u=class extends r.default{constructor(e){super(e),this.directionMode="relative",this.relativeDirectionIsBilateral=!1}get effectiveDirectionMode(){switch(this.directionMode){case"relative":return this.relativeDirectionIsBilateral?c.rZ.RelativeBilateral:c.rZ.Relative;case"absolute":return c.rZ.Absolute}}get displayUnits(){var e;return null!==(e=this._get("displayUnits"))&&void 0!==e?e:new s}set displayUnits(e){this._set("displayUnits",e)}get inputUnits(){var e;return null!==(e=this._get("inputUnits"))&&void 0!==e?e:new s}set inputUnits(e){this._set("inputUnits",e)}};(0,n._)([(0,l.MZ)({type:String,nonNullable:!0})],u.prototype,"directionMode",void 0),(0,n._)([(0,l.MZ)({type:Boolean,nonNullable:!0})],u.prototype,"relativeDirectionIsBilateral",void 0),(0,n._)([(0,l.MZ)()],u.prototype,"effectiveDirectionMode",null),(0,n._)([(0,l.MZ)({type:s,nonNullable:!0})],u.prototype,"displayUnits",null),(0,n._)([(0,l.MZ)({type:s,nonNullable:!0})],u.prototype,"inputUnits",null),u=(0,n._)([(0,o.$)("esri.views.interactive.sketch.SketchValueOptions")],u);const v=u},89646:(e,t,i)=>{i.d(t,{$h:()=>g,Ef:()=>w,IP:()=>y,P1:()=>_,hF:()=>Z,jQ:()=>R,rT:()=>U,rZ:()=>n,uR:()=>b});var n,r,l=i(73582),o=i(24648),a=i(31633),s=i(19555),c=i(72745),u=i(20664),v=i(9392),p=i(14487),d=i(7137),h=i(80963);function g(e,t){if(null==e||null==t)return;const i=f(e,t);return null!=i?(0,o.Wq)(i,"radians","geographic"):void 0}(r=n||(n={})).Absolute="absolute",r.Relative="relative",r.RelativeBilateral="relative-bilateral";const f=(()=>{const e=(0,v.vt)(),t=(0,v.vt)();return(i,n)=>{var r,l;return(0,u.i)(e,i.x,i.y,null!==(r=i.z)&&void 0!==r?r:0),(0,u.i)(t,n.x,n.y,null!==(l=n.z)&&void 0!==l?l:0),y(e,t,i.spatialReference,n.spatialReference)}})(),y=(()=>{const e=(0,c.vt)(),t=(0,v.vt)(),i=(0,v.vt)();return(n,r,l,o)=>{if((0,u.p)(n,r))return;const v=(0,d.geodesicCompatibleSpatialReference)(l),g=(0,d.geodesicCompatibleSpatialReference)(o);if(v&&g&&(0,h.aI)(v,g)&&(0,p.F)(n,l,t,v)&&(0,p.F)(r,o,i,g)){const{azimuth:e}=(0,d.inverseGeodeticSolver)(B,t,i,v);return null!=e?(0,a.oU)(e,"degrees","radians"):void 0}e[0]=r[0]-n[0],e[1]=r[1]-n[1];let f=(0,s.g7)(c.JP,e);return e[0]<0&&(f=S-f),f}})();function b(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n.Absolute;if(t&&i)switch(r){case n.Absolute:return g(t,i);case n.Relative:return R(M(e,t,i),n.Relative);case n.RelativeBilateral:return R(M(e,t,i),n.RelativeBilateral)}}function M(e,t,i){if(!e||!t||!i)return;const n=f(e,t),r=f(t,i);return null!=n&&null!=r?(0,o.Wq)(r-n,"radians","geographic"):void 0}function R(e,t){if(null!=e)switch(t){case n.Absolute:return _(e);case n.Relative:{const t=Z(e);let i=I.normalize(t,0,!0);return-180===i&&(i=180),(0,o.Wq)(i,"degrees","geographic")}case n.RelativeBilateral:{const t=Z(e),i=Math.abs(I.normalize(t,0,!0));return(0,o.Wq)(i,"degrees","geographic")}}}function _(e){const t=Z(e),i=k.normalize(t,0,!0);return(0,o.Wq)(i,"degrees","geographic")}const U=(()=>{const e=(0,v.vt)();return function(t,i,n,r,l){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"geodesic";(0,u.c)(e,i);const c=Z(l);if("geodesic"===s){const l=(0,d.geodesicCompatibleSpatialReference)(n);if(l&&(0,p.F)(e,n,e,l))return(0,d.directGeodeticSolver)(t,e,c,r,l),t[2]=i[2],!!(0,p.F)(t,l,t,n)}const v=(0,o.g2)(c,"geographic","arithmetic"),h=(0,a.oU)(v,"degrees","radians"),g=i[0]+r*Math.cos(h),f=i[1]+r*Math.sin(h),y=i[2];return(0,u.i)(t,g,f,y),!0}})();function Z(e){if(null!=e)return(0,o.g2)(m(e),e.rotationType,"geographic")}function w(e){if(null!=e)return(0,o.g2)(m(e),e.rotationType,"arithmetic")}function m(e){return(0,a.oU)(e.value,e.unit,"degrees")}const B=new d.InverseGeodeticSolverResult,S=2*Math.PI,k=l.ie,I=new l.hr(-180,180)}}]);
//# sourceMappingURL=73265.2efd7720.chunk.js.map