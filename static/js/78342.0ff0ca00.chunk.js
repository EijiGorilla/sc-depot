"use strict";(self.webpackChunksc_depot=self.webpackChunksc_depot||[]).push([[78342],{78342:(a,e,i)=>{i.r(e),i.d(e,{default:()=>c});var s=i(89379),n=i(53986),l=i(50076),r=i(28383),t=i(90494),o=i(42633),u=i(11563);const f=["layer"],d=["layerAdapter"],p=5;async function c(a){const e=await async function(a){if(null===a||void 0===a||!a.layer||!a.field&&!a.valueExpression)throw new l.default("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(a.valueExpression&&!a.view)throw new l.default("class-breaks:missing-parameters","View is required when 'valueExpression' is specified");a.forBinning&&(0,t.p)(a,"class-breaks");const{layer:e}=a,i=(0,n.A)(a,f),d=a.forBinning?u.Mi:u.J4,c=(0,u.Jg)(e,d,a.forBinning);if(!c)throw new l.default("class-breaks:invalid-parameters","'layer' must be one of these types: "+(0,u.Ho)(d).join(", "));const m=(0,s.A)({layerAdapter:c},i);m.normalizationType=(0,o.Wy)(m),m.numClasses=m.numClasses||p;const w=null!=m.signal?{signal:m.signal}:null;await c.load(w);const h=m.field,v=m.minValue,y=m.maxValue,b=null!=v||null!=y,g=m.classificationMethod,k="percent-of-total"===m.normalizationType,z=!1!==m.analyzeData,x=h?c.getField(h):null,q=await(0,o.EG)({field:m.field,normalizationField:m.normalizationField,valueExpression:m.valueExpression}),E=(0,r.MH)(c,q,"class-breaks:invalid-parameters");if(E)throw E;if(x){const a=(0,r.hw)(c,x,"class-breaks:invalid-parameters");if(a)throw a}if(m.valueExpression&&m.normalizationType)throw new l.default("class-breaks:invalid-parameters","Normalization is not allowed when 'valueExpression' is specified");if(b)if(z){if(k&&null==m.normalizationTotal)throw new l.default("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified")}else{if(null==v||null==y)throw new l.default("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(v>=y)throw new l.default("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");if(g&&"equal-interval"!==g)throw new l.default("class-breaks:invalid-parameters","'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(k&&null==m.normalizationTotal)throw new l.default("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false")}else if(!z)throw new l.default("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");m.filter&&!m.filter.spatialRelationship&&(m.filter.spatialRelationship="intersects");const V=(0,r.Wk)(m.filter,"class-breaks:invalid-parameters");if(V)throw V;return m}(a),{layerAdapter:i}=e,c=(0,n.A)(e,d);return i.classBreaks(c)}},90494:(a,e,i)=>{i.d(e,{p:()=>l,z:()=>n});var s=i(50076);const n="aggregateCount";function l(a,e){if(!a.view)throw new s.default("".concat(e,":missing-parameters"),"'view' parameter is required for binning");if(a.sqlExpression)throw new s.default("".concat(e,":invalid-parameters"),"'sqlExpression' parameter is not supported for binning");if("3d"===a.view.type)throw new s.default("".concat(e,":invalid-parameters"),"3d view is not supported for binning")}}}]);
//# sourceMappingURL=78342.0ff0ca00.chunk.js.map